import {
  toolbar_default
} from "./chunk-KZMOYZAB.js";
import {
  addClass,
  calcTreeLine,
  cell_default,
  clearTableAllStatus,
  colToVisible,
  convertHeaderColumnToRows,
  createHandleGetRowId,
  createHandleUpdateRowId,
  getAbsolutePos,
  getCellHeight,
  getCellValue,
  getColReMinWidth,
  getDomNode,
  getEventTargetNode,
  getOffsetHeight,
  getOffsetPos,
  getOffsetSize,
  getPaddingTopBottomSize,
  getPropClass,
  getRefElem,
  getRootColumn,
  getRowUniqueId,
  getRowid,
  getRowkey,
  getTpImg,
  handleFieldOrColumn,
  handleRowidOrRow,
  hasClass,
  initTpImg,
  isColumnInfo,
  isPx,
  isScale,
  mergeBodyMethod,
  removeClass,
  restoreScrollLocation,
  rowToVisible,
  scrollToView,
  setCellValue,
  setScrollLeft,
  setScrollTop,
  toCssUnit,
  toFilters,
  toTreePathSeq,
  triggerEvent,
  updateCellTitle
} from "./chunk-R6CTOU3H.js";
import {
  eqEmptyValue,
  errLog,
  formatText,
  getChangeEvent,
  getFuncText,
  getLastZIndex,
  getModelEvent,
  getOnName,
  getSlotVNs,
  hasChildrenList,
  isEmptyValue,
  isEnableConf,
  nextZIndex,
  parseFile,
  warnLog
} from "./chunk-7RWK5NAT.js";
import {
  VxeUI
} from "./chunk-3RG3LAXI.js";
import {
  require_xe_utils
} from "./chunk-VW5LRYBF.js";
import {
  Teleport,
  TransitionGroup,
  computed,
  createCommentVNode,
  defineComponent,
  h,
  inject,
  nextTick,
  onActivated,
  onBeforeUnmount,
  onDeactivated,
  onMounted,
  onUnmounted,
  provide,
  reactive,
  ref,
  resolveComponent,
  watch
} from "./chunk-24RLYKRK.js";
import {
  __toESM
} from "./chunk-USJHI7ER.js";

// node_modules/vxe-table/es/table/src/table.js
var import_xe_utils8 = __toESM(require_xe_utils());

// node_modules/vxe-table/es/table/src/body.js
var import_xe_utils = __toESM(require_xe_utils());
var { getI18n, renderer, renderEmptyElement } = VxeUI;
var renderType = "body";
var body_default = defineComponent({
  name: "VxeTableBody",
  props: {
    tableData: Array,
    tableColumn: Array,
    fixedColumn: Array,
    fixedType: {
      type: String,
      default: ""
    }
  },
  setup(props) {
    const $xeTable = inject("$xeTable", {});
    const { xID, props: tableProps, context: tableContext, reactData: tableReactData, internalData: tableInternalData } = $xeTable;
    const { computeEditOpts, computeMouseOpts, computeCellOffsetWidth, computeAreaOpts, computeDefaultRowHeight, computeEmptyOpts, computeTooltipOpts, computeRadioOpts, computeExpandOpts, computeTreeOpts, computeCheckboxOpts, computeCellOpts, computeValidOpts, computeRowOpts, computeColumnOpts, computeRowDragOpts, computeColumnDragOpts, computeResizableOpts } = $xeTable.getComputeMaps();
    const refElem = ref();
    const refBodyScroll = ref();
    const refBodyTable = ref();
    const refBodyColgroup = ref();
    const refBodyTBody = ref();
    const refBodyXSpace = ref();
    const refBodyYSpace = ref();
    const refBodyEmptyBlock = ref();
    const isVMScrollProcess = () => {
      const { delayHover } = tableProps;
      const { lastScrollTime, isDragResize } = tableReactData;
      return !!(isDragResize || lastScrollTime && Date.now() < lastScrollTime + delayHover);
    };
    const renderLine = (rowid, params, cellHeight) => {
      const { row, column } = params;
      const { afterFullData } = tableInternalData;
      const { treeConfig } = tableProps;
      const treeOpts = computeTreeOpts.value;
      const { slots, treeNode } = column;
      const { fullAllDataRowIdData } = tableInternalData;
      if (slots && slots.line) {
        return $xeTable.callSlot(slots.line, params);
      }
      const rest = fullAllDataRowIdData[rowid];
      let rLevel = 0;
      let prevRow = null;
      if (rest) {
        rLevel = rest.level;
        prevRow = rest.items[rest.treeIndex - 1];
      }
      const isFirstRow = $xeTable.eqRow(afterFullData[0], row);
      if (treeConfig && treeNode && (treeOpts.showLine || treeOpts.line)) {
        return [
          h("div", {
            key: "tl",
            class: "vxe-tree--line-wrapper"
          }, [
            h("div", {
              class: "vxe-tree--line",
              style: {
                height: `${isFirstRow ? 1 : calcTreeLine(params, prevRow)}px`,
                bottom: `-${Math.floor(cellHeight / 2)}px`,
                left: `${rLevel * treeOpts.indent + (rLevel ? 2 - getOffsetSize($xeTable) : 0) + 16}px`
              }
            })
          ])
        ];
      }
      return [];
    };
    const renderTdColumn = (seq, rowid, fixedType, isOptimizeMode, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, columns, items) => {
      const $xeGrid = $xeTable.xeGrid;
      const { fullAllDataRowIdData, fullColumnIdData, visibleColumn } = tableInternalData;
      const { columnKey, resizable: allResizable, showOverflow: allShowOverflow, border, height, cellClassName: allCellClassName, cellStyle, align: allAlign, spanMethod, mouseConfig, editConfig, editRules, tooltipConfig, padding: allPadding } = tableProps;
      const { tableData, dragRow, overflowX, currentColumn, scrollXLoad, scrollYLoad, calcCellHeightFlag, resizeHeightFlag, resizeWidthFlag, mergeList, editStore, isAllOverflow, validErrorMaps } = tableReactData;
      const { afterFullData, scrollXStore, scrollYStore } = tableInternalData;
      const cellOpts = computeCellOpts.value;
      const validOpts = computeValidOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const editOpts = computeEditOpts.value;
      const tooltipOpts = computeTooltipOpts.value;
      const resizableOpts = computeResizableOpts.value;
      const { isAllColumnDrag, isAllRowDrag } = resizableOpts;
      const rowOpts = computeRowOpts.value;
      const rowDragOpts = computeRowDragOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const customCellHeight = calcCellHeightFlag ? cellOpts.height || rowOpts.height : 0;
      const { disabledMethod: dragDisabledMethod, isCrossDrag, isPeerDrag } = rowDragOpts;
      const columnOpts = computeColumnOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const areaOpts = computeAreaOpts.value;
      const cellOffsetWidth = computeCellOffsetWidth.value;
      const { selectCellToRow } = areaOpts;
      const { type, cellRender, editRender, align, showOverflow, className, treeNode, rowResize, padding, verticalAlign, slots } = column;
      const { verticalAlign: allVerticalAlign } = cellOpts;
      const { actived } = editStore;
      const rowRest = fullAllDataRowIdData[rowid] || {};
      const colid = column.id;
      const colRest = fullColumnIdData[colid] || {};
      const renderOpts = editRender || cellRender;
      const compConf = renderOpts ? renderer.get(renderOpts.name) : null;
      const compCellClassName = compConf ? compConf.tableCellClassName || compConf.cellClassName : null;
      const compCellStyle = compConf ? compConf.tableCellStyle || compConf.cellStyle : "";
      const showAllTip = tooltipOpts.showAll;
      const columnIndex = colRest.index;
      const _columnIndex = colRest._index;
      const isEdit = isEnableConf(editRender);
      const resizeHeight = resizeHeightFlag ? rowRest.resizeHeight : 0;
      let fixedHiddenColumn = fixedType ? column.fixed !== fixedType : column.fixed && overflowX;
      const isCellPadding = import_xe_utils.default.eqNull(padding) ? allPadding === null ? cellOpts.padding : allPadding : padding;
      const cellOverflow = import_xe_utils.default.eqNull(showOverflow) ? allShowOverflow : showOverflow;
      const showEllipsis = cellOverflow === "ellipsis";
      const showTitle = cellOverflow === "title";
      const showTooltip = cellOverflow === true || cellOverflow === "tooltip";
      const hasEllipsis = isAllOverflow || showTitle || showTooltip || showEllipsis;
      const showResizable = import_xe_utils.default.isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable;
      const isCsHeight = !!customCellHeight;
      const isRsHeight = resizeHeight > 0;
      let isDirty;
      const tdOns = {};
      const cellAlign = align || (compConf ? compConf.tableCellAlign : "") || allAlign;
      const cellVerticalAlign = import_xe_utils.default.eqNull(verticalAlign) ? allVerticalAlign : verticalAlign;
      const errorValidItem = validErrorMaps[`${rowid}:${colid}`];
      const showValidTip = editRules && validOpts.showMessage && (validOpts.message === "default" ? height || tableData.length > 1 : validOpts.message === "inline");
      const tdAttrs = { colid };
      const cellParams = {
        $table: $xeTable,
        $grid: $xeGrid,
        isEdit: false,
        seq,
        rowid,
        row,
        rowIndex,
        $rowIndex,
        _rowIndex,
        column,
        columnIndex,
        $columnIndex,
        _columnIndex,
        fixed: fixedType,
        type: renderType,
        isHidden: !!fixedHiddenColumn,
        level: rowLevel,
        visibleData: afterFullData,
        data: tableData,
        items
      };
      let isRowDragCell = false;
      let isDisabledDrag = false;
      if (rowOpts.drag) {
        isRowDragCell = rowDragOpts.trigger === "row" || column.dragSort && rowDragOpts.trigger === "cell";
      }
      if (isRowDragCell) {
        isDisabledDrag = !!(dragDisabledMethod && dragDisabledMethod(cellParams));
      }
      if (showTitle || showTooltip || showAllTip || tooltipConfig) {
        tdOns.onMouseenter = (evnt) => {
          if (isVMScrollProcess()) {
            return;
          }
          if (showTitle) {
            updateCellTitle(evnt.currentTarget, column);
          } else if (showTooltip || showAllTip) {
            $xeTable.triggerBodyTooltipEvent(evnt, cellParams);
          }
          $xeTable.dispatchEvent("cell-mouseenter", Object.assign({ cell: evnt.currentTarget }, cellParams), evnt);
        };
      }
      if (showTooltip || showAllTip || tooltipConfig) {
        tdOns.onMouseleave = (evnt) => {
          if (isVMScrollProcess()) {
            return;
          }
          if (showTooltip || showAllTip) {
            $xeTable.handleTargetLeaveEvent(evnt);
          }
          $xeTable.dispatchEvent("cell-mouseleave", Object.assign({ cell: evnt.currentTarget }, cellParams), evnt);
        };
      }
      if (isRowDragCell || checkboxOpts.range || mouseConfig) {
        tdOns.onMousedown = (evnt) => {
          $xeTable.triggerCellMousedownEvent(evnt, cellParams);
        };
      }
      if (isRowDragCell) {
        tdOns.onMouseup = $xeTable.triggerCellMouseupEvent;
      }
      tdOns.onClick = (evnt) => {
        $xeTable.triggerCellClickEvent(evnt, cellParams);
      };
      tdOns.onDblclick = (evnt) => {
        $xeTable.triggerCellDblclickEvent(evnt, cellParams);
      };
      let isMergeCell = false;
      if (mergeList.length) {
        const spanRest = mergeBodyMethod(mergeList, _rowIndex, _columnIndex);
        if (spanRest) {
          const { rowspan, colspan } = spanRest;
          if (!rowspan || !colspan) {
            return null;
          }
          if (rowspan > 1) {
            isMergeCell = true;
            tdAttrs.rowspan = rowspan;
          }
          if (colspan > 1) {
            isMergeCell = true;
            tdAttrs.colspan = colspan;
          }
        }
      } else if (spanMethod) {
        const { rowspan = 1, colspan = 1 } = spanMethod(cellParams) || {};
        if (!rowspan || !colspan) {
          return null;
        }
        if (rowspan > 1) {
          tdAttrs.rowspan = rowspan;
        }
        if (colspan > 1) {
          tdAttrs.colspan = colspan;
        }
      }
      if (fixedHiddenColumn && mergeList) {
        if (tdAttrs.colspan > 1 || tdAttrs.rowspan > 1) {
          fixedHiddenColumn = false;
        }
      }
      if (!fixedHiddenColumn && editConfig && (editRender || cellRender) && (editOpts.showStatus || editOpts.showUpdateStatus)) {
        isDirty = $xeTable.isUpdateByRow(row, column.field);
      }
      const isVNAutoHeight = scrollYLoad && !hasEllipsis;
      const cellHeight = rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
      const isLastColumn = $columnIndex === columns.length - 1;
      const isAutoCellWidth = !column.resizeWidth && (column.minWidth === "auto" || column.width === "auto");
      let isVNPreEmptyStatus = false;
      if (!isMergeCell) {
        if (!dragRow || getRowid($xeTable, dragRow) !== rowid) {
          if (scrollYLoad && (_rowIndex < scrollYStore.visibleStartIndex - scrollYStore.preloadSize || _rowIndex > scrollYStore.visibleEndIndex + scrollYStore.preloadSize)) {
            isVNPreEmptyStatus = true;
          } else if (scrollXLoad && !column.fixed && (_columnIndex < scrollXStore.visibleStartIndex - scrollXStore.preloadSize || _columnIndex > scrollXStore.visibleEndIndex + scrollXStore.preloadSize)) {
            isVNPreEmptyStatus = true;
          }
        }
      }
      const tcStyle = {};
      if (hasEllipsis && resizeWidthFlag) {
        let tsColspan = tdAttrs.colspan || 0;
        if (tsColspan > 1) {
          for (let index = 1; index < tsColspan; index++) {
            const nextColumn = visibleColumn[columnIndex + index];
            if (nextColumn) {
              tsColspan += nextColumn.renderWidth;
            }
          }
        }
        tcStyle.width = `${column.renderWidth - cellOffsetWidth * tsColspan}px`;
      }
      if (scrollYLoad || hasEllipsis || isCsHeight || isRsHeight) {
        tcStyle.height = `${cellHeight}px`;
      } else {
        tcStyle.minHeight = `${cellHeight}px`;
      }
      const tdVNs = [];
      if (fixedHiddenColumn && isAllOverflow) {
        tdVNs.push(h("div", {
          key: "tc",
          class: ["vxe-cell", {
            "c--title": showTitle,
            "c--tooltip": showTooltip,
            "c--ellipsis": showEllipsis
          }],
          style: tcStyle
        }));
      } else {
        tdVNs.push(...renderLine(rowid, cellParams, cellHeight), h("div", {
          key: "tc",
          class: ["vxe-cell", {
            "c--title": showTitle,
            "c--tooltip": showTooltip,
            "c--ellipsis": showEllipsis
          }],
          style: tcStyle,
          title: showTitle ? $xeTable.getCellLabel(row, column) : null
        }, isVNPreEmptyStatus ? [] : [
          h("div", {
            colid,
            rowid,
            class: "vxe-cell--wrapper"
          }, column.renderCell(cellParams))
        ]));
        if (showValidTip && errorValidItem) {
          const errRule = errorValidItem.rule;
          const validSlot = slots ? slots.valid : null;
          const validParams = Object.assign(Object.assign(Object.assign({}, cellParams), errorValidItem), { rule: errorValidItem });
          tdVNs.push(h("div", {
            key: "tcv",
            class: ["vxe-cell--valid-error-tip", getPropClass(validOpts.className, validParams)],
            style: errRule && errRule.maxWidth ? {
              width: `${errRule.maxWidth}px`
            } : null
          }, [
            h("div", {
              class: `vxe-cell--valid-error-wrapper vxe-cell--valid-error-theme-${validOpts.theme || "normal"}`
            }, [
              validSlot ? $xeTable.callSlot(validSlot, validParams) : [
                h("span", {
                  class: "vxe-cell--valid-error-msg"
                }, errorValidItem.content)
              ]
            ])
          ]));
        }
      }
      let showAreaRowStatus = false;
      if (mouseConfig && mouseOpts.area && selectCellToRow) {
        if (!_columnIndex && selectCellToRow === true || selectCellToRow === column.field) {
          showAreaRowStatus = true;
        }
      }
      if (!fixedHiddenColumn && showResizable && isAllColumnDrag) {
        tdVNs.push(h("div", {
          key: "tcc",
          class: ["vxe-cell--col-resizable", {
            "is--line": !border || border === "none"
          }],
          onMousedown: (evnt) => $xeTable.handleColResizeMousedownEvent(evnt, fixedType, cellParams),
          onDblclick: (evnt) => $xeTable.handleColResizeDblclickEvent(evnt, cellParams)
        }));
      }
      if ((rowResize || isAllRowDrag) && rowOpts.resizable) {
        tdVNs.push(h("div", {
          key: "tcr",
          class: "vxe-cell--row-resizable",
          onMousedown: (evnt) => $xeTable.handleRowResizeMousedownEvent(evnt, cellParams),
          onDblclick: (evnt) => $xeTable.handleRowResizeDblclickEvent(evnt, cellParams)
        }));
      }
      return h("td", Object.assign(Object.assign(Object.assign({ class: [
        "vxe-body--column",
        colid,
        cellVerticalAlign ? `col--vertical-${cellVerticalAlign}` : "",
        cellAlign ? `col--${cellAlign}` : "",
        type ? `col--${type}` : "",
        {
          "col--last": isLastColumn,
          "col--tree-node": treeNode,
          "col--edit": isEdit,
          "col--ellipsis": hasEllipsis,
          "col--cs-height": isCsHeight,
          "col--rs-height": isRsHeight,
          "col--to-row": showAreaRowStatus,
          "col--auto-height": isVNAutoHeight,
          "fixed--width": !isAutoCellWidth,
          "fixed--hidden": fixedHiddenColumn,
          "is--padding": isCellPadding,
          "is--progress": fixedHiddenColumn && isAllOverflow || isVNPreEmptyStatus,
          "is--drag-cell": isRowDragCell && (isCrossDrag || isPeerDrag || !rowLevel),
          "is--drag-disabled": isDisabledDrag,
          "col--dirty": isDirty,
          "col--active": editConfig && isEdit && (actived.row === row && (actived.column === column || editOpts.mode === "row")),
          "col--valid-error": !!errorValidItem,
          "col--current": currentColumn === column
        },
        getPropClass(compCellClassName, cellParams),
        getPropClass(className, cellParams),
        getPropClass(allCellClassName, cellParams)
      ], key: columnKey || scrollXLoad || scrollYLoad || columnOpts.useKey || rowOpts.useKey || columnOpts.drag ? colid : $columnIndex }, tdAttrs), { style: Object.assign({}, import_xe_utils.default.isFunction(compCellStyle) ? compCellStyle(cellParams) : compCellStyle, import_xe_utils.default.isFunction(cellStyle) ? cellStyle(cellParams) : cellStyle) }), tdOns), isOptimizeMode && fixedHiddenColumn ? [] : tdVNs);
    };
    const renderRows = (fixedType, isOptimizeMode, tableData, tableColumn) => {
      const { stripe, rowKey, highlightHoverRow, rowClassName, rowStyle, editConfig, treeConfig } = tableProps;
      const { hasFixedColumn, treeExpandedFlag, isColLoading, scrollXLoad, scrollYLoad, isAllOverflow, rowExpandedFlag, expandColumn, selectRadioRow, pendingRowFlag, isDragColMove, rowExpandHeightFlag } = tableReactData;
      const { fullAllDataRowIdData, treeExpandedMaps, pendingRowMaps, rowExpandedMaps } = tableInternalData;
      const checkboxOpts = computeCheckboxOpts.value;
      const radioOpts = computeRadioOpts.value;
      const treeOpts = computeTreeOpts.value;
      const editOpts = computeEditOpts.value;
      const rowOpts = computeRowOpts.value;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const { transform, seqMode } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const rows = [];
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      tableData.forEach((row, $rowIndex) => {
        const rowid = handleGetRowId(row);
        const rowRest = fullAllDataRowIdData[rowid] || {};
        let rowIndex = $rowIndex;
        let rowLevel = 0;
        let seq = -1;
        let _rowIndex = -1;
        const trOn = {};
        if (rowOpts.isHover || highlightHoverRow) {
          trOn.onMouseenter = (evnt) => {
            if (isVMScrollProcess()) {
              return;
            }
            $xeTable.triggerHoverEvent(evnt, { row, rowIndex });
          };
          trOn.onMouseleave = () => {
            if (isVMScrollProcess()) {
              return;
            }
            $xeTable.clearHoverRow();
          };
        }
        if (rowRest) {
          rowLevel = rowRest.level;
          if (treeConfig && transform && seqMode === "increasing") {
            seq = rowRest._index + 1;
          } else {
            seq = rowRest.seq;
          }
          rowIndex = rowRest.index;
          _rowIndex = rowRest._index;
        }
        const params = { $table: $xeTable, seq, rowid, fixed: fixedType, type: renderType, level: rowLevel, row, rowIndex, $rowIndex, _rowIndex };
        const isExpandRow = expandColumn && !!rowExpandedFlag && !!rowExpandedMaps[rowid];
        let isExpandTree = false;
        let rowChildren = [];
        let isNewRow = false;
        if (editConfig) {
          isNewRow = $xeTable.isInsertByRow(row);
        }
        if (treeConfig && !scrollYLoad && !transform) {
          rowChildren = row[childrenField];
          isExpandTree = !!treeExpandedFlag && rowChildren && rowChildren.length > 0 && !!treeExpandedMaps[rowid];
        }
        if (rowOpts.drag && (!treeConfig || transform)) {
          trOn.onDragstart = $xeTable.handleRowDragDragstartEvent;
          trOn.onDragend = $xeTable.handleRowDragDragendEvent;
          trOn.onDragover = $xeTable.handleRowDragDragoverEvent;
        }
        const trClass = [
          "vxe-body--row",
          treeConfig ? `row--level-${rowLevel}` : "",
          {
            "row--stripe": stripe && (_rowIndex + 1) % 2 === 0,
            "is--new": isNewRow,
            "is--expand-row": isExpandRow,
            "is--expand-tree": isExpandTree,
            "row--new": isNewRow && (editOpts.showStatus || editOpts.showInsertStatus),
            "row--radio": radioOpts.highlight && $xeTable.eqRow(selectRadioRow, row),
            "row--checked": checkboxOpts.highlight && $xeTable.isCheckedByCheckboxRow(row),
            "row--pending": !!pendingRowFlag && !!pendingRowMaps[rowid]
          },
          getPropClass(rowClassName, params)
        ];
        const tdVNs = tableColumn.map((column, $columnIndex) => {
          return renderTdColumn(seq, rowid, fixedType, isOptimizeMode, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, tableColumn, tableData);
        });
        rows.push(!isColLoading && (columnOpts.drag && columnDragOpts.animation) ? h(TransitionGroup, Object.assign({ name: `vxe-header--col-list${isDragColMove ? "" : "-disabled"}`, tag: "tr", class: trClass, rowid, style: rowStyle ? import_xe_utils.default.isFunction(rowStyle) ? rowStyle(params) : rowStyle : null, key: rowKey || scrollXLoad || scrollYLoad || rowOpts.useKey || rowOpts.drag || columnOpts.drag || treeConfig ? rowid : $rowIndex }, trOn), {
          default: () => tdVNs
        }) : h("tr", Object.assign({ class: trClass, rowid, style: rowStyle ? import_xe_utils.default.isFunction(rowStyle) ? rowStyle(params) : rowStyle : null, key: rowKey || scrollXLoad || scrollYLoad || rowOpts.useKey || rowOpts.drag || columnOpts.drag || treeConfig ? rowid : $rowIndex }, trOn), tdVNs));
        if (isExpandRow) {
          const expandOpts = computeExpandOpts.value;
          const { height: expandHeight, padding, mode: expandMode } = expandOpts;
          if (expandMode === "fixed") {
            rows.push(h("tr", {
              class: "vxe-body--row-expanded-place",
              key: `expand_${rowid}`,
              rowid
            }, [
              h("td", {
                class: "vxe-body--row-expanded-place-column",
                colspan: tableColumn.length,
                style: {
                  height: `${rowExpandHeightFlag ? rowRest.expandHeight || expandHeight : 0}px`
                }
              })
            ]));
          } else {
            const cellStyle = {};
            if (expandHeight) {
              cellStyle.height = `${expandHeight}px`;
            }
            if (treeConfig) {
              cellStyle.paddingLeft = `${rowLevel * treeOpts.indent + 30}px`;
            }
            const { showOverflow } = expandColumn;
            const hasEllipsis = import_xe_utils.default.isUndefined(showOverflow) || import_xe_utils.default.isNull(showOverflow) ? isAllOverflow : showOverflow;
            const expandParams = { $table: $xeTable, seq, column: expandColumn, fixed: fixedType, type: renderType, level: rowLevel, row, rowIndex, $rowIndex, _rowIndex };
            rows.push(h("tr", {
              class: ["vxe-body--expanded-row", {
                "is--padding": padding
              }],
              key: `expand_${rowid}`
            }, [
              h("td", {
                class: ["vxe-body--expanded-column", {
                  "fixed--hidden": fixedType && !hasFixedColumn,
                  "col--ellipsis": hasEllipsis
                }],
                colspan: tableColumn.length
              }, [
                h("div", {
                  class: ["vxe-body--expanded-cell", {
                    "is--ellipsis": expandHeight
                  }],
                  style: cellStyle
                }, [
                  expandColumn.renderData(expandParams)
                ])
              ])
            ]));
          }
        }
        if (isExpandTree) {
          rows.push(...renderRows(fixedType, isOptimizeMode, rowChildren, tableColumn));
        }
      });
      return rows;
    };
    onMounted(() => {
      nextTick(() => {
        const { fixedType } = props;
        const { elemStore } = tableInternalData;
        const prefix = `${fixedType || "main"}-body-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}scroll`] = refBodyScroll;
        elemStore[`${prefix}table`] = refBodyTable;
        elemStore[`${prefix}colgroup`] = refBodyColgroup;
        elemStore[`${prefix}list`] = refBodyTBody;
        elemStore[`${prefix}xSpace`] = refBodyXSpace;
        elemStore[`${prefix}ySpace`] = refBodyYSpace;
        elemStore[`${prefix}emptyBlock`] = refBodyEmptyBlock;
      });
    });
    onUnmounted(() => {
      const { fixedType } = props;
      const { elemStore } = tableInternalData;
      const prefix = `${fixedType || "main"}-body-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}scroll`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
      elemStore[`${prefix}ySpace`] = null;
      elemStore[`${prefix}emptyBlock`] = null;
    });
    const renderVN = () => {
      const { slots } = tableContext;
      const $xeGrid = $xeTable.xeGrid;
      const { fixedColumn, fixedType, tableColumn } = props;
      const { spanMethod, footerSpanMethod, mouseConfig } = tableProps;
      const { isGroup, tableData, isRowLoading, isColLoading, overflowX, scrollXLoad, scrollYLoad, isAllOverflow, isDragRowMove, expandColumn, dragRow, dragCol } = tableReactData;
      const { visibleColumn, fullAllDataRowIdData, fullColumnIdData } = tableInternalData;
      const rowOpts = computeRowOpts.value;
      const emptyOpts = computeEmptyOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const rowDragOpts = computeRowDragOpts.value;
      const expandOpts = computeExpandOpts.value;
      let renderDataList = tableData;
      let renderColumnList = tableColumn;
      let isOptimizeMode = false;
      if (scrollXLoad || scrollYLoad || isAllOverflow) {
        if (expandColumn && expandOpts.mode !== "fixed" || spanMethod || footerSpanMethod) {
        } else {
          isOptimizeMode = true;
        }
      }
      if (!isColLoading && (fixedType || !overflowX)) {
        renderColumnList = visibleColumn;
      }
      if (fixedType) {
        if (isOptimizeMode) {
          renderColumnList = fixedColumn || [];
        }
      }
      if (scrollYLoad && dragRow) {
        if (renderDataList.length > 2) {
          const dRowRest = fullAllDataRowIdData[getRowid($xeTable, dragRow)];
          if (dRowRest) {
            const drIndex = dRowRest._index;
            const firstRow = renderDataList[0];
            const lastRow = renderDataList[renderDataList.length - 1];
            const firstRowRest = fullAllDataRowIdData[getRowid($xeTable, firstRow)];
            const lastRowRest = fullAllDataRowIdData[getRowid($xeTable, lastRow)];
            if (firstRowRest && lastRowRest) {
              const frIndex = firstRowRest._index;
              const lrIndex = lastRowRest._index;
              if (drIndex < frIndex) {
                renderDataList = [dragRow].concat(renderDataList);
              } else if (drIndex > lrIndex) {
                renderDataList = renderDataList.concat([dragRow]);
              }
            }
          }
        }
      }
      if (!fixedType && !isGroup) {
        if (scrollXLoad && dragCol) {
          if (renderColumnList.length > 2) {
            const dCowRest = fullColumnIdData[dragCol.id];
            if (dCowRest) {
              const dcIndex = dCowRest._index;
              const firstCol = renderColumnList[0];
              const lastCol = renderColumnList[renderColumnList.length - 1];
              const firstColRest = fullColumnIdData[firstCol.id];
              const lastColRest = fullColumnIdData[lastCol.id];
              if (firstColRest && lastColRest) {
                const fcIndex = firstColRest._index;
                const lcIndex = lastColRest._index;
                if (dcIndex < fcIndex) {
                  renderColumnList = [dragCol].concat(renderColumnList);
                } else if (dcIndex > lcIndex) {
                  renderColumnList = renderColumnList.concat([dragCol]);
                }
              }
            }
          }
        }
      }
      let emptyContent;
      const emptySlot = slots ? slots.empty : null;
      if (emptySlot) {
        emptyContent = $xeTable.callSlot(emptySlot, { $table: $xeTable, $grid: $xeGrid });
      } else {
        const compConf = emptyOpts.name ? renderer.get(emptyOpts.name) : null;
        const rtEmptyView = compConf ? compConf.renderTableEmpty || compConf.renderTableEmptyView || compConf.renderEmpty : null;
        if (rtEmptyView) {
          emptyContent = getSlotVNs(rtEmptyView(emptyOpts, { $table: $xeTable }));
        } else {
          emptyContent = tableProps.emptyText || getI18n("vxe.table.emptyText");
        }
      }
      const ons = {
        onScroll(evnt) {
          $xeTable.triggerBodyScrollEvent(evnt, fixedType);
        }
      };
      return h("div", {
        ref: refElem,
        class: ["vxe-table--body-wrapper", fixedType ? `fixed-${fixedType}--wrapper` : "body--wrapper"],
        xid: xID
      }, [
        h("div", Object.assign({ ref: refBodyScroll, class: "vxe-table--body-inner-wrapper" }, ons), [
          fixedType ? renderEmptyElement($xeTable) : h("div", {
            ref: refBodyXSpace,
            class: "vxe-body--x-space"
          }),
          h("div", {
            ref: refBodyYSpace,
            class: "vxe-body--y-space"
          }),
          h("table", {
            ref: refBodyTable,
            class: "vxe-table--body",
            xid: xID,
            cellspacing: 0,
            cellpadding: 0,
            border: 0
          }, [
            /**
             * 列宽
             */
            h("colgroup", {
              ref: refBodyColgroup
            }, renderColumnList.map((column, $columnIndex) => {
              return h("col", {
                name: column.id,
                key: $columnIndex,
                style: {
                  width: `${column.renderWidth}px`
                }
              });
            })),
            /**
             * 内容
             */
            !(isRowLoading || isColLoading) && (rowOpts.drag && rowDragOpts.animation) ? h(TransitionGroup, {
              ref: refBodyTBody,
              name: `vxe-body--row-list${isDragRowMove ? "" : "-disabled"}`,
              tag: "tbody"
            }, {
              default: () => renderRows(fixedType, isOptimizeMode, renderDataList, renderColumnList)
            }) : h("tbody", {
              ref: refBodyTBody
            }, renderRows(fixedType, isOptimizeMode, renderDataList, renderColumnList))
          ]),
          h("div", {
            class: "vxe-table--checkbox-range"
          }),
          mouseConfig && mouseOpts.area ? h("div", {
            class: "vxe-table--cell-area"
          }, [
            h("span", {
              class: "vxe-table--cell-main-area"
            }, mouseOpts.extension ? [
              h("span", {
                class: "vxe-table--cell-main-area-btn",
                onMousedown(evnt) {
                  if ($xeTable.triggerCellAreaExtendMousedownEvent) {
                    $xeTable.triggerCellAreaExtendMousedownEvent(evnt, { $table: $xeTable, fixed: fixedType, type: renderType });
                  }
                }
              })
            ] : []),
            h("span", {
              class: "vxe-table--cell-copy-area"
            }),
            h("span", {
              class: "vxe-table--cell-extend-area"
            }),
            h("span", {
              class: "vxe-table--cell-multi-area"
            }),
            h("span", {
              class: "vxe-table--cell-active-area"
            }),
            h("span", {
              class: "vxe-table--cell-row-status-area"
            })
          ]) : renderEmptyElement($xeTable),
          !fixedType ? h("div", {
            class: "vxe-table--empty-block",
            ref: refBodyEmptyBlock
          }, [
            h("div", {
              class: "vxe-table--empty-content"
            }, emptyContent)
          ]) : renderEmptyElement($xeTable)
        ])
      ]);
    };
    return renderVN;
  }
});

// node_modules/vxe-table/es/table/src/header.js
var import_xe_utils2 = __toESM(require_xe_utils());
var { renderer: renderer2, renderEmptyElement: renderEmptyElement2 } = VxeUI;
var renderType2 = "header";
var header_default = defineComponent({
  name: "VxeTableHeader",
  props: {
    tableData: Array,
    tableColumn: Array,
    tableGroupColumn: Array,
    fixedColumn: Array,
    fixedType: {
      type: String,
      default: null
    }
  },
  setup(props) {
    const $xeTable = inject("$xeTable", {});
    const { xID, props: tableProps, reactData: tableReactData, internalData: tableInternalData } = $xeTable;
    const { computeColumnOpts, computeColumnDragOpts, computeCellOpts, computeMouseOpts, computeHeaderCellOpts, computeDefaultRowHeight } = $xeTable.getComputeMaps();
    const headerColumn = ref([]);
    const refElem = ref();
    const refHeaderScroll = ref();
    const refHeaderTable = ref();
    const refHeaderColgroup = ref();
    const refHeaderTHead = ref();
    const refHeaderXSpace = ref();
    const refHeaderBorderRepair = ref();
    const uploadColumn = () => {
      const { isGroup } = tableReactData;
      headerColumn.value = isGroup ? convertHeaderColumnToRows(props.tableGroupColumn) : [];
    };
    const renderRows = (isGroup, isOptimizeMode, cols, $rowIndex) => {
      const $xeGrid = $xeTable.xeGrid;
      const { fixedType } = props;
      const { resizable: allResizable, columnKey, headerCellClassName, headerCellStyle, showHeaderOverflow: allColumnHeaderOverflow, headerAlign: allHeaderAlign, align: allAlign, mouseConfig } = tableProps;
      const { currentColumn, dragCol, scrollXLoad, scrollYLoad, overflowX } = tableReactData;
      const { fullColumnIdData, scrollXStore } = tableInternalData;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const cellOpts = computeCellOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const headerCellOpts = computeHeaderCellOpts.value;
      const currCellHeight = getCellHeight(headerCellOpts.height || cellOpts.height) || defaultRowHeight;
      const { disabledMethod: dragDisabledMethod, isCrossDrag, isPeerDrag } = columnDragOpts;
      return cols.map((column, $columnIndex) => {
        const { type, showHeaderOverflow, headerAlign, align, filters, headerClassName, editRender, cellRender } = column;
        const colid = column.id;
        const colRest = fullColumnIdData[colid] || {};
        const renderOpts = editRender || cellRender;
        const compConf = renderOpts ? renderer2.get(renderOpts.name) : null;
        const isColGroup = column.children && column.children.length;
        const fixedHiddenColumn = fixedType ? column.fixed !== fixedType && !isColGroup : !!column.fixed && overflowX;
        const isPadding = import_xe_utils2.default.isBoolean(headerCellOpts.padding) ? headerCellOpts.padding : cellOpts.padding;
        const headOverflow = import_xe_utils2.default.eqNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
        const headAlign = headerAlign || (compConf ? compConf.tableHeaderCellAlign : "") || allHeaderAlign || align || (compConf ? compConf.tableCellAlign : "") || allAlign;
        let showEllipsis = headOverflow === "ellipsis";
        const showTitle = headOverflow === "title";
        const showTooltip = headOverflow === true || headOverflow === "tooltip";
        let hasEllipsis = showTitle || showTooltip || showEllipsis;
        let hasFilter = false;
        let firstFilterOption = null;
        if (filters) {
          firstFilterOption = filters[0];
          hasFilter = filters.some((item) => item.checked);
        }
        const columnIndex = colRest.index;
        const _columnIndex = colRest._index;
        const cellParams = { $table: $xeTable, $grid: $xeGrid, $rowIndex, column, columnIndex, $columnIndex, _columnIndex, firstFilterOption, fixed: fixedType, type: renderType2, isHidden: fixedHiddenColumn, hasFilter };
        const thAttrs = {
          colid,
          colspan: column.colSpan > 1 ? column.colSpan : null,
          rowspan: column.rowSpan > 1 ? column.rowSpan : null
        };
        const thOns = {
          onClick: (evnt) => $xeTable.triggerHeaderCellClickEvent(evnt, cellParams),
          onDblclick: (evnt) => $xeTable.triggerHeaderCellDblclickEvent(evnt, cellParams)
        };
        if (scrollXLoad && !hasEllipsis) {
          showEllipsis = hasEllipsis = true;
        }
        const isColDragCell = columnOpts.drag && columnDragOpts.trigger === "cell";
        let isDisabledDrag = false;
        if (isColDragCell) {
          isDisabledDrag = !!(dragDisabledMethod && dragDisabledMethod(cellParams));
        }
        if (mouseConfig || isColDragCell) {
          thOns.onMousedown = (evnt) => $xeTable.triggerHeaderCellMousedownEvent(evnt, cellParams);
        }
        if (columnOpts.drag) {
          thOns.onDragstart = $xeTable.handleHeaderCellDragDragstartEvent;
          thOns.onDragend = $xeTable.handleHeaderCellDragDragendEvent;
          thOns.onDragover = $xeTable.handleHeaderCellDragDragoverEvent;
          if (isColDragCell) {
            thOns.onMouseup = $xeTable.handleHeaderCellDragMouseupEvent;
          }
        }
        const isLastColumn = $columnIndex === cols.length - 1;
        const showResizable = import_xe_utils2.default.isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable;
        const isAutoCellWidth = !column.resizeWidth && (column.minWidth === "auto" || column.width === "auto");
        let isVNPreEmptyStatus = false;
        if (!isGroup) {
          if (!dragCol || dragCol.id !== colid) {
            if (scrollXLoad && !column.fixed && (_columnIndex < scrollXStore.visibleStartIndex - scrollXStore.preloadSize || _columnIndex > scrollXStore.visibleEndIndex + scrollXStore.preloadSize)) {
              isVNPreEmptyStatus = true;
            }
          }
        }
        const tcStyle = {};
        if (hasEllipsis) {
          tcStyle.height = `${currCellHeight}px`;
        } else {
          tcStyle.minHeight = `${currCellHeight}px`;
        }
        return h("th", Object.assign(Object.assign(Object.assign({ class: [
          "vxe-header--column",
          colid,
          {
            [`col--${headAlign}`]: headAlign,
            [`col--${type}`]: type,
            "col--last": isLastColumn,
            "col--fixed": column.fixed,
            "col--group": isColGroup,
            "col--ellipsis": hasEllipsis,
            "fixed--width": !isAutoCellWidth,
            "fixed--hidden": fixedHiddenColumn,
            "is--padding": isPadding,
            "is--sortable": column.sortable,
            "col--filter": !!filters,
            "is--filter-active": hasFilter,
            "is--drag-active": columnOpts.drag && !column.fixed && !isDisabledDrag && (isCrossDrag || isPeerDrag || !column.parentId),
            "is--drag-disabled": columnOpts.drag && isDisabledDrag,
            "col--current": currentColumn === column
          },
          headerClassName ? import_xe_utils2.default.isFunction(headerClassName) ? headerClassName(cellParams) : headerClassName : "",
          headerCellClassName ? import_xe_utils2.default.isFunction(headerCellClassName) ? headerCellClassName(cellParams) : headerCellClassName : ""
        ], style: headerCellStyle ? import_xe_utils2.default.isFunction(headerCellStyle) ? headerCellStyle(cellParams) : headerCellStyle : null }, thAttrs), thOns), { key: columnKey || scrollXLoad || scrollYLoad || columnOpts.useKey || columnOpts.drag || isColGroup ? colid : $columnIndex }), [
          h("div", {
            class: ["vxe-cell", {
              "c--title": showTitle,
              "c--tooltip": showTooltip,
              "c--ellipsis": showEllipsis
            }],
            style: tcStyle
          }, isVNPreEmptyStatus || isOptimizeMode && fixedHiddenColumn ? [] : [
            h("div", {
              colid,
              class: "vxe-cell--wrapper"
            }, column.renderHeader(cellParams))
          ]),
          /**
           * 列宽拖动
           */
          !fixedHiddenColumn && showResizable ? h("div", {
            class: "vxe-cell--col-resizable",
            onMousedown: (evnt) => $xeTable.handleColResizeMousedownEvent(evnt, fixedType, cellParams),
            onDblclick: (evnt) => $xeTable.handleColResizeDblclickEvent(evnt, cellParams)
          }) : renderEmptyElement2($xeTable)
        ]);
      });
    };
    const renderHeads = (isGroup, isOptimizeMode, headerGroups) => {
      const { fixedType } = props;
      const { headerRowClassName, headerRowStyle } = tableProps;
      const { isColLoading, isDragColMove } = tableReactData;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      return headerGroups.map((cols, $rowIndex) => {
        const params = { $table: $xeTable, $rowIndex, fixed: fixedType, type: renderType2 };
        if (!isColLoading && columnOpts.drag && columnDragOpts.animation) {
          return h(TransitionGroup, {
            key: $rowIndex,
            name: `vxe-header--col-list${isDragColMove ? "" : "-disabled"}`,
            tag: "tr",
            class: [
              "vxe-header--row",
              headerRowClassName ? import_xe_utils2.default.isFunction(headerRowClassName) ? headerRowClassName(params) : headerRowClassName : ""
            ],
            style: headerRowStyle ? import_xe_utils2.default.isFunction(headerRowStyle) ? headerRowStyle(params) : headerRowStyle : null
          }, {
            default: () => renderRows(isGroup, isOptimizeMode, cols, $rowIndex)
          });
        }
        return h("tr", {
          key: $rowIndex,
          class: [
            "vxe-header--row",
            headerRowClassName ? import_xe_utils2.default.isFunction(headerRowClassName) ? headerRowClassName(params) : headerRowClassName : ""
          ],
          style: headerRowStyle ? import_xe_utils2.default.isFunction(headerRowStyle) ? headerRowStyle(params) : headerRowStyle : null
        }, renderRows(isGroup, isOptimizeMode, cols, $rowIndex));
      });
    };
    const renderVN = () => {
      const { fixedType, fixedColumn, tableColumn } = props;
      const { mouseConfig, showHeaderOverflow: allColumnHeaderOverflow, spanMethod, footerSpanMethod } = tableProps;
      const { isGroup, isColLoading, overflowX, scrollXLoad, scrollYLoad, dragCol } = tableReactData;
      const { visibleColumn, fullColumnIdData } = tableInternalData;
      const mouseOpts = computeMouseOpts.value;
      let renderHeaderList = headerColumn.value;
      let renderColumnList = tableColumn;
      let isOptimizeMode = false;
      if (isGroup) {
        renderColumnList = visibleColumn;
      } else {
        if (scrollXLoad || scrollYLoad || allColumnHeaderOverflow) {
          if (spanMethod || footerSpanMethod) {
          } else {
            isOptimizeMode = true;
          }
        }
        if (!isColLoading && (fixedType || !overflowX)) {
          renderColumnList = visibleColumn;
        }
        if (fixedType) {
          if (isOptimizeMode) {
            renderColumnList = fixedColumn || [];
          }
        }
        renderHeaderList = [renderColumnList];
      }
      if (!fixedType && !isGroup) {
        if (scrollXLoad && dragCol) {
          if (renderColumnList.length > 2) {
            const dCowRest = fullColumnIdData[dragCol.id];
            if (dCowRest) {
              const dcIndex = dCowRest._index;
              const firstCol = renderColumnList[0];
              const lastCol = renderColumnList[renderColumnList.length - 1];
              const firstColRest = fullColumnIdData[firstCol.id];
              const lastColRest = fullColumnIdData[lastCol.id];
              if (firstColRest && lastColRest) {
                const fcIndex = firstColRest._index;
                const lcIndex = lastColRest._index;
                if (dcIndex < fcIndex) {
                  renderColumnList = [dragCol].concat(renderColumnList);
                  renderHeaderList = [[dragCol].concat(renderHeaderList[0])].concat(renderHeaderList.slice(1));
                } else if (dcIndex > lcIndex) {
                  renderColumnList = renderColumnList.concat([dragCol]);
                  renderHeaderList = [renderHeaderList[0].concat([dragCol])].concat(renderHeaderList.slice(1));
                }
              }
            }
          }
        }
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-table--header-wrapper", fixedType ? `fixed-${fixedType}--wrapper` : "body--wrapper"],
        xid: xID
      }, [
        h("div", {
          ref: refHeaderScroll,
          class: "vxe-table--header-inner-wrapper",
          onScroll(evnt) {
            $xeTable.triggerHeaderScrollEvent(evnt, fixedType);
          }
        }, [
          fixedType ? renderEmptyElement2($xeTable) : h("div", {
            ref: refHeaderXSpace,
            class: "vxe-body--x-space"
          }),
          h("table", {
            ref: refHeaderTable,
            class: "vxe-table--header",
            xid: xID,
            cellspacing: 0,
            cellpadding: 0,
            border: 0
          }, [
            /**
             * 列宽
             */
            h("colgroup", {
              ref: refHeaderColgroup
            }, renderColumnList.map((column, $columnIndex) => {
              return h("col", {
                name: column.id,
                key: $columnIndex,
                style: {
                  width: `${column.renderWidth}px`
                }
              });
            })),
            /**
            * 头部
            */
            h("thead", {
              ref: refHeaderTHead
            }, renderHeads(isGroup, isOptimizeMode, renderHeaderList))
          ]),
          mouseConfig && mouseOpts.area ? h("div", {
            class: "vxe-table--cell-area"
          }, [
            h("span", {
              class: "vxe-table--cell-main-area"
            }),
            h("span", {
              class: "vxe-table--cell-copy-area"
            }),
            h("span", {
              class: "vxe-table--cell-extend-area"
            }),
            h("span", {
              class: "vxe-table--cell-multi-area"
            }),
            h("span", {
              class: "vxe-table--cell-active-area"
            }),
            h("span", {
              class: "vxe-table--cell-col-status-area"
            })
          ]) : renderEmptyElement2($xeTable)
        ])
      ]);
    };
    watch(() => props.tableColumn, uploadColumn);
    onMounted(() => {
      nextTick(() => {
        const { fixedType } = props;
        const { internalData } = $xeTable;
        const { elemStore } = internalData;
        const prefix = `${fixedType || "main"}-header-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}scroll`] = refHeaderScroll;
        elemStore[`${prefix}table`] = refHeaderTable;
        elemStore[`${prefix}colgroup`] = refHeaderColgroup;
        elemStore[`${prefix}list`] = refHeaderTHead;
        elemStore[`${prefix}xSpace`] = refHeaderXSpace;
        elemStore[`${prefix}repair`] = refHeaderBorderRepair;
        uploadColumn();
      });
    });
    onUnmounted(() => {
      const { fixedType } = props;
      const { internalData } = $xeTable;
      const { elemStore } = internalData;
      const prefix = `${fixedType || "main"}-header-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}scroll`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
      elemStore[`${prefix}repair`] = null;
    });
    return renderVN;
  }
});

// node_modules/vxe-table/es/table/src/footer.js
var import_xe_utils3 = __toESM(require_xe_utils());
var { renderer: renderer3, renderEmptyElement: renderEmptyElement3 } = VxeUI;
var renderType3 = "footer";
function mergeFooterMethod(mergeFooterList, _rowIndex, _columnIndex) {
  for (let mIndex = 0; mIndex < mergeFooterList.length; mIndex++) {
    const { row: mergeRowIndex, col: mergeColIndex, rowspan: mergeRowspan, colspan: mergeColspan } = mergeFooterList[mIndex];
    if (mergeColIndex > -1 && mergeRowIndex > -1 && mergeRowspan && mergeColspan) {
      if (mergeRowIndex === _rowIndex && mergeColIndex === _columnIndex) {
        return { rowspan: mergeRowspan, colspan: mergeColspan };
      }
      if (_rowIndex >= mergeRowIndex && _rowIndex < mergeRowIndex + mergeRowspan && _columnIndex >= mergeColIndex && _columnIndex < mergeColIndex + mergeColspan) {
        return { rowspan: 0, colspan: 0 };
      }
    }
  }
}
var footer_default = defineComponent({
  name: "VxeTableFooter",
  props: {
    footerTableData: {
      type: Array,
      default: () => []
    },
    tableColumn: {
      type: Array,
      default: () => []
    },
    fixedColumn: {
      type: Array,
      default: () => []
    },
    fixedType: {
      type: String,
      default: null
    }
  },
  setup(props) {
    const $xeTable = inject("$xeTable", {});
    const { xID, props: tableProps, reactData: tableReactData, internalData: tableInternalData } = $xeTable;
    const { computeTooltipOpts, computeColumnOpts, computeColumnDragOpts, computeCellOpts, computeFooterCellOpts, computeDefaultRowHeight, computeResizableOpts } = $xeTable.getComputeMaps();
    const refElem = ref();
    const refFooterScroll = ref();
    const refFooterTable = ref();
    const refFooterColgroup = ref();
    const refFooterTFoot = ref();
    const refFooterXSpace = ref();
    const renderRows = (tableColumn, footerTableData, row, $rowIndex, _rowIndex) => {
      const $xeGrid = $xeTable.xeGrid;
      const { fixedType } = props;
      const { resizable: allResizable, border, footerCellClassName, footerCellStyle, footerAlign: allFooterAlign, footerSpanMethod, align: allAlign, columnKey, showFooterOverflow: allColumnFooterOverflow } = tableProps;
      const { scrollXLoad, scrollYLoad, overflowX, currentColumn, mergeFooterList } = tableReactData;
      const { fullColumnIdData, scrollXStore } = tableInternalData;
      const tooltipOpts = computeTooltipOpts.value;
      const resizableOpts = computeResizableOpts.value;
      const { isAllColumnDrag } = resizableOpts;
      const columnOpts = computeColumnOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const cellOpts = computeCellOpts.value;
      const footerCellOpts = computeFooterCellOpts.value;
      const currCellHeight = getCellHeight(footerCellOpts.height || cellOpts.height) || defaultRowHeight;
      return tableColumn.map((column, $columnIndex) => {
        const { type, showFooterOverflow, footerAlign, align, footerClassName, editRender, cellRender } = column;
        const colid = column.id;
        const colRest = fullColumnIdData[colid] || {};
        const renderOpts = editRender || cellRender;
        const compConf = renderOpts ? renderer3.get(renderOpts.name) : null;
        const showAllTip = tooltipOpts.showAll;
        const isColGroup = column.children && column.children.length;
        const fixedHiddenColumn = fixedType ? column.fixed !== fixedType && !isColGroup : column.fixed && overflowX;
        const isPadding = import_xe_utils3.default.isBoolean(footerCellOpts.padding) ? footerCellOpts.padding : cellOpts.padding;
        const footOverflow = import_xe_utils3.default.eqNull(showFooterOverflow) ? allColumnFooterOverflow : showFooterOverflow;
        const footAlign = footerAlign || (compConf ? compConf.tableFooterCellAlign : "") || allFooterAlign || align || (compConf ? compConf.tableCellAlign : "") || allAlign;
        let showEllipsis = footOverflow === "ellipsis";
        const showTitle = footOverflow === "title";
        const showTooltip = footOverflow === true || footOverflow === "tooltip";
        let hasEllipsis = showTitle || showTooltip || showEllipsis;
        const showResizable = import_xe_utils3.default.isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable;
        const attrs = { colid };
        const tfOns = {};
        const columnIndex = colRest.index;
        const _columnIndex = colRest._index;
        const itemIndex = _columnIndex;
        const cellParams = {
          $table: $xeTable,
          $grid: $xeGrid,
          row,
          rowIndex: _rowIndex,
          _rowIndex,
          $rowIndex,
          column,
          columnIndex,
          $columnIndex,
          _columnIndex,
          itemIndex,
          items: row,
          fixed: fixedType,
          type: renderType3,
          data: footerTableData
        };
        if (scrollXLoad && !hasEllipsis) {
          showEllipsis = hasEllipsis = true;
        }
        if (showTitle || showTooltip || showAllTip) {
          tfOns.onMouseenter = (evnt) => {
            if (showTitle) {
              updateCellTitle(evnt.currentTarget, column);
            } else if (showTooltip || showAllTip) {
              $xeTable.triggerFooterTooltipEvent(evnt, cellParams);
            }
          };
        }
        if (showTooltip || showAllTip) {
          tfOns.onMouseleave = (evnt) => {
            if (showTooltip || showAllTip) {
              $xeTable.handleTargetLeaveEvent(evnt);
            }
          };
        }
        tfOns.onClick = (evnt) => {
          $xeTable.dispatchEvent("footer-cell-click", Object.assign({ cell: evnt.currentTarget }, cellParams), evnt);
        };
        tfOns.onDblclick = (evnt) => {
          $xeTable.dispatchEvent("footer-cell-dblclick", Object.assign({ cell: evnt.currentTarget }, cellParams), evnt);
        };
        let isMergeCell = false;
        if (mergeFooterList.length) {
          const spanRest = mergeFooterMethod(mergeFooterList, _rowIndex, _columnIndex);
          if (spanRest) {
            const { rowspan, colspan } = spanRest;
            if (!rowspan || !colspan) {
              return null;
            }
            if (rowspan > 1) {
              isMergeCell = true;
              attrs.rowspan = rowspan;
            }
            if (colspan > 1) {
              isMergeCell = true;
              attrs.colspan = colspan;
            }
          }
        } else if (footerSpanMethod) {
          const { rowspan = 1, colspan = 1 } = footerSpanMethod(cellParams) || {};
          if (!rowspan || !colspan) {
            return null;
          }
          if (rowspan > 1) {
            attrs.rowspan = rowspan;
          }
          if (colspan > 1) {
            attrs.colspan = colspan;
          }
        }
        const isLastColumn = $columnIndex === tableColumn.length - 1;
        const isAutoCellWidth = !column.resizeWidth && (column.minWidth === "auto" || column.width === "auto");
        let isVNPreEmptyStatus = false;
        if (!isMergeCell) {
          if (scrollXLoad && !column.fixed && (_columnIndex < scrollXStore.visibleStartIndex - scrollXStore.preloadSize || _columnIndex > scrollXStore.visibleEndIndex + scrollXStore.preloadSize)) {
            isVNPreEmptyStatus = true;
          }
        }
        const tcStyle = {};
        if (hasEllipsis) {
          tcStyle.height = `${currCellHeight}px`;
        } else {
          tcStyle.minHeight = `${currCellHeight}px`;
        }
        return h("td", Object.assign(Object.assign(Object.assign(Object.assign({ class: ["vxe-footer--column", column.id, {
          [`col--${footAlign}`]: footAlign,
          [`col--${type}`]: type,
          "col--last": isLastColumn,
          "fixed--width": !isAutoCellWidth,
          "fixed--hidden": fixedHiddenColumn,
          "is--padding": isPadding,
          "col--ellipsis": hasEllipsis,
          "col--current": currentColumn === column
        }, getPropClass(footerClassName, cellParams), getPropClass(footerCellClassName, cellParams)] }, attrs), { style: footerCellStyle ? import_xe_utils3.default.isFunction(footerCellStyle) ? footerCellStyle(cellParams) : footerCellStyle : null }), tfOns), { key: columnKey || scrollXLoad || scrollYLoad || columnOpts.useKey || columnOpts.drag ? column.id : $columnIndex }), [
          h("div", {
            class: ["vxe-cell", {
              "c--title": showTitle,
              "c--tooltip": showTooltip,
              "c--ellipsis": showEllipsis
            }],
            style: tcStyle
          }, isVNPreEmptyStatus ? [] : [
            h("div", {
              colid,
              class: "vxe-cell--wrapper"
            }, column.renderFooter(cellParams))
          ]),
          /**
           * 列宽拖动
           */
          !fixedHiddenColumn && showResizable && isAllColumnDrag ? h("div", {
            class: ["vxe-cell--col-resizable", {
              "is--line": !border || border === "none"
            }],
            onMousedown: (evnt) => $xeTable.handleColResizeMousedownEvent(evnt, fixedType, cellParams),
            onDblclick: (evnt) => $xeTable.handleColResizeDblclickEvent(evnt, cellParams)
          }) : renderEmptyElement3($xeTable)
        ]);
      });
    };
    const renderHeads = (renderColumnList) => {
      const { fixedType, footerTableData } = props;
      const { footerRowClassName, footerRowStyle } = tableProps;
      const { isColLoading, isDragColMove } = tableReactData;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      return footerTableData.map((row, $rowIndex) => {
        const _rowIndex = $rowIndex;
        const rowParams = { $table: $xeTable, row, _rowIndex, $rowIndex, fixed: fixedType, type: renderType3 };
        if (!isColLoading && columnOpts.drag && columnDragOpts.animation) {
          return h(TransitionGroup, {
            key: $rowIndex,
            name: `vxe-header--col-list${isDragColMove ? "" : "-disabled"}`,
            tag: "tr",
            class: [
              "vxe-footer--row",
              footerRowClassName ? import_xe_utils3.default.isFunction(footerRowClassName) ? footerRowClassName(rowParams) : footerRowClassName : ""
            ],
            style: footerRowStyle ? import_xe_utils3.default.isFunction(footerRowStyle) ? footerRowStyle(rowParams) : footerRowStyle : null
          }, {
            default: () => renderRows(renderColumnList, footerTableData, row, $rowIndex, _rowIndex)
          });
        }
        return h("tr", {
          key: $rowIndex,
          class: [
            "vxe-footer--row",
            footerRowClassName ? import_xe_utils3.default.isFunction(footerRowClassName) ? footerRowClassName(rowParams) : footerRowClassName : ""
          ],
          style: footerRowStyle ? import_xe_utils3.default.isFunction(footerRowStyle) ? footerRowStyle(rowParams) : footerRowStyle : null
        }, renderRows(renderColumnList, footerTableData, row, $rowIndex, _rowIndex));
      });
    };
    const renderVN = () => {
      const { fixedType, fixedColumn, tableColumn } = props;
      const { spanMethod, footerSpanMethod, showFooterOverflow: allColumnFooterOverflow } = tableProps;
      const { visibleColumn, fullColumnIdData } = tableInternalData;
      const { isGroup, isColLoading, overflowX, scrollXLoad, scrollYLoad, dragCol } = tableReactData;
      let renderColumnList = tableColumn;
      let isOptimizeMode = false;
      if (scrollXLoad || scrollYLoad || allColumnFooterOverflow) {
        if (spanMethod || footerSpanMethod) {
        } else {
          isOptimizeMode = true;
        }
      }
      if (!isColLoading && (fixedType || !overflowX)) {
        renderColumnList = visibleColumn;
      }
      if (fixedType) {
        if (isOptimizeMode) {
          renderColumnList = fixedColumn || [];
        }
      }
      if (!fixedType && !isGroup) {
        if (scrollXLoad && dragCol) {
          if (renderColumnList.length > 2) {
            const dCowRest = fullColumnIdData[dragCol.id];
            if (dCowRest) {
              const dcIndex = dCowRest._index;
              const firstCol = renderColumnList[0];
              const lastCol = renderColumnList[renderColumnList.length - 1];
              const firstColRest = fullColumnIdData[firstCol.id];
              const lastColRest = fullColumnIdData[lastCol.id];
              if (firstColRest && lastColRest) {
                const fcIndex = firstColRest._index;
                const lcIndex = lastColRest._index;
                if (dcIndex < fcIndex) {
                  renderColumnList = [dragCol].concat(renderColumnList);
                } else if (dcIndex > lcIndex) {
                  renderColumnList = renderColumnList.concat([dragCol]);
                }
              }
            }
          }
        }
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-table--footer-wrapper", fixedType ? `fixed-${fixedType}--wrapper` : "body--wrapper"],
        xid: xID
      }, [
        h("div", {
          ref: refFooterScroll,
          class: "vxe-table--footer-inner-wrapper",
          onScroll(evnt) {
            $xeTable.triggerFooterScrollEvent(evnt, fixedType);
          }
        }, [
          fixedType ? renderEmptyElement3($xeTable) : h("div", {
            ref: refFooterXSpace,
            class: "vxe-body--x-space"
          }),
          h("table", {
            ref: refFooterTable,
            class: "vxe-table--footer",
            xid: xID,
            cellspacing: 0,
            cellpadding: 0,
            border: 0
          }, [
            /**
            * 列宽
            */
            h("colgroup", {
              ref: refFooterColgroup
            }, renderColumnList.map((column, $columnIndex) => {
              return h("col", {
                name: column.id,
                key: $columnIndex,
                style: {
                  width: `${column.renderWidth}px`
                }
              });
            })),
            /**
            * 底部
            */
            h("tfoot", {
              ref: refFooterTFoot
            }, renderHeads(renderColumnList))
          ])
        ])
      ]);
    };
    onMounted(() => {
      nextTick(() => {
        const { fixedType } = props;
        const { elemStore } = tableInternalData;
        const prefix = `${fixedType || "main"}-footer-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}scroll`] = refFooterScroll;
        elemStore[`${prefix}table`] = refFooterTable;
        elemStore[`${prefix}colgroup`] = refFooterColgroup;
        elemStore[`${prefix}list`] = refFooterTFoot;
        elemStore[`${prefix}xSpace`] = refFooterXSpace;
      });
    });
    onUnmounted(() => {
      const { fixedType } = props;
      const { elemStore } = tableInternalData;
      const prefix = `${fixedType || "main"}-footer-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}scroll`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
    });
    return renderVN;
  }
});

// node_modules/vxe-table/es/table/src/props.js
var { getConfig } = VxeUI;
var props_default = {
  /** 基本属性 */
  id: [String, Function],
  // 数据
  data: Array,
  // 表格的高度
  height: [Number, String],
  // 表格的最小高度
  minHeight: {
    type: [Number, String],
    default: () => getConfig().table.minHeight
  },
  // 表格的最大高度
  maxHeight: [Number, String],
  // 已废弃，被 column-config.resizable 替换
  resizable: {
    type: Boolean,
    default: () => getConfig().table.resizable
  },
  // 是否带有斑马纹
  stripe: {
    type: Boolean,
    default: () => getConfig().table.stripe
  },
  // 是否带有边框
  border: {
    type: [Boolean, String],
    default: () => getConfig().table.border
  },
  // 已废弃，被 cell-config.padding 替换
  padding: {
    type: Boolean,
    default: null
  },
  // 是否圆角边框
  round: {
    type: Boolean,
    default: () => getConfig().table.round
  },
  // 表格的尺寸
  size: {
    type: String,
    default: () => getConfig().table.size || getConfig().size
  },
  // 列的宽度是否自撑开（可能会被废弃的参数，不要使用）
  fit: {
    type: Boolean,
    default: () => getConfig().table.fit
  },
  // 表格是否加载中
  loading: Boolean,
  // 所有的列对其方式
  align: {
    type: String,
    default: () => getConfig().table.align
  },
  // 所有的表头列的对齐方式
  headerAlign: {
    type: String,
    default: () => getConfig().table.headerAlign
  },
  // 所有的表尾列的对齐方式
  footerAlign: {
    type: String,
    default: () => getConfig().table.footerAlign
  },
  // 是否显示表头
  showHeader: {
    type: Boolean,
    default: () => getConfig().table.showHeader
  },
  // （即将废弃）是否要高亮当前选中行
  highlightCurrentRow: {
    type: Boolean,
    default: () => getConfig().table.highlightCurrentRow
  },
  // （即将废弃）鼠标移到行是否要高亮显示
  highlightHoverRow: {
    type: Boolean,
    default: () => getConfig().table.highlightHoverRow
  },
  /**
   * （即将废弃）是否要高亮当前选中列
   * @deprecated
   */
  highlightCurrentColumn: {
    type: Boolean,
    default: () => getConfig().table.highlightCurrentColumn
  },
  /**
   * （即将废弃）鼠标移到列是否要高亮显示
   * @deprecated
   */
  highlightHoverColumn: {
    type: Boolean,
    default: () => getConfig().table.highlightHoverColumn
  },
  // （即将废弃）激活单元格编辑时是否高亮显示
  highlightCell: Boolean,
  // 是否显示表尾合计
  showFooter: Boolean,
  // 表尾数据
  footerData: Array,
  // 表尾合计的计算方法
  footerMethod: Function,
  // 给行附加 className
  rowClassName: [String, Function],
  // 给单元格附加 className
  cellClassName: [String, Function],
  // 给表头的行附加 className
  headerRowClassName: [String, Function],
  // 给表头的单元格附加 className
  headerCellClassName: [String, Function],
  // 给表尾的行附加 className
  footerRowClassName: [String, Function],
  // 给表尾的单元格附加 className
  footerCellClassName: [String, Function],
  // 给单元格附加样式
  cellStyle: [Object, Function],
  // 给表头单元格附加样式
  headerCellStyle: [Object, Function],
  // 给表尾单元格附加样式
  footerCellStyle: [Object, Function],
  // 给行附加样式
  rowStyle: [Object, Function],
  // 给表头行附加样式
  headerRowStyle: [Object, Function],
  // 给表尾行附加样式
  footerRowStyle: [Object, Function],
  // 合并指定单元格
  mergeCells: Array,
  // 合并指定的表尾
  mergeFooterItems: Array,
  // 自定义合并行或列的方法
  spanMethod: Function,
  // 表尾合并行或列
  footerSpanMethod: Function,
  // 设置所有内容过长时显示为省略号
  showOverflow: {
    type: [Boolean, String],
    default: () => getConfig().table.showOverflow
  },
  // 设置表头所有内容过长时显示为省略号
  showHeaderOverflow: {
    type: [Boolean, String],
    default: () => getConfig().table.showHeaderOverflow
  },
  // 设置表尾所有内容过长时显示为省略号
  showFooterOverflow: {
    type: [Boolean, String],
    default: () => getConfig().table.showFooterOverflow
  },
  /** 高级属性 */
  // （即将废弃）columnKey 已废弃，被 column-config.useKey 替换
  columnKey: Boolean,
  // （即将废弃）rowKey 已废弃，被 row-config.useKey 替换
  rowKey: Boolean,
  // （即将废弃）rowId 已废弃，被 row-config.keyField 替换
  rowId: {
    type: String,
    default: () => getConfig().table.rowId
  },
  zIndex: Number,
  emptyText: {
    type: String,
    default: () => getConfig().table.emptyText
  },
  keepSource: {
    type: Boolean,
    default: () => getConfig().table.keepSource
  },
  // 是否自动监听父容器变化去更新响应式表格宽高
  autoResize: {
    type: Boolean,
    default: () => getConfig().table.autoResize
  },
  // 是否自动根据状态属性去更新响应式表格宽高
  syncResize: [Boolean, String, Number],
  // 响应式布局配置项
  resizeConfig: Object,
  // 列配置信息
  columnConfig: Object,
  // 当前列配置信息
  currentColumnConfig: Object,
  // 单元格配置信息
  cellConfig: Object,
  // 表头单元格配置信息
  headerCellConfig: Object,
  // 表尾单元格配置信息
  footerCellConfig: Object,
  // 行配置信息
  rowConfig: Object,
  // 当前行配置信息
  currentRowConfig: Object,
  // 已废弃，被 rowDragConfig 替换
  dragConfig: Object,
  // 行拖拽排序配置项
  rowDragConfig: Object,
  // 列拖拽排序配置项
  columnDragConfig: Object,
  // 列调整配置项
  resizableConfig: Object,
  // 序号配置项
  seqConfig: Object,
  // 排序配置项
  sortConfig: Object,
  // 筛选配置项
  filterConfig: Object,
  // 单选框配置
  radioConfig: Object,
  // 复选框配置项
  checkboxConfig: Object,
  // tooltip 配置项
  tooltipConfig: Object,
  // 导出配置项
  exportConfig: Object,
  // 导入配置项
  importConfig: Object,
  // 打印配置项
  printConfig: Object,
  // 展开行配置项
  expandConfig: Object,
  // 树形结构配置项
  treeConfig: Object,
  // 快捷菜单配置项
  menuConfig: Object,
  // 鼠标配置项
  mouseConfig: Object,
  // 区域配置项
  areaConfig: Object,
  // 按键配置项
  keyboardConfig: Object,
  // 复制粘/贴配置项
  clipConfig: Object,
  // 查找/替换配置项
  fnrConfig: Object,
  // 编辑配置项
  editConfig: Object,
  // 校验配置项
  validConfig: Object,
  // 校验规则配置项
  editRules: Object,
  // 加载中配置项
  loadingConfig: Object,
  // 空内容渲染配置项
  emptyRender: Object,
  // 自定义列配置项
  customConfig: Object,
  // （即将废弃）横向虚拟滚动配置项
  scrollX: Object,
  // （即将废弃）纵向虚拟滚动配置项
  scrollY: Object,
  // 横向虚拟滚动配置项
  virtualXConfig: Object,
  // 纵向虚拟滚动配置项
  virtualYConfig: Object,
  // 滚动条配置项
  scrollbarConfig: Object,
  // （即将废弃）优化相关
  animat: {
    type: Boolean,
    default: () => getConfig().table.animat
  },
  // （可能会被废弃的参数，不要使用）
  delayHover: {
    type: Number,
    default: () => getConfig().table.delayHover
  },
  // 额外的参数
  params: Object
};

// node_modules/vxe-table/es/table/src/emits.js
var emits_default = [
  "update:data",
  "keydown-start",
  "keydown",
  "keydown-end",
  "paste",
  "copy",
  "cut",
  "current-change",
  "radio-change",
  "checkbox-change",
  "checkbox-all",
  "checkbox-range-start",
  "checkbox-range-change",
  "checkbox-range-end",
  "checkbox-range-select",
  "cell-click",
  "cell-dblclick",
  "cell-menu",
  "cell-mouseenter",
  "cell-mouseleave",
  "cell-selected",
  "cell-delete-value",
  "cell-backspace-value",
  "header-cell-click",
  "header-cell-dblclick",
  "header-cell-menu",
  "footer-cell-click",
  "footer-cell-dblclick",
  "footer-cell-menu",
  "clear-merge",
  "sort-change",
  "clear-sort",
  "filter-change",
  "filter-visible",
  "clear-filter",
  "resizable-change",
  "column-resizable-change",
  "row-resizable-change",
  "toggle-row-expand",
  "toggle-tree-expand",
  "menu-click",
  "edit-closed",
  "row-dragstart",
  "row-dragover",
  "row-dragend",
  "column-dragstart",
  "column-dragover",
  "column-dragend",
  "enter-append-row",
  "edit-actived",
  "edit-activated",
  "edit-disabled",
  "valid-error",
  "scroll",
  "scroll-boundary",
  "custom",
  "change-fnr",
  "open-fnr",
  "show-fnr",
  "hide-fnr",
  "fnr-change",
  "fnr-find",
  "fnr-find-all",
  "fnr-replace",
  "fnr-replace-all",
  "cell-area-copy",
  "cell-area-cut",
  "cell-area-paste",
  "cell-area-merge",
  "clear-cell-area-selection",
  "clear-cell-area-merge",
  "header-cell-area-selection",
  "cell-area-selection-invalid",
  "cell-area-selection-start",
  "cell-area-selection-drag",
  "cell-area-selection-end",
  "cell-area-extension-start",
  "cell-area-extension-drag",
  "cell-area-extension-end",
  "cell-area-selection-all-start",
  "cell-area-selection-all-end",
  "cell-area-arrows-start",
  "cell-area-arrows-end",
  "active-cell-change-start",
  "active-cell-change-end"
];

// node_modules/vxe-table/es/table/module/custom/panel.js
var import_xe_utils4 = __toESM(require_xe_utils());
var { getI18n: getI18n2, getIcon, renderEmptyElement: renderEmptyElement4 } = VxeUI;
var panel_default = defineComponent({
  name: "TableCustomPanel",
  props: {
    customStore: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props) {
    const VxeUIModalComponent = VxeUI.getComponent("VxeModal");
    const VxeUIDrawerComponent = VxeUI.getComponent("VxeDrawer");
    const VxeUIButtonComponent = VxeUI.getComponent("VxeButton");
    const VxeUINumberInputComponent = VxeUI.getComponent("VxeNumberInput");
    const VxeUIRadioGroupComponent = VxeUI.getComponent("VxeRadioGroup");
    const $xeTable = inject("$xeTable", {});
    const { props: tableProps, reactData, internalData } = $xeTable;
    const { computeCustomOpts, computeColumnDragOpts, computeColumnOpts, computeIsMaxFixedColumn, computeResizableOpts } = $xeTable.getComputeMaps();
    const refElem = ref();
    const bodyElemRef = ref();
    const refDragLineElem = ref();
    const refDragTipElem = ref();
    const dragColumnRef = ref();
    let prevDragCol;
    let prevDragToChild = false;
    let prevDragPos;
    const handleWrapperMouseenterEvent = (evnt) => {
      const { customStore } = props;
      customStore.activeWrapper = true;
      $xeTable.customOpenEvent(evnt);
    };
    const handleWrapperMouseleaveEvent = (evnt) => {
      const { customStore } = props;
      customStore.activeWrapper = false;
      setTimeout(() => {
        if (!customStore.activeBtn && !customStore.activeWrapper) {
          $xeTable.customCloseEvent(evnt);
        }
      }, 300);
    };
    const confirmCustomEvent = ({ $event }) => {
      reactData.isCustomStatus = true;
      $xeTable.saveCustom();
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent("confirm", $event);
    };
    const cancelCloseEvent = ({ $event }) => {
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent("close", $event);
    };
    const cancelCustomEvent = ({ $event }) => {
      $xeTable.cancelCustom();
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent("cancel", $event);
    };
    const handleResetCustomEvent = (evnt) => {
      $xeTable.resetCustom(true);
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent("reset", evnt);
    };
    const resetCustomEvent = ({ $event }) => {
      if (VxeUI.modal) {
        VxeUI.modal.confirm({
          content: getI18n2("vxe.custom.cstmConfirmRestore"),
          className: "vxe-table--ignore-clear",
          escClosable: true
        }).then((type) => {
          if (type === "confirm") {
            handleResetCustomEvent($event);
          }
        });
      } else {
        handleResetCustomEvent($event);
      }
    };
    const handleOptionCheck = (column) => {
      const { customColumnList } = reactData;
      const matchObj = import_xe_utils4.default.findTree(customColumnList, (item) => item === column);
      if (matchObj && matchObj.parent) {
        const { parent } = matchObj;
        if (parent.children && parent.children.length) {
          parent.renderVisible = parent.children.every((column2) => column2.renderVisible);
          parent.halfVisible = !parent.renderVisible && parent.children.some((column2) => column2.renderVisible || column2.halfVisible);
          handleOptionCheck(parent);
        }
      }
    };
    const changeCheckboxOption = (column) => {
      const isChecked = !column.renderVisible;
      const customOpts = computeCustomOpts.value;
      if (customOpts.immediate) {
        import_xe_utils4.default.eachTree([column], (item) => {
          item.visible = isChecked;
          item.renderVisible = isChecked;
          item.halfVisible = false;
        });
        reactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore("update:visible");
      } else {
        import_xe_utils4.default.eachTree([column], (item) => {
          item.renderVisible = isChecked;
          item.halfVisible = false;
        });
      }
      handleOptionCheck(column);
      $xeTable.checkCustomStatus();
    };
    const changeColumnWidth = (column) => {
      const customOpts = computeCustomOpts.value;
      if (customOpts.immediate) {
        if (column.renderResizeWidth !== column.renderWidth) {
          column.resizeWidth = column.renderResizeWidth;
          column.renderWidth = column.renderResizeWidth;
          reactData.isCustomStatus = true;
          $xeTable.handleCustom();
          $xeTable.saveCustomStore("update:width");
        }
      }
    };
    const changeFixedOption = (column, colFixed) => {
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const customOpts = computeCustomOpts.value;
      if (customOpts.immediate) {
        if (column.renderFixed === colFixed) {
          import_xe_utils4.default.eachTree([column], (col) => {
            col.fixed = "";
            col.renderFixed = "";
          });
        } else {
          if (!isMaxFixedColumn || column.renderFixed) {
            import_xe_utils4.default.eachTree([column], (col) => {
              col.fixed = colFixed;
              col.renderFixed = colFixed;
            });
          }
        }
        reactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore("update:fixed");
      } else {
        if (column.renderFixed === colFixed) {
          import_xe_utils4.default.eachTree([column], (col) => {
            col.renderFixed = "";
          });
        } else {
          if (!isMaxFixedColumn || column.renderFixed) {
            import_xe_utils4.default.eachTree([column], (col) => {
              col.renderFixed = colFixed;
            });
          }
        }
      }
    };
    const allOptionEvent = () => {
      $xeTable.toggleCustomAllCheckbox();
    };
    const showDropTip = (evnt, optEl, showLine, dragPos) => {
      const el = bodyElemRef.value;
      if (!el) {
        return;
      }
      const wrapperRect = el.getBoundingClientRect();
      if (optEl) {
        const dragLineEl = refDragLineElem.value;
        if (dragLineEl) {
          if (showLine) {
            const optRect = optEl.getBoundingClientRect();
            dragLineEl.style.display = "block";
            dragLineEl.style.top = `${Math.max(1, optRect.y + el.scrollTop - wrapperRect.y)}px`;
            dragLineEl.style.height = `${optRect.height}px`;
            dragLineEl.style.width = `${optRect.width}px`;
            dragLineEl.setAttribute("drag-pos", dragPos);
            dragLineEl.setAttribute("drag-to-child", prevDragToChild ? "y" : "n");
          } else {
            dragLineEl.style.display = "";
          }
        }
      }
      const dragTipEl = refDragTipElem.value;
      if (dragTipEl) {
        dragTipEl.style.display = "block";
        dragTipEl.style.top = `${Math.min(el.clientHeight + el.scrollTop - dragTipEl.clientHeight, evnt.clientY + el.scrollTop - wrapperRect.y)}px`;
        dragTipEl.style.left = `${Math.min(el.clientWidth + el.scrollLeft - dragTipEl.clientWidth, evnt.clientX + el.scrollLeft - wrapperRect.x)}px`;
        dragTipEl.setAttribute("drag-status", showLine ? prevDragToChild ? "sub" : "normal" : "disabled");
      }
    };
    const hideDropTip = () => {
      const dragTipEl = refDragTipElem.value;
      const dragLineEl = refDragLineElem.value;
      if (dragTipEl) {
        dragTipEl.style.display = "";
      }
      if (dragLineEl) {
        dragLineEl.style.display = "";
      }
    };
    const sortMousedownEvent = (evnt) => {
      const btnEl = evnt.currentTarget;
      const cellEl = btnEl.parentElement;
      const tdEl = cellEl.parentElement;
      const trEl = tdEl.parentElement;
      const colid = trEl.getAttribute("colid");
      const column = $xeTable.getColumnById(colid);
      trEl.draggable = true;
      dragColumnRef.value = column;
      addClass(trEl, "active--drag-origin");
    };
    const sortMouseupEvent = (evnt) => {
      const btnEl = evnt.currentTarget;
      const cellEl = btnEl.parentElement;
      const tdEl = cellEl.parentElement;
      const trEl = tdEl.parentElement;
      hideDropTip();
      trEl.draggable = false;
      dragColumnRef.value = null;
      removeClass(trEl, "active--drag-origin");
    };
    const sortDragstartEvent = (evnt) => {
      if (evnt.dataTransfer) {
        evnt.dataTransfer.setDragImage(getTpImg(), 0, 0);
      }
    };
    const sortDragendEvent = (evnt) => {
      const { mouseConfig } = tableProps;
      const { customColumnList } = reactData;
      const { collectColumn } = internalData;
      const customOpts = computeCustomOpts.value;
      const { immediate } = customOpts;
      const trEl = evnt.currentTarget;
      const dragCol = dragColumnRef.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const { isCrossDrag, isSelfToChildDrag, isToChildDrag, dragEndMethod } = columnDragOpts;
      const dragOffsetIndex = prevDragPos === "bottom" ? 1 : 0;
      if (prevDragCol && dragCol) {
        if (prevDragCol !== dragCol) {
          const dragColumn = dragCol;
          const newColumn = prevDragCol;
          Promise.resolve(dragEndMethod ? dragEndMethod({
            oldColumn: dragColumn,
            newColumn,
            dragColumn,
            dragPos: prevDragPos,
            dragToChild: !!prevDragToChild,
            offsetIndex: dragOffsetIndex
          }) : true).then((status) => {
            if (!status) {
              return;
            }
            let oafIndex = -1;
            let nafIndex = -1;
            const oldAllMaps = {};
            import_xe_utils4.default.eachTree([dragColumn], (column) => {
              oldAllMaps[column.id] = column;
            });
            let isSelfToChildStatus = false;
            if (immediate) {
              if (dragColumn.parentId && newColumn.parentId) {
                if (!isCrossDrag) {
                  return;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!(isCrossDrag && isSelfToChildDrag)) {
                    if (VxeUI.modal) {
                      VxeUI.modal.message({
                        status: "error",
                        content: getI18n2("vxe.error.treeDragChild")
                      });
                    }
                    return;
                  }
                }
              } else if (dragColumn.parentId) {
                if (!isCrossDrag) {
                  return;
                }
              } else if (newColumn.parentId) {
                if (!isCrossDrag) {
                  return;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!(isCrossDrag && isSelfToChildDrag)) {
                    if (VxeUI.modal) {
                      VxeUI.modal.message({
                        status: "error",
                        content: getI18n2("vxe.error.treeDragChild")
                      });
                    }
                    return;
                  }
                }
              } else {
              }
              const oldewMatchRest = import_xe_utils4.default.findTree(collectColumn, (item) => item.id === dragColumn.id);
              if (isSelfToChildStatus && (isCrossDrag && isSelfToChildDrag)) {
                if (oldewMatchRest) {
                  const { items: oCols, index: oIndex } = oldewMatchRest;
                  const childList = dragColumn.children || [];
                  childList.forEach((column) => {
                    column.parentId = dragColumn.parentId;
                  });
                  oCols.splice(oIndex, 1, ...childList);
                  dragColumn.children = [];
                }
              } else {
                if (oldewMatchRest) {
                  const { items: oCols, index: oIndex, parent: oParent } = oldewMatchRest;
                  oCols.splice(oIndex, 1);
                  if (!oParent) {
                    oafIndex = oIndex;
                  }
                }
              }
              const newMatchRest = import_xe_utils4.default.findTree(collectColumn, (item) => item.id === newColumn.id);
              if (newMatchRest) {
                const { items: nCols, index: nIndex, parent: nParent } = newMatchRest;
                if (isCrossDrag && isToChildDrag && prevDragToChild) {
                  dragColumn.parentId = newColumn.id;
                  newColumn.children = (newColumn.children || []).concat([dragColumn]);
                } else {
                  dragColumn.parentId = newColumn.parentId;
                  nCols.splice(nIndex + dragOffsetIndex, 0, dragColumn);
                }
                if (!nParent) {
                  nafIndex = nIndex;
                }
              }
              import_xe_utils4.default.eachTree(collectColumn, (column, index, items, path, parent) => {
                if (!parent) {
                  const sortIndex = index + 1;
                  column.renderSortNumber = sortIndex;
                }
              });
            } else {
              oafIndex = import_xe_utils4.default.findIndexOf(customColumnList, (item) => item.id === dragColumn.id);
              customColumnList.splice(oafIndex, 1);
              nafIndex = import_xe_utils4.default.findIndexOf(customColumnList, (item) => item.id === newColumn.id);
              customColumnList.splice(nafIndex + dragOffsetIndex, 0, dragColumn);
            }
            reactData.isDragColMove = true;
            if (mouseConfig) {
              if ($xeTable.clearSelected) {
                $xeTable.clearSelected();
              }
              if ($xeTable.clearCellAreas) {
                $xeTable.clearCellAreas();
                $xeTable.clearCopyCellArea();
              }
            }
            $xeTable.dispatchEvent("column-dragend", {
              oldColumn: dragColumn,
              newColumn,
              dragColumn,
              dragPos: prevDragPos,
              offsetIndex: dragOffsetIndex,
              _index: {
                newIndex: nafIndex,
                oldIndex: oafIndex
              }
            }, evnt);
            if (immediate) {
              reactData.customColumnList = collectColumn.slice(0);
              $xeTable.handleColDragSwapColumn();
            }
          }).catch(() => {
          });
        }
      }
      hideDropTip();
      dragColumnRef.value = null;
      trEl.draggable = false;
      trEl.removeAttribute("drag-pos");
      removeClass(trEl, "active--drag-target");
      removeClass(trEl, "active--drag-origin");
    };
    const sortDragoverEvent = (evnt) => {
      const customOpts = computeCustomOpts.value;
      const { immediate } = customOpts;
      const columnDragOpts = computeColumnDragOpts.value;
      const { isCrossDrag, isToChildDrag } = columnDragOpts;
      const optEl = evnt.currentTarget;
      const hasCtrlKey = evnt.ctrlKey;
      const colid = optEl.getAttribute("colid");
      const column = $xeTable.getColumnById(colid);
      const dragCol = dragColumnRef.value;
      if (column && (isCrossDrag || column.level === 1)) {
        evnt.preventDefault();
        const offsetY = evnt.clientY - optEl.getBoundingClientRect().y;
        const dragPos = offsetY < optEl.clientHeight / 2 ? "top" : "bottom";
        if (dragCol && dragCol.id === column.id || !isCrossDrag && column.level > 1 || !immediate && column.level > 1 || column.renderFixed) {
          showDropTip(evnt, optEl, false, dragPos);
          return;
        }
        prevDragToChild = !!(isCrossDrag && isToChildDrag && hasCtrlKey && immediate);
        prevDragCol = column;
        prevDragPos = dragPos;
        showDropTip(evnt, optEl, true, dragPos);
      }
    };
    const renderDragTip = () => {
      const dragCol = dragColumnRef.value;
      const columnDragOpts = computeColumnDragOpts.value;
      return h("div", {}, [
        h("div", {
          ref: refDragLineElem,
          class: ["vxe-table-custom-popup--drag-line", {
            "is--guides": columnDragOpts.showGuidesStatus
          }]
        }),
        h("div", {
          ref: refDragTipElem,
          class: "vxe-table-custom-popup--drag-tip"
        }, [
          h("div", {
            class: "vxe-table-custom-popup--drag-tip-wrapper"
          }, [
            h("div", {
              class: "vxe-table-custom-popup--drag-tip-status"
            }, [
              h("span", {
                class: ["vxe-table-custom-popup--drag-tip-normal-status", getIcon().TABLE_DRAG_STATUS_ROW]
              }),
              h("span", {
                class: ["vxe-table-custom-popup--drag-tip-sub-status", getIcon().TABLE_DRAG_STATUS_SUB_ROW]
              }),
              h("span", {
                class: ["vxe-table-custom-popup--drag-tip-disabled-status", getIcon().TABLE_DRAG_DISABLED]
              })
            ]),
            h("div", {
              class: "vxe-table-custom-popup--drag-tip-content"
            }, getI18n2("vxe.custom.cstmDragTarget", [dragCol && dragCol.type !== "html" ? dragCol.getTitle() : ""]))
          ])
        ])
      ]);
    };
    const renderSimplePanel = () => {
      const $xeGrid = $xeTable.xeGrid;
      const { customStore } = props;
      const { isCustomStatus, customColumnList } = reactData;
      const customOpts = computeCustomOpts.value;
      const { immediate } = customOpts;
      const columnDragOpts = computeColumnDragOpts.value;
      const { maxHeight } = customStore;
      const { checkMethod, visibleMethod, allowVisible, allowSort, allowFixed, trigger, placement } = customOpts;
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const { isCrossDrag } = columnDragOpts;
      const slots = customOpts.slots || {};
      const headerSlot = slots.header;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const colVNs = [];
      const customWrapperOns = {};
      const isAllChecked = customStore.isAll;
      const isAllIndeterminate = customStore.isIndeterminate;
      if (trigger === "hover") {
        customWrapperOns.onMouseenter = handleWrapperMouseenterEvent;
        customWrapperOns.onMouseleave = handleWrapperMouseleaveEvent;
      }
      const params = {
        $table: $xeTable,
        $grid: $xeGrid,
        columns: customColumnList,
        isAllChecked,
        isAllIndeterminate,
        isCustomStatus
      };
      import_xe_utils4.default.eachTree(customColumnList, (column, index, items, path, parent) => {
        const isVisible = visibleMethod ? visibleMethod({ column }) : true;
        if (isVisible) {
          const isChecked = column.renderVisible;
          const isIndeterminate = column.halfVisible;
          const isColGroup = column.children && column.children.length;
          const colTitle = formatText(column.getTitle(), 1);
          const isDisabled = checkMethod ? !checkMethod({ column }) : false;
          const isHidden = !isChecked;
          colVNs.push(h("li", {
            key: column.id,
            colid: column.id,
            class: ["vxe-table-custom--option", `level--${column.level}`, {
              "is--hidden": isDisabled || isHidden,
              "is--group": isColGroup
            }],
            onDragstart: sortDragstartEvent,
            onDragend: sortDragendEvent,
            onDragover: sortDragoverEvent
          }, [
            allowVisible ? h("div", {
              class: ["vxe-table-custom--checkbox-option", {
                "is--checked": isChecked,
                "is--indeterminate": isIndeterminate,
                "is--disabled": isDisabled
              }],
              title: getI18n2("vxe.custom.setting.colVisible"),
              onClick: () => {
                if (!isDisabled) {
                  changeCheckboxOption(column);
                }
              }
            }, [
              h("span", {
                class: ["vxe-checkbox--icon", isIndeterminate ? getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon().TABLE_CHECKBOX_CHECKED : getIcon().TABLE_CHECKBOX_UNCHECKED]
              })
            ]) : createCommentVNode(),
            h("div", {
              class: "vxe-table-custom--name-option"
            }, [
              allowSort && ((isCrossDrag ? immediate : false) || column.level === 1) ? h("div", {
                class: "vxe-table-custom--sort-option"
              }, [
                h("span", Object.assign({ class: ["vxe-table-custom--sort-btn", {
                  "is--disabled": isDisabled || isHidden || column.renderFixed
                }], title: getI18n2("vxe.custom.setting.sortHelpTip") }, isDisabled || isHidden || column.renderFixed ? {} : {
                  onMousedown: sortMousedownEvent,
                  onMouseup: sortMouseupEvent
                }), [
                  h("i", {
                    class: getIcon().TABLE_CUSTOM_SORT
                  })
                ])
              ]) : createCommentVNode(),
              column.type === "html" ? h("div", {
                key: "1",
                class: "vxe-table-custom--checkbox-label",
                innerHTML: colTitle
              }) : h("div", {
                key: "0",
                class: "vxe-table-custom--checkbox-label"
              }, colTitle)
            ]),
            !parent && allowFixed ? h("div", {
              class: "vxe-table-custom--fixed-option"
            }, [
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                mode: "text",
                icon: column.renderFixed === "left" ? getIcon().TOOLBAR_TOOLS_FIXED_LEFT_ACTIVE : getIcon().TOOLBAR_TOOLS_FIXED_LEFT,
                status: column.renderFixed === "left" ? "primary" : "",
                disabled: isDisabled || isHidden || isMaxFixedColumn && !column.renderFixed,
                title: getI18n2(column.renderFixed === "left" ? "vxe.toolbar.cancelFixed" : "vxe.toolbar.fixedLeft"),
                onClick: () => {
                  changeFixedOption(column, "left");
                }
              }) : createCommentVNode(),
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                mode: "text",
                icon: column.renderFixed === "right" ? getIcon().TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVE : getIcon().TOOLBAR_TOOLS_FIXED_RIGHT,
                status: column.renderFixed === "right" ? "primary" : "",
                disabled: isDisabled || isHidden || isMaxFixedColumn && !column.renderFixed,
                title: getI18n2(column.renderFixed === "right" ? "vxe.toolbar.cancelFixed" : "vxe.toolbar.fixedRight"),
                onClick: () => {
                  changeFixedOption(column, "right");
                }
              }) : createCommentVNode()
            ]) : createCommentVNode()
          ]));
        }
      });
      return h("div", {
        ref: refElem,
        key: "simple",
        class: ["vxe-table-custom-wrapper", `placement--${placement}`, {
          "is--active": customStore.visible
        }],
        style: maxHeight && !["left", "right"].includes(placement) ? {
          maxHeight: `${maxHeight}px`
        } : {}
      }, customStore.visible ? [
        h("div", {
          class: "vxe-table-custom--header"
        }, headerSlot ? $xeTable.callSlot(headerSlot, params) : [
          h("ul", {
            class: "vxe-table-custom--panel-list"
          }, [
            h("li", {
              class: "vxe-table-custom--option"
            }, [
              allowVisible ? h("div", {
                class: ["vxe-table-custom--checkbox-option", {
                  "is--checked": isAllChecked,
                  "is--indeterminate": isAllIndeterminate
                }],
                title: getI18n2("vxe.table.allTitle"),
                onClick: allOptionEvent
              }, [
                h("span", {
                  class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? getIcon().TABLE_CHECKBOX_CHECKED : getIcon().TABLE_CHECKBOX_UNCHECKED]
                }),
                h("span", {
                  class: "vxe-checkbox--label"
                }, getI18n2("vxe.toolbar.customAll"))
              ]) : h("span", {
                class: "vxe-checkbox--label"
              }, getI18n2("vxe.table.customTitle"))
            ])
          ])
        ]),
        h("div", {
          ref: bodyElemRef,
          class: "vxe-table-custom--body"
        }, [
          topSlot ? h("div", {
            class: "vxe-table-custom--panel-top"
          }, $xeTable.callSlot(topSlot, params)) : renderEmptyElement4($xeTable),
          defaultSlot ? h("div", {
            class: "vxe-table-custom--panel-body"
          }, $xeTable.callSlot(defaultSlot, params)) : h(TransitionGroup, Object.assign({ class: "vxe-table-custom--panel-list", name: "vxe-table-custom--list", tag: "ul" }, customWrapperOns), {
            default: () => colVNs
          }),
          bottomSlot ? h("div", {
            class: "vxe-table-custom--panel-bottom"
          }, $xeTable.callSlot(bottomSlot, params)) : renderEmptyElement4($xeTable),
          renderDragTip()
        ]),
        customOpts.showFooter ? h("div", {
          class: "vxe-table-custom--footer"
        }, footerSlot ? $xeTable.callSlot(footerSlot, params) : [
          h("div", {
            class: "vxe-table-custom--footer-buttons"
          }, [
            VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              mode: "text",
              content: customOpts.resetButtonText || getI18n2("vxe.table.customRestore"),
              disabled: !isCustomStatus,
              onClick: resetCustomEvent
            }) : createCommentVNode(),
            immediate ? VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              mode: "text",
              content: customOpts.closeButtonText || getI18n2("vxe.table.customClose"),
              onClick: cancelCloseEvent
            }) : createCommentVNode() : VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              mode: "text",
              content: customOpts.cancelButtonText || getI18n2("vxe.table.customCancel"),
              onClick: cancelCustomEvent
            }) : createCommentVNode(),
            immediate ? createCommentVNode() : VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              mode: "text",
              status: "primary",
              content: customOpts.confirmButtonText || getI18n2("vxe.table.customConfirm"),
              onClick: confirmCustomEvent
            }) : createCommentVNode()
          ])
        ]) : null
      ] : []);
    };
    const renderPopupPanel = () => {
      const $xeGrid = $xeTable.xeGrid;
      const { customStore } = props;
      const { resizable: allResizable } = tableProps;
      const { isCustomStatus, customColumnList } = reactData;
      const customOpts = computeCustomOpts.value;
      const { immediate } = customOpts;
      const columnDragOpts = computeColumnDragOpts.value;
      const { mode, modalOptions, drawerOptions, allowVisible, allowSort, allowFixed, allowResizable, checkMethod, visibleMethod } = customOpts;
      const columnOpts = computeColumnOpts.value;
      const { maxFixedSize } = columnOpts;
      const resizableOpts = computeResizableOpts.value;
      const { minWidth: reMinWidth, maxWidth: reMaxWidth } = resizableOpts;
      const modalOpts = Object.assign({}, modalOptions);
      const drawerOpts = Object.assign({}, drawerOptions);
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const { isCrossDrag } = columnDragOpts;
      const slots = customOpts.slots || {};
      const headerSlot = slots.header;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const trVNs = [];
      const isAllChecked = customStore.isAll;
      const isAllIndeterminate = customStore.isIndeterminate;
      const params = {
        $table: $xeTable,
        $grid: $xeGrid,
        columns: customColumnList,
        isAllChecked,
        isAllIndeterminate,
        isCustomStatus
      };
      import_xe_utils4.default.eachTree(customColumnList, (column, index, items, path, parent) => {
        const isVisible = visibleMethod ? visibleMethod({ column }) : true;
        if (isVisible) {
          let customMinWidth = 0;
          let customMaxWidth = 0;
          if (allowResizable) {
            const resizeParams = {
              $table: $xeTable,
              column,
              columnIndex: index,
              $columnIndex: index,
              $rowIndex: -1
            };
            if (reMinWidth) {
              customMinWidth = import_xe_utils4.default.toNumber(import_xe_utils4.default.isFunction(reMinWidth) ? reMinWidth(resizeParams) : reMinWidth);
            }
            if (reMaxWidth) {
              customMaxWidth = import_xe_utils4.default.toNumber(import_xe_utils4.default.isFunction(reMaxWidth) ? reMaxWidth(resizeParams) : reMaxWidth);
            }
          }
          const isChecked = column.renderVisible;
          const isIndeterminate = column.halfVisible;
          const colTitle = formatText(column.getTitle(), 1);
          const isColGroup = column.children && column.children.length;
          const isDisabled = checkMethod ? !checkMethod({ column }) : false;
          const isHidden = !isChecked;
          trVNs.push(h("tr", {
            key: column.id,
            colid: column.id,
            class: [`vxe-table-custom-popup--row level--${column.level}`, {
              "is--group": isColGroup
            }],
            onDragstart: sortDragstartEvent,
            onDragend: sortDragendEvent,
            onDragover: sortDragoverEvent
          }, [
            allowVisible ? h("td", {
              class: "vxe-table-custom-popup--column-item col--visible"
            }, [
              h("div", {
                class: ["vxe-table-custom--checkbox-option", {
                  "is--checked": isChecked,
                  "is--indeterminate": isIndeterminate,
                  "is--disabled": isDisabled
                }],
                title: getI18n2("vxe.custom.setting.colVisible"),
                onClick: () => {
                  if (!isDisabled) {
                    changeCheckboxOption(column);
                  }
                }
              }, [
                h("span", {
                  class: ["vxe-checkbox--icon", isIndeterminate ? getIcon().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon().TABLE_CHECKBOX_CHECKED : getIcon().TABLE_CHECKBOX_UNCHECKED]
                })
              ])
            ]) : createCommentVNode(),
            h("td", {
              class: "vxe-table-custom-popup--column-item col--name"
            }, [
              h("div", {
                class: "vxe-table-custom-popup--name"
              }, [
                allowSort ? (isCrossDrag ? immediate : false) || column.level === 1 ? h("div", Object.assign({ class: ["vxe-table-custom-popup--column-sort-btn", {
                  "is--disabled": isDisabled || isHidden || column.renderFixed
                }], title: getI18n2("vxe.custom.setting.sortHelpTip") }, isDisabled || isHidden || column.renderFixed ? {} : {
                  onMousedown: sortMousedownEvent,
                  onMouseup: sortMouseupEvent
                }), [
                  h("i", {
                    class: getIcon().TABLE_CUSTOM_SORT
                  })
                ]) : h("div", {
                  class: "vxe-table-custom-popup--column-sort-placeholder"
                }) : createCommentVNode(),
                column.type === "html" ? h("div", {
                  key: "1",
                  class: "vxe-table-custom-popup--title",
                  innerHTML: colTitle
                }) : h("div", {
                  key: "0",
                  class: "vxe-table-custom-popup--title",
                  title: colTitle
                }, colTitle)
              ])
            ]),
            allowResizable ? h("td", {
              class: "vxe-table-custom-popup--column-item col--resizable"
            }, [
              column.children && column.children.length || !(import_xe_utils4.default.isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable) ? h("span", "-") : VxeUINumberInputComponent ? h(VxeUINumberInputComponent, {
                type: "integer",
                immediate: false,
                disabled: isDisabled || isHidden,
                modelValue: column.renderResizeWidth,
                min: customMinWidth || void 0,
                max: customMaxWidth || void 0,
                "onUpdate:modelValue"(value) {
                  const width = Math.max(0, Number(value));
                  column.renderResizeWidth = width;
                },
                onChange() {
                  changeColumnWidth(column);
                }
              }) : createCommentVNode()
            ]) : createCommentVNode(),
            allowFixed ? h("td", {
              class: "vxe-table-custom-popup--column-item col--fixed"
            }, [
              parent ? h("span", "-") : VxeUIRadioGroupComponent ? h(VxeUIRadioGroupComponent, {
                modelValue: column.renderFixed || "",
                type: "button",
                size: "mini",
                disabled: isDisabled || isHidden,
                options: [
                  { label: getI18n2("vxe.custom.setting.fixedLeft"), value: "left", disabled: isDisabled || isHidden || isMaxFixedColumn },
                  { label: getI18n2("vxe.custom.setting.fixedUnset"), value: "", disabled: isDisabled || isHidden },
                  { label: getI18n2("vxe.custom.setting.fixedRight"), value: "right", disabled: isDisabled || isHidden || isMaxFixedColumn }
                ],
                "onUpdate:modelValue"(value) {
                  changeFixedOption(column, value);
                }
              }) : createCommentVNode()
            ]) : createCommentVNode()
          ]));
        }
      });
      const scopedSlots = {
        default: () => {
          if (defaultSlot) {
            return $xeTable.callSlot(defaultSlot, params);
          }
          return h("div", {
            ref: bodyElemRef,
            class: "vxe-table-custom-popup--body"
          }, [
            topSlot ? h("div", {
              class: "vxe-table-custom-popup--table-top"
            }, $xeTable.callSlot(topSlot, params)) : renderEmptyElement4($xeTable),
            h("div", {
              class: "vxe-table-custom-popup--table-wrapper"
            }, [
              h("table", {}, [
                h("colgroup", {}, [
                  allowVisible ? h("col", {
                    class: "vxe-table-custom-popup--table-col-seq"
                  }) : createCommentVNode(),
                  h("col", {
                    class: "vxe-table-custom-popup--table-col-title"
                  }),
                  allowResizable ? h("col", {
                    class: "vxe-table-custom-popup--table-col-width"
                  }) : createCommentVNode(),
                  allowFixed ? h("col", {
                    class: "vxe-table-custom-popup--table-col-fixed"
                  }) : createCommentVNode()
                ]),
                h("thead", {}, [
                  h("tr", {}, [
                    allowVisible ? h("th", {}, [
                      h("div", {
                        class: ["vxe-table-custom--checkbox-option", {
                          "is--checked": isAllChecked,
                          "is--indeterminate": isAllIndeterminate
                        }],
                        title: getI18n2("vxe.table.allTitle"),
                        onClick: allOptionEvent
                      }, [
                        h("span", {
                          class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? getIcon().TABLE_CHECKBOX_CHECKED : getIcon().TABLE_CHECKBOX_UNCHECKED]
                        }),
                        h("span", {
                          class: "vxe-checkbox--label"
                        }, getI18n2("vxe.toolbar.customAll"))
                      ])
                    ]) : createCommentVNode(),
                    h("th", {}, getI18n2("vxe.custom.setting.colTitle")),
                    allowResizable ? h("th", {}, getI18n2("vxe.custom.setting.colResizable")) : createCommentVNode(),
                    allowFixed ? h("th", {}, getI18n2(`vxe.custom.setting.${maxFixedSize ? "colFixedMax" : "colFixed"}`, [maxFixedSize])) : createCommentVNode()
                  ])
                ]),
                h(TransitionGroup, {
                  class: "vxe-table-custom--panel-list",
                  tag: "tbody",
                  name: "vxe-table-custom--list"
                }, {
                  default: () => trVNs
                })
              ])
            ]),
            bottomSlot ? h("div", {
              class: "vxe-table-custom-popup--table-bottom"
            }, $xeTable.callSlot(bottomSlot, params)) : renderEmptyElement4($xeTable),
            renderDragTip()
          ]);
        },
        footer: () => {
          if (footerSlot) {
            return $xeTable.callSlot(footerSlot, params);
          }
          return h("div", {
            class: "vxe-table-custom-popup--footer"
          }, [
            VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              content: customOpts.resetButtonText || getI18n2("vxe.custom.cstmRestore"),
              disabled: !isCustomStatus,
              onClick: resetCustomEvent
            }) : createCommentVNode(),
            immediate ? VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              content: customOpts.closeButtonText || getI18n2("vxe.table.customClose"),
              onClick: cancelCloseEvent
            }) : createCommentVNode() : VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              content: customOpts.cancelButtonText || getI18n2("vxe.table.customCancel"),
              onClick: cancelCustomEvent
            }) : createCommentVNode(),
            immediate ? createCommentVNode() : VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              status: "primary",
              content: customOpts.confirmButtonText || getI18n2("vxe.custom.cstmConfirm"),
              onClick: confirmCustomEvent
            }) : createCommentVNode()
          ]);
        }
      };
      if (headerSlot) {
        scopedSlots.header = () => $xeTable.callSlot(headerSlot, params);
      }
      if (mode === "drawer") {
        return VxeUIDrawerComponent ? h(VxeUIDrawerComponent, {
          key: "drawer",
          className: ["vxe-table-custom-drawer-wrapper", "vxe-table--ignore-clear", drawerOpts.className || ""].join(" "),
          modelValue: customStore.visible,
          title: drawerOpts.title || getI18n2("vxe.custom.cstmTitle"),
          width: drawerOpts.width || Math.min(880, Math.floor(document.documentElement.clientWidth * 0.6)),
          position: drawerOpts.position,
          resize: !!drawerOpts.resize,
          escClosable: !!drawerOpts.escClosable,
          maskClosable: !!drawerOpts.maskClosable,
          destroyOnClose: true,
          showFooter: true,
          "onUpdate:modelValue"(value) {
            customStore.visible = value;
          }
        }, scopedSlots) : createCommentVNode();
      }
      return VxeUIModalComponent ? h(VxeUIModalComponent, {
        key: "modal",
        className: ["vxe-table-custom-modal-wrapper", "vxe-table--ignore-clear", modalOpts.className || ""].join(" "),
        modelValue: customStore.visible,
        title: modalOpts.title || getI18n2("vxe.custom.cstmTitle"),
        width: modalOpts.width || Math.min(880, document.documentElement.clientWidth),
        minWidth: modalOpts.minWidth || 700,
        height: modalOpts.height || Math.min(680, document.documentElement.clientHeight),
        minHeight: modalOpts.minHeight || 400,
        showZoom: modalOpts.showZoom,
        showMaximize: modalOpts.showMaximize,
        showMinimize: modalOpts.showMinimize,
        mask: modalOpts.mask,
        lockView: modalOpts.lockView,
        resize: modalOpts.resize,
        escClosable: !!modalOpts.escClosable,
        maskClosable: !!modalOpts.maskClosable,
        destroyOnClose: true,
        showFooter: true,
        "onUpdate:modelValue"(value) {
          customStore.visible = value;
        }
      }, scopedSlots) : createCommentVNode();
    };
    const renderVN = () => {
      const customOpts = computeCustomOpts.value;
      if (["modal", "drawer", "popup"].includes(`${customOpts.mode}`)) {
        return renderPopupPanel();
      }
      return renderSimplePanel();
    };
    nextTick(() => {
      const customOpts = computeCustomOpts.value;
      const { mode } = customOpts;
      if (!VxeUIModalComponent) {
        errLog("vxe.error.reqComp", ["vxe-modal"]);
      }
      if (!VxeUIDrawerComponent && mode === "drawer") {
        errLog("vxe.error.reqComp", ["vxe-drawer"]);
      }
      if (!VxeUIButtonComponent) {
        errLog("vxe.error.reqComp", ["vxe-button"]);
      }
      if (!VxeUINumberInputComponent) {
        errLog("vxe.error.reqComp", ["vxe-number-input"]);
      }
      if (!VxeUIRadioGroupComponent) {
        errLog("vxe.error.reqComp", ["vxe-radio-group"]);
      }
    });
    return renderVN;
  }
});

// node_modules/vxe-table/es/table/module/filter/panel.js
var { getI18n: getI18n3, getIcon: getIcon2, renderer: renderer4 } = VxeUI;
var panel_default2 = defineComponent({
  name: "VxeTableFilterPanel",
  props: {
    filterStore: Object
  },
  setup(props) {
    const $xeTable = inject("$xeTable", {});
    const { reactData: tableReactData, internalData: tableInternalData, getComputeMaps } = $xeTable;
    const { computeFilterOpts } = getComputeMaps();
    const computeHasCheckOption = computed(() => {
      const { filterStore } = props;
      return filterStore && filterStore.options.some((option) => option.checked);
    });
    const filterCheckAllEvent = (evnt, value) => {
      const { filterStore } = props;
      filterStore.options.forEach((option) => {
        option._checked = value;
        option.checked = value;
      });
      filterStore.isAllSelected = value;
      filterStore.isIndeterminate = false;
    };
    const confirmFilter = (evnt) => {
      $xeTable.handleFilterConfirmFilter(evnt);
    };
    const changeRadioOption = (evnt, checked, item) => {
      $xeTable.handleFilterChangeRadioOption(evnt, checked, item);
    };
    const resetFilter = (evnt) => {
      $xeTable.handleFilterResetFilter(evnt);
    };
    const changeMultipleOption = (evnt, checked, item) => {
      $xeTable.handleFilterChangeMultipleOption(evnt, checked, item);
    };
    const changeOption = (evnt, checked, item) => {
      $xeTable.handleFilterChangeOption(evnt, checked, item);
    };
    const changeAllOption = (evnt, checked) => {
      const { filterStore } = props;
      if (filterStore.multiple) {
        filterCheckAllEvent(evnt, checked);
      } else {
        resetFilter(evnt);
      }
    };
    const $panel = {
      changeRadioOption,
      changeMultipleOption,
      changeAllOption,
      changeOption,
      confirmFilter,
      resetFilter
    };
    const renderOptions = (filterRender, compConf) => {
      const { filterStore } = props;
      const { column, multiple, maxHeight } = filterStore;
      const slots = column ? column.slots : null;
      const filterSlot = slots ? slots.filter : null;
      const params = Object.assign({}, tableInternalData._currFilterParams, { $panel, $table: $xeTable });
      const rtFilter = compConf ? compConf.renderTableFilter || compConf.renderFilter : null;
      if (filterSlot) {
        return [
          h("div", {
            class: "vxe-table--filter-template",
            style: maxHeight ? {
              maxHeight: `${maxHeight}px`
            } : {}
          }, $xeTable.callSlot(filterSlot, params))
        ];
      } else if (rtFilter) {
        return [
          h("div", {
            class: "vxe-table--filter-template",
            style: maxHeight ? {
              maxHeight: `${maxHeight}px`
            } : {}
          }, getSlotVNs(rtFilter(filterRender, params)))
        ];
      }
      const isAllChecked = multiple ? filterStore.isAllSelected : !filterStore.options.some((item) => item._checked);
      const isAllIndeterminate = multiple && filterStore.isIndeterminate;
      return [
        h("ul", {
          class: "vxe-table--filter-header"
        }, [
          h("li", {
            class: ["vxe-table--filter-option", {
              "is--checked": isAllChecked,
              "is--indeterminate": isAllIndeterminate
            }],
            title: getI18n3(multiple ? "vxe.table.allTitle" : "vxe.table.allFilter"),
            onClick: (evnt) => {
              changeAllOption(evnt, !filterStore.isAllSelected);
            }
          }, (multiple ? [
            h("span", {
              class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon2().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? getIcon2().TABLE_CHECKBOX_CHECKED : getIcon2().TABLE_CHECKBOX_UNCHECKED]
            })
          ] : []).concat([
            h("span", {
              class: "vxe-checkbox--label"
            }, getI18n3("vxe.table.allFilter"))
          ]))
        ]),
        h("ul", {
          class: "vxe-table--filter-body",
          style: maxHeight ? {
            maxHeight: `${maxHeight}px`
          } : {}
        }, filterStore.options.map((item) => {
          const isChecked = item._checked;
          const isIndeterminate = false;
          return h("li", {
            class: ["vxe-table--filter-option", {
              "is--checked": item._checked
            }],
            title: item.label,
            onClick: (evnt) => {
              changeOption(evnt, !item._checked, item);
            }
          }, (multiple ? [
            h("span", {
              class: ["vxe-checkbox--icon", isIndeterminate ? getIcon2().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon2().TABLE_CHECKBOX_CHECKED : getIcon2().TABLE_CHECKBOX_UNCHECKED]
            })
          ] : []).concat([
            h("span", {
              class: "vxe-checkbox--label"
            }, formatText(item.label, 1))
          ]));
        }))
      ];
    };
    const renderFooters = () => {
      const { filterStore } = props;
      const { column, multiple } = filterStore;
      const filterOpts = computeFilterOpts.value;
      const hasCheckOption = computeHasCheckOption.value;
      const { filterRender } = column;
      const compConf = isEnableConf(filterRender) ? renderer4.get(filterRender.name) : null;
      const isDisabled = !hasCheckOption && !filterStore.isAllSelected && !filterStore.isIndeterminate;
      return multiple && (compConf ? !(compConf.showTableFilterFooter === false || compConf.showFilterFooter === false || compConf.isFooter === false) : true) ? [
        h("div", {
          class: "vxe-table--filter-footer"
        }, [
          h("button", {
            class: {
              "is--disabled": isDisabled
            },
            disabled: isDisabled,
            onClick: confirmFilter
          }, filterOpts.confirmButtonText || getI18n3("vxe.table.confirmFilter")),
          h("button", {
            onClick: resetFilter
          }, filterOpts.resetButtonText || getI18n3("vxe.table.resetFilter"))
        ])
      ] : [];
    };
    const renderVN = () => {
      const { filterStore } = props;
      const { initStore } = tableReactData;
      const { visible, multiple, column } = filterStore;
      const filterRender = column ? column.filterRender : null;
      const compConf = isEnableConf(filterRender) ? renderer4.get(filterRender.name) : null;
      const filterClassName = compConf ? compConf.tableFilterClassName || compConf.filterClassName : "";
      const params = Object.assign({}, tableInternalData._currFilterParams, { $panel, $table: $xeTable });
      const filterOpts = computeFilterOpts.value;
      const { destroyOnClose } = filterOpts;
      return h("div", {
        class: [
          "vxe-table--filter-wrapper",
          "filter--prevent-default",
          getPropClass(filterClassName, params),
          {
            "is--animat": $xeTable.props.animat,
            "is--multiple": multiple,
            "is--active": visible
          }
        ],
        style: filterStore.style
      }, initStore.filter && (destroyOnClose ? visible : true) && column ? renderOptions(filterRender, compConf).concat(renderFooters()) : []);
    };
    return renderVN;
  }
});

// node_modules/vxe-table/es/table/module/export/import-panel.js
var import_xe_utils5 = __toESM(require_xe_utils());
var { getI18n: getI18n4, getIcon: getIcon3 } = VxeUI;
var import_panel_default = defineComponent({
  name: "VxeTableImportPanel",
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(props) {
    const VxeUIModalComponent = VxeUI.getComponent("VxeModal");
    const VxeUIButtonComponent = VxeUI.getComponent("VxeButton");
    const VxeUISelectComponent = VxeUI.getComponent("VxeSelect");
    const $xeTable = inject("$xeTable", {});
    const { computeImportOpts } = $xeTable.getComputeMaps();
    const reactData = reactive({
      loading: false
    });
    const refFileBtn = ref();
    const computeSelectName = computed(() => {
      const { storeData } = props;
      return `${storeData.filename}.${storeData.type}`;
    });
    const computeHasFile = computed(() => {
      const { storeData } = props;
      return storeData.file && storeData.type;
    });
    const computeParseTypeLabel = computed(() => {
      const { storeData } = props;
      const { type, typeList } = storeData;
      if (type) {
        const selectItem = import_xe_utils5.default.find(typeList, (item) => type === item.value);
        return selectItem ? selectItem.label : "*.*";
      }
      return `*.${typeList.map((item) => item.value).join(", *.")}`;
    });
    const clearFileEvent = () => {
      const { storeData } = props;
      Object.assign(storeData, {
        filename: "",
        sheetName: "",
        type: ""
      });
    };
    const selectFileEvent = () => {
      const { storeData, defaultOptions } = props;
      $xeTable.readFile(defaultOptions).then((params) => {
        const { file } = params;
        Object.assign(storeData, parseFile(file), { file });
      }).catch((e) => e);
    };
    const showEvent = () => {
      nextTick(() => {
        const targetElem = refFileBtn.value;
        if (targetElem) {
          targetElem.focus();
        }
      });
    };
    const cancelEvent = () => {
      const { storeData } = props;
      storeData.visible = false;
    };
    const importEvent = () => {
      const { storeData, defaultOptions } = props;
      const importOpts = computeImportOpts.value;
      reactData.loading = true;
      $xeTable.importByFile(storeData.file, Object.assign({}, importOpts, defaultOptions)).then(() => {
        reactData.loading = false;
        storeData.visible = false;
      }).catch(() => {
        reactData.loading = false;
      });
    };
    const renderVN = () => {
      const $xeGrid = $xeTable.xeGrid;
      const { defaultOptions, storeData } = props;
      const selectName = computeSelectName.value;
      const hasFile = computeHasFile.value;
      const parseTypeLabel = computeParseTypeLabel.value;
      const slots = defaultOptions.slots || {};
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      return VxeUIModalComponent ? h(VxeUIModalComponent, {
        id: "VXE_IMPORT_MODAL",
        modelValue: storeData.visible,
        title: getI18n4("vxe.import.impTitle"),
        className: "vxe-table-export-popup-wrapper",
        width: 540,
        minWidth: 360,
        minHeight: 240,
        mask: true,
        lockView: true,
        showFooter: true,
        escClosable: true,
        maskClosable: true,
        showMaximize: true,
        resize: true,
        loading: reactData.loading,
        "onUpdate:modelValue"(value) {
          storeData.visible = value;
        },
        onShow: showEvent
      }, {
        default: () => {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            options: defaultOptions,
            params: defaultOptions.params
          };
          return h("div", {
            class: "vxe-table-export--panel"
          }, [
            topSlot ? h("div", {
              class: "vxe-table-export--panel-top"
            }, $xeTable.callSlot(topSlot, params)) : createCommentVNode(),
            h("div", {
              class: "vxe-table-export--panel-body"
            }, defaultSlot ? $xeTable.callSlot(defaultSlot, params) : [
              h("table", {
                class: "vxe-table-export--panel-table",
                cellspacing: 0,
                cellpadding: 0,
                border: 0
              }, [
                h("tbody", [
                  h("tr", [
                    h("td", getI18n4("vxe.import.impFile")),
                    h("td", [
                      hasFile ? h("div", {
                        class: "vxe-table-export--selected--file",
                        title: selectName
                      }, [
                        h("span", selectName),
                        h("i", {
                          class: getIcon3().INPUT_CLEAR,
                          onClick: clearFileEvent
                        })
                      ]) : h("button", {
                        ref: refFileBtn,
                        class: "vxe-table-export--select--file",
                        onClick: selectFileEvent
                      }, getI18n4("vxe.import.impSelect"))
                    ])
                  ]),
                  h("tr", [
                    h("td", getI18n4("vxe.import.impType")),
                    h("td", parseTypeLabel)
                  ]),
                  h("tr", [
                    h("td", getI18n4("vxe.import.impMode")),
                    h("td", [
                      VxeUISelectComponent ? h(VxeUISelectComponent, {
                        modelValue: defaultOptions.mode,
                        options: storeData.modeList,
                        "onUpdate:modelValue"(value) {
                          defaultOptions.mode = value;
                        }
                      }) : createCommentVNode()
                    ])
                  ])
                ])
              ])
            ]),
            bottomSlot ? h("div", {
              class: "vxe-table-export--panel-bottom"
            }, $xeTable.callSlot(bottomSlot, params)) : createCommentVNode()
          ]);
        },
        footer() {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            options: defaultOptions,
            params: defaultOptions.params
          };
          return h("div", {
            class: "vxe-table-export--panel-footer"
          }, footerSlot ? $xeTable.callSlot(footerSlot, params) : [
            h("div", {
              class: "vxe-table-export--panel-btns"
            }, [
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                content: getI18n4("vxe.import.impCancel"),
                onClick: cancelEvent
              }) : createCommentVNode(),
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                status: "primary",
                disabled: !hasFile || reactData.loading,
                content: getI18n4("vxe.import.impConfirm"),
                onClick: importEvent
              }) : createCommentVNode()
            ])
          ]);
        }
      }) : createCommentVNode();
    };
    nextTick(() => {
      if (!VxeUIModalComponent) {
        errLog("vxe.error.reqComp", ["vxe-modal"]);
      }
      if (!VxeUIButtonComponent) {
        errLog("vxe.error.reqComp", ["vxe-button"]);
      }
      if (!VxeUISelectComponent) {
        errLog("vxe.error.reqComp", ["vxe-select"]);
      }
    });
    return renderVN;
  }
});

// node_modules/vxe-table/es/table/module/export/export-panel.js
var import_xe_utils6 = __toESM(require_xe_utils());
var { getI18n: getI18n5, getIcon: getIcon4 } = VxeUI;
var export_panel_default = defineComponent({
  name: "VxeTableExportPanel",
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(props) {
    const VxeUIModalComponent = VxeUI.getComponent("VxeModal");
    const VxeUIButtonComponent = VxeUI.getComponent("VxeButton");
    const VxeUISelectComponent = VxeUI.getComponent("VxeSelect");
    const VxeUIInputComponent = VxeUI.getComponent("VxeInput");
    const VxeUICheckboxComponent = VxeUI.getComponent("VxeCheckbox");
    const $xeTable = inject("$xeTable", {});
    const { computeExportOpts, computePrintOpts } = $xeTable.getComputeMaps();
    const reactData = reactive({
      isAll: false,
      isIndeterminate: false,
      loading: false
    });
    const xButtonConfirm = ref();
    const xInputFilename = ref();
    const xInputSheetname = ref();
    const computeCheckedAll = computed(() => {
      const { storeData } = props;
      return storeData.columns.every((column) => column.checked);
    });
    const computeShowSheet = computed(() => {
      const { defaultOptions } = props;
      return ["html", "xml", "xlsx", "pdf"].indexOf(defaultOptions.type) > -1;
    });
    const computeSupportMerge = computed(() => {
      const { storeData, defaultOptions } = props;
      return !defaultOptions.original && defaultOptions.mode === "current" && (storeData.isPrint || ["html", "xlsx"].indexOf(defaultOptions.type) > -1);
    });
    const computeSupportStyle = computed(() => {
      const { defaultOptions } = props;
      return !defaultOptions.original && ["xlsx"].indexOf(defaultOptions.type) > -1;
    });
    const handleOptionCheck = (column) => {
      const { storeData } = props;
      const matchObj = import_xe_utils6.default.findTree(storeData.columns, (item) => item === column);
      if (matchObj && matchObj.parent) {
        const { parent } = matchObj;
        if (parent.children && parent.children.length) {
          parent.checked = parent.children.every((column2) => column2.checked);
          parent.halfChecked = !parent.checked && parent.children.some((column2) => column2.checked || column2.halfChecked);
          handleOptionCheck(parent);
        }
      }
    };
    const checkStatus = () => {
      const { storeData } = props;
      const columns = storeData.columns;
      reactData.isAll = columns.every((column) => column.disabled || column.checked);
      reactData.isIndeterminate = !reactData.isAll && columns.some((column) => !column.disabled && (column.checked || column.halfChecked));
    };
    const changeOption = (column) => {
      const isChecked = !column.checked;
      import_xe_utils6.default.eachTree([column], (item) => {
        item.checked = isChecked;
        item.halfChecked = false;
      });
      handleOptionCheck(column);
      checkStatus();
    };
    const allColumnEvent = () => {
      const { storeData } = props;
      const isAll = !reactData.isAll;
      import_xe_utils6.default.eachTree(storeData.columns, (column) => {
        if (!column.disabled) {
          column.checked = isAll;
          column.halfChecked = false;
        }
      });
      reactData.isAll = isAll;
      checkStatus();
    };
    const showEvent = () => {
      nextTick(() => {
        const filenameInp = xInputFilename.value;
        const sheetnameInp = xInputSheetname.value;
        const confirmBtn = xButtonConfirm.value;
        const targetElem = filenameInp || sheetnameInp || confirmBtn;
        if (targetElem) {
          targetElem.focus();
        }
      });
      checkStatus();
    };
    const getExportOption = () => {
      const { storeData, defaultOptions } = props;
      const { hasMerge, columns } = storeData;
      const checkedAll = computeCheckedAll.value;
      const supportMerge = computeSupportMerge.value;
      const expColumns = import_xe_utils6.default.searchTree(columns, (column) => column.checked, { children: "children", mapChildren: "childNodes", original: true });
      return Object.assign({}, defaultOptions, {
        columns: expColumns,
        isMerge: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false
      });
    };
    const printEvent = () => {
      const { storeData } = props;
      const printOpts = computePrintOpts.value;
      storeData.visible = false;
      $xeTable.print(Object.assign({}, printOpts, getExportOption()));
    };
    const exportEvent = () => {
      const { storeData } = props;
      const exportOpts = computeExportOpts.value;
      reactData.loading = true;
      $xeTable.exportData(Object.assign({}, exportOpts, getExportOption())).then(() => {
        reactData.loading = false;
        storeData.visible = false;
      }).catch(() => {
        reactData.loading = false;
      });
    };
    const cancelEvent = () => {
      const { storeData } = props;
      storeData.visible = false;
    };
    const confirmEvent = () => {
      const { storeData } = props;
      if (storeData.isPrint) {
        printEvent();
      } else {
        exportEvent();
      }
    };
    const renderVN = () => {
      const $xeGrid = $xeTable.xeGrid;
      const { defaultOptions, storeData } = props;
      const { isAll: isAllChecked, isIndeterminate: isAllIndeterminate } = reactData;
      const { hasTree, hasMerge, isPrint, hasColgroup, columns } = storeData;
      const { isHeader } = defaultOptions;
      const cols = [];
      const checkedAll = computeCheckedAll.value;
      const showSheet = computeShowSheet.value;
      const supportMerge = computeSupportMerge.value;
      const supportStyle = computeSupportStyle.value;
      const slots = defaultOptions.slots || {};
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const parameterSlot = slots.parameter;
      import_xe_utils6.default.eachTree(columns, (column) => {
        const colTitle = formatText(column.getTitle(), 1);
        const isColGroup = column.children && column.children.length;
        const isChecked = column.checked;
        const indeterminate = column.halfChecked;
        const isHtml = column.type === "html";
        cols.push(h("li", {
          key: column.id,
          class: ["vxe-table-export--panel-column-option", `level--${column.level}`, {
            "is--group": isColGroup,
            "is--checked": isChecked,
            "is--indeterminate": indeterminate,
            "is--disabled": column.disabled
          }],
          title: isHtml ? "" : colTitle,
          onClick: () => {
            if (!column.disabled) {
              changeOption(column);
            }
          }
        }, [
          h("span", {
            class: ["vxe-checkbox--icon", indeterminate ? getIcon4().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon4().TABLE_CHECKBOX_CHECKED : getIcon4().TABLE_CHECKBOX_UNCHECKED]
          }),
          isHtml ? h("span", {
            key: "1",
            class: "vxe-checkbox--label",
            innerHTML: colTitle
          }) : h("span", {
            key: "0",
            class: "vxe-checkbox--label"
          }, colTitle)
        ]));
      });
      return VxeUIModalComponent ? h(VxeUIModalComponent, {
        id: "VXE_EXPORT_MODAL",
        modelValue: storeData.visible,
        title: getI18n5(isPrint ? "vxe.export.printTitle" : "vxe.export.expTitle"),
        className: "vxe-table-export-popup-wrapper",
        width: 660,
        minWidth: 500,
        minHeight: 400,
        mask: true,
        lockView: true,
        showFooter: true,
        escClosable: true,
        maskClosable: true,
        showMaximize: true,
        resize: true,
        loading: reactData.loading,
        "onUpdate:modelValue"(value) {
          storeData.visible = value;
        },
        onShow: showEvent
      }, {
        default: () => {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            options: defaultOptions,
            columns,
            params: defaultOptions.params
          };
          const hasEmptyData = defaultOptions.mode === "empty";
          return h("div", {
            class: "vxe-table-export--panel"
          }, [
            topSlot ? h("div", {
              class: "vxe-table-export--panel-top"
            }, $xeTable.callSlot(topSlot, params)) : createCommentVNode(),
            h("div", {
              class: "vxe-table-export--panel-body"
            }, defaultSlot ? $xeTable.callSlot(defaultSlot, params) : [
              h("table", {
                class: "vxe-table-export--panel-table",
                cellspacing: 0,
                cellpadding: 0,
                border: 0
              }, [
                h("tbody", [
                  [
                    isPrint ? createCommentVNode() : h("tr", [
                      h("td", getI18n5("vxe.export.expName")),
                      h("td", [
                        VxeUIInputComponent ? h(VxeUIInputComponent, {
                          ref: xInputFilename,
                          modelValue: defaultOptions.filename,
                          type: "text",
                          clearable: true,
                          placeholder: getI18n5("vxe.export.expNamePlaceholder"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.filename = value;
                          }
                        }) : createCommentVNode()
                      ])
                    ]),
                    isPrint ? createCommentVNode() : h("tr", [
                      h("td", getI18n5("vxe.export.expType")),
                      h("td", [
                        VxeUISelectComponent ? h(VxeUISelectComponent, {
                          modelValue: defaultOptions.type,
                          options: storeData.typeList,
                          "onUpdate:modelValue"(value) {
                            defaultOptions.type = value;
                          }
                        }) : createCommentVNode()
                      ])
                    ]),
                    isPrint || showSheet ? h("tr", [
                      h("td", getI18n5("vxe.export.expSheetName")),
                      h("td", [
                        VxeUIInputComponent ? h(VxeUIInputComponent, {
                          ref: xInputSheetname,
                          modelValue: defaultOptions.sheetName,
                          type: "text",
                          clearable: true,
                          placeholder: getI18n5("vxe.export.expSheetNamePlaceholder"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.sheetName = value;
                          }
                        }) : createCommentVNode()
                      ])
                    ]) : createCommentVNode(),
                    h("tr", [
                      h("td", getI18n5("vxe.export.expMode")),
                      h("td", [
                        VxeUISelectComponent ? h(VxeUISelectComponent, {
                          modelValue: defaultOptions.mode,
                          options: storeData.modeList.map((item) => {
                            return {
                              value: item.value,
                              label: getI18n5(item.label)
                            };
                          }),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.mode = value;
                          }
                        }) : createCommentVNode()
                      ])
                    ]),
                    h("tr", [
                      h("td", [getI18n5("vxe.export.expColumn")]),
                      h("td", [
                        h("div", {
                          class: "vxe-table-export--panel-column"
                        }, [
                          h("ul", {
                            class: "vxe-table-export--panel-column-header"
                          }, [
                            h("li", {
                              class: ["vxe-table-export--panel-column-option", {
                                "is--checked": isAllChecked,
                                "is--indeterminate": isAllIndeterminate
                              }],
                              title: getI18n5("vxe.table.allTitle"),
                              onClick: allColumnEvent
                            }, [
                              h("span", {
                                class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon4().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? getIcon4().TABLE_CHECKBOX_CHECKED : getIcon4().TABLE_CHECKBOX_UNCHECKED]
                              }),
                              h("span", {
                                class: "vxe-checkbox--label"
                              }, getI18n5("vxe.export.expCurrentColumn"))
                            ])
                          ]),
                          h("ul", {
                            class: "vxe-table-export--panel-column-body"
                          }, cols)
                        ])
                      ])
                    ]),
                    h("tr", [
                      h("td", getI18n5("vxe.export.expOpts")),
                      parameterSlot ? h("td", [
                        h("div", {
                          class: "vxe-table-export--panel-option-row"
                        }, $xeTable.callSlot(parameterSlot, params))
                      ]) : h("td", [
                        h("div", {
                          class: "vxe-table-export--panel-option-row"
                        }, [
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: hasEmptyData || defaultOptions.isHeader,
                            disabled: hasEmptyData,
                            title: getI18n5("vxe.export.expHeaderTitle"),
                            content: getI18n5("vxe.export.expOptHeader"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isHeader = value;
                            }
                          }) : createCommentVNode(),
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: defaultOptions.isFooter,
                            disabled: !storeData.hasFooter,
                            title: getI18n5("vxe.export.expFooterTitle"),
                            content: getI18n5("vxe.export.expOptFooter"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isFooter = value;
                            }
                          }) : createCommentVNode(),
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: hasEmptyData ? false : defaultOptions.original,
                            disabled: hasEmptyData,
                            title: getI18n5("vxe.export.expOriginalTitle"),
                            content: getI18n5("vxe.export.expOptOriginal"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.original = value;
                            }
                          }) : createCommentVNode()
                        ]),
                        h("div", {
                          class: "vxe-table-export--panel-option-row"
                        }, [
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            // modelValue: supportGroup || (isHeader && hasColgroup && supportMerge) ? defaultOptions.isColgroup : false,
                            // title: getI18n('vxe.export.expColgroupTitle'),
                            // disabled: !supportGroup && (!isHeader || !hasColgroup || !supportMerge),
                            modelValue: isHeader && hasColgroup && supportMerge ? defaultOptions.isColgroup : false,
                            title: getI18n5("vxe.export.expColgroupTitle"),
                            disabled: !isHeader || !hasColgroup || !supportMerge,
                            content: getI18n5("vxe.export.expOptColgroup"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isColgroup = value;
                            }
                          }) : createCommentVNode(),
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false,
                            title: getI18n5("vxe.export.expMergeTitle"),
                            disabled: hasEmptyData || !hasMerge || !supportMerge || !checkedAll,
                            content: getI18n5("vxe.export.expOptMerge"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isMerge = value;
                            }
                          }) : createCommentVNode(),
                          isPrint || !VxeUICheckboxComponent ? createCommentVNode() : h(VxeUICheckboxComponent, {
                            modelValue: supportStyle ? defaultOptions.useStyle : false,
                            disabled: !supportStyle,
                            title: getI18n5("vxe.export.expUseStyleTitle"),
                            content: getI18n5("vxe.export.expOptUseStyle"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.useStyle = value;
                            }
                          }),
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: hasTree ? defaultOptions.isAllExpand : false,
                            disabled: hasEmptyData || !hasTree,
                            title: getI18n5("vxe.export.expAllExpandTitle"),
                            content: getI18n5("vxe.export.expOptAllExpand"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isAllExpand = value;
                            }
                          }) : createCommentVNode()
                        ])
                      ])
                    ])
                  ]
                ])
              ])
            ]),
            bottomSlot ? h("div", {
              class: "vxe-table-export--panel-bottom"
            }, $xeTable.callSlot(bottomSlot, params)) : createCommentVNode()
          ]);
        },
        footer() {
          const params = {
            $table: $xeTable,
            $grid: $xeGrid,
            options: defaultOptions,
            columns,
            params: defaultOptions.params
          };
          return h("div", {
            class: "vxe-table-export--panel-footer"
          }, footerSlot ? $xeTable.callSlot(footerSlot, params) : [
            h("div", {
              class: "vxe-table-export--panel-btns"
            }, [
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                content: getI18n5("vxe.export.expCancel"),
                onClick: cancelEvent
              }) : createCommentVNode(),
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                ref: xButtonConfirm,
                status: "primary",
                content: getI18n5(isPrint ? "vxe.export.expPrint" : "vxe.export.expConfirm"),
                onClick: confirmEvent
              }) : createCommentVNode()
            ])
          ]);
        }
      }) : createCommentVNode();
    };
    nextTick(() => {
      if (!VxeUIModalComponent) {
        errLog("vxe.error.reqComp", ["vxe-modal"]);
      }
      if (!VxeUIButtonComponent) {
        errLog("vxe.error.reqComp", ["vxe-button"]);
      }
      if (!VxeUISelectComponent) {
        errLog("vxe.error.reqComp", ["vxe-select"]);
      }
      if (!VxeUIInputComponent) {
        errLog("vxe.error.reqComp", ["vxe-input"]);
      }
      if (!VxeUICheckboxComponent) {
        errLog("vxe.error.reqComp", ["vxe-checkbox"]);
      }
    });
    return renderVN;
  }
});

// node_modules/vxe-table/es/table/module/menu/panel.js
var import_xe_utils7 = __toESM(require_xe_utils());
var { getIcon: getIcon5 } = VxeUI;
var panel_default3 = defineComponent({
  name: "VxeTableMenuPanel",
  setup(props, context) {
    const xID = import_xe_utils7.default.uniqueId();
    const $xeTable = inject("$xeTable", {});
    const { reactData: tableReactData } = $xeTable;
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xeMenuPanel = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    const renderVN = () => {
      const { ctxMenuStore } = tableReactData;
      const { computeMenuOpts } = $xeTable.getComputeMaps();
      const menuOpts = computeMenuOpts.value;
      return h(Teleport, {
        to: "body",
        disabled: false
      }, [
        h("div", {
          ref: refElem,
          class: ["vxe-table--context-menu-wrapper", menuOpts.className, {
            "is--visible": ctxMenuStore.visible
          }],
          style: ctxMenuStore.style
        }, ctxMenuStore.list.map((options, gIndex) => {
          return options.every((item) => item.visible === false) ? createCommentVNode() : h("ul", {
            class: "vxe-context-menu--option-wrapper",
            key: gIndex
          }, options.map((item, index) => {
            const hasChildMenus = item.children && item.children.some((child) => child.visible !== false);
            const prefixOpts = Object.assign({}, item.prefixConfig);
            const suffixOpts = Object.assign({}, item.suffixConfig);
            return item.visible === false ? null : h("li", {
              class: [item.className, {
                "link--disabled": item.disabled,
                "link--active": item === ctxMenuStore.selected
              }],
              key: `${gIndex}_${index}`
            }, [
              h("a", {
                class: "vxe-context-menu--link",
                onClick(evnt) {
                  $xeTable.ctxMenuLinkEvent(evnt, item);
                },
                onMouseover(evnt) {
                  $xeTable.ctxMenuMouseoverEvent(evnt, item);
                },
                onMouseout(evnt) {
                  $xeTable.ctxMenuMouseoutEvent(evnt, item);
                }
              }, [
                h("div", {
                  class: ["vxe-context-menu--link-prefix", prefixOpts.className || ""]
                }, [
                  h("i", {
                    class: prefixOpts.icon || item.prefixIcon
                  }),
                  prefixOpts.content ? h("span", {}, `${prefixOpts.content}`) : createCommentVNode()
                ]),
                h("div", {
                  class: "vxe-context-menu--link-content"
                }, getFuncText(item.name)),
                h("div", {
                  class: ["vxe-context-menu--link-suffix", suffixOpts.className || ""]
                }, [
                  h("i", {
                    class: suffixOpts.icon || item.suffixIcon || (hasChildMenus ? getIcon5().TABLE_MENU_OPTIONS : "")
                  }),
                  suffixOpts.content ? h("span", `${suffixOpts.content}`) : createCommentVNode()
                ])
              ]),
              hasChildMenus ? h("ul", {
                class: ["vxe-table--context-menu-clild-wrapper", {
                  "is--show": item === ctxMenuStore.selected && ctxMenuStore.showChild
                }]
              }, item.children.map((child, cIndex) => {
                const childPrefixOpts = Object.assign({}, child.prefixConfig);
                const childSuffixOpts = Object.assign({}, child.suffixConfig);
                return child.visible === false ? null : h("li", {
                  class: [child.className, {
                    "link--disabled": child.disabled,
                    "link--active": child === ctxMenuStore.selectChild
                  }],
                  key: `${gIndex}_${index}_${cIndex}`
                }, [
                  h("a", {
                    class: "vxe-context-menu--link",
                    onClick(evnt) {
                      $xeTable.ctxMenuLinkEvent(evnt, child);
                    },
                    onMouseover(evnt) {
                      $xeTable.ctxMenuMouseoverEvent(evnt, item, child);
                    },
                    onMouseout(evnt) {
                      $xeTable.ctxMenuMouseoutEvent(evnt, item);
                    }
                  }, [
                    h("div", {
                      class: ["vxe-context-menu--link-prefix", childPrefixOpts.className || ""]
                    }, [
                      h("i", {
                        class: childPrefixOpts.icon || child.prefixIcon
                      }),
                      childPrefixOpts.content ? h("span", `${childPrefixOpts.content}`) : createCommentVNode()
                    ]),
                    h("div", {
                      class: "vxe-context-menu--link-content"
                    }, getFuncText(child.name)),
                    h("div", {
                      class: ["vxe-context-menu--link-suffix", childSuffixOpts.className || ""]
                    }, [
                      h("i", {
                        class: childSuffixOpts.icon
                      }),
                      childSuffixOpts.content ? h("span", `${childSuffixOpts.content}`) : createCommentVNode()
                    ])
                  ])
                ]);
              })) : null
            ]);
          }));
        }))
      ]);
    };
    $xeMenuPanel.renderVN = renderVN;
    return $xeMenuPanel;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-table/es/table/src/table.js
var { getConfig: getConfig2, getIcon: getIcon6, getI18n: getI18n6, renderer: renderer5, formats, createEvent, globalResize, interceptor, hooks, globalEvents, GLOBAL_EVENT_KEYS, useFns, renderEmptyElement: renderEmptyElement5 } = VxeUI;
var supportMaxRow = 5e6;
var customStorageKey = "VXE_CUSTOM_STORE";
var maxYHeight = 5e6;
var maxXWidth = 5e6;
var table_default = defineComponent({
  name: "VxeTable",
  props: props_default,
  emits: emits_default,
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils8.default.uniqueId();
    const browseObj2 = import_xe_utils8.default.browse();
    const VxeUILoadingComponent = VxeUI.getComponent("VxeLoading");
    const VxeUITooltipComponent = VxeUI.getComponent("VxeTooltip");
    const $xeTabs = inject("$xeTabs", null);
    const { computeSize } = useFns.useSize(props);
    const reactData = reactive({
      // 低性能的静态列
      staticColumns: [],
      // 渲染的列分组
      tableGroupColumn: [],
      // 可视区渲染的列
      tableColumn: [],
      // 渲染中的数据
      tableData: [],
      // 是否启用了横向 X 可视渲染方式加载
      scrollXLoad: false,
      // 是否启用了纵向 Y 可视渲染方式加载
      scrollYLoad: false,
      // 是否存在纵向滚动条
      overflowY: true,
      // 是否存在横向滚动条
      overflowX: false,
      // 纵向滚动条的宽度
      scrollbarWidth: 0,
      // 横向滚动条的高度
      scrollbarHeight: 0,
      // 最后滚动时间戳
      lastScrollTime: 0,
      // 行高
      rowHeight: 0,
      // 表格父容器的高度
      parentHeight: 0,
      // 是否使用分组表头
      isGroup: false,
      isAllOverflow: false,
      // 复选框属性，是否全选
      isAllSelected: false,
      // 复选框属性，有选中且非全选状态
      isIndeterminate: false,
      // 当前行
      currentRow: null,
      // 单选框属性，选中列
      currentColumn: null,
      // 单选框属性，选中行
      selectRadioRow: null,
      // 表尾合计数据
      footerTableData: [],
      // 展开列信息
      expandColumn: null,
      // 树节点列信息
      treeNodeColumn: null,
      hasFixedColumn: false,
      // 合并单元格的对象集
      mergeList: [],
      // 合并表尾数据的对象集
      mergeFooterList: [],
      // 刷新列标识，当列筛选被改变时，触发表格刷新数据
      upDataFlag: 0,
      // 刷新列标识，当列的特定属性被改变时，触发表格刷新列
      reColumnFlag: 0,
      // 初始化标识
      initStore: {
        filter: false,
        import: false,
        export: false,
        custom: false
      },
      // 自定义列相关的信息
      customStore: {
        btnEl: null,
        isAll: false,
        isIndeterminate: false,
        activeBtn: false,
        activeWrapper: false,
        visible: false,
        maxHeight: 0,
        oldSortMaps: {},
        oldFixedMaps: {},
        oldVisibleMaps: {}
      },
      customColumnList: [],
      // 当前选中的筛选列
      filterStore: {
        isAllSelected: false,
        isIndeterminate: false,
        style: null,
        options: [],
        column: null,
        multiple: false,
        visible: false,
        maxHeight: null
      },
      // 存放列相关的信息
      columnStore: {
        leftList: [],
        centerList: [],
        rightList: [],
        resizeList: [],
        pxList: [],
        pxMinList: [],
        autoMinList: [],
        scaleList: [],
        scaleMinList: [],
        autoList: [],
        remainList: []
      },
      // 存放快捷菜单的信息
      ctxMenuStore: {
        selected: null,
        visible: false,
        showChild: false,
        selectChild: null,
        list: [],
        style: null
      },
      // 存放可编辑相关信息
      editStore: {
        indexs: {
          columns: []
        },
        titles: {
          columns: []
        },
        // 选中源
        selected: {
          row: null,
          column: null
        },
        // 已复制源
        copyed: {
          cut: false,
          rows: [],
          columns: []
        },
        // 激活
        actived: {
          row: null,
          column: null
        },
        // 当前被强制聚焦单元格，只会在鼠标点击后算聚焦
        focused: {
          row: null,
          column: null
        }
      },
      // 存放 tooltip 相关信息
      tooltipStore: {
        row: null,
        column: null,
        content: null,
        visible: false,
        currOpts: {}
      },
      // 存放数据校验相关信息
      validStore: {
        visible: false
      },
      validErrorMaps: {},
      // 导入相关信息
      importStore: {
        inited: false,
        file: null,
        type: "",
        modeList: [],
        typeList: [],
        filename: "",
        visible: false
      },
      importParams: {
        mode: "",
        types: null,
        message: true
      },
      // 导出相关信息
      exportStore: {
        inited: false,
        name: "",
        modeList: [],
        typeList: [],
        columns: [],
        isPrint: false,
        hasFooter: false,
        hasMerge: false,
        hasTree: false,
        hasColgroup: false,
        visible: false
      },
      exportParams: {
        filename: "",
        sheetName: "",
        mode: "",
        type: "",
        isColgroup: false,
        isMerge: false,
        isAllExpand: false,
        useStyle: false,
        original: false,
        message: true,
        isHeader: false,
        isFooter: false
      },
      rowExpandedFlag: 1,
      treeExpandedFlag: 1,
      updateCheckboxFlag: 1,
      pendingRowFlag: 1,
      insertRowFlag: 1,
      removeRowFlag: 1,
      rowHeightStore: {
        default: 48,
        medium: 44,
        small: 40,
        mini: 36
      },
      scrollVMLoading: false,
      scrollYHeight: 0,
      scrollYTop: 0,
      isScrollYBig: false,
      scrollXLeft: 0,
      scrollXWidth: 0,
      isScrollXBig: false,
      rowExpandHeightFlag: 1,
      calcCellHeightFlag: 1,
      resizeHeightFlag: 1,
      resizeWidthFlag: 1,
      isCustomStatus: false,
      isDragRowMove: false,
      dragRow: null,
      isDragColMove: false,
      dragCol: null,
      dragTipText: "",
      isDragResize: false,
      isRowLoading: false,
      isColLoading: false
    });
    const internalData = {
      tZindex: 0,
      elemStore: {},
      // 存放横向 X 虚拟滚动相关的信息
      scrollXStore: {
        preloadSize: 0,
        offsetSize: 0,
        visibleSize: 0,
        visibleStartIndex: 0,
        visibleEndIndex: 0,
        startIndex: 0,
        endIndex: 0
      },
      // 存放纵向 Y 虚拟滚动相关信息
      scrollYStore: {
        preloadSize: 0,
        offsetSize: 0,
        visibleSize: 0,
        visibleStartIndex: 0,
        visibleEndIndex: 0,
        startIndex: 0,
        endIndex: 0
      },
      // 表格宽度
      tableWidth: 0,
      // 表格高度
      tableHeight: 0,
      // 表头高度
      headerHeight: 0,
      // 表尾高度
      footerHeight: 0,
      customHeight: 0,
      customMinHeight: 0,
      customMaxHeight: 0,
      // 当前 hover 行
      hoverRow: null,
      // 最后滚动位置
      lastScrollLeft: 0,
      lastScrollTop: 0,
      // 单选框属性，已选中保留的行
      radioReserveRow: null,
      // 复选框属性，已选中保留的行集合
      checkboxReserveRowMap: {},
      // 行数据，已展开保留的行集合
      rowExpandedReserveRowMap: {},
      // 树结构数据，已展开保留的行集合
      treeExpandedReserveRowMap: {},
      // 树结构数据，不确定状态的集合
      treeIndeterminateRowMaps: {},
      // 列表完整数据、条件处理后
      tableFullData: [],
      afterFullData: [],
      afterTreeFullData: [],
      // 列表条件处理后数据集合
      afterFullRowMaps: {},
      // 树结构完整数据、条件处理后
      tableFullTreeData: [],
      tableSynchData: [],
      tableSourceData: [],
      // 收集的列配置（带分组）
      collectColumn: [],
      // 完整所有列（不带分组）
      tableFullColumn: [],
      // 渲染所有列
      visibleColumn: [],
      // 总的缓存数据集
      fullAllDataRowIdData: {},
      // 渲染中缓存数据
      sourceDataRowIdData: {},
      fullDataRowIdData: {},
      fullColumnIdData: {},
      fullColumnFieldData: {},
      // 已展开的行集合
      rowExpandedMaps: {},
      // 懒加载中的展开行的集合
      rowExpandLazyLoadedMaps: {},
      // 已展开树节点集合
      treeExpandedMaps: {},
      // 懒加载中的树节点的集合
      treeExpandLazyLoadedMaps: {},
      // 复选框属性，已选中的行集合
      selectCheckboxMaps: {},
      // 已标记的对象集
      pendingRowMaps: {},
      // 已新增的临时行
      insertRowMaps: {},
      // 已删除行
      removeRowMaps: {},
      inited: false,
      tooltipTimeout: null,
      initStatus: false,
      isActivated: false
    };
    let tableMethods = {};
    let tablePrivateMethods = {};
    const refElem = ref();
    const refVarElem = ref();
    const refTooltip = ref();
    const refCommTooltip = ref();
    const refValidTooltip = ref();
    const refTableMenu = ref();
    const refTableFilter = ref();
    const refTableCustom = ref();
    const refTableViewportElem = ref();
    const refTableHeader = ref();
    const refTableBody = ref();
    const refTableFooter = ref();
    const refTableLeftHeader = ref();
    const refTableLeftBody = ref();
    const refTableLeftFooter = ref();
    const refTableRightHeader = ref();
    const refTableRightBody = ref();
    const refTableRightFooter = ref();
    const refLeftContainer = ref();
    const refRightContainer = ref();
    const refColResizeBar = ref();
    const refRowResizeBar = ref();
    const refEmptyPlaceholder = ref();
    const refDragTipElem = ref();
    const refDragRowLineElem = ref();
    const refDragColLineElem = ref();
    const refRowExpandElem = ref();
    const refRowExpandYSpaceElem = ref();
    const refScrollXVirtualElem = ref();
    const refScrollYVirtualElem = ref();
    const refScrollXHandleElem = ref();
    const refScrollXLeftCornerElem = ref();
    const refScrollXRightCornerElem = ref();
    const refScrollYHandleElem = ref();
    const refScrollYTopCornerElem = ref();
    const refScrollXWrapperElem = ref();
    const refScrollYWrapperElem = ref();
    const refScrollYBottomCornerElem = ref();
    const refScrollXSpaceElem = ref();
    const refScrollYSpaceElem = ref();
    const $xeGrid = inject("$xeGrid", null);
    let $xeToolbar;
    const computeTableId = computed(() => {
      const { id } = props;
      if (id) {
        if (import_xe_utils8.default.isFunction(id)) {
          return `${id({ $table: $xeTable, $grid: $xeGrid }) || ""}`;
        }
        return `${id}`;
      }
      return "";
    });
    const computeValidOpts = computed(() => {
      return Object.assign({}, getConfig2().table.validConfig, props.validConfig);
    });
    const computeSXOpts = computed(() => {
      const virtualXOpts = computeVirtualXOpts.value;
      return virtualXOpts;
    });
    const computeScrollXThreshold = computed(() => {
      const virtualXOpts = computeVirtualXOpts.value;
      const { threshold } = virtualXOpts;
      if (threshold) {
        return import_xe_utils8.default.toNumber(threshold);
      }
      return 0;
    });
    const computeSYOpts = computed(() => {
      const virtualYOpts = computeVirtualYOpts.value;
      return virtualYOpts;
    });
    const computeVirtualXOpts = computed(() => {
      return Object.assign({}, getConfig2().table.scrollX, getConfig2().table.virtualXConfig, props.scrollX, props.virtualXConfig);
    });
    const computeVirtualYOpts = computed(() => {
      return Object.assign({}, getConfig2().table.scrollY, getConfig2().table.virtualYConfig, props.scrollY, props.virtualYConfig);
    });
    const computeScrollbarOpts = computed(() => {
      return Object.assign({}, getConfig2().table.scrollbarConfig, props.scrollbarConfig);
    });
    const computeScrollbarXToTop = computed(() => {
      const scrollbarOpts = computeScrollbarOpts.value;
      return !!(scrollbarOpts.x && scrollbarOpts.x.position === "top");
    });
    const computeScrollbarYToLeft = computed(() => {
      const scrollbarOpts = computeScrollbarOpts.value;
      return !!(scrollbarOpts.y && scrollbarOpts.y.position === "left");
    });
    const computeScrollYThreshold = computed(() => {
      const virtualYOpts = computeVirtualYOpts.value;
      const { threshold } = virtualYOpts;
      if (threshold) {
        return import_xe_utils8.default.toNumber(threshold);
      }
      return 0;
    });
    const computeRowHeightMaps = computed(() => {
      return reactData.rowHeightStore;
    });
    const computeDefaultRowHeight = computed(() => {
      const vSize = computeSize.value;
      const rowHeightMaps = computeRowHeightMaps.value;
      return rowHeightMaps[vSize || "default"] || 18;
    });
    const computeColumnOpts = computed(() => {
      return Object.assign({}, getConfig2().table.columnConfig, props.columnConfig);
    });
    const computeCurrentColumnOpts = computed(() => {
      return Object.assign({}, getConfig2().table.currentColumnConfig, props.currentColumnConfig);
    });
    const computeCellOpts = computed(() => {
      const cellOpts = Object.assign({}, getConfig2().table.cellConfig, props.cellConfig);
      if (cellOpts.height) {
        cellOpts.height = import_xe_utils8.default.toNumber(cellOpts.height);
      }
      return cellOpts;
    });
    const computeHeaderCellOpts = computed(() => {
      const headerCellOpts = Object.assign({}, getConfig2().table.headerCellConfig, props.headerCellConfig);
      if (headerCellOpts.height) {
        headerCellOpts.height = import_xe_utils8.default.toNumber(headerCellOpts.height);
      }
      return headerCellOpts;
    });
    const computeFooterCellOpts = computed(() => {
      const footerCellOpts = Object.assign({}, getConfig2().table.footerCellConfig, props.footerCellConfig);
      if (footerCellOpts.height) {
        footerCellOpts.height = import_xe_utils8.default.toNumber(footerCellOpts.height);
      }
      return footerCellOpts;
    });
    const computeRowOpts = computed(() => {
      return Object.assign({}, getConfig2().table.rowConfig, props.rowConfig);
    });
    const computeCurrentRowOpts = computed(() => {
      return Object.assign({}, getConfig2().table.currentRowConfig, props.currentRowConfig);
    });
    const computeRowDragOpts = computed(() => {
      return Object.assign({}, getConfig2().table.rowDragConfig, props.rowDragConfig);
    });
    const computeColumnDragOpts = computed(() => {
      return Object.assign({}, getConfig2().table.columnDragConfig, props.columnDragConfig);
    });
    const computeResizeOpts = computed(() => {
      return Object.assign({}, getConfig2().table.resizeConfig, props.resizeConfig);
    });
    const computeResizableOpts = computed(() => {
      return Object.assign({}, getConfig2().table.resizableConfig, props.resizableConfig);
    });
    const computeSeqOpts = computed(() => {
      return Object.assign({ startIndex: 0 }, getConfig2().table.seqConfig, props.seqConfig);
    });
    const computeRadioOpts = computed(() => {
      return Object.assign({}, getConfig2().table.radioConfig, props.radioConfig);
    });
    const computeCheckboxOpts = computed(() => {
      return Object.assign({}, getConfig2().table.checkboxConfig, props.checkboxConfig);
    });
    const computeTooltipOpts = computed(() => {
      return Object.assign({}, getConfig2().tooltip, getConfig2().table.tooltipConfig, props.tooltipConfig);
    });
    const computeTableTipConfig = computed(() => {
      const { tooltipStore } = reactData;
      const tooltipOpts = computeTooltipOpts.value;
      return Object.assign({}, tooltipOpts, tooltipStore.currOpts);
    });
    const computeValidTipConfig = computed(() => {
      const tooltipOpts = computeTooltipOpts.value;
      return Object.assign({}, tooltipOpts);
    });
    const computeEditOpts = computed(() => {
      return Object.assign({}, getConfig2().table.editConfig, props.editConfig);
    });
    const computeSortOpts = computed(() => {
      return Object.assign({ orders: ["asc", "desc", null] }, getConfig2().table.sortConfig, props.sortConfig);
    });
    const computeFilterOpts = computed(() => {
      return Object.assign({}, getConfig2().table.filterConfig, props.filterConfig);
    });
    const computeMouseOpts = computed(() => {
      return Object.assign({}, getConfig2().table.mouseConfig, props.mouseConfig);
    });
    const computeAreaOpts = computed(() => {
      return Object.assign({}, getConfig2().table.areaConfig, props.areaConfig);
    });
    const computeKeyboardOpts = computed(() => {
      return Object.assign({}, getConfig2().table.keyboardConfig, props.keyboardConfig);
    });
    const computeClipOpts = computed(() => {
      return Object.assign({}, getConfig2().table.clipConfig, props.clipConfig);
    });
    const computeFNROpts = computed(() => {
      return Object.assign({}, getConfig2().table.fnrConfig, props.fnrConfig);
    });
    const computeMenuOpts = computed(() => {
      return Object.assign({}, getConfig2().table.menuConfig, props.menuConfig);
    });
    const computeLeftFixedWidth = computed(() => {
      const { columnStore } = reactData;
      const { leftList } = columnStore;
      let leftWidth = 0;
      for (let i = 0; i < leftList.length; i++) {
        const column = leftList[i];
        leftWidth += column.renderWidth;
      }
      return leftWidth;
    });
    const computeRightFixedWidth = computed(() => {
      const { columnStore } = reactData;
      const { rightList } = columnStore;
      let leftWidth = 0;
      for (let i = 0; i < rightList.length; i++) {
        const column = rightList[i];
        leftWidth += column.renderWidth;
      }
      return leftWidth;
    });
    const computeHeaderMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const headerOpts = menuOpts.header;
      return headerOpts && headerOpts.options ? headerOpts.options : [];
    });
    const computeBodyMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const bodyOpts = menuOpts.body;
      return bodyOpts && bodyOpts.options ? bodyOpts.options : [];
    });
    const computeFooterMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const footerOpts = menuOpts.footer;
      return footerOpts && footerOpts.options ? footerOpts.options : [];
    });
    const computeIsMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const headerMenu = computeHeaderMenu.value;
      const bodyMenu = computeBodyMenu.value;
      const footerMenu = computeFooterMenu.value;
      return !!(props.menuConfig && isEnableConf(menuOpts) && (headerMenu.length || bodyMenu.length || footerMenu.length));
    });
    const computeMenuList = computed(() => {
      const { ctxMenuStore } = reactData;
      const rest = [];
      ctxMenuStore.list.forEach((list) => {
        list.forEach((item) => {
          rest.push(item);
        });
      });
      return rest;
    });
    const computeExportOpts = computed(() => {
      return Object.assign({}, getConfig2().table.exportConfig, props.exportConfig);
    });
    const computeImportOpts = computed(() => {
      return Object.assign({}, getConfig2().table.importConfig, props.importConfig);
    });
    const computePrintOpts = computed(() => {
      return Object.assign({}, getConfig2().table.printConfig, props.printConfig);
    });
    const computeExpandOpts = computed(() => {
      return Object.assign({}, getConfig2().table.expandConfig, props.expandConfig);
    });
    const computeTreeOpts = computed(() => {
      return Object.assign({}, getConfig2().table.treeConfig, props.treeConfig);
    });
    const computeEmptyOpts = computed(() => {
      return Object.assign({}, getConfig2().table.emptyRender, props.emptyRender);
    });
    const computeLoadingOpts = computed(() => {
      return Object.assign({}, getConfig2().table.loadingConfig, props.loadingConfig);
    });
    const computeCellOffsetWidth = computed(() => {
      return props.border ? Math.max(2, Math.ceil(reactData.scrollbarWidth / reactData.tableColumn.length)) : 1;
    });
    const computeCustomOpts = computed(() => {
      return Object.assign({}, getConfig2().table.customConfig, props.customConfig);
    });
    const computeTableRowExpandedList = computed(() => {
      const { rowExpandedFlag, tableData, expandColumn } = reactData;
      const { rowExpandedMaps } = internalData;
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      const expandList = [];
      if (expandColumn && rowExpandedFlag) {
        const rowKeys = {};
        tableData.forEach((row) => {
          rowKeys[handleGetRowId(row)] = true;
        });
        import_xe_utils8.default.each(rowExpandedMaps, (row, rowid) => {
          if (rowKeys[rowid]) {
            expandList.push(row);
          }
        });
      }
      return expandList;
    });
    const computeAutoWidthColumnList = computed(() => {
      const { visibleColumn } = internalData;
      const { tableColumn } = reactData;
      return tableColumn.length || visibleColumn.length ? visibleColumn.filter((column) => column.width === "auto" || column.minWidth === "auto") : [];
    });
    const computeFixedColumnSize = computed(() => {
      const { tableColumn } = reactData;
      const { collectColumn } = internalData;
      let fixedSize = 0;
      if (tableColumn.length && collectColumn.length) {
        collectColumn.forEach((column) => {
          if (column.renderFixed) {
            fixedSize++;
          }
        });
      }
      return fixedSize;
    });
    const computeIsMaxFixedColumn = computed(() => {
      const fixedColumnSize = computeFixedColumnSize.value;
      const columnOpts = computeColumnOpts.value;
      const { maxFixedSize } = columnOpts;
      if (maxFixedSize) {
        return fixedColumnSize >= maxFixedSize;
      }
      return false;
    });
    const computeTableBorder = computed(() => {
      const { border } = props;
      if (border === true) {
        return "full";
      }
      if (border) {
        return border;
      }
      return "default";
    });
    const computeIsAllCheckboxDisabled = computed(() => {
      const { treeConfig } = props;
      const { tableData } = reactData;
      const { tableFullData } = internalData;
      const checkboxOpts = computeCheckboxOpts.value;
      const { strict, checkMethod } = checkboxOpts;
      if (strict) {
        if (tableData.length || tableFullData.length) {
          if (checkMethod) {
            if (treeConfig) {
            }
            return tableFullData.every((row) => !checkMethod({ row }));
          }
          return false;
        }
        return true;
      }
      return false;
    });
    const computeVirtualScrollBars = computed(() => {
      const { overflowX, scrollXLoad, overflowY, scrollYLoad } = reactData;
      return {
        x: overflowX && scrollXLoad,
        y: overflowY && scrollYLoad
      };
    });
    const refMaps = {
      refElem,
      refTooltip,
      refValidTooltip,
      refTableFilter,
      refTableCustom,
      refTableMenu,
      refTableHeader,
      refTableBody,
      refTableFooter,
      refTableLeftHeader,
      refTableLeftBody,
      refTableLeftFooter,
      refTableRightHeader,
      refTableRightBody,
      refTableRightFooter,
      refLeftContainer,
      refRightContainer,
      refColResizeBar,
      refRowResizeBar,
      refScrollXVirtualElem,
      refScrollYVirtualElem,
      refScrollXHandleElem,
      refScrollYHandleElem,
      refScrollXSpaceElem,
      refScrollYSpaceElem
    };
    const computeMaps = {
      computeSize,
      computeTableId,
      computeValidOpts,
      computeVirtualXOpts,
      computeVirtualYOpts,
      computeScrollbarOpts,
      computeScrollbarXToTop,
      computeScrollbarYToLeft,
      computeColumnOpts,
      computeCurrentColumnOpts,
      computeScrollXThreshold,
      computeScrollYThreshold,
      computeRowHeightMaps,
      computeDefaultRowHeight,
      computeCellOpts,
      computeHeaderCellOpts,
      computeFooterCellOpts,
      computeRowOpts,
      computeCurrentRowOpts,
      computeRowDragOpts,
      computeColumnDragOpts,
      computeResizeOpts,
      computeResizableOpts,
      computeSeqOpts,
      computeRadioOpts,
      computeCheckboxOpts,
      computeTooltipOpts,
      computeEditOpts,
      computeSortOpts,
      computeFilterOpts,
      computeMouseOpts,
      computeAreaOpts,
      computeKeyboardOpts,
      computeClipOpts,
      computeFNROpts,
      computeHeaderMenu,
      computeBodyMenu,
      computeFooterMenu,
      computeIsMenu,
      computeMenuOpts,
      computeExportOpts,
      computeImportOpts,
      computePrintOpts,
      computeExpandOpts,
      computeTreeOpts,
      computeEmptyOpts,
      computeLoadingOpts,
      computeCellOffsetWidth,
      computeCustomOpts,
      computeLeftFixedWidth,
      computeRightFixedWidth,
      computeFixedColumnSize,
      computeIsMaxFixedColumn,
      computeIsAllCheckboxDisabled,
      computeVirtualScrollBars,
      computeSXOpts,
      computeSYOpts
    };
    const $xeTable = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps,
      xeGrid: $xeGrid,
      xegrid: $xeGrid
    };
    const eqCellValue = (row1, row2, field) => {
      const val1 = import_xe_utils8.default.get(row1, field);
      const val2 = import_xe_utils8.default.get(row2, field);
      if (eqEmptyValue(val1) && eqEmptyValue(val2)) {
        return true;
      }
      if (import_xe_utils8.default.isString(val1) || import_xe_utils8.default.isNumber(val1)) {
        return "" + val1 === "" + val2;
      }
      return import_xe_utils8.default.isEqual(val1, val2);
    };
    const getNextSortOrder = (column) => {
      const sortOpts = computeSortOpts.value;
      const { orders } = sortOpts;
      const currOrder = column.order || null;
      const oIndex = orders.indexOf(currOrder) + 1;
      return orders[oIndex < orders.length ? oIndex : 0];
    };
    const getCustomStorageMap = (id) => {
      const version = getConfig2().version;
      const rest = import_xe_utils8.default.toStringJSON(localStorage.getItem(customStorageKey) || "");
      const maps = rest && rest._v === version ? rest : { _v: version };
      return (id ? maps[id] : maps) || {};
    };
    const setCustomStorageMap = (id, data) => {
      const version = getConfig2().version;
      const maps = getCustomStorageMap();
      maps[id] = data || void 0;
      maps._v = version;
      localStorage.setItem(customStorageKey, import_xe_utils8.default.toJSONString(maps));
    };
    const getRecoverRowMaps = (keyMaps) => {
      const { fullAllDataRowIdData } = internalData;
      const restKeys = {};
      import_xe_utils8.default.each(keyMaps, (row, rowid) => {
        if (fullAllDataRowIdData[rowid]) {
          restKeys[rowid] = row;
        }
      });
      return restKeys;
    };
    const handleReserveRow = (reserveRowMap) => {
      const { fullDataRowIdData } = internalData;
      const reserveList = [];
      import_xe_utils8.default.each(reserveRowMap, (item, rowid) => {
        if (fullDataRowIdData[rowid] && $xeTable.findRowIndexOf(reserveList, fullDataRowIdData[rowid].row) === -1) {
          reserveList.push(fullDataRowIdData[rowid].row);
        }
      });
      return reserveList;
    };
    const handleVirtualXVisible = () => {
      const { isScrollXBig, scrollXWidth } = reactData;
      const { elemStore, visibleColumn, fullColumnIdData } = internalData;
      const leftFixedWidth = computeLeftFixedWidth.value;
      const rightFixedWidth = computeRightFixedWidth.value;
      const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
      if (bodyScrollElem) {
        const clientWidth = bodyScrollElem.clientWidth;
        let scrollLeft = bodyScrollElem.scrollLeft;
        if (isScrollXBig) {
          scrollLeft = Math.ceil((scrollXWidth - clientWidth) * Math.min(1, scrollLeft / (maxXWidth - clientWidth)));
        }
        const startLeft = scrollLeft + leftFixedWidth;
        const endLeft = scrollLeft + clientWidth - rightFixedWidth;
        let leftIndex = 0;
        let rightIndex = visibleColumn.length;
        while (leftIndex < rightIndex) {
          const cIndex = Math.floor((leftIndex + rightIndex) / 2);
          const column = visibleColumn[cIndex];
          const colid = column.id;
          const colRest = fullColumnIdData[colid] || {};
          if (colRest.oLeft <= startLeft) {
            leftIndex = cIndex + 1;
          } else {
            rightIndex = cIndex;
          }
        }
        let visibleSize = 0;
        const toVisibleIndex = Math.max(0, leftIndex < visibleColumn.length ? leftIndex - 2 : 0);
        for (let cIndex = toVisibleIndex, cLen = visibleColumn.length; cIndex < cLen; cIndex++) {
          const column = visibleColumn[cIndex];
          const colid = column.id;
          const colRest = fullColumnIdData[colid] || {};
          visibleSize++;
          if (colRest.oLeft > endLeft || visibleSize >= 60) {
            break;
          }
        }
        return { toVisibleIndex: Math.max(0, toVisibleIndex), visibleSize: Math.max(1, visibleSize) };
      }
      return { toVisibleIndex: 0, visibleSize: 6 };
    };
    const calcVarRowHeightConfig = (sizeKey, sizeEl) => {
      const { rowHeightStore } = reactData;
      if (sizeEl && sizeEl.clientHeight) {
        rowHeightStore[sizeKey] = sizeEl.clientHeight;
      }
    };
    const computeRowHeight = () => {
      const { isAllOverflow } = reactData;
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableBodyElem = tableBody ? tableBody.$el : null;
      const defaultRowHeight = computeDefaultRowHeight.value;
      let rowHeight = 0;
      if (isAllOverflow) {
        if (tableBodyElem) {
          const tableHeaderElem = tableHeader ? tableHeader.$el : null;
          let firstTrElem;
          firstTrElem = tableBodyElem.querySelector("tr");
          if (!firstTrElem && tableHeaderElem) {
            firstTrElem = tableHeaderElem.querySelector("tr");
          }
          if (firstTrElem) {
            rowHeight = firstTrElem.clientHeight;
          }
        }
        if (!rowHeight) {
          rowHeight = defaultRowHeight;
        }
      } else {
        rowHeight = defaultRowHeight;
      }
      return Math.max(18, rowHeight);
    };
    const handleVirtualYVisible = () => {
      const { isAllOverflow, expandColumn, isScrollYBig, scrollYHeight } = reactData;
      const { elemStore, isResizeCellHeight, afterFullData, fullAllDataRowIdData } = internalData;
      const rowOpts = computeRowOpts.value;
      const cellOpts = computeCellOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
      if (bodyScrollElem) {
        const clientHeight = bodyScrollElem.clientHeight;
        let scrollTop = bodyScrollElem.scrollTop;
        if (isScrollYBig) {
          scrollTop = Math.ceil((scrollYHeight - clientHeight) * Math.min(1, scrollTop / (maxYHeight - clientHeight)));
        }
        const startTop = scrollTop;
        const endTop = scrollTop + clientHeight;
        let toVisibleIndex = -1;
        let visibleSize = 0;
        const isCustomCellHeight = isResizeCellHeight || cellOpts.height || rowOpts.height;
        if (!isCustomCellHeight && !expandColumn && isAllOverflow) {
          toVisibleIndex = Math.floor(startTop / defaultRowHeight) - 1;
          visibleSize = Math.ceil(clientHeight / defaultRowHeight) + 1;
        } else {
          const { handleGetRowId } = createHandleGetRowId($xeTable);
          let leftIndex = 0;
          let rightIndex = afterFullData.length;
          while (leftIndex < rightIndex) {
            const rIndex = Math.floor((leftIndex + rightIndex) / 2);
            const row = afterFullData[rIndex];
            const rowid = handleGetRowId(row);
            const rowRest = fullAllDataRowIdData[rowid] || {};
            if (rowRest.oTop <= startTop) {
              leftIndex = rIndex + 1;
            } else {
              rightIndex = rIndex;
            }
          }
          toVisibleIndex = Math.max(0, leftIndex < afterFullData.length ? leftIndex - 2 : 0);
          for (let rIndex = toVisibleIndex, rLen = afterFullData.length; rIndex < rLen; rIndex++) {
            const row = afterFullData[rIndex];
            const rowid = handleGetRowId(row);
            const rowRest = fullAllDataRowIdData[rowid] || {};
            visibleSize++;
            if (rowRest.oTop > endTop || visibleSize >= 100) {
              break;
            }
          }
        }
        return { toVisibleIndex: Math.max(0, toVisibleIndex), visibleSize: Math.max(6, visibleSize) };
      }
      return { toVisibleIndex: 0, visibleSize: 6 };
    };
    const calculateMergerOffsetIndex = (list, offsetItem, type) => {
      for (let mcIndex = 0, len = list.length; mcIndex < len; mcIndex++) {
        const mergeItem = list[mcIndex];
        const { startIndex, endIndex } = offsetItem;
        const mergeStartIndex = mergeItem[type];
        const mergeSpanNumber = mergeItem[type + "span"];
        const mergeEndIndex = mergeStartIndex + mergeSpanNumber;
        if (mergeStartIndex < startIndex && startIndex < mergeEndIndex) {
          offsetItem.startIndex = mergeStartIndex;
        }
        if (mergeStartIndex < endIndex && endIndex < mergeEndIndex) {
          offsetItem.endIndex = mergeEndIndex;
        }
        if (offsetItem.startIndex !== startIndex || offsetItem.endIndex !== endIndex) {
          mcIndex = -1;
        }
      }
    };
    const setMerges = (merges, mList, rowList) => {
      if (merges) {
        const { visibleColumn } = internalData;
        if (!import_xe_utils8.default.isArray(merges)) {
          merges = [merges];
        }
        merges.forEach((item) => {
          let { row, col, rowspan, colspan } = item;
          if (rowList && import_xe_utils8.default.isNumber(row)) {
            row = rowList[row];
          }
          if (import_xe_utils8.default.isNumber(col)) {
            col = visibleColumn[col];
          }
          if ((rowList ? row : import_xe_utils8.default.isNumber(row)) && col && (rowspan || colspan)) {
            rowspan = import_xe_utils8.default.toNumber(rowspan) || 1;
            colspan = import_xe_utils8.default.toNumber(colspan) || 1;
            if (rowspan > 1 || colspan > 1) {
              const mcIndex = import_xe_utils8.default.findIndexOf(mList, (item2) => (item2._row === row || getRowid($xeTable, item2._row) === getRowid($xeTable, row)) && (item2._col.id === col || item2._col.id === col.id));
              const mergeItem = mList[mcIndex];
              if (mergeItem) {
                mergeItem.rowspan = rowspan;
                mergeItem.colspan = colspan;
                mergeItem._rowspan = rowspan;
                mergeItem._colspan = colspan;
              } else {
                const mergeRowIndex = rowList ? $xeTable.findRowIndexOf(rowList, row) : row;
                const mergeColIndex = tableMethods.getVTColumnIndex(col);
                mList.push({
                  row: mergeRowIndex,
                  col: mergeColIndex,
                  rowspan,
                  colspan,
                  _row: row,
                  _col: col,
                  _rowspan: rowspan,
                  _colspan: colspan
                });
              }
            }
          }
        });
      }
    };
    const removeMerges = (merges, mList, rowList) => {
      const rest = [];
      if (merges) {
        const { visibleColumn } = internalData;
        if (!import_xe_utils8.default.isArray(merges)) {
          merges = [merges];
        }
        merges.forEach((item) => {
          let { row, col } = item;
          if (rowList && import_xe_utils8.default.isNumber(row)) {
            row = rowList[row];
          }
          if (import_xe_utils8.default.isNumber(col)) {
            col = visibleColumn[col];
          }
          const mcIndex = import_xe_utils8.default.findIndexOf(mList, (item2) => (item2._row === row || getRowid($xeTable, item2._row) === getRowid($xeTable, row)) && (item2._col.id === col || item2._col.id === col.id));
          if (mcIndex > -1) {
            const rItems = mList.splice(mcIndex, 1);
            rest.push(rItems[0]);
          }
        });
      }
      return rest;
    };
    const clearAllSort = () => {
      const { tableFullColumn } = internalData;
      tableFullColumn.forEach((column) => {
        column.order = null;
      });
    };
    const calcTableHeight = (key) => {
      const { parentHeight } = reactData;
      const val = props[key];
      let num = 0;
      if (val) {
        if (val === "100%" || val === "auto") {
          num = parentHeight;
        } else {
          const excludeHeight = $xeTable.getExcludeHeight();
          if (isScale(val)) {
            num = Math.floor((import_xe_utils8.default.toInteger(val) || 1) / 100 * parentHeight);
          } else {
            num = import_xe_utils8.default.toNumber(val);
          }
          num = Math.max(40, num - excludeHeight);
        }
      }
      return num;
    };
    const handleCustomRestore = (storeData) => {
      let { collectColumn } = internalData;
      const { resizableData, sortData, visibleData, fixedData } = storeData;
      let hasCustomSort = false;
      if (resizableData || sortData || visibleData || fixedData) {
        import_xe_utils8.default.eachTree(collectColumn, (column, index, items, path, parentColumn) => {
          const colKey = column.getKey();
          if (!parentColumn) {
            if (fixedData && fixedData[colKey] !== void 0) {
              column.fixed = fixedData[colKey];
            }
            if (sortData && import_xe_utils8.default.isNumber(sortData[colKey])) {
              hasCustomSort = true;
              column.renderSortNumber = sortData[colKey];
            }
          }
          if (resizableData && import_xe_utils8.default.isNumber(resizableData[colKey])) {
            column.resizeWidth = resizableData[colKey];
          }
          if (visibleData && import_xe_utils8.default.isBoolean(visibleData[colKey])) {
            column.visible = visibleData[colKey];
          }
        });
        if (hasCustomSort) {
          collectColumn = import_xe_utils8.default.orderBy(collectColumn, "renderSortNumber");
          internalData.collectColumn = collectColumn;
          internalData.tableFullColumn = getColumnList(collectColumn);
        }
        reactData.isCustomStatus = true;
      } else {
        reactData.isCustomStatus = false;
      }
    };
    const restoreCustomStorage = () => {
      const { customConfig } = props;
      const tableId = computeTableId.value;
      const customOpts = computeCustomOpts.value;
      const { storage, restoreStore } = customOpts;
      const isAllCustom = storage === true;
      const storageOpts = isAllCustom ? {} : Object.assign({}, storage || {});
      const isCustomResizable = isAllCustom || storageOpts.resizable;
      const isCustomVisible = isAllCustom || storageOpts.visible;
      const isCustomFixed = isAllCustom || storageOpts.fixed;
      const isCustomSort = isAllCustom || storageOpts.sort;
      if ((customConfig ? isEnableConf(customOpts) : customOpts.enabled) && (isCustomResizable || isCustomVisible || isCustomFixed || isCustomSort)) {
        if (!tableId) {
          errLog("vxe.error.reqProp", ["id"]);
          return;
        }
        const storeData = getCustomStorageMap(tableId);
        if (restoreStore) {
          return Promise.resolve(restoreStore({ id: tableId, type: "restore", storeData })).then((storeData2) => {
            if (!storeData2) {
              return;
            }
            return handleCustomRestore(storeData2);
          }).catch((e) => e);
        } else {
          return handleCustomRestore(storeData);
        }
      }
    };
    const cacheColumnMap = () => {
      const { tableFullColumn, collectColumn } = internalData;
      const fullColumnIdData = internalData.fullColumnIdData = {};
      const fullColumnFieldData = internalData.fullColumnFieldData = {};
      const mouseOpts = computeMouseOpts.value;
      const expandOpts = computeExpandOpts.value;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const { isCrossDrag, isSelfToChildDrag } = columnDragOpts;
      const customOpts = computeCustomOpts.value;
      const { storage } = customOpts;
      const rowOpts = computeRowOpts.value;
      const isGroup = collectColumn.some(hasChildrenList);
      let isAllOverflow = !!props.showOverflow;
      let expandColumn;
      let treeNodeColumn;
      let checkboxColumn;
      let radioColumn;
      let htmlColumn;
      let hasFixed;
      const handleFunc = (column, index, items, path, parentColumn) => {
        const { id: colid, field, fixed, type, treeNode } = column;
        const rest = { $index: -1, _index: -1, column, colid, index, items, parent: parentColumn || null, width: 0, oLeft: 0 };
        if (field) {
          if (fullColumnFieldData[field]) {
            errLog("vxe.error.colRepet", ["field", field]);
          }
          fullColumnFieldData[field] = rest;
        } else {
          if (storage && !type || columnOpts.drag && (isCrossDrag || isSelfToChildDrag)) {
            errLog("vxe.error.reqProp", [`${column.getTitle() || type || ""} -> column.field=?`]);
          }
        }
        if (!hasFixed && fixed) {
          hasFixed = fixed;
        }
        if (!htmlColumn && type === "html") {
          htmlColumn = column;
        }
        if (treeNode) {
          if (true) {
            if (treeNodeColumn) {
              warnLog("vxe.error.colRepet", ["tree-node", treeNode]);
            }
          }
          if (!treeNodeColumn) {
            treeNodeColumn = column;
          }
        } else if (type === "expand") {
          if (true) {
            if (expandColumn) {
              warnLog("vxe.error.colRepet", ["type", type]);
            }
          }
          if (!expandColumn) {
            expandColumn = column;
          }
        }
        if (true) {
          if (type === "checkbox") {
            if (checkboxColumn) {
              warnLog("vxe.error.colRepet", ["type", type]);
            }
            if (!checkboxColumn) {
              checkboxColumn = column;
            }
          } else if (type === "radio") {
            if (radioColumn) {
              warnLog("vxe.error.colRepet", ["type", type]);
            }
            if (!radioColumn) {
              radioColumn = column;
            }
          }
        }
        if (isAllOverflow && column.showOverflow === false) {
          isAllOverflow = false;
        }
        if (fullColumnIdData[colid]) {
          errLog("vxe.error.colRepet", ["colId", colid]);
        }
        fullColumnIdData[colid] = rest;
      };
      if (isGroup) {
        import_xe_utils8.default.eachTree(collectColumn, (column, index, items, path, parentColumn, nodes) => {
          column.level = nodes.length;
          handleFunc(column, index, items, path, parentColumn);
        });
      } else {
        tableFullColumn.forEach(handleFunc);
      }
      if (expandColumn && expandOpts.mode !== "fixed" && mouseOpts.area) {
        errLog("vxe.error.errConflicts", ["mouse-config.area", "column.type=expand"]);
      }
      if (htmlColumn) {
        if (!columnOpts.useKey) {
          errLog("vxe.error.reqProp", ["column-config.useKey & column.type=html"]);
        }
        if (!rowOpts.useKey) {
          errLog("vxe.error.reqProp", ["row-config.useKey & column.type=html"]);
        }
      }
      reactData.isGroup = isGroup;
      reactData.treeNodeColumn = treeNodeColumn;
      reactData.expandColumn = expandColumn;
      reactData.isAllOverflow = isAllOverflow;
    };
    const updateHeight = () => {
      internalData.customHeight = calcTableHeight("height");
      internalData.customMinHeight = calcTableHeight("minHeight");
      internalData.customMaxHeight = calcTableHeight("maxHeight");
    };
    const calcColumnAutoWidth = (column, wrapperEl) => {
      const cellElemList = wrapperEl.querySelectorAll(`.vxe-cell--wrapper[colid="${column.id}"]`);
      let leftRightPadding = 0;
      const firstCellEl = cellElemList[0];
      if (firstCellEl && firstCellEl.parentElement) {
        const cellStyle = getComputedStyle(firstCellEl.parentElement);
        leftRightPadding = Math.ceil(import_xe_utils8.default.toNumber(cellStyle.paddingLeft) + import_xe_utils8.default.toNumber(cellStyle.paddingRight));
      }
      let colWidth = column.renderAutoWidth - leftRightPadding;
      for (let i = 0; i < cellElemList.length; i++) {
        const celEl = cellElemList[i];
        colWidth = Math.max(colWidth, celEl ? Math.ceil(celEl.scrollWidth) + 4 : 0);
      }
      return colWidth + leftRightPadding;
    };
    const calcCellWidth = () => {
      const autoWidthColumnList = computeAutoWidthColumnList.value;
      const { fullColumnIdData } = internalData;
      const el = refElem.value;
      if (el) {
        el.setAttribute("data-calc-col", "Y");
        autoWidthColumnList.forEach((column) => {
          const colid = column.id;
          const colRest = fullColumnIdData[colid];
          const colWidth = calcColumnAutoWidth(column, el);
          if (colRest) {
            colRest.width = Math.max(colWidth, colRest.width);
          }
          column.renderAutoWidth = colWidth;
        });
        $xeTable.analyColumnWidth();
        el.removeAttribute("data-calc-col");
      }
    };
    const autoCellWidth = () => {
      const { elemStore } = internalData;
      const scrollbarOpts = computeScrollbarOpts.value;
      const tableBody = refTableBody.value;
      const bodyElem = tableBody ? tableBody.$el : null;
      if (!bodyElem) {
        return;
      }
      const yHandleEl = refScrollYHandleElem.value;
      if (!yHandleEl) {
        return;
      }
      const xHandleEl = refScrollXHandleElem.value;
      if (!xHandleEl) {
        return;
      }
      let tWidth = 0;
      const minCellWidth = 40;
      const bodyWidth = bodyElem.clientWidth;
      let remainWidth = bodyWidth;
      let meanWidth = remainWidth / 100;
      const { fit } = props;
      const { columnStore } = reactData;
      const { resizeList, pxMinList, autoMinList, pxList, scaleList, scaleMinList, autoList, remainList } = columnStore;
      pxMinList.forEach((column) => {
        const minWidth = import_xe_utils8.default.toInteger(column.minWidth);
        tWidth += minWidth;
        column.renderWidth = minWidth;
      });
      autoMinList.forEach((column) => {
        const caWidth = Math.max(60, import_xe_utils8.default.toInteger(column.renderAutoWidth));
        tWidth += caWidth;
        column.renderWidth = caWidth;
      });
      scaleMinList.forEach((column) => {
        const smWidth = Math.floor(import_xe_utils8.default.toInteger(column.minWidth) * meanWidth);
        tWidth += smWidth;
        column.renderWidth = smWidth;
      });
      scaleList.forEach((column) => {
        const sfWidth = Math.floor(import_xe_utils8.default.toInteger(column.width) * meanWidth);
        tWidth += sfWidth;
        column.renderWidth = sfWidth;
      });
      pxList.forEach((column) => {
        const pWidth = import_xe_utils8.default.toInteger(column.width);
        tWidth += pWidth;
        column.renderWidth = pWidth;
      });
      autoList.forEach((column) => {
        const aWidth = Math.max(60, import_xe_utils8.default.toInteger(column.renderAutoWidth));
        tWidth += aWidth;
        column.renderWidth = aWidth;
      });
      resizeList.forEach((column) => {
        const reWidth = import_xe_utils8.default.toInteger(column.resizeWidth);
        tWidth += reWidth;
        column.renderWidth = reWidth;
      });
      remainWidth -= tWidth;
      meanWidth = remainWidth > 0 ? Math.floor(remainWidth / (scaleMinList.length + pxMinList.length + autoMinList.length + remainList.length)) : 0;
      if (fit) {
        if (remainWidth > 0) {
          scaleMinList.concat(pxMinList).concat(autoMinList).forEach((column) => {
            tWidth += meanWidth;
            column.renderWidth += meanWidth;
          });
        }
      } else {
        meanWidth = minCellWidth;
      }
      remainList.forEach((column) => {
        const width = Math.max(meanWidth, minCellWidth);
        column.renderWidth = width;
        tWidth += width;
      });
      if (fit) {
        const dynamicList = scaleList.concat(scaleMinList).concat(pxMinList).concat(autoMinList).concat(remainList);
        let dynamicSize = dynamicList.length - 1;
        if (dynamicSize > 0) {
          let i = bodyWidth - tWidth;
          if (i > 0) {
            while (i > 0 && dynamicSize >= 0) {
              i--;
              dynamicList[dynamicSize--].renderWidth++;
            }
            tWidth = bodyWidth;
          }
        }
      }
      const tableHeight = bodyElem.offsetHeight;
      const overflowY = yHandleEl.scrollHeight > yHandleEl.clientHeight;
      reactData.scrollbarWidth = Math.max(scrollbarOpts.width || 0, yHandleEl.offsetWidth - yHandleEl.clientWidth);
      reactData.overflowY = overflowY;
      reactData.scrollXWidth = tWidth;
      internalData.tableHeight = tableHeight;
      const headerTableElem = getRefElem(elemStore["main-header-table"]);
      const footerTableElem = getRefElem(elemStore["main-footer-table"]);
      const headerHeight = headerTableElem ? headerTableElem.clientHeight : 0;
      const overflowX = tWidth > bodyWidth;
      const footerHeight = footerTableElem ? footerTableElem.clientHeight : 0;
      reactData.scrollbarHeight = Math.max(scrollbarOpts.height || 0, xHandleEl.offsetHeight - xHandleEl.clientHeight);
      internalData.headerHeight = headerHeight;
      internalData.footerHeight = footerHeight;
      reactData.overflowX = overflowX;
      reactData.resizeWidthFlag++;
      updateColumnOffsetLeft();
      updateHeight();
      reactData.parentHeight = Math.max(internalData.headerHeight + footerHeight + 20, $xeTable.getParentHeight());
      if (overflowX) {
        $xeTable.checkScrolling();
      }
    };
    const calcCellAutoHeight = (rowRest, wrapperEl) => {
      const cellElemList = wrapperEl.querySelectorAll(`.vxe-cell--wrapper[rowid="${rowRest.rowid}"]`);
      let colHeight = rowRest.height;
      for (let i = 0; i < cellElemList.length; i++) {
        const cellElem = cellElemList[i];
        const tdEl = cellElem.parentElement;
        const topBottomPadding = Math.ceil(import_xe_utils8.default.toNumber(tdEl.style.paddingTop) + import_xe_utils8.default.toNumber(tdEl.style.paddingBottom));
        const cellHeight = cellElem ? cellElem.clientHeight : 0;
        colHeight = Math.max(colHeight - topBottomPadding, Math.ceil(cellHeight));
      }
      return colHeight;
    };
    const calcCellHeight = () => {
      const { tableData, isAllOverflow, scrollYLoad, scrollXLoad } = reactData;
      const { fullAllDataRowIdData } = internalData;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const el = refElem.value;
      if (!isAllOverflow && scrollYLoad && el) {
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        el.setAttribute("data-calc-row", "Y");
        tableData.forEach((row) => {
          const rowid = handleGetRowId(row);
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            const reHeight = calcCellAutoHeight(rowRest, el);
            rowRest.height = Math.max(defaultRowHeight, scrollXLoad ? Math.max(rowRest.height, reHeight) : reHeight);
          }
          el.removeAttribute("data-calc-row");
        });
        reactData.calcCellHeightFlag++;
      }
    };
    const getOrderField = (column) => {
      const { sortBy, sortType } = column;
      return (row) => {
        let cellValue;
        if (sortBy) {
          cellValue = import_xe_utils8.default.isFunction(sortBy) ? sortBy({ row, column }) : import_xe_utils8.default.get(row, sortBy);
        } else {
          cellValue = tableMethods.getCellLabel(row, column);
        }
        if (!sortType || sortType === "auto") {
          return isNaN(cellValue) ? cellValue : import_xe_utils8.default.toNumber(cellValue);
        } else if (sortType === "number") {
          return import_xe_utils8.default.toNumber(cellValue);
        } else if (sortType === "string") {
          return import_xe_utils8.default.toValueString(cellValue);
        }
        return cellValue;
      };
    };
    const updateAfterListIndex = () => {
      const { treeConfig } = props;
      const { afterFullData, fullDataRowIdData, fullAllDataRowIdData } = internalData;
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      const fullMaps = {};
      afterFullData.forEach((row, index) => {
        const rowid = handleGetRowId(row);
        const rowRest = fullAllDataRowIdData[rowid];
        const seq = index + 1;
        if (rowRest) {
          if (!treeConfig) {
            rowRest.seq = seq;
          }
          rowRest._index = index;
        } else {
          const rest = { row, rowid, seq, index: -1, $index: -1, _index: index, treeIndex: -1, items: [], parent: null, level: 0, height: 0, resizeHeight: 0, oTop: 0, expandHeight: 0 };
          fullAllDataRowIdData[rowid] = rest;
          fullDataRowIdData[rowid] = rest;
        }
        fullMaps[rowid] = row;
      });
      internalData.afterFullRowMaps = fullMaps;
    };
    const updateAfterDataIndex = () => {
      const { treeConfig } = props;
      const { fullDataRowIdData, fullAllDataRowIdData, afterTreeFullData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { transform } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const fullMaps = {};
      if (treeConfig) {
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        import_xe_utils8.default.eachTree(afterTreeFullData, (row, index, items, path) => {
          const rowid = handleGetRowId(row);
          const rowRest = fullAllDataRowIdData[rowid];
          const seq = path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : ".").join("");
          if (rowRest) {
            rowRest.seq = seq;
            rowRest.treeIndex = index;
          } else {
            const rest = { row, rowid, seq, index: -1, $index: -1, _index: -1, treeIndex: -1, items: [], parent: null, level: 0, height: 0, resizeHeight: 0, oTop: 0, expandHeight: 0 };
            fullAllDataRowIdData[rowid] = rest;
            fullDataRowIdData[rowid] = rest;
          }
          fullMaps[rowid] = row;
        }, { children: transform ? treeOpts.mapChildrenField : childrenField });
        internalData.afterFullRowMaps = fullMaps;
        updateAfterListIndex();
      } else {
        updateAfterListIndex();
      }
    };
    const handleVirtualTreeToList = () => {
      const { treeConfig } = props;
      const { fullAllDataRowIdData, treeExpandedMaps } = internalData;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      if (treeConfig && treeOpts.transform) {
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        const fullData = [];
        const expandMaps = {};
        import_xe_utils8.default.eachTree(internalData.afterTreeFullData, (row, index, items, path, parentRow) => {
          const rowid = handleGetRowId(row);
          const parentRowid = handleGetRowId(parentRow);
          if (!parentRow || expandMaps[parentRowid] && treeExpandedMaps[parentRowid]) {
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              rowRest._index = fullData.length;
            }
            expandMaps[rowid] = 1;
            fullData.push(row);
          }
        }, { children: childrenField });
        internalData.afterFullData = fullData;
        updateScrollYStatus(fullData);
        return fullData;
      }
      return internalData.afterFullData;
    };
    const updateAfterFullData = () => {
      const { treeConfig } = props;
      const { tableFullColumn, tableFullData, tableFullTreeData } = internalData;
      const filterOpts = computeFilterOpts.value;
      const sortOpts = computeSortOpts.value;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const { transform, rowField, parentField, mapChildrenField } = treeOpts;
      const { isEvery, remote: allRemoteFilter, filterMethod: allFilterMethod } = filterOpts;
      const { remote: allRemoteSort, sortMethod: allSortMethod, multiple: sortMultiple, chronological } = sortOpts;
      let tableData = [];
      let tableTree = [];
      if (!allRemoteFilter || !allRemoteSort) {
        const filterColumns = [];
        let orderColumns = [];
        tableFullColumn.forEach((column) => {
          const { field, sortable, order, filters } = column;
          if (!allRemoteFilter && filters && filters.length) {
            const valueList = [];
            const itemList = [];
            filters.forEach((item) => {
              if (item.checked) {
                itemList.push(item);
                valueList.push(item.value);
              }
            });
            if (itemList.length) {
              filterColumns.push({ column, valueList, itemList });
            }
          }
          if (!allRemoteSort && sortable && order) {
            orderColumns.push({ column, field, property: field, order, sortTime: column.sortTime });
          }
        });
        if (sortMultiple && chronological && orderColumns.length > 1) {
          orderColumns = import_xe_utils8.default.orderBy(orderColumns, "sortTime");
        }
        if (!allRemoteFilter && filterColumns.length) {
          const handleFilter = (row) => {
            return filterColumns.every(({ column, valueList, itemList }) => {
              const { filterMethod, filterRender } = column;
              const compConf = isEnableConf(filterRender) ? renderer5.get(filterRender.name) : null;
              const compFilterMethod = compConf ? compConf.tableFilterMethod || compConf.filterMethod : null;
              const tdFilterMethod = compConf ? compConf.tableFilterDefaultMethod || compConf.defaultTableFilterMethod || compConf.defaultFilterMethod : null;
              const cellValue = getCellValue(row, column);
              if (filterMethod) {
                return itemList.some((item) => filterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xeTable }));
              } else if (compFilterMethod) {
                return itemList.some((item) => compFilterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xeTable }));
              } else if (allFilterMethod) {
                return allFilterMethod({ options: itemList, values: valueList, cellValue, row, column });
              } else if (tdFilterMethod) {
                return itemList.some((item) => tdFilterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xeTable }));
              }
              return valueList.indexOf(import_xe_utils8.default.get(row, column.field)) > -1;
            });
          };
          if (treeConfig && transform) {
            tableTree = import_xe_utils8.default.searchTree(tableFullTreeData, handleFilter, {
              original: true,
              isEvery,
              children: mapChildrenField,
              mapChildren: childrenField
            });
            tableData = tableTree;
          } else {
            tableData = treeConfig ? tableFullTreeData.filter(handleFilter) : tableFullData.filter(handleFilter);
            tableTree = tableData;
          }
        } else {
          if (treeConfig && transform) {
            tableTree = import_xe_utils8.default.searchTree(tableFullTreeData, () => true, {
              original: true,
              isEvery,
              children: mapChildrenField,
              mapChildren: childrenField
            });
            tableData = tableTree;
          } else {
            tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);
            tableTree = tableData;
          }
        }
        if (!allRemoteSort && orderColumns.length) {
          if (treeConfig && transform) {
            if (allSortMethod) {
              const sortRests = allSortMethod({ data: tableTree, sortList: orderColumns, $table: $xeTable });
              tableTree = import_xe_utils8.default.isArray(sortRests) ? sortRests : tableTree;
            } else {
              const treeList = import_xe_utils8.default.toTreeArray(tableTree, {
                children: mapChildrenField
              });
              tableTree = import_xe_utils8.default.toArrayTree(import_xe_utils8.default.orderBy(treeList, orderColumns.map(({ column, order }) => [getOrderField(column), order])), {
                key: rowField,
                parentKey: parentField,
                children: childrenField,
                mapChildren: mapChildrenField
              });
            }
            tableData = tableTree;
          } else {
            if (allSortMethod) {
              const sortRests = allSortMethod({ data: tableData, sortList: orderColumns, $table: $xeTable });
              tableData = import_xe_utils8.default.isArray(sortRests) ? sortRests : tableData;
            } else {
              tableData = import_xe_utils8.default.orderBy(tableData, orderColumns.map(({ column, order }) => [getOrderField(column), order]));
            }
            tableTree = tableData;
          }
        }
      } else {
        if (treeConfig && transform) {
          tableTree = import_xe_utils8.default.searchTree(tableFullTreeData, () => true, {
            original: true,
            isEvery,
            children: treeOpts.mapChildrenField,
            mapChildren: childrenField
          });
          tableData = tableTree;
        } else {
          tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);
          tableTree = tableData;
        }
      }
      internalData.afterFullData = tableData;
      internalData.afterTreeFullData = tableTree;
      updateAfterDataIndex();
    };
    const updateStyle = () => {
      const { showHeaderOverflow: allColumnHeaderOverflow, showFooterOverflow: allColumnFooterOverflow, mouseConfig, spanMethod, footerSpanMethod } = props;
      const { isGroup, currentRow, tableColumn, scrollXLoad, scrollYLoad, overflowX, scrollbarWidth, overflowY, scrollbarHeight, scrollXWidth, columnStore, editStore, isAllOverflow, expandColumn } = reactData;
      const { visibleColumn, tableHeight, headerHeight, footerHeight, elemStore, customHeight, customMinHeight, customMaxHeight } = internalData;
      const el = refElem.value;
      if (!el) {
        return;
      }
      const containerList = ["main", "left", "right"];
      const osbWidth = overflowY ? scrollbarWidth : 0;
      const osbHeight = overflowX ? scrollbarHeight : 0;
      const emptyPlaceholderElem = refEmptyPlaceholder.value;
      const mouseOpts = computeMouseOpts.value;
      const expandOpts = computeExpandOpts.value;
      const bodyWrapperElem = getRefElem(elemStore["main-body-wrapper"]);
      const bodyTableElem = getRefElem(elemStore["main-body-table"]);
      if (emptyPlaceholderElem) {
        emptyPlaceholderElem.style.top = `${headerHeight}px`;
        emptyPlaceholderElem.style.height = bodyWrapperElem ? `${bodyWrapperElem.offsetHeight - osbHeight}px` : "";
      }
      let bodyHeight = 0;
      let bodyMaxHeight = 0;
      const bodyMinHeight = customMinHeight - headerHeight - footerHeight - osbHeight;
      if (customMaxHeight) {
        bodyMaxHeight = Math.max(bodyMinHeight, customMaxHeight - headerHeight - footerHeight - osbHeight);
      }
      if (customHeight) {
        bodyHeight = customHeight - headerHeight - footerHeight - osbHeight;
      }
      if (!bodyHeight) {
        if (bodyTableElem) {
          bodyHeight = bodyTableElem.clientHeight;
        }
      }
      if (bodyHeight) {
        if (bodyMaxHeight) {
          bodyHeight = Math.min(bodyMaxHeight, bodyHeight);
        }
        bodyHeight = Math.max(bodyMinHeight, bodyHeight);
      }
      const scrollbarXToTop = computeScrollbarXToTop.value;
      const xLeftCornerEl = refScrollXLeftCornerElem.value;
      const xRightCornerEl = refScrollXRightCornerElem.value;
      const scrollXVirtualEl = refScrollXVirtualElem.value;
      if (scrollXVirtualEl) {
        scrollXVirtualEl.style.height = `${osbHeight}px`;
        scrollXVirtualEl.style.visibility = overflowX ? "visible" : "hidden";
      }
      const xWrapperEl = refScrollXWrapperElem.value;
      if (xWrapperEl) {
        xWrapperEl.style.left = scrollbarXToTop ? `${osbWidth}px` : "";
        xWrapperEl.style.width = `${el.clientWidth - osbWidth}px`;
      }
      if (xLeftCornerEl) {
        xLeftCornerEl.style.width = scrollbarXToTop ? `${osbWidth}px` : "";
        xLeftCornerEl.style.display = scrollbarXToTop ? osbWidth && osbHeight ? "block" : "" : "";
      }
      if (xRightCornerEl) {
        xRightCornerEl.style.width = scrollbarXToTop ? "" : `${osbWidth}px`;
        xRightCornerEl.style.display = scrollbarXToTop ? "" : osbWidth && osbHeight ? "block" : "";
      }
      const scrollYVirtualEl = refScrollYVirtualElem.value;
      if (scrollYVirtualEl) {
        scrollYVirtualEl.style.width = `${osbWidth}px`;
        scrollYVirtualEl.style.height = `${bodyHeight + headerHeight + footerHeight}px`;
        scrollYVirtualEl.style.visibility = overflowY ? "visible" : "hidden";
      }
      const yTopCornerEl = refScrollYTopCornerElem.value;
      if (yTopCornerEl) {
        yTopCornerEl.style.height = `${headerHeight}px`;
        yTopCornerEl.style.display = headerHeight ? "block" : "";
      }
      const yWrapperEl = refScrollYWrapperElem.value;
      if (yWrapperEl) {
        yWrapperEl.style.height = `${bodyHeight}px`;
        yWrapperEl.style.top = `${headerHeight}px`;
      }
      const yBottomCornerEl = refScrollYBottomCornerElem.value;
      if (yBottomCornerEl) {
        yBottomCornerEl.style.height = `${footerHeight}px`;
        yBottomCornerEl.style.top = `${headerHeight + bodyHeight}px`;
        yBottomCornerEl.style.display = footerHeight ? "block" : "";
      }
      const rowExpandEl = refRowExpandElem.value;
      if (rowExpandEl) {
        rowExpandEl.style.height = `${bodyHeight}px`;
        rowExpandEl.style.top = `${headerHeight}px`;
      }
      containerList.forEach((name, index) => {
        const fixedType = index > 0 ? name : "";
        const layoutList = ["header", "body", "footer"];
        const isFixedLeft = fixedType === "left";
        let fixedColumn = [];
        let fixedWrapperElem;
        if (fixedType) {
          fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;
          fixedWrapperElem = isFixedLeft ? refLeftContainer.value : refRightContainer.value;
        }
        layoutList.forEach((layout) => {
          const wrapperElem = getRefElem(elemStore[`${name}-${layout}-wrapper`]);
          const currScrollElem = getRefElem(elemStore[`${name}-${layout}-scroll`]);
          const tableElem = getRefElem(elemStore[`${name}-${layout}-table`]);
          if (layout === "header") {
            let renderColumnList = tableColumn;
            let isOptimizeMode = false;
            if (isGroup) {
              renderColumnList = visibleColumn;
            } else {
              if (scrollXLoad || scrollYLoad || allColumnHeaderOverflow) {
                if (spanMethod || footerSpanMethod) {
                } else {
                  isOptimizeMode = true;
                }
              }
              if (fixedType) {
                renderColumnList = visibleColumn;
                if (isOptimizeMode) {
                  renderColumnList = fixedColumn || [];
                }
              }
            }
            const tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (fixedType) {
              if (isGroup) {
                if (wrapperElem) {
                  wrapperElem.style.width = scrollXWidth ? `${scrollXWidth}px` : "";
                }
              } else {
                if (isOptimizeMode) {
                  if (wrapperElem) {
                    wrapperElem.style.width = tWidth ? `${tWidth}px` : "";
                  }
                } else {
                  if (wrapperElem) {
                    wrapperElem.style.width = scrollXWidth ? `${scrollXWidth}px` : "";
                  }
                }
              }
            }
            if (currScrollElem) {
              currScrollElem.style.height = `${headerHeight}px`;
            }
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth}px` : "";
            }
          } else if (layout === "body") {
            if (currScrollElem) {
              currScrollElem.style.maxHeight = customMaxHeight ? `${bodyMaxHeight}px` : "";
              currScrollElem.style.height = customHeight ? `${bodyHeight}px` : "";
              currScrollElem.style.minHeight = `${bodyMinHeight}px`;
            }
            if (fixedWrapperElem) {
              if (wrapperElem) {
                wrapperElem.style.top = `${headerHeight}px`;
              }
              fixedWrapperElem.style.height = `${customHeight > 0 ? customHeight : tableHeight + headerHeight + footerHeight + osbHeight}px`;
              fixedWrapperElem.style.width = `${fixedColumn.reduce((previous, column) => previous + column.renderWidth, 0)}px`;
            }
            let renderColumnList = tableColumn;
            let isOptimizeMode = false;
            if (scrollXLoad || scrollYLoad || isAllOverflow) {
              if (expandColumn && expandOpts.mode !== "fixed" || spanMethod || footerSpanMethod) {
              } else {
                isOptimizeMode = true;
              }
            }
            if (fixedType) {
              renderColumnList = visibleColumn;
              if (isOptimizeMode) {
                renderColumnList = fixedColumn || [];
              }
            }
            const tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (fixedType) {
              if (isOptimizeMode) {
                if (wrapperElem) {
                  wrapperElem.style.width = tWidth ? `${tWidth}px` : "";
                }
              } else {
                if (wrapperElem) {
                  wrapperElem.style.width = scrollXWidth ? `${scrollXWidth}px` : "";
                }
              }
            }
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth}px` : "";
              tableElem.style.paddingRight = osbWidth && fixedType && (browseObj2["-moz"] || browseObj2.safari) ? `${osbWidth}px` : "";
            }
            const emptyBlockElem = getRefElem(elemStore[`${name}-${layout}-emptyBlock`]);
            if (emptyBlockElem) {
              emptyBlockElem.style.width = tWidth ? `${tWidth}px` : "";
            }
          } else if (layout === "footer") {
            let renderColumnList = tableColumn;
            let isOptimizeMode = false;
            if (scrollXLoad || scrollYLoad || allColumnFooterOverflow) {
              if (spanMethod || footerSpanMethod) {
              } else {
                isOptimizeMode = true;
              }
            }
            if (fixedType) {
              renderColumnList = visibleColumn;
              if (isOptimizeMode) {
                renderColumnList = fixedColumn || [];
              }
            }
            const tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (fixedType) {
              if (isOptimizeMode) {
                if (wrapperElem) {
                  wrapperElem.style.width = tWidth ? `${tWidth}px` : "";
                }
              } else {
                if (wrapperElem) {
                  wrapperElem.style.width = scrollXWidth ? `${scrollXWidth}px` : "";
                }
              }
            }
            if (currScrollElem) {
              currScrollElem.style.height = `${footerHeight}px`;
              if (fixedWrapperElem) {
                if (wrapperElem) {
                  wrapperElem.style.top = `${customHeight > 0 ? customHeight - footerHeight - osbHeight : tableHeight + headerHeight}px`;
                }
              }
            }
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth}px` : "";
            }
          }
        });
      });
      if (currentRow) {
        $xeTable.setCurrentRow(currentRow);
      }
      if (mouseConfig && mouseOpts.selected && editStore.selected.row && editStore.selected.column) {
        $xeTable.addCellSelectedClass();
      }
      return nextTick();
    };
    const checkValidate = (type) => {
      if ($xeTable.triggerValidate) {
        return $xeTable.triggerValidate(type);
      }
      return nextTick();
    };
    const handleChangeCell = (evnt, params) => {
      checkValidate("blur").catch((e) => e).then(() => {
        $xeTable.handleEdit(params, evnt).then(() => checkValidate("change")).catch((e) => e);
      });
    };
    const handleDefaultSort = () => {
      const { sortConfig } = props;
      if (sortConfig) {
        const sortOpts = computeSortOpts.value;
        let { defaultSort } = sortOpts;
        if (defaultSort) {
          if (!import_xe_utils8.default.isArray(defaultSort)) {
            defaultSort = [defaultSort];
          }
          if (defaultSort.length) {
            (sortConfig.multiple ? defaultSort : defaultSort.slice(0, 1)).forEach((item, index) => {
              const { field, order } = item;
              if (field && order) {
                const column = $xeTable.getColumnByField(field);
                if (column && column.sortable) {
                  column.order = order;
                  column.sortTime = Date.now() + index;
                }
              }
            });
            if (!sortOpts.remote) {
              $xeTable.handleTableData(true).then(updateStyle);
            }
          }
        }
      }
    };
    const handleDefaultSelectionChecked = () => {
      const { checkboxConfig } = props;
      if (checkboxConfig) {
        const { fullDataRowIdData } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkAll, checkRowKeys } = checkboxOpts;
        if (checkAll) {
          handleCheckedAllCheckboxRow(true, true);
        } else if (checkRowKeys) {
          const defSelection = [];
          checkRowKeys.forEach((rowid) => {
            if (fullDataRowIdData[rowid]) {
              defSelection.push(fullDataRowIdData[rowid].row);
            }
          });
          handleCheckedCheckboxRow(defSelection, true, true);
        }
      }
    };
    const handleDefaultRadioChecked = () => {
      const { radioConfig } = props;
      if (radioConfig) {
        const { fullDataRowIdData } = internalData;
        const radioOpts = computeRadioOpts.value;
        const { checkRowKey: rowid, reserve } = radioOpts;
        if (rowid) {
          if (fullDataRowIdData[rowid]) {
            handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);
          }
          if (reserve) {
            const rowkey = getRowkey($xeTable);
            internalData.radioReserveRow = { [rowkey]: rowid };
          }
        }
      }
    };
    const handleDefaultRowExpand = () => {
      const { expandConfig } = props;
      if (expandConfig) {
        const { fullDataRowIdData } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { expandAll, expandRowKeys } = expandOpts;
        if (expandAll) {
          $xeTable.setAllRowExpand(true);
        } else if (expandRowKeys) {
          const defExpandeds = [];
          expandRowKeys.forEach((rowid) => {
            if (fullDataRowIdData[rowid]) {
              defExpandeds.push(fullDataRowIdData[rowid].row);
            }
          });
          $xeTable.setRowExpand(defExpandeds, true);
        }
      }
    };
    const handleRadioReserveRow = (row) => {
      const radioOpts = computeRadioOpts.value;
      if (radioOpts.reserve) {
        internalData.radioReserveRow = row;
      }
    };
    const handleCheckboxReserveRow = (row, checked) => {
      const { checkboxReserveRowMap } = internalData;
      const checkboxOpts = computeCheckboxOpts.value;
      if (checkboxOpts.reserve) {
        const rowid = getRowid($xeTable, row);
        if (checked) {
          checkboxReserveRowMap[rowid] = row;
        } else if (checkboxReserveRowMap[rowid]) {
          delete checkboxReserveRowMap[rowid];
        }
      }
    };
    const handleCheckedRadioRow = (row, isForce) => {
      const radioOpts = computeRadioOpts.value;
      const { checkMethod } = radioOpts;
      if (row && (isForce || (!checkMethod || checkMethod({ row })))) {
        reactData.selectRadioRow = row;
        handleRadioReserveRow(row);
      }
      return nextTick();
    };
    const handleCheckedCheckboxRow = (rows, value, isForce) => {
      if (rows && !import_xe_utils8.default.isArray(rows)) {
        rows = [rows];
      }
      $xeTable.handleBatchSelectRows(rows, !!value, isForce);
      $xeTable.checkSelectionStatus();
      return nextTick();
    };
    const handleCheckedAllCheckboxRow = (checked, isForce) => {
      const { treeConfig } = props;
      const { afterFullData, checkboxReserveRowMap, selectCheckboxMaps } = internalData;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const checkboxOpts = computeCheckboxOpts.value;
      const { checkField, reserve, checkMethod } = checkboxOpts;
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
      const selectRowMaps = {};
      if (checkField) {
        const checkValFn = (row) => {
          if (isForce || (!checkMethod || checkMethod({ row }))) {
            if (checked) {
              selectRowMaps[handleGetRowId(row)] = row;
            }
            import_xe_utils8.default.set(row, checkField, checked);
          }
          if (treeConfig && indeterminateField) {
            import_xe_utils8.default.set(row, indeterminateField, false);
          }
        };
        if (treeConfig) {
          import_xe_utils8.default.eachTree(afterFullData, checkValFn, { children: childrenField });
        } else {
          afterFullData.forEach(checkValFn);
        }
      } else {
        if (treeConfig) {
          if (checked) {
            import_xe_utils8.default.eachTree(afterFullData, (row) => {
              if (isForce || (!checkMethod || checkMethod({ row }))) {
                const rowid = handleGetRowId(row);
                selectRowMaps[rowid] = row;
              }
            }, { children: childrenField });
          } else {
            if (!isForce && checkMethod) {
              import_xe_utils8.default.eachTree(afterFullData, (row) => {
                const rowid = handleGetRowId(row);
                if (checkMethod({ row }) ? 0 : selectCheckboxMaps[rowid]) {
                  selectRowMaps[rowid] = row;
                }
              }, { children: childrenField });
            }
          }
        } else {
          if (checked) {
            if (!isForce && checkMethod) {
              afterFullData.forEach((row) => {
                const rowid = handleGetRowId(row);
                if (selectCheckboxMaps[rowid] || checkMethod({ row })) {
                  selectRowMaps[rowid] = row;
                }
              });
            } else {
              afterFullData.forEach((row) => {
                const rowid = handleGetRowId(row);
                selectRowMaps[rowid] = row;
              });
            }
          } else {
            if (!isForce && checkMethod) {
              afterFullData.forEach((row) => {
                const rowid = handleGetRowId(row);
                if (checkMethod({ row }) ? 0 : selectCheckboxMaps[rowid]) {
                  selectRowMaps[rowid] = row;
                }
              });
            }
          }
        }
      }
      if (reserve) {
        if (checked) {
          import_xe_utils8.default.each(selectRowMaps, (row, rowid) => {
            checkboxReserveRowMap[rowid] = row;
          });
        } else {
          afterFullData.forEach((row) => handleCheckboxReserveRow(row, false));
        }
      }
      reactData.updateCheckboxFlag++;
      internalData.selectCheckboxMaps = checkField ? {} : selectRowMaps;
      reactData.isAllSelected = checked;
      reactData.isIndeterminate = false;
      internalData.treeIndeterminateRowMaps = {};
      $xeTable.checkSelectionStatus();
      return nextTick();
    };
    const handleReserveStatus = () => {
      const { treeConfig } = props;
      const { expandColumn, currentRow, selectRadioRow } = reactData;
      const { fullDataRowIdData, fullAllDataRowIdData, radioReserveRow, selectCheckboxMaps, treeExpandedMaps, rowExpandedMaps } = internalData;
      const expandOpts = computeExpandOpts.value;
      const treeOpts = computeTreeOpts.value;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      if (selectRadioRow && !fullAllDataRowIdData[getRowid($xeTable, selectRadioRow)]) {
        reactData.selectRadioRow = null;
      }
      if (radioOpts.reserve && radioReserveRow) {
        const rowid = getRowid($xeTable, radioReserveRow);
        if (fullDataRowIdData[rowid]) {
          handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);
        }
      }
      internalData.selectCheckboxMaps = getRecoverRowMaps(selectCheckboxMaps);
      reactData.updateCheckboxFlag++;
      if (checkboxOpts.reserve) {
        handleCheckedCheckboxRow(handleReserveRow(internalData.checkboxReserveRowMap), true, true);
      }
      if (currentRow && !fullAllDataRowIdData[getRowid($xeTable, currentRow)]) {
        reactData.currentRow = null;
      }
      internalData.rowExpandedMaps = expandColumn ? getRecoverRowMaps(rowExpandedMaps) : {};
      reactData.rowExpandedFlag++;
      if (expandColumn && expandOpts.reserve) {
        $xeTable.setRowExpand(handleReserveRow(internalData.rowExpandedReserveRowMap), true);
      }
      internalData.treeExpandedMaps = treeConfig ? getRecoverRowMaps(treeExpandedMaps) : {};
      reactData.treeExpandedFlag++;
      if (treeConfig && treeOpts.reserve) {
        $xeTable.setTreeExpand(handleReserveRow(internalData.treeExpandedReserveRowMap), true);
      }
    };
    const handleDefaultTreeExpand = () => {
      const { treeConfig } = props;
      if (treeConfig) {
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { expandAll, expandRowKeys } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        if (expandAll) {
          $xeTable.setAllTreeExpand(true);
        } else if (expandRowKeys) {
          const defExpandeds = [];
          const rowkey = getRowkey($xeTable);
          expandRowKeys.forEach((rowid) => {
            const matchObj = import_xe_utils8.default.findTree(tableFullData, (item) => rowid === import_xe_utils8.default.get(item, rowkey), { children: childrenField });
            if (matchObj) {
              defExpandeds.push(matchObj.item);
            }
          });
          $xeTable.setTreeExpand(defExpandeds, true);
        }
      }
    };
    const handleAsyncTreeExpandChilds = (row) => {
      const treeOpts = computeTreeOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const { transform, loadMethod } = treeOpts;
      const { checkStrictly } = checkboxOpts;
      return new Promise((resolve) => {
        if (loadMethod) {
          const { fullAllDataRowIdData, treeExpandLazyLoadedMaps } = internalData;
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          treeExpandLazyLoadedMaps[rowid] = row;
          Promise.resolve(loadMethod({ $table: $xeTable, row })).then((childRecords) => {
            if (rowRest) {
              rowRest.treeLoaded = true;
            }
            if (treeExpandLazyLoadedMaps[rowid]) {
              delete treeExpandLazyLoadedMaps[rowid];
            }
            if (!import_xe_utils8.default.isArray(childRecords)) {
              childRecords = [];
            }
            if (childRecords) {
              return $xeTable.loadTreeChildren(row, childRecords).then((childRows) => {
                const { treeExpandedMaps } = internalData;
                if (childRows.length && !treeExpandedMaps[rowid]) {
                  treeExpandedMaps[rowid] = row;
                }
                reactData.treeExpandedFlag++;
                if (!checkStrictly && $xeTable.isCheckedByCheckboxRow(row)) {
                  handleCheckedCheckboxRow(childRows, true);
                }
                return nextTick().then(() => {
                  if (transform) {
                    $xeTable.handleTableData();
                    updateAfterDataIndex();
                    return nextTick();
                  }
                });
              });
            }
          }).catch(() => {
            const { treeExpandLazyLoadedMaps: treeExpandLazyLoadedMaps2 } = internalData;
            if (rowRest) {
              rowRest.treeLoaded = false;
            }
            if (treeExpandLazyLoadedMaps2[rowid]) {
              delete treeExpandLazyLoadedMaps2[rowid];
            }
          }).finally(() => {
            reactData.treeExpandedFlag++;
            nextTick().then(() => $xeTable.recalculate()).then(() => resolve());
          });
        } else {
          resolve();
        }
      });
    };
    const handleTreeExpandReserve = (row, expanded) => {
      const { treeExpandedReserveRowMap } = internalData;
      const treeOpts = computeTreeOpts.value;
      if (treeOpts.reserve) {
        const rowid = getRowid($xeTable, row);
        if (expanded) {
          treeExpandedReserveRowMap[rowid] = row;
        } else if (treeExpandedReserveRowMap[rowid]) {
          delete treeExpandedReserveRowMap[rowid];
        }
      }
    };
    const handleAsyncRowExpand = (row) => {
      return new Promise((resolve) => {
        const expandOpts = computeExpandOpts.value;
        const { loadMethod } = expandOpts;
        if (loadMethod) {
          const { fullAllDataRowIdData, rowExpandLazyLoadedMaps } = internalData;
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          rowExpandLazyLoadedMaps[rowid] = row;
          loadMethod({ $table: $xeTable, row, rowIndex: $xeTable.getRowIndex(row), $rowIndex: $xeTable.getVMRowIndex(row) }).then(() => {
            const { rowExpandedMaps } = internalData;
            if (rowRest) {
              rowRest.expandLoaded = true;
            }
            rowExpandedMaps[rowid] = row;
            reactData.rowExpandedFlag++;
          }).catch(() => {
            if (rowRest) {
              rowRest.expandLoaded = false;
            }
          }).finally(() => {
            const { rowExpandLazyLoadedMaps: rowExpandLazyLoadedMaps2 } = internalData;
            if (rowExpandLazyLoadedMaps2[rowid]) {
              delete rowExpandLazyLoadedMaps2[rowid];
            }
            reactData.rowExpandedFlag++;
            nextTick().then(() => $xeTable.recalculate()).then(() => $xeTable.updateCellAreas()).then(() => resolve());
          });
        } else {
          resolve();
        }
      });
    };
    const handleRowExpandReserve = (row, expanded) => {
      const { rowExpandedReserveRowMap } = internalData;
      const expandOpts = computeExpandOpts.value;
      if (expandOpts.reserve) {
        const rowid = getRowid($xeTable, row);
        if (expanded) {
          rowExpandedReserveRowMap[rowid] = row;
        } else if (rowExpandedReserveRowMap[rowid]) {
          delete rowExpandedReserveRowMap[rowid];
        }
      }
    };
    const handleDefaultMergeCells = () => {
      const { mergeCells } = props;
      if (mergeCells) {
        $xeTable.setMergeCells(mergeCells);
      }
    };
    const handleDefaultMergeFooterItems = () => {
      const { mergeFooterItems } = props;
      if (mergeFooterItems) {
        $xeTable.setMergeFooterItems(mergeFooterItems);
      }
    };
    const computeScrollLoad = () => {
      return nextTick().then(() => {
        const { scrollXLoad, scrollYLoad } = reactData;
        const { scrollXStore, scrollYStore } = internalData;
        const virtualYOpts = computeVirtualYOpts.value;
        const virtualXOpts = computeVirtualXOpts.value;
        if (scrollXLoad) {
          const { toVisibleIndex: toXVisibleIndex, visibleSize: visibleXSize } = handleVirtualXVisible();
          const offsetXSize = Math.max(0, virtualXOpts.oSize ? import_xe_utils8.default.toNumber(virtualXOpts.oSize) : 0);
          scrollXStore.preloadSize = import_xe_utils8.default.toNumber(virtualXOpts.preSize);
          scrollXStore.offsetSize = offsetXSize;
          scrollXStore.visibleSize = visibleXSize;
          scrollXStore.endIndex = Math.max(scrollXStore.startIndex + scrollXStore.visibleSize + offsetXSize, scrollXStore.endIndex);
          scrollXStore.visibleStartIndex = Math.max(scrollXStore.startIndex, toXVisibleIndex);
          scrollXStore.visibleEndIndex = Math.min(scrollXStore.endIndex, toXVisibleIndex + visibleXSize);
          $xeTable.updateScrollXData().then(() => {
            loadScrollXData();
          });
        } else {
          $xeTable.updateScrollXSpace();
        }
        const rowHeight = computeRowHeight();
        scrollYStore.rowHeight = rowHeight;
        reactData.rowHeight = rowHeight;
        const { toVisibleIndex: toYVisibleIndex, visibleSize: visibleYSize } = handleVirtualYVisible();
        if (scrollYLoad) {
          const offsetYSize = Math.max(0, virtualYOpts.oSize ? import_xe_utils8.default.toNumber(virtualYOpts.oSize) : 0);
          scrollYStore.preloadSize = import_xe_utils8.default.toNumber(virtualYOpts.preSize);
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex + visibleYSize + offsetYSize, scrollYStore.endIndex);
          scrollYStore.visibleStartIndex = Math.max(scrollYStore.startIndex, toYVisibleIndex);
          scrollYStore.visibleEndIndex = Math.min(scrollYStore.endIndex, toYVisibleIndex + visibleYSize);
          $xeTable.updateScrollYData().then(() => {
            loadScrollYData();
          });
        } else {
          $xeTable.updateScrollYSpace();
        }
        nextTick(() => {
          updateStyle();
        });
      });
    };
    const handleRecalculateLayout = (reFull) => {
      const el = refElem.value;
      internalData.rceRunTime = Date.now();
      if (!el || !el.clientWidth) {
        return nextTick();
      }
      const varEl = refVarElem.value;
      if (varEl) {
        const [defEl, mediumEl, smallEl, miniEl] = varEl.children;
        calcVarRowHeightConfig("default", defEl);
        calcVarRowHeightConfig("medium", mediumEl);
        calcVarRowHeightConfig("small", smallEl);
        calcVarRowHeightConfig("mini", miniEl);
      }
      calcCellWidth();
      autoCellWidth();
      updateStyle();
      updateRowExpandStyle();
      return computeScrollLoad().then(() => {
        if (reFull === true) {
          calcCellWidth();
          autoCellWidth();
          updateStyle();
          if (reFull) {
            updateRowOffsetTop();
          }
          updateRowExpandStyle();
          return computeScrollLoad();
        }
      });
    };
    const loadTableData = (datas, isReset) => {
      const { keepSource, treeConfig } = props;
      const { scrollYLoad: oldScrollYLoad } = reactData;
      const { scrollYStore, scrollXStore, lastScrollLeft, lastScrollTop } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { transform } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      let treeData = [];
      let fullData = reactive(datas ? datas.slice(0) : []);
      if (fullData.length > supportMaxRow) {
        errLog("vxe.error.errMaxRow", [supportMaxRow]);
      }
      if (treeConfig) {
        if (transform) {
          if (!treeOpts.rowField) {
            errLog("vxe.error.reqProp", ["tree-config.rowField"]);
          }
          if (!treeOpts.parentField) {
            errLog("vxe.error.reqProp", ["tree-config.parentField"]);
          }
          if (!childrenField) {
            errLog("vxe.error.reqProp", ["tree-config.childrenField"]);
          }
          if (!treeOpts.mapChildrenField) {
            errLog("vxe.error.reqProp", ["tree-config.mapChildrenField"]);
          }
          if (childrenField === treeOpts.mapChildrenField) {
            errLog("vxe.error.errConflicts", ["tree-config.childrenField", "tree-config.mapChildrenField"]);
          }
          treeData = import_xe_utils8.default.toArrayTree(fullData, {
            key: treeOpts.rowField,
            parentKey: treeOpts.parentField,
            children: childrenField,
            mapChildren: treeOpts.mapChildrenField
          });
          fullData = treeData.slice(0);
        } else {
          treeData = fullData.slice(0);
        }
      }
      scrollYStore.startIndex = 0;
      scrollYStore.endIndex = 1;
      scrollXStore.startIndex = 0;
      scrollXStore.endIndex = 1;
      reactData.isRowLoading = true;
      reactData.scrollVMLoading = false;
      internalData.insertRowMaps = {};
      internalData.removeRowMaps = {};
      const sYLoad = updateScrollYStatus(fullData);
      reactData.isDragColMove = false;
      reactData.isDragRowMove = false;
      internalData.tableFullData = fullData;
      internalData.tableFullTreeData = treeData;
      $xeTable.cacheRowMap(true);
      internalData.tableSynchData = datas;
      if (isReset) {
        internalData.isResizeCellHeight = false;
      }
      if (keepSource) {
        $xeTable.cacheSourceMap(fullData);
      }
      if ($xeTable.clearCellAreas && props.mouseConfig) {
        $xeTable.clearCellAreas();
        $xeTable.clearCopyCellArea();
      }
      $xeTable.clearMergeCells();
      $xeTable.clearMergeFooterItems();
      $xeTable.handleTableData(true);
      $xeTable.updateFooter();
      return nextTick().then(() => {
        updateHeight();
        updateStyle();
      }).then(() => {
        computeScrollLoad();
      }).then(() => {
        if (sYLoad) {
          scrollYStore.endIndex = scrollYStore.visibleSize;
        }
        if (sYLoad) {
          if (!(props.height || props.maxHeight)) {
            errLog("vxe.error.reqProp", ["table.height | table.max-height | table.scroll-y={enabled: false}"]);
          }
          if (props.spanMethod) {
            errLog("vxe.error.scrollErrProp", ["table.span-method"]);
          }
        }
        handleReserveStatus();
        $xeTable.checkSelectionStatus();
        return new Promise((resolve) => {
          nextTick().then(() => $xeTable.recalculate()).then(() => {
            let targetScrollLeft = lastScrollLeft;
            let targetScrollTop = lastScrollTop;
            const virtualXOpts = computeVirtualXOpts.value;
            const virtualYOpts = computeVirtualYOpts.value;
            if (virtualXOpts.scrollToLeftOnChange) {
              targetScrollLeft = 0;
            }
            if (virtualYOpts.scrollToTopOnChange) {
              targetScrollTop = 0;
            }
            reactData.isRowLoading = false;
            calcCellHeight();
            updateRowOffsetTop();
            if (oldScrollYLoad === sYLoad) {
              restoreScrollLocation($xeTable, targetScrollLeft, targetScrollTop).then(() => {
                resolve();
              });
            } else {
              setTimeout(() => {
                restoreScrollLocation($xeTable, targetScrollLeft, targetScrollTop).then(() => {
                  resolve();
                });
              });
            }
          });
        });
      });
    };
    const handleLoadDefaults = () => {
      handleDefaultSelectionChecked();
      handleDefaultRadioChecked();
      handleDefaultRowExpand();
      handleDefaultTreeExpand();
      handleDefaultMergeCells();
      handleDefaultMergeFooterItems();
      nextTick(() => setTimeout(() => $xeTable.recalculate()));
    };
    const handleInitDefaults = () => {
      handleDefaultSort();
    };
    const handleTableColumn = () => {
      const { scrollXLoad } = reactData;
      const { visibleColumn, scrollXStore, fullColumnIdData } = internalData;
      const tableColumn = scrollXLoad ? visibleColumn.slice(scrollXStore.startIndex, scrollXStore.endIndex) : visibleColumn.slice(0);
      tableColumn.forEach((column, $index) => {
        const colid = column.id;
        const colRest = fullColumnIdData[colid];
        if (colRest) {
          colRest.$index = $index;
        }
      });
      reactData.tableColumn = tableColumn;
    };
    const handleUpdateColumn = () => {
      const columnList = import_xe_utils8.default.orderBy(internalData.collectColumn, "renderSortNumber");
      internalData.collectColumn = columnList;
      const tableFullColumn = getColumnList(columnList);
      internalData.tableFullColumn = tableFullColumn;
      cacheColumnMap();
    };
    const loadScrollXData = () => {
      const { mergeList, mergeFooterList, isScrollXBig } = reactData;
      const { scrollXStore } = internalData;
      const { preloadSize, startIndex, endIndex, offsetSize } = scrollXStore;
      const { toVisibleIndex, visibleSize } = handleVirtualXVisible();
      const offsetItem = {
        startIndex: Math.max(0, isScrollXBig ? toVisibleIndex - 1 : toVisibleIndex - 1 - offsetSize - preloadSize),
        endIndex: isScrollXBig ? toVisibleIndex + visibleSize : toVisibleIndex + visibleSize + offsetSize + preloadSize
      };
      scrollXStore.visibleStartIndex = toVisibleIndex - 1;
      scrollXStore.visibleEndIndex = toVisibleIndex + visibleSize + 1;
      calculateMergerOffsetIndex(mergeList.concat(mergeFooterList), offsetItem, "col");
      const { startIndex: offsetStartIndex, endIndex: offsetEndIndex } = offsetItem;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollXStore.startIndex = offsetStartIndex;
          scrollXStore.endIndex = offsetEndIndex;
          $xeTable.updateScrollXData();
        }
      }
      $xeTable.closeTooltip();
    };
    const getColumnList = (columns) => {
      const result = [];
      columns.forEach((column) => {
        result.push(...column.children && column.children.length ? getColumnList(column.children) : [column]);
      });
      return result;
    };
    const parseColumns = (isReset) => {
      const leftList = [];
      const centerList = [];
      const rightList = [];
      const { isGroup, columnStore } = reactData;
      const virtualXOpts = computeVirtualXOpts.value;
      const { collectColumn, tableFullColumn, scrollXStore, fullColumnIdData } = internalData;
      if (isGroup) {
        const leftGroupList = [];
        const centerGroupList = [];
        const rightGroupList = [];
        import_xe_utils8.default.eachTree(collectColumn, (column, index, items, path, parentColumn) => {
          const isColGroup = hasChildrenList(column);
          if (parentColumn && parentColumn.fixed) {
            column.fixed = parentColumn.fixed;
          }
          if (parentColumn && column.fixed !== parentColumn.fixed) {
            errLog("vxe.error.groupFixed");
          }
          if (isColGroup) {
            column.visible = !!import_xe_utils8.default.findTree(column.children, (subColumn) => hasChildrenList(subColumn) ? false : subColumn.visible);
          } else if (column.visible) {
            if (column.fixed === "left") {
              leftList.push(column);
            } else if (column.fixed === "right") {
              rightList.push(column);
            } else {
              centerList.push(column);
            }
          }
        });
        collectColumn.forEach((column) => {
          if (column.visible) {
            if (column.fixed === "left") {
              leftGroupList.push(column);
            } else if (column.fixed === "right") {
              rightGroupList.push(column);
            } else {
              centerGroupList.push(column);
            }
          }
        });
        reactData.tableGroupColumn = leftGroupList.concat(centerGroupList).concat(rightGroupList);
      } else {
        tableFullColumn.forEach((column) => {
          if (column.visible) {
            if (column.fixed === "left") {
              leftList.push(column);
            } else if (column.fixed === "right") {
              rightList.push(column);
            } else {
              centerList.push(column);
            }
          }
        });
      }
      const visibleColumn = leftList.concat(centerList).concat(rightList);
      const scrollXLoad = !!virtualXOpts.enabled && virtualXOpts.gt > -1 && (virtualXOpts.gt === 0 || virtualXOpts.gt < tableFullColumn.length);
      reactData.hasFixedColumn = leftList.length > 0 || rightList.length > 0;
      Object.assign(columnStore, { leftList, centerList, rightList });
      if (scrollXLoad) {
        if (props.spanMethod) {
          warnLog("vxe.error.scrollErrProp", ["span-method"]);
        }
        if (props.footerSpanMethod) {
          warnLog("vxe.error.scrollErrProp", ["footer-span-method"]);
        }
        if (isReset) {
          const { visibleSize } = handleVirtualXVisible();
          scrollXStore.startIndex = 0;
          scrollXStore.endIndex = visibleSize;
          scrollXStore.visibleSize = visibleSize;
          scrollXStore.visibleStartIndex = 0;
          scrollXStore.visibleEndIndex = visibleSize;
        }
      }
      if (visibleColumn.length !== internalData.visibleColumn.length || !internalData.visibleColumn.every((column, index) => column === visibleColumn[index])) {
        $xeTable.clearMergeCells();
        $xeTable.clearMergeFooterItems();
      }
      reactData.scrollXLoad = scrollXLoad;
      visibleColumn.forEach((column, index) => {
        const colid = column.id;
        const colRest = fullColumnIdData[colid];
        if (colRest) {
          colRest._index = index;
        }
      });
      internalData.visibleColumn = visibleColumn;
      handleTableColumn();
      if (isReset) {
        updateColumnOffsetLeft();
        return $xeTable.updateFooter().then(() => {
          return $xeTable.recalculate();
        }).then(() => {
          $xeTable.updateCellAreas();
          return $xeTable.recalculate();
        });
      }
      return $xeTable.updateFooter();
    };
    const initColumnSort = () => {
      const { collectColumn } = internalData;
      collectColumn.forEach((column, index) => {
        const sortIndex = index + 1;
        column.sortNumber = sortIndex;
        column.renderSortNumber = sortIndex;
      });
    };
    const handleColumn = (collectColumn) => {
      const expandOpts = computeExpandOpts.value;
      internalData.collectColumn = collectColumn;
      const tableFullColumn = getColumnList(collectColumn);
      internalData.tableFullColumn = tableFullColumn;
      reactData.isColLoading = true;
      reactData.isDragColMove = false;
      initColumnSort();
      return Promise.resolve(restoreCustomStorage()).then(() => {
        const { scrollXLoad, scrollYLoad, expandColumn } = reactData;
        cacheColumnMap();
        parseColumns(true).then(() => {
          if (reactData.scrollXLoad) {
            loadScrollXData();
          }
        });
        $xeTable.clearMergeCells();
        $xeTable.clearMergeFooterItems();
        $xeTable.handleTableData(true);
        if ((scrollXLoad || scrollYLoad) && (expandColumn && expandOpts.mode !== "fixed")) {
          warnLog("vxe.error.scrollErrProp", ["column.type=expand"]);
        }
        return nextTick().then(() => {
          if ($xeToolbar) {
            $xeToolbar.syncUpdate({
              collectColumn: internalData.collectColumn,
              $table: $xeTable
            });
          }
          if ($xeTable.handleUpdateCustomColumn) {
            $xeTable.handleUpdateCustomColumn();
          }
          reactData.isColLoading = false;
          return $xeTable.recalculate();
        });
      });
    };
    const updateScrollYStatus = (fullData) => {
      const { treeConfig } = props;
      const virtualYOpts = computeVirtualYOpts.value;
      const treeOpts = computeTreeOpts.value;
      const { transform } = treeOpts;
      const allList = fullData || internalData.tableFullData;
      const scrollYLoad = (transform || !treeConfig) && !!virtualYOpts.enabled && virtualYOpts.gt > -1 && (virtualYOpts.gt === 0 || virtualYOpts.gt < allList.length);
      reactData.scrollYLoad = scrollYLoad;
      return scrollYLoad;
    };
    const handleBaseTreeExpand = (rows, expanded) => {
      const { treeNodeColumn } = reactData;
      const { fullAllDataRowIdData, tableFullData, treeExpandedMaps, treeExpandLazyLoadedMaps } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { reserve, lazy, accordion, toggleMethod } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
      const result = [];
      const columnIndex = tableMethods.getColumnIndex(treeNodeColumn);
      const $columnIndex = tableMethods.getVMColumnIndex(treeNodeColumn);
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      let validRows = toggleMethod ? rows.filter((row) => toggleMethod({ $table: $xeTable, expanded, column: treeNodeColumn, columnIndex, $columnIndex, row })) : rows;
      if (accordion) {
        validRows = validRows.length ? [validRows[validRows.length - 1]] : [];
        const matchObj = import_xe_utils8.default.findTree(tableFullData, (item) => item === validRows[0], { children: childrenField });
        if (matchObj) {
          matchObj.items.forEach((item) => {
            const rowid = handleGetRowId(item);
            if (treeExpandedMaps[rowid]) {
              delete treeExpandedMaps[rowid];
            }
          });
        }
      }
      if (expanded) {
        validRows.forEach((row) => {
          const rowid = handleGetRowId(row);
          if (!treeExpandedMaps[rowid]) {
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              const isLoad = lazy && row[hasChildField] && !rowRest.treeLoaded && !treeExpandLazyLoadedMaps[rowid];
              if (isLoad) {
                result.push(handleAsyncTreeExpandChilds(row));
              } else {
                if (row[childrenField] && row[childrenField].length) {
                  treeExpandedMaps[rowid] = row;
                }
              }
            }
          }
        });
      } else {
        validRows.forEach((item) => {
          const rowid = handleGetRowId(item);
          if (treeExpandedMaps[rowid]) {
            delete treeExpandedMaps[rowid];
          }
        });
      }
      if (reserve) {
        validRows.forEach((row) => handleTreeExpandReserve(row, expanded));
      }
      reactData.treeExpandedFlag++;
      return Promise.all(result).then(() => {
        return tableMethods.recalculate();
      });
    };
    const handleVirtualTreeExpand = (rows, expanded) => {
      return handleBaseTreeExpand(rows, expanded).then(() => {
        handleVirtualTreeToList();
        tablePrivateMethods.handleTableData();
        updateAfterDataIndex();
        return nextTick();
      }).then(() => {
        return tableMethods.recalculate(true);
      }).then(() => {
        setTimeout(() => {
          tableMethods.updateCellAreas();
        }, 30);
      });
    };
    const handleCheckAllEvent = (evnt, value) => {
      handleCheckedAllCheckboxRow(value);
      if (evnt) {
        dispatchEvent("checkbox-all", {
          records: () => $xeTable.getCheckboxRecords(),
          reserves: () => $xeTable.getCheckboxReserveRecords(),
          indeterminates: () => $xeTable.getCheckboxIndeterminateRecords(),
          checked: value
        }, evnt);
      }
    };
    const loadScrollYData = () => {
      const { mergeList, isAllOverflow, isScrollYBig } = reactData;
      const { scrollYStore } = internalData;
      const { preloadSize, startIndex, endIndex, offsetSize } = scrollYStore;
      const autoOffsetYSize = isAllOverflow ? offsetSize : offsetSize + 1;
      const { toVisibleIndex, visibleSize } = handleVirtualYVisible();
      const offsetItem = {
        startIndex: Math.max(0, isScrollYBig ? toVisibleIndex - 1 : toVisibleIndex - 1 - offsetSize - preloadSize),
        endIndex: isScrollYBig ? toVisibleIndex + visibleSize : toVisibleIndex + visibleSize + autoOffsetYSize + preloadSize
      };
      scrollYStore.visibleStartIndex = toVisibleIndex - 1;
      scrollYStore.visibleEndIndex = toVisibleIndex + visibleSize + 1;
      calculateMergerOffsetIndex(mergeList, offsetItem, "row");
      const { startIndex: offsetStartIndex, endIndex: offsetEndIndex } = offsetItem;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          $xeTable.updateScrollYData();
        }
      }
    };
    const createGetRowCacheProp = (prop) => {
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      return function(row) {
        const { fullAllDataRowIdData } = internalData;
        if (row) {
          const rowid = handleGetRowId(row);
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            return rowRest[prop];
          }
        }
        return -1;
      };
    };
    const createGetColumnCacheProp = (prop) => {
      return function(column) {
        const { fullColumnIdData } = internalData;
        if (column) {
          const colRest = fullColumnIdData[column.id];
          if (colRest) {
            return colRest[prop];
          }
        }
        return -1;
      };
    };
    const lazyScrollXData = () => {
      const { lxTimeout, lxRunTime, scrollXStore } = internalData;
      const { visibleSize } = scrollXStore;
      const fpsTime = Math.max(5, Math.min(10, Math.floor(visibleSize / 3)));
      if (lxTimeout) {
        clearTimeout(lxTimeout);
      }
      if (!lxRunTime || lxRunTime + fpsTime < Date.now()) {
        internalData.lxRunTime = Date.now();
        loadScrollXData();
      }
      internalData.lxTimeout = setTimeout(() => {
        internalData.lxTimeout = void 0;
        internalData.lxRunTime = void 0;
        loadScrollXData();
      }, fpsTime);
    };
    const lazyScrollYData = () => {
      const { lyTimeout, lyRunTime, scrollYStore } = internalData;
      const { visibleSize } = scrollYStore;
      const fpsTime = Math.floor(Math.max(4, Math.min(10, visibleSize / 3)));
      if (lyTimeout) {
        clearTimeout(lyTimeout);
      }
      if (!lyRunTime || lyRunTime + fpsTime < Date.now()) {
        internalData.lyRunTime = Date.now();
        loadScrollYData();
      }
      internalData.lyTimeout = setTimeout(() => {
        internalData.lyTimeout = void 0;
        internalData.lyRunTime = void 0;
        loadScrollYData();
      }, fpsTime);
    };
    const checkLastSyncScroll = (isRollX, isRollY) => {
      const { scrollXLoad, scrollYLoad } = reactData;
      const { lcsTimeout } = internalData;
      if (lcsTimeout) {
        clearTimeout(lcsTimeout);
      }
      internalData.lcsTimeout = setTimeout(() => {
        internalData.lcsRunTime = Date.now();
        internalData.lcsTimeout = void 0;
        internalData.intoRunScroll = false;
        internalData.inVirtualScroll = false;
        internalData.inWheelScroll = false;
        internalData.inHeaderScroll = false;
        internalData.inBodyScroll = false;
        internalData.inFooterScroll = false;
        internalData.scrollRenderType = "";
        calcCellHeight();
        if (isRollX && scrollXLoad) {
          $xeTable.updateScrollXData();
        }
        if (isRollY && scrollYLoad) {
          $xeTable.updateScrollYData().then(() => {
            calcCellHeight();
            $xeTable.updateScrollYSpace();
          });
        }
        updateRowExpandStyle();
        $xeTable.updateCellAreas();
      }, 200);
    };
    const getWheelSpeed = (lastScrollTime) => {
      let multiple = 1;
      const currTime = Date.now();
      if (lastScrollTime + 25 > currTime) {
        multiple = 1.18;
      } else if (lastScrollTime + 30 > currTime) {
        multiple = 1.15;
      } else if (lastScrollTime + 40 > currTime) {
        multiple = 1.12;
      } else if (lastScrollTime + 55 > currTime) {
        multiple = 1.09;
      } else if (lastScrollTime + 75 > currTime) {
        multiple = 1.06;
      } else if (lastScrollTime + 100 > currTime) {
        multiple = 1.03;
      }
      return multiple;
    };
    const wheelScrollLeftTo = (scrollLeft, cb) => {
      requestAnimationFrame(() => {
        cb(scrollLeft);
      });
    };
    const wheelScrollTopTo = (diffNum, cb) => {
      const duration = Math.abs(diffNum);
      const startTime = performance.now();
      let countTop = 0;
      const step = (timestamp) => {
        let progress = (timestamp - startTime) / duration;
        if (progress > 1) {
          progress = 1;
        }
        const easedProgress = Math.pow(progress, 2);
        const offsetTop = Math.floor(diffNum * easedProgress) - countTop;
        countTop += offsetTop;
        cb(offsetTop);
        if (progress < 1) {
          requestAnimationFrame(step);
        }
      };
      requestAnimationFrame(step);
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $table: $xeTable, $grid: $xeGrid }, params));
    };
    const handleScrollToRowColumn = (fieldOrColumn, row) => {
      const { fullColumnIdData } = internalData;
      const column = handleFieldOrColumn($xeTable, fieldOrColumn);
      if (column && fullColumnIdData[column.id]) {
        return colToVisible($xeTable, column, row);
      }
      return nextTick();
    };
    const handleUpdateResize = () => {
      const el = refElem.value;
      if (el && el.clientWidth && el.clientHeight) {
        tableMethods.recalculate();
      }
    };
    const handleUpdateColResize = (evnt, params) => {
      $xeTable.analyColumnWidth();
      $xeTable.recalculate().then(() => {
        $xeTable.saveCustomStore("update:width");
        $xeTable.updateCellAreas();
        $xeTable.dispatchEvent("column-resizable-change", params, evnt);
        $xeTable.dispatchEvent("resizable-change", params, evnt);
        setTimeout(() => $xeTable.recalculate(true), 300);
      });
    };
    const handleUpdateRowResize = (evnt, params) => {
      reactData.resizeHeightFlag++;
      $xeTable.recalculate().then(() => {
        $xeTable.updateCellAreas();
        $xeTable.dispatchEvent("row-resizable-change", params, evnt);
        setTimeout(() => $xeTable.recalculate(true), 300);
      });
    };
    const updateColumnOffsetLeft = () => {
      const { visibleColumn, fullColumnIdData } = internalData;
      let offsetLeft = 0;
      for (let cIndex = 0, rLen = visibleColumn.length; cIndex < rLen; cIndex++) {
        const column = visibleColumn[cIndex];
        const colid = column.id;
        const colRest = fullColumnIdData[colid];
        colRest.oLeft = offsetLeft;
        offsetLeft += column.renderWidth;
      }
    };
    const updateRowOffsetTop = () => {
      const { expandColumn } = reactData;
      const { afterFullData, fullAllDataRowIdData, rowExpandedMaps } = internalData;
      const expandOpts = computeExpandOpts.value;
      const rowOpts = computeRowOpts.value;
      const cellOpts = computeCellOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const { handleGetRowId } = createHandleGetRowId($xeTable);
      let offsetTop = 0;
      for (let rIndex = 0, rLen = afterFullData.length; rIndex < rLen; rIndex++) {
        const row = afterFullData[rIndex];
        const rowid = handleGetRowId(row);
        const rowRest = fullAllDataRowIdData[rowid] || {};
        rowRest.oTop = offsetTop;
        offsetTop += rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
        if (expandColumn && rowExpandedMaps[rowid]) {
          offsetTop += rowRest.expandHeight || expandOpts.height || 0;
        }
      }
    };
    const updateRowExpandStyle = () => {
      const { expandColumn, scrollYLoad, scrollYTop, isScrollYBig } = reactData;
      const expandOpts = computeExpandOpts.value;
      const rowOpts = computeRowOpts.value;
      const cellOpts = computeCellOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const { mode } = expandOpts;
      if (expandColumn && mode === "fixed") {
        const { elemStore, fullAllDataRowIdData } = internalData;
        const rowExpandEl = refRowExpandElem.value;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        if (rowExpandEl && bodyScrollElem) {
          let isUpdateHeight = false;
          import_xe_utils8.default.arrayEach(rowExpandEl.children, (reEl) => {
            const expandEl = reEl;
            const rowid = expandEl.getAttribute("rowid") || "";
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              const expandHeight = expandEl.offsetHeight + 1;
              const trEl = bodyScrollElem.querySelector(`.vxe-body--row[rowid="${rowid}"]`);
              let offsetTop = 0;
              if (scrollYLoad) {
                if (isScrollYBig && trEl) {
                  offsetTop = trEl.offsetTop + trEl.offsetHeight;
                } else {
                  offsetTop = rowRest.oTop + (rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight);
                }
              } else {
                if (trEl) {
                  offsetTop = trEl.offsetTop + trEl.offsetHeight;
                }
              }
              if (isScrollYBig) {
                offsetTop += scrollYTop;
              }
              expandEl.style.top = toCssUnit(offsetTop);
              if (!isUpdateHeight) {
                if (rowRest.expandHeight !== expandHeight) {
                  isUpdateHeight = true;
                }
              }
              rowRest.expandHeight = expandHeight;
            }
          });
          if (isUpdateHeight) {
            reactData.rowExpandHeightFlag++;
            nextTick(() => {
              updateRowOffsetTop();
            });
          }
        }
      }
    };
    const handleRowExpandScroll = () => {
      const { elemStore } = internalData;
      const rowExpandEl = refRowExpandElem.value;
      const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
      if (rowExpandEl && bodyScrollElem) {
        rowExpandEl.scrollTop = bodyScrollElem.scrollTop;
      }
    };
    tableMethods = {
      dispatchEvent,
      getEl() {
        return refElem.value;
      },
      /**
       * 重置表格的一切数据状态
       */
      clearAll() {
        return clearTableAllStatus($xeTable);
      },
      /**
       * 同步 data 数据（即将废弃）
       * 如果用了该方法，那么组件将不再记录增删改的状态，只能自行实现对应逻辑
       * 对于某些特殊的场景，比如深层树节点元素发生变动时可能会用到
       */
      syncData() {
        warnLog("vxe.error.delFunc", ["syncData", "getData"]);
        return nextTick().then(() => {
          reactData.tableData = [];
          emit("update:data", internalData.tableFullData);
          return nextTick();
        });
      },
      /**
       * 手动处理数据，用于手动排序与筛选
       * 对于手动更改了排序、筛选...等条件后需要重新处理数据时可能会用到
       */
      updateData() {
        const { scrollXLoad, scrollYLoad } = reactData;
        return tablePrivateMethods.handleTableData(true).then(() => {
          tableMethods.updateFooter();
          if (scrollXLoad || scrollYLoad) {
            if (scrollXLoad) {
              tablePrivateMethods.updateScrollXSpace();
            }
            if (scrollYLoad) {
              tablePrivateMethods.updateScrollYSpace();
            }
            return tableMethods.refreshScroll();
          }
        }).then(() => {
          tableMethods.updateCellAreas();
          return tableMethods.recalculate(true);
        }).then(() => {
          setTimeout(() => $xeTable.recalculate(), 50);
        });
      },
      /**
       * 重新加载数据，不会清空表格状态
       * @param {Array} datas 数据
       */
      loadData(datas) {
        const { initStatus } = internalData;
        return loadTableData(datas, false).then(() => {
          internalData.inited = true;
          internalData.initStatus = true;
          if (!initStatus) {
            handleLoadDefaults();
          }
          return tableMethods.recalculate();
        });
      },
      /**
       * 重新加载数据，会清空表格状态
       * @param {Array} datas 数据
       */
      reloadData(datas) {
        return tableMethods.clearAll().then(() => {
          internalData.inited = true;
          internalData.initStatus = true;
          return loadTableData(datas, true);
        }).then(() => {
          handleLoadDefaults();
          return tableMethods.recalculate();
        });
      },
      /**
       * 修改行数据
       */
      setRow(rows, record) {
        if (rows && record) {
          let rest = rows;
          if (!import_xe_utils8.default.isArray(rows)) {
            rest = [rows];
          }
          const rowkey = getRowkey($xeTable);
          rest.forEach((row) => {
            const rowid = getRowid($xeTable, row);
            const newRecord = import_xe_utils8.default.clone(Object.assign({}, record), true);
            import_xe_utils8.default.set(newRecord, rowkey, rowid);
            Object.assign(row, newRecord);
          });
        }
        return nextTick();
      },
      /**
       * 局部加载行数据并恢复到初始状态
       * 对于行数据需要局部更改的场景中可能会用到
       * @param {Row} row 行对象
       * @param {Object} record 新数据
       * @param {String} field 字段名
       */
      reloadRow(row, record, field) {
        const { keepSource } = props;
        const { tableData } = reactData;
        const { tableSourceData } = internalData;
        if (keepSource) {
          const rowIndex = tableMethods.getRowIndex(row);
          const oRow = tableSourceData[rowIndex];
          if (oRow && row) {
            if (field) {
              const newValue = import_xe_utils8.default.clone(import_xe_utils8.default.get(record || row, field), true);
              import_xe_utils8.default.set(row, field, newValue);
              import_xe_utils8.default.set(oRow, field, newValue);
            } else {
              const rowkey = getRowkey($xeTable);
              const rowid = getRowid($xeTable, row);
              const newRecord = import_xe_utils8.default.clone(Object.assign({}, record), true);
              import_xe_utils8.default.set(newRecord, rowkey, rowid);
              import_xe_utils8.default.destructuring(oRow, Object.assign(row, newRecord));
            }
          }
          reactData.tableData = tableData.slice(0);
        } else {
          if (true) {
            warnLog("vxe.error.reqProp", ["keep-source"]);
          }
        }
        return nextTick();
      },
      getParams() {
        return props.params;
      },
      /**
       * 用于树结构，给行数据加载子节点
       */
      loadTreeChildren(row, childRecords) {
        const { keepSource } = props;
        const { tableSourceData, fullDataRowIdData, fullAllDataRowIdData, sourceDataRowIdData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const parentRest = fullAllDataRowIdData[getRowid($xeTable, row)];
        const parentLevel = parentRest ? parentRest.level : 0;
        return tableMethods.createData(childRecords).then((rows) => {
          if (keepSource) {
            const rowid = getRowid($xeTable, row);
            const matchObj = import_xe_utils8.default.findTree(tableSourceData, (item) => rowid === getRowid($xeTable, item), { children: childrenField });
            if (matchObj) {
              matchObj.item[childrenField] = import_xe_utils8.default.clone(rows, true);
            }
            rows.forEach((childRow) => {
              const rowid2 = getRowid($xeTable, childRow);
              sourceDataRowIdData[rowid2] = import_xe_utils8.default.clone(childRow, true);
            });
          }
          import_xe_utils8.default.eachTree(rows, (childRow, index, items, path, parentItem, nodes) => {
            const rowid = getRowid($xeTable, childRow);
            const parentRow = parentItem || parentRest.row;
            const rest = { row: childRow, rowid, seq: -1, index, _index: -1, $index: -1, treeIndex: -1, items, parent: parentRow, level: parentLevel + nodes.length, height: 0, resizeHeight: 0, oTop: 0, expandHeight: 0 };
            fullDataRowIdData[rowid] = rest;
            fullAllDataRowIdData[rowid] = rest;
          }, { children: childrenField });
          row[childrenField] = rows;
          if (transform) {
            row[mapChildrenField] = import_xe_utils8.default.clone(rows, false);
          }
          updateAfterDataIndex();
          return rows;
        });
      },
      /**
       * 加载列配置
       * 对于表格列需要重载、局部递增场景下可能会用到
       * @param {ColumnInfo} columns 列配置
       */
      loadColumn(columns) {
        const collectColumn = import_xe_utils8.default.mapTree(columns, (column) => reactive(cell_default.createColumn($xeTable, column)));
        return handleColumn(collectColumn);
      },
      /**
       * 加载列配置并恢复到初始状态
       * 对于表格列需要重载、局部递增场景下可能会用到
       * @param {ColumnInfo} columns 列配置
       */
      reloadColumn(columns) {
        return tableMethods.clearAll().then(() => {
          return tableMethods.loadColumn(columns);
        });
      },
      /**
       * 根据 tr 元素获取对应的 row 信息
       * @param {Element} tr 元素
       */
      getRowNode(tr) {
        if (tr) {
          const { fullAllDataRowIdData } = internalData;
          const rowid = tr.getAttribute("rowid");
          if (rowid) {
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              return {
                rowid: rowRest.rowid,
                item: rowRest.row,
                index: rowRest.index,
                items: rowRest.items,
                parent: rowRest.parent
              };
            }
          }
        }
        return null;
      },
      /**
       * 根据 th/td 元素获取对应的 column 信息
       * @param {Element} cell 元素
       */
      getColumnNode(cell) {
        if (cell) {
          const { fullColumnIdData } = internalData;
          const colid = cell.getAttribute("colid");
          if (colid) {
            const colRest = fullColumnIdData[colid];
            if (colRest) {
              return {
                colid: colRest.colid,
                item: colRest.column,
                index: colRest.index,
                items: colRest.items,
                parent: colRest.parent
              };
            }
          }
        }
        return null;
      },
      /**
       * 根据 row 获取序号
       * @param {Row} row 行对象
       */
      getRowSeq: createGetRowCacheProp("seq"),
      /**
       * 根据 row 获取相对于 data 中的索引
       * @param {Row} row 行对象
       */
      getRowIndex: createGetRowCacheProp("index"),
      /**
       * 根据 row 获取相对于当前数据中的索引
       * @param {Row} row 行对象
       */
      getVTRowIndex: createGetRowCacheProp("_index"),
      /**
       * 根据 row 获取渲染中的虚拟索引
       * @param {Row} row 行对象
       */
      getVMRowIndex: createGetRowCacheProp("$index"),
      /**
       * 根据 column 获取相对于 columns 中的索引
       * @param {ColumnInfo} column 列配置
       */
      getColumnIndex: createGetColumnCacheProp("index"),
      /**
       * 根据 column 获取相对于当前表格列中的索引
       * @param {ColumnInfo} column 列配置
       */
      getVTColumnIndex: createGetColumnCacheProp("_index"),
      /**
       * 根据 column 获取渲染中的虚拟索引
       * @param {ColumnInfo} column 列配置
       */
      getVMColumnIndex: createGetColumnCacheProp("$index"),
      /**
       * 创建 data 对象
       * 对于某些特殊场景可能会用到，会自动对数据的字段名进行检测，如果不存在就自动定义
       * @param {Array} records 新数据
       */
      createData(records) {
        return nextTick().then(() => {
          return reactive(tablePrivateMethods.defineField(records));
        });
      },
      /**
       * 创建 Row|Rows 对象
       * 对于某些特殊场景需要对数据进行手动插入时可能会用到
       * @param {Array/Object} records 新数据
       */
      createRow(records) {
        const isArr = import_xe_utils8.default.isArray(records);
        if (!isArr) {
          records = [records || {}];
        }
        return tableMethods.createData(records).then((rows) => isArr ? rows : rows[0]);
      },
      /**
       * 还原数据
       * 如果不传任何参数，则还原整个表格
       * 如果传 row 则还原一行
       * 如果传 rows 则还原多行
       * 如果还额外传了 field 则还原指定的单元格数据
       */
      revertData(rows, field) {
        const { keepSource, treeConfig } = props;
        const { fullAllDataRowIdData, fullDataRowIdData, tableSourceData, sourceDataRowIdData, tableFullData, afterFullData, removeRowMaps } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform } = treeOpts;
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        if (!keepSource) {
          if (true) {
            errLog("vxe.error.reqProp", ["keep-source"]);
          }
          return nextTick();
        }
        let targetRows = rows;
        if (rows) {
          if (!import_xe_utils8.default.isArray(rows)) {
            targetRows = [rows];
          }
        } else {
          targetRows = import_xe_utils8.default.toArray($xeTable.getUpdateRecords());
        }
        let reDelFlag = false;
        if (targetRows.length) {
          targetRows.forEach((item) => {
            const rowid = handleGetRowId(item);
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              const row = rowRest.row;
              if (!$xeTable.isInsertByRow(row)) {
                const oRow = sourceDataRowIdData[rowid];
                if (oRow && row) {
                  if (field) {
                    import_xe_utils8.default.set(row, field, import_xe_utils8.default.clone(import_xe_utils8.default.get(oRow, field), true));
                  } else {
                    import_xe_utils8.default.destructuring(row, import_xe_utils8.default.clone(oRow, true));
                  }
                  if (!fullDataRowIdData[rowid] && $xeTable.isRemoveByRow(row)) {
                    if (removeRowMaps[rowid]) {
                      delete removeRowMaps[rowid];
                    }
                    tableFullData.unshift(row);
                    afterFullData.unshift(row);
                    reDelFlag = true;
                  }
                }
              }
            }
          });
        }
        if (rows) {
          if (reDelFlag) {
            reactData.removeRowFlag++;
            $xeTable.updateFooter();
            $xeTable.cacheRowMap(false);
            $xeTable.handleTableData(treeConfig && transform);
            if (!(treeConfig && transform)) {
              $xeTable.updateAfterDataIndex();
            }
            $xeTable.checkSelectionStatus();
            if (reactData.scrollYLoad) {
              $xeTable.updateScrollYSpace();
            }
          }
          return nextTick().then(() => {
            $xeTable.updateCellAreas();
            return $xeTable.recalculate();
          });
        }
        return $xeTable.reloadData(tableSourceData);
      },
      /**
       * 清空单元格内容
       * 如果不创参数，则清空整个表格内容
       * 如果传 row 则清空一行内容
       * 如果传 rows 则清空多行内容
       * 如果还额外传了 field 则清空指定单元格内容
       * @param {Array/Row} rows 行数据
       * @param {String} field 字段名
       */
      clearData(rows, field) {
        const { tableFullData, visibleColumn } = internalData;
        if (!arguments.length) {
          rows = tableFullData;
        } else if (rows && !import_xe_utils8.default.isArray(rows)) {
          rows = [rows];
        }
        if (field) {
          rows.forEach((row) => import_xe_utils8.default.set(row, field, null));
        } else {
          rows.forEach((row) => {
            visibleColumn.forEach((column) => {
              if (column.field) {
                setCellValue(row, column, null);
              }
            });
          });
        }
        return nextTick();
      },
      getCellElement(row, fieldOrColumn) {
        const { elemStore } = internalData;
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (!column) {
          return null;
        }
        const rowid = getRowid($xeTable, row);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
        const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
        let bodyElem;
        if (column) {
          if (column.fixed) {
            if (column.fixed === "left") {
              if (leftScrollElem) {
                bodyElem = leftScrollElem;
              }
            } else {
              if (rightScrollElem) {
                bodyElem = rightScrollElem;
              }
            }
          }
          if (!bodyElem) {
            bodyElem = bodyScrollElem;
          }
          if (bodyElem) {
            return bodyElem.querySelector(`.vxe-body--row[rowid="${rowid}"] .${column.id}`);
          }
        }
        return null;
      },
      getCellLabel(row, fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (!column) {
          return null;
        }
        const formatter = column.formatter;
        const cellValue = getCellValue(row, column);
        let cellLabel = cellValue;
        if (formatter) {
          let formatData;
          const { fullAllDataRowIdData } = internalData;
          const rowid = getRowid($xeTable, row);
          const colid = column.id;
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            formatData = rowRest.formatData;
            if (!formatData) {
              formatData = fullAllDataRowIdData[rowid].formatData = {};
            }
            if (rowRest && formatData[colid]) {
              if (formatData[colid].value === cellValue) {
                return formatData[colid].label;
              }
            }
          }
          const formatParams = { cellValue, row, rowIndex: tableMethods.getRowIndex(row), column, columnIndex: tableMethods.getColumnIndex(column) };
          if (import_xe_utils8.default.isString(formatter)) {
            const gFormatOpts = formats.get(formatter);
            const tcFormatMethod = gFormatOpts ? gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod : null;
            cellLabel = tcFormatMethod ? tcFormatMethod(formatParams) : "";
          } else if (import_xe_utils8.default.isArray(formatter)) {
            const gFormatOpts = formats.get(formatter[0]);
            const tcFormatMethod = gFormatOpts ? gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod : null;
            cellLabel = tcFormatMethod ? tcFormatMethod(formatParams, ...formatter.slice(1)) : "";
          } else {
            cellLabel = formatter(formatParams);
          }
          if (formatData) {
            formatData[colid] = { value: cellValue, label: cellLabel };
          }
        }
        return cellLabel;
      },
      /**
       * 检查是否为临时行数据
       * @param {Row} row 行对象
       */
      isInsertByRow(row) {
        const rowid = getRowid($xeTable, row);
        return !!reactData.insertRowFlag && !!internalData.insertRowMaps[rowid];
      },
      isRemoveByRow(row) {
        const rowid = getRowid($xeTable, row);
        return !!reactData.removeRowFlag && !!internalData.removeRowMaps[rowid];
      },
      /**
       * 删除所有新增的临时数据
       * @returns
       */
      removeInsertRow() {
        internalData.insertRowMaps = {};
        return $xeTable.remove($xeTable.getInsertRecords());
      },
      /**
       * 检查行或列数据是否发生改变
       * @param {Row} rowidOrRow 行对象、行主键
       * @param {String} field 字段名
       */
      isUpdateByRow(rowidOrRow, field) {
        const { keepSource } = props;
        const { tableFullColumn, fullDataRowIdData, sourceDataRowIdData } = internalData;
        if (keepSource) {
          const rowid = import_xe_utils8.default.isString(rowidOrRow) || import_xe_utils8.default.isNumber(rowidOrRow) ? rowidOrRow : getRowid($xeTable, rowidOrRow);
          const rowRest = fullDataRowIdData[rowid];
          if (!rowRest) {
            return false;
          }
          const row = rowRest.row;
          const oRow = sourceDataRowIdData[rowid];
          if (oRow) {
            if (arguments.length > 1) {
              return !eqCellValue(oRow, row, field);
            }
            for (let index = 0, len = tableFullColumn.length; index < len; index++) {
              const property = tableFullColumn[index].field;
              if (property && !eqCellValue(oRow, row, property)) {
                return true;
              }
            }
          }
        }
        return false;
      },
      /**
       * 获取表格的可视列，也可以指定索引获取列
       * @param {Number} columnIndex 索引
       */
      getColumns(columnIndex) {
        const { visibleColumn } = internalData;
        return import_xe_utils8.default.isUndefined(columnIndex) ? visibleColumn.slice(0) : visibleColumn[columnIndex];
      },
      /**
       * 根据列获取列的唯一主键
       */
      getColid(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        return column ? column.id : null;
      },
      /**
       * 根据列的唯一主键获取列
       * @param {String} colid 列主键
       */
      getColumnById(colid) {
        const { fullColumnIdData } = internalData;
        return colid && fullColumnIdData[colid] ? fullColumnIdData[colid].column : null;
      },
      /**
       * 根据列的字段名获取列
       * @param {String} field 字段名
       */
      getColumnByField(field) {
        const fullColumnFieldData = internalData.fullColumnFieldData;
        return field && fullColumnFieldData[field] ? fullColumnFieldData[field].column : null;
      },
      getParentColumn(fieldOrColumn) {
        const { fullColumnIdData } = internalData;
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        return column && column.parentId && fullColumnIdData[column.parentId] ? fullColumnIdData[column.parentId].column : null;
      },
      /**
       * 获取当前表格的列
       * 收集到的全量列、全量表头列、处理条件之后的全量表头列、当前渲染中的表头列
       */
      getTableColumn() {
        return {
          collectColumn: internalData.collectColumn.slice(0),
          fullColumn: internalData.tableFullColumn.slice(0),
          visibleColumn: internalData.visibleColumn.slice(0),
          tableColumn: reactData.tableColumn.slice(0)
        };
      },
      /**
       * 移动列到指定列的位置
       * @param fieldOrColumn
       * @param targetFieldOrColumn
       * @param options
       */
      moveColumnTo(fieldOrColumn, targetFieldOrColumn, options) {
        const { fullColumnIdData, visibleColumn } = internalData;
        const { dragToChild, dragPos, isCrossDrag } = Object.assign({}, options);
        const dragCol = handleFieldOrColumn($xeTable, fieldOrColumn);
        let prevDragCol = null;
        const colRest = dragCol ? fullColumnIdData[dragCol.id] : null;
        let defPos = "left";
        if (import_xe_utils8.default.isNumber(targetFieldOrColumn)) {
          if (colRest && targetFieldOrColumn) {
            let currList = colRest.items;
            let offsetIndex = colRest._index + targetFieldOrColumn;
            if (isCrossDrag) {
              currList = visibleColumn;
              offsetIndex = colRest._index + targetFieldOrColumn;
            }
            if (offsetIndex > 0 && offsetIndex < currList.length - 1) {
              prevDragCol = currList[offsetIndex];
            }
            if (targetFieldOrColumn > 0) {
              defPos = "right";
            }
          }
        } else {
          prevDragCol = handleFieldOrColumn($xeTable, targetFieldOrColumn);
          const targetColRest = prevDragCol ? fullColumnIdData[prevDragCol.id] : null;
          if (colRest && targetColRest) {
            if (targetColRest._index > colRest._index) {
              defPos = "right";
            }
          }
        }
        return $xeTable.handleColDragSwapEvent(null, true, dragCol, prevDragCol, dragPos || defPos, dragToChild === true);
      },
      /**
       * 移动行到指定行的位置
       * @param rowidOrRow
       * @param targetRowidOrRow
       * @param options
       */
      moveRowTo(rowidOrRow, targetRowidOrRow, options) {
        const { treeConfig } = props;
        const { fullAllDataRowIdData, afterFullData } = internalData;
        const { dragToChild, dragPos, isCrossDrag } = Object.assign({}, options);
        const treeOpts = computeTreeOpts.value;
        const dragRow = handleRowidOrRow($xeTable, rowidOrRow);
        let prevDragRow = null;
        let defPos = "top";
        const rowRest = dragRow ? fullAllDataRowIdData[getRowid($xeTable, dragRow)] : null;
        if (import_xe_utils8.default.isNumber(targetRowidOrRow)) {
          if (rowRest && targetRowidOrRow) {
            let currList = afterFullData;
            let offsetIndex = rowRest._index + targetRowidOrRow;
            if (treeConfig) {
              currList = rowRest.items;
              if (treeOpts.transform) {
                offsetIndex = rowRest.treeIndex + targetRowidOrRow;
                if (isCrossDrag) {
                  currList = afterFullData;
                  offsetIndex = rowRest._index + targetRowidOrRow;
                }
              }
            }
            if (offsetIndex >= 0 && offsetIndex <= currList.length - 1) {
              prevDragRow = currList[offsetIndex];
            }
            if (targetRowidOrRow > 0) {
              defPos = "bottom";
            }
          }
        } else {
          prevDragRow = handleRowidOrRow($xeTable, targetRowidOrRow);
          const targetRowRest = prevDragRow ? fullAllDataRowIdData[getRowid($xeTable, prevDragRow)] : null;
          if (rowRest && targetRowRest) {
            if (targetRowRest._index > rowRest._index) {
              defPos = "bottom";
            }
          }
        }
        return $xeTable.handleRowDragSwapEvent(null, true, dragRow, prevDragRow, dragPos || defPos, dragToChild === true);
      },
      /**
       * 获取表格的全量列
       */
      getFullColumns() {
        const { collectColumn } = internalData;
        return collectColumn.slice(0);
      },
      /**
       * 获取数据，和 data 的行为一致，也可以指定索引获取数据
       */
      getData(rowIndex) {
        const tableSynchData = props.data || internalData.tableSynchData;
        return import_xe_utils8.default.isUndefined(rowIndex) ? tableSynchData.slice(0) : tableSynchData[rowIndex];
      },
      /**
       * 用于多选行，获取已选中的数据
       */
      getCheckboxRecords(isFull) {
        const { treeConfig } = props;
        const { tableFullData, afterFullData, afterTreeFullData, tableFullTreeData, fullDataRowIdData, afterFullRowMaps, selectCheckboxMaps } = internalData;
        const treeOpts = computeTreeOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const { transform, mapChildrenField } = treeOpts;
        const { checkField } = checkboxOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let rowList = [];
        if (checkField) {
          if (treeConfig) {
            const currTableData = isFull ? transform ? tableFullTreeData : tableFullData : transform ? afterTreeFullData : afterFullData;
            rowList = import_xe_utils8.default.filterTree(currTableData, (row) => import_xe_utils8.default.get(row, checkField), { children: transform ? mapChildrenField : childrenField });
          } else {
            const currTableData = isFull ? tableFullData : afterFullData;
            rowList = currTableData.filter((row) => import_xe_utils8.default.get(row, checkField));
          }
        } else {
          import_xe_utils8.default.each(selectCheckboxMaps, (row, rowid) => {
            if (isFull) {
              if (fullDataRowIdData[rowid]) {
                rowList.push(fullDataRowIdData[rowid].row);
              }
            } else {
              if (afterFullRowMaps[rowid]) {
                rowList.push(afterFullRowMaps[rowid]);
              }
            }
          });
        }
        return rowList;
      },
      /**
       * 只对 tree-config 有效，获取行的子级
       */
      getTreeRowChildren(rowOrRowid) {
        const { treeConfig } = props;
        const { fullAllDataRowIdData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        if (rowOrRowid && treeConfig) {
          let rowid;
          if (import_xe_utils8.default.isString(rowOrRowid)) {
            rowid = rowOrRowid;
          } else {
            rowid = getRowid($xeTable, rowOrRowid);
          }
          if (rowid) {
            const rest = fullAllDataRowIdData[rowid];
            const row = rest ? rest.row : null;
            if (row) {
              return row[transform ? mapChildrenField : childrenField] || [];
            }
          }
        }
        return [];
      },
      /**
       * 只对 tree-config 有效，获取行的父级
       */
      getTreeParentRow(rowOrRowid) {
        const { treeConfig } = props;
        const { fullAllDataRowIdData } = internalData;
        if (rowOrRowid && treeConfig) {
          let rowid;
          if (import_xe_utils8.default.isString(rowOrRowid)) {
            rowid = rowOrRowid;
          } else {
            rowid = getRowid($xeTable, rowOrRowid);
          }
          if (rowid) {
            const rest = fullAllDataRowIdData[rowid];
            return rest ? rest.parent : null;
          }
        }
        return null;
      },
      getParentRow(rowOrRowid) {
        warnLog("vxe.error.delFunc", ["getParentRow", "getTreeParentRow"]);
        return $xeTable.getTreeParentRow(rowOrRowid);
      },
      /**
       * 根据行的唯一主键获取行
       * @param {String/Number} rowid 行主键
       */
      getRowById(cellValue) {
        const { fullAllDataRowIdData } = internalData;
        const rowid = import_xe_utils8.default.eqNull(cellValue) ? "" : encodeURIComponent(cellValue || "");
        return fullAllDataRowIdData[rowid] ? fullAllDataRowIdData[rowid].row : null;
      },
      /**
       * 根据行获取行的唯一主键
       * @param {Row} row 行对象
       */
      getRowid(row) {
        return getRowid($xeTable, row);
      },
      /**
       * 获取处理后的表格数据
       * 如果存在筛选条件，继续处理
       * 如果存在排序，继续处理
       */
      getTableData() {
        const { tableData, footerTableData } = reactData;
        const { tableFullData, afterFullData, tableFullTreeData } = internalData;
        return {
          fullData: props.treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0),
          visibleData: afterFullData.slice(0),
          tableData: tableData.slice(0),
          footerData: footerTableData.slice(0)
        };
      },
      /**
       * 获取表格的全量数据，如果是 tree-config 则返回带层级的树结构
       */
      getFullData() {
        const { treeConfig } = props;
        const { tableFullData, tableFullTreeData } = internalData;
        if (treeConfig) {
          const treeOpts = computeTreeOpts.value;
          const { transform, mapChildrenField, rowField, parentField } = treeOpts;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          if (transform) {
            return import_xe_utils8.default.toArrayTree(import_xe_utils8.default.toTreeArray(tableFullTreeData, {
              children: mapChildrenField
            }), {
              key: rowField,
              parentKey: parentField,
              children: childrenField,
              mapChildren: mapChildrenField
            });
          }
          return tableFullTreeData.slice(0);
        }
        return tableFullData.slice(0);
      },
      /**
       * 设置为固定列
       */
      setColumnFixed(fieldOrColumn, fixed) {
        let status = false;
        const cols = import_xe_utils8.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        const columnOpts = computeColumnOpts.value;
        const isMaxFixedColumn = computeIsMaxFixedColumn.value;
        for (let i = 0; i < cols.length; i++) {
          const item = cols[i];
          const column = handleFieldOrColumn($xeTable, item);
          const targetColumn = getRootColumn($xeTable, column);
          if (targetColumn && targetColumn.fixed !== fixed) {
            if (!targetColumn.fixed && isMaxFixedColumn) {
              if (VxeUI.modal) {
                VxeUI.modal.message({
                  status: "error",
                  content: getI18n6("vxe.table.maxFixedCol", [columnOpts.maxFixedSize])
                });
              }
              return nextTick();
            }
            import_xe_utils8.default.eachTree([targetColumn], (column2) => {
              column2.fixed = fixed;
            });
            tablePrivateMethods.saveCustomStore("update:fixed");
            if (!status) {
              status = true;
            }
          }
        }
        if (status) {
          return tableMethods.refreshColumn();
        }
        return nextTick();
      },
      /**
       * 取消指定固定列
       */
      clearColumnFixed(fieldOrColumn) {
        let status = false;
        const cols = import_xe_utils8.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        cols.forEach((item) => {
          const column = handleFieldOrColumn($xeTable, item);
          const targetColumn = getRootColumn($xeTable, column);
          if (targetColumn && targetColumn.fixed) {
            import_xe_utils8.default.eachTree([targetColumn], (column2) => {
              column2.fixed = null;
            });
            tablePrivateMethods.saveCustomStore("update:fixed");
            if (!status) {
              status = true;
            }
          }
        });
        if (status) {
          return tableMethods.refreshColumn();
        }
        return nextTick();
      },
      /**
       * 隐藏指定列
       */
      hideColumn(fieldOrColumn) {
        let status = false;
        const cols = import_xe_utils8.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        cols.forEach((item) => {
          const column = handleFieldOrColumn($xeTable, item);
          if (column && column.visible) {
            column.visible = false;
            if (!status) {
              status = true;
            }
          }
        });
        if (status) {
          return tablePrivateMethods.handleCustom();
        }
        return nextTick();
      },
      /**
       * 显示指定列
       */
      showColumn(fieldOrColumn) {
        let status = false;
        const cols = import_xe_utils8.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        cols.forEach((item) => {
          const column = handleFieldOrColumn($xeTable, item);
          if (column && !column.visible) {
            column.visible = true;
            if (!status) {
              status = true;
            }
          }
        });
        if (status) {
          return tablePrivateMethods.handleCustom();
        }
        return nextTick();
      },
      setColumnWidth(fieldOrColumn, width) {
        const { elemStore } = internalData;
        let status = false;
        const cols = import_xe_utils8.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        let cWidth = import_xe_utils8.default.toInteger(width);
        if (isScale(width)) {
          const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
          const bodyWidth = bodyScrollElem ? bodyScrollElem.clientWidth - 1 : 0;
          cWidth = Math.floor(cWidth * bodyWidth);
        }
        if (cWidth) {
          cols.forEach((item) => {
            const column = handleFieldOrColumn($xeTable, item);
            if (column) {
              column.resizeWidth = cWidth;
              if (!status) {
                status = true;
              }
            }
          });
          if (status) {
            return $xeTable.refreshColumn().then(() => {
              return { status };
            });
          }
        }
        return nextTick().then(() => {
          return { status };
        });
      },
      getColumnWidth(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column) {
          return column.renderWidth;
        }
        return 0;
      },
      /**
       * 手动重置列的显示隐藏、列宽拖动的状态、固定列、排序列；
       * 如果为 true 则重置所有状态
       * 如果已关联工具栏，则会同步更新
       */
      resetColumn(options) {
        warnLog("vxe.error.delFunc", ["resetColumn", "resetCustom"]);
        return $xeTable.resetCustom(options);
      },
      /**
       * 刷新列信息
       * 将固定的列左边、右边分别靠边
       * 如果传 true 则会检查列顺序并排序
       */
      refreshColumn(initSort) {
        if (initSort) {
          handleUpdateColumn();
        }
        return parseColumns(true).then(() => {
          return tableMethods.refreshScroll();
        }).then(() => {
          return tableMethods.recalculate();
        });
      },
      setRowHeightConf(heightConf) {
        const { fullAllDataRowIdData } = internalData;
        let status = false;
        if (heightConf) {
          import_xe_utils8.default.each(heightConf, (height, rowid) => {
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              const rHeight = import_xe_utils8.default.toInteger(height);
              if (rHeight) {
                rowRest.resizeHeight = rHeight;
                if (!status) {
                  status = true;
                }
              }
            }
          });
          if (status) {
            internalData.isResizeCellHeight = true;
            reactData.resizeHeightFlag++;
          }
        }
        return nextTick().then(() => {
          updateRowOffsetTop();
          return { status };
        });
      },
      getRowHeightConf(isFull) {
        const { fullAllDataRowIdData, afterFullData } = internalData;
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        const rowOpts = computeRowOpts.value;
        const cellOpts = computeCellOpts.value;
        const defaultRowHeight = computeDefaultRowHeight.value;
        const rest = {};
        afterFullData.forEach((row) => {
          const rowid = handleGetRowId(row);
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            const resizeHeight = rowRest.resizeHeight;
            if (resizeHeight || isFull) {
              const currCellHeight = resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
              rest[rowid] = currCellHeight;
            }
          }
        });
        return rest;
      },
      setRowHeight(rowOrId, height) {
        const { fullAllDataRowIdData } = internalData;
        let status = false;
        const rows = import_xe_utils8.default.isArray(rowOrId) ? rowOrId : [rowOrId];
        let rHeight = import_xe_utils8.default.toInteger(height);
        if (isScale(height)) {
          const tableBody = refTableBody.value;
          const bodyElem = tableBody ? tableBody.$el : null;
          const bodyHeight = bodyElem ? bodyElem.clientHeight - 1 : 0;
          rHeight = Math.floor(rHeight * bodyHeight);
        }
        if (rHeight) {
          const { handleGetRowId } = createHandleGetRowId($xeTable);
          rows.forEach((row) => {
            const rowid = import_xe_utils8.default.isString(row) || import_xe_utils8.default.isNumber(row) ? row : handleGetRowId(row);
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              rowRest.resizeHeight = rHeight;
              if (!status) {
                status = true;
              }
            }
          });
          if (status) {
            internalData.isResizeCellHeight = true;
            reactData.resizeHeightFlag++;
          }
        }
        return nextTick().then(() => {
          return { status };
        });
      },
      getRowHeight(rowOrId) {
        const { fullAllDataRowIdData } = internalData;
        const rowOpts = computeRowOpts.value;
        const cellOpts = computeCellOpts.value;
        const defaultRowHeight = computeDefaultRowHeight.value;
        const rowid = import_xe_utils8.default.isString(rowOrId) || import_xe_utils8.default.isNumber(rowOrId) ? rowOrId : getRowid($xeTable, rowOrId);
        const rowRest = fullAllDataRowIdData[rowid];
        if (rowRest) {
          return rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
        }
        return 0;
      },
      /**
       * 刷新滚动操作，手动同步滚动相关位置（对于某些特殊的操作，比如滚动条错位、固定列不同步）
       */
      refreshScroll() {
        const { elemStore, lastScrollLeft, lastScrollTop } = internalData;
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
        const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
        const xHandleEl = refScrollXHandleElem.value;
        const yHandleEl = refScrollYHandleElem.value;
        return new Promise((resolve) => {
          if (lastScrollLeft || lastScrollTop) {
            return restoreScrollLocation($xeTable, lastScrollLeft, lastScrollTop).then().then(() => {
              setTimeout(resolve, 10);
            });
          }
          internalData.intoRunScroll = true;
          setScrollTop(yHandleEl, lastScrollTop);
          setScrollTop(bodyScrollElem, lastScrollTop);
          setScrollTop(leftScrollElem, lastScrollTop);
          setScrollTop(rightScrollElem, lastScrollTop);
          setScrollLeft(xHandleEl, lastScrollLeft);
          setScrollLeft(bodyScrollElem, lastScrollLeft);
          setScrollLeft(headerScrollElem, lastScrollLeft);
          setScrollLeft(footerScrollElem, lastScrollLeft);
          setTimeout(() => {
            internalData.intoRunScroll = false;
            resolve();
          }, 10);
        });
      },
      /**
       * 重新渲染布局
       * 刷新布局
       */
      recalculate(reFull) {
        return new Promise((resolve) => {
          const { rceTimeout, rceRunTime } = internalData;
          const resizeOpts = computeResizeOpts.value;
          const refreshDelay = resizeOpts.refreshDelay || 20;
          const el = refElem.value;
          if (el && el.clientWidth) {
            autoCellWidth();
            updateRowExpandStyle();
          }
          if (rceTimeout) {
            clearTimeout(rceTimeout);
            if (rceRunTime && rceRunTime + (refreshDelay - 5) < Date.now()) {
              resolve(handleRecalculateLayout(!!reFull));
            } else {
              nextTick(() => {
                resolve();
              });
            }
          } else {
            resolve(handleRecalculateLayout(!!reFull));
          }
          internalData.rceTimeout = setTimeout(() => {
            internalData.rceTimeout = void 0;
            handleRecalculateLayout(!!reFull);
          }, refreshDelay);
        });
      },
      openTooltip(target, content) {
        const $commTip = refCommTooltip.value;
        if ($commTip && $commTip.open) {
          return $commTip.open(target, content);
        }
        return nextTick();
      },
      /**
       * 关闭 tooltip
       */
      closeTooltip() {
        const { tooltipStore } = reactData;
        const $tooltip = refTooltip.value;
        const $commTip = refCommTooltip.value;
        if (tooltipStore.visible) {
          Object.assign(tooltipStore, {
            row: null,
            column: null,
            content: null,
            visible: false,
            currOpts: {}
          });
          if ($tooltip && $tooltip.close) {
            $tooltip.close();
          }
        }
        if ($commTip && $commTip.close) {
          $commTip.close();
        }
        return nextTick();
      },
      /**
       * 判断列头复选框是否被选中
       */
      isAllCheckboxChecked() {
        return reactData.isAllSelected;
      },
      /**
       * 判断列头复选框是否被半选
       */
      isAllCheckboxIndeterminate() {
        return !reactData.isAllSelected && reactData.isIndeterminate;
      },
      /**
       * 获取复选框半选状态的行数据
       */
      getCheckboxIndeterminateRecords(isFull) {
        const { treeConfig } = props;
        const { fullDataRowIdData, treeIndeterminateRowMaps } = internalData;
        if (treeConfig) {
          const fullRest = [];
          const defRest = [];
          import_xe_utils8.default.each(treeIndeterminateRowMaps, (item, rowid) => {
            if (item) {
              fullRest.push(item);
              if (fullDataRowIdData[rowid]) {
                defRest.push(item);
              }
            }
          });
          if (isFull) {
            return fullRest;
          }
          return defRest;
        }
        return [];
      },
      /**
       * 用于多选行，设置行为选中状态，第二个参数为选中与否
       * @param {Array/Row} rows 行数据
       * @param {Boolean} value 是否选中
       */
      setCheckboxRow(rows, checked) {
        if (rows && !import_xe_utils8.default.isArray(rows)) {
          rows = [rows];
        }
        return handleCheckedCheckboxRow(rows, checked, true);
      },
      setCheckboxRowKey(keys, checked) {
        const { fullAllDataRowIdData } = internalData;
        if (!import_xe_utils8.default.isArray(keys)) {
          keys = [keys];
        }
        const rows = [];
        keys.forEach((rowid) => {
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            rows.push(rowRest.row);
          }
        });
        return handleCheckedCheckboxRow(rows, checked, true);
      },
      isCheckedByCheckboxRow(row) {
        const { updateCheckboxFlag } = reactData;
        const { selectCheckboxMaps } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        if (checkField) {
          return import_xe_utils8.default.get(row, checkField);
        }
        return !!updateCheckboxFlag && !!selectCheckboxMaps[getRowid($xeTable, row)];
      },
      isCheckedByCheckboxRowKey(rowid) {
        const { updateCheckboxFlag } = reactData;
        const { fullAllDataRowIdData, selectCheckboxMaps } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        if (checkField) {
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            return import_xe_utils8.default.get(rowRest.row, checkField);
          }
          return false;
        }
        return !!updateCheckboxFlag && !!selectCheckboxMaps[rowid];
      },
      isIndeterminateByCheckboxRow(row) {
        const { treeIndeterminateRowMaps } = internalData;
        return !!treeIndeterminateRowMaps[getRowid($xeTable, row)] && !$xeTable.isCheckedByCheckboxRow(row);
      },
      isIndeterminateByCheckboxRowKey(rowid) {
        const { treeIndeterminateRowMaps } = internalData;
        return !!treeIndeterminateRowMaps[rowid] && !$xeTable.isCheckedByCheckboxRowKey(rowid);
      },
      /**
       * 多选，切换某一行的选中状态
       */
      toggleCheckboxRow(row) {
        const { selectCheckboxMaps } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        const checked = checkField ? !import_xe_utils8.default.get(row, checkField) : !selectCheckboxMaps[getRowid($xeTable, row)];
        tablePrivateMethods.handleBatchSelectRows([row], checked, true);
        tablePrivateMethods.checkSelectionStatus();
        return nextTick();
      },
      /**
       * 用于多选行，设置所有行的选中状态
       * @param {Boolean} value 是否选中
       */
      setAllCheckboxRow(value) {
        return handleCheckedAllCheckboxRow(value, true);
      },
      /**
       * 获取单选框保留选中的行
       */
      getRadioReserveRecord(isFull) {
        const { treeConfig } = props;
        const { fullDataRowIdData, radioReserveRow, afterFullData } = internalData;
        const radioOpts = computeRadioOpts.value;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        if (radioOpts.reserve && radioReserveRow) {
          const rowid = getRowid($xeTable, radioReserveRow);
          if (isFull) {
            if (!fullDataRowIdData[rowid]) {
              return radioReserveRow;
            }
          } else {
            const rowkey = getRowkey($xeTable);
            if (treeConfig) {
              const matchObj = import_xe_utils8.default.findTree(afterFullData, (row) => rowid === import_xe_utils8.default.get(row, rowkey), { children: childrenField });
              if (matchObj) {
                return radioReserveRow;
              }
            } else {
              if (!afterFullData.some((row) => rowid === import_xe_utils8.default.get(row, rowkey))) {
                return radioReserveRow;
              }
            }
          }
        }
        return null;
      },
      clearRadioReserve() {
        internalData.radioReserveRow = null;
        return nextTick();
      },
      /**
       * 获取复选框保留选中的行
       */
      getCheckboxReserveRecords(isFull) {
        const { treeConfig } = props;
        const { afterFullData, fullDataRowIdData, checkboxReserveRowMap } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const reserveSelection = [];
        if (checkboxOpts.reserve) {
          const { handleGetRowId } = createHandleGetRowId($xeTable);
          const afterFullIdMaps = {};
          if (treeConfig) {
            import_xe_utils8.default.eachTree(afterFullData, (row) => {
              afterFullIdMaps[handleGetRowId(row)] = 1;
            }, { children: childrenField });
          } else {
            afterFullData.forEach((row) => {
              afterFullIdMaps[handleGetRowId(row)] = 1;
            });
          }
          import_xe_utils8.default.each(checkboxReserveRowMap, (oldRow, oldRowid) => {
            if (oldRow) {
              if (isFull) {
                if (!fullDataRowIdData[oldRowid]) {
                  reserveSelection.push(oldRow);
                }
              } else {
                if (!afterFullIdMaps[oldRowid]) {
                  reserveSelection.push(oldRow);
                }
              }
            }
          });
        }
        return reserveSelection;
      },
      clearCheckboxReserve() {
        internalData.checkboxReserveRowMap = {};
        return nextTick();
      },
      /**
       * 多选，切换所有行的选中状态
       */
      toggleAllCheckboxRow() {
        handleCheckAllEvent(null, !reactData.isAllSelected);
        return nextTick();
      },
      /**
       * 用于多选行，手动清空用户的选择
       * 清空行为不管是否被禁用还是保留记录，都将彻底清空选中状态
       */
      clearCheckboxRow() {
        const { treeConfig } = props;
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, reserve } = checkboxOpts;
        const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
        if (checkField) {
          const handleClearChecked = (item) => {
            if (treeConfig && indeterminateField) {
              import_xe_utils8.default.set(item, indeterminateField, false);
            }
            import_xe_utils8.default.set(item, checkField, false);
          };
          if (treeConfig) {
            import_xe_utils8.default.eachTree(tableFullData, handleClearChecked, { children: childrenField });
          } else {
            tableFullData.forEach(handleClearChecked);
          }
        }
        if (reserve) {
          tableFullData.forEach((row) => handleCheckboxReserveRow(row, false));
        }
        reactData.isAllSelected = false;
        reactData.isIndeterminate = false;
        internalData.selectCheckboxMaps = {};
        internalData.treeIndeterminateRowMaps = {};
        reactData.updateCheckboxFlag++;
        return nextTick();
      },
      /**
       * 用于当前行，设置某一行为高亮状态
       * @param {Row} row 行对象
       */
      setCurrentRow(row) {
        const rowOpts = computeRowOpts.value;
        const el = refElem.value;
        tableMethods.clearCurrentRow();
        reactData.currentRow = row;
        if (rowOpts.isCurrent || props.highlightCurrentRow) {
          if (el) {
            import_xe_utils8.default.arrayEach(el.querySelectorAll(`[rowid="${getRowid($xeTable, row)}"]`), (elem) => addClass(elem, "row--current"));
          }
        }
        return nextTick();
      },
      isCheckedByRadioRow(row) {
        const { selectRadioRow } = reactData;
        if (row && selectRadioRow) {
          return $xeTable.eqRow(selectRadioRow, row);
        }
        return false;
      },
      isCheckedByRadioRowKey(key) {
        const { selectRadioRow } = reactData;
        if (selectRadioRow) {
          return key === getRowid($xeTable, selectRadioRow);
        }
        return false;
      },
      /**
       * 用于单选行，设置某一行为选中状态
       * @param {Row} row 行对象
       */
      setRadioRow(row) {
        return handleCheckedRadioRow(row, true);
      },
      /**
       * 用于单选行，设置某一行为选中状态
       * @param key 行主键
       */
      setRadioRowKey(rowid) {
        const { fullAllDataRowIdData } = internalData;
        const rowRest = fullAllDataRowIdData[rowid];
        if (rowRest) {
          return handleCheckedRadioRow(rowRest.row, true);
        }
        return nextTick();
      },
      /**
       * 用于当前行，手动清空当前高亮的状态
       */
      clearCurrentRow() {
        const el = refElem.value;
        reactData.currentRow = null;
        internalData.hoverRow = null;
        if (el) {
          import_xe_utils8.default.arrayEach(el.querySelectorAll(".row--current"), (elem) => removeClass(elem, "row--current"));
        }
        return nextTick();
      },
      /**
       * 用于单选行，手动清空用户的选择
       */
      clearRadioRow() {
        reactData.selectRadioRow = null;
        return nextTick();
      },
      /**
       * 用于当前行，获取当前行的数据
       */
      getCurrentRecord() {
        const rowOpts = computeRowOpts.value;
        return rowOpts.isCurrent || props.highlightCurrentRow ? reactData.currentRow : null;
      },
      /**
       * 用于单选行，获取当已选中的数据
       */
      getRadioRecord(isFull) {
        const { fullDataRowIdData, afterFullRowMaps } = internalData;
        const { selectRadioRow } = reactData;
        if (selectRadioRow) {
          const rowid = getRowid($xeTable, selectRadioRow);
          if (isFull) {
            if (fullDataRowIdData[rowid]) {
              return selectRadioRow;
            }
          } else {
            if (afterFullRowMaps[rowid]) {
              return selectRadioRow;
            }
          }
        }
        return null;
      },
      getCurrentColumn() {
        const columnOpts = computeColumnOpts.value;
        return columnOpts.isCurrent || props.highlightCurrentColumn ? reactData.currentColumn : null;
      },
      /**
       * 用于当前列，设置某列行为高亮状态
       */
      setCurrentColumn(fieldOrColumn) {
        const { mouseConfig } = props;
        const mouseOpts = computeMouseOpts.value;
        const isMouseSelected = mouseConfig && mouseOpts.selected;
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column) {
          $xeTable.clearCurrentColumn();
          reactData.currentColumn = column;
        }
        return nextTick().then(() => {
          if (isMouseSelected) {
            $xeTable.addCellSelectedClass();
          }
        });
      },
      /**
       * 用于当前列，手动清空当前高亮的状态
       */
      clearCurrentColumn() {
        reactData.currentColumn = null;
        return nextTick();
      },
      setPendingRow(rows, status) {
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        const { pendingRowMaps } = internalData;
        if (rows && !import_xe_utils8.default.isArray(rows)) {
          rows = [rows];
        }
        if (status) {
          rows.forEach((row) => {
            const rowid = handleGetRowId(row);
            if (rowid && !pendingRowMaps[rowid]) {
              pendingRowMaps[rowid] = row;
            }
          });
        } else {
          rows.forEach((row) => {
            const rowid = handleGetRowId(row);
            if (rowid && pendingRowMaps[rowid]) {
              delete pendingRowMaps[rowid];
            }
          });
        }
        reactData.pendingRowFlag++;
        return nextTick();
      },
      togglePendingRow(rows) {
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        const { pendingRowMaps } = internalData;
        if (rows && !import_xe_utils8.default.isArray(rows)) {
          rows = [rows];
        }
        rows.forEach((row) => {
          const rowid = handleGetRowId(row);
          if (rowid) {
            if (pendingRowMaps[rowid]) {
              delete pendingRowMaps[rowid];
            } else {
              pendingRowMaps[rowid] = row;
            }
          }
        });
        reactData.pendingRowFlag++;
        return nextTick();
      },
      hasPendingByRow(row) {
        return tableMethods.isPendingByRow(row);
      },
      isPendingByRow(row) {
        const { pendingRowMaps } = internalData;
        const rowid = getRowid($xeTable, row);
        return !!pendingRowMaps[rowid];
      },
      getPendingRecords() {
        const { fullAllDataRowIdData, pendingRowMaps } = internalData;
        const insertRecords = [];
        import_xe_utils8.default.each(pendingRowMaps, (row, rowid) => {
          if (fullAllDataRowIdData[rowid]) {
            insertRecords.push(row);
          }
        });
        return insertRecords;
      },
      clearPendingRow() {
        internalData.pendingRowMaps = {};
        reactData.pendingRowFlag++;
        return nextTick();
      },
      sort(sortConfs, sortOrder) {
        const sortOpts = computeSortOpts.value;
        const { multiple, remote, orders } = sortOpts;
        if (sortConfs) {
          if (import_xe_utils8.default.isString(sortConfs)) {
            sortConfs = [
              { field: sortConfs, order: sortOrder }
            ];
          }
        }
        if (!import_xe_utils8.default.isArray(sortConfs)) {
          sortConfs = [sortConfs];
        }
        if (sortConfs.length) {
          if (!multiple) {
            clearAllSort();
          }
          (multiple ? sortConfs : [sortConfs[0]]).forEach((confs, index) => {
            let { field, order } = confs;
            let column = field;
            if (import_xe_utils8.default.isString(field)) {
              column = tableMethods.getColumnByField(field);
            }
            if (column && column.sortable) {
              if (orders.indexOf(order) === -1) {
                order = getNextSortOrder(column);
              }
              if (column.order !== order) {
                column.order = order;
              }
              column.sortTime = Date.now() + index;
            }
          });
          if (!remote) {
            tablePrivateMethods.handleTableData(true);
          }
          return nextTick().then(() => {
            tableMethods.updateCellAreas();
            return updateStyle();
          });
        }
        return nextTick();
      },
      setSort(sortConfs, isUpdate) {
        const sortOpts = computeSortOpts.value;
        const { multiple, remote, orders } = sortOpts;
        if (!import_xe_utils8.default.isArray(sortConfs)) {
          sortConfs = [sortConfs];
        }
        if (sortConfs && sortConfs.length) {
          if (!multiple) {
            sortConfs = [sortConfs[0]];
            clearAllSort();
          }
          let firstColumn = null;
          sortConfs.forEach((confs, index) => {
            let { field, order } = confs;
            let column = field;
            if (import_xe_utils8.default.isString(field)) {
              column = tableMethods.getColumnByField(field);
            }
            if (!firstColumn) {
              firstColumn = column;
            }
            if (column && column.sortable) {
              if (orders.indexOf(order) === -1) {
                order = getNextSortOrder(column);
              }
              if (column.order !== order) {
                column.order = order;
              }
              column.sortTime = Date.now() + index;
            }
          });
          if (isUpdate) {
            if (!remote) {
              tablePrivateMethods.handleTableData(true);
            }
            $xeTable.handleColumnSortEvent(new Event("click"), firstColumn);
          }
          return nextTick().then(() => {
            tableMethods.updateCellAreas();
            return updateStyle();
          });
        }
        return nextTick();
      },
      /**
       * 清空指定列的排序条件
       * 如果为空则清空所有列的排序条件
       * @param {String} fieldOrColumn 列或字段名
       */
      clearSort(fieldOrColumn) {
        const sortOpts = computeSortOpts.value;
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xeTable, fieldOrColumn);
          if (column) {
            column.order = null;
          }
        } else {
          clearAllSort();
        }
        if (!sortOpts.remote) {
          tablePrivateMethods.handleTableData(true);
        }
        return nextTick().then(updateStyle);
      },
      isSort(fieldOrColumn) {
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xeTable, fieldOrColumn);
          return column ? column.sortable && !!column.order : false;
        }
        return tableMethods.getSortColumns().length > 0;
      },
      getSortColumns() {
        const sortOpts = computeSortOpts.value;
        const { multiple, chronological } = sortOpts;
        const sortList = [];
        const { tableFullColumn } = internalData;
        tableFullColumn.forEach((column) => {
          const { field, order } = column;
          if (column.sortable && order) {
            sortList.push({ column, field, property: field, order, sortTime: column.sortTime });
          }
        });
        if (multiple && chronological && sortList.length > 1) {
          return import_xe_utils8.default.orderBy(sortList, "sortTime");
        }
        return sortList;
      },
      /**
       * 关闭筛选
       * @param {Event} evnt 事件
       */
      closeFilter() {
        const { filterStore } = reactData;
        const { column, visible } = filterStore;
        Object.assign(filterStore, {
          isAllSelected: false,
          isIndeterminate: false,
          options: [],
          visible: false
        });
        if (visible) {
          dispatchEvent("filter-visible", {
            column,
            property: column.field,
            field: column.field,
            filterList: () => $xeTable.getCheckedFilters(),
            visible: false
          }, null);
        }
        return nextTick();
      },
      /**
       * 判断指定列是否为筛选状态，如果为空则判断所有列
       * @param {String} fieldOrColumn 字段名
       */
      isActiveFilterByColumn(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column) {
          return column.filters && column.filters.some((option) => option.checked);
        }
        return $xeTable.getCheckedFilters().length > 0;
      },
      isFilter(fieldOrColumn) {
        return tableMethods.isActiveFilterByColumn(fieldOrColumn);
      },
      /**
       * 判断展开行是否懒加载完成
       * @param {Row} row 行对象
       */
      isRowExpandLoaded(row) {
        const { fullAllDataRowIdData } = internalData;
        const rowRest = fullAllDataRowIdData[getRowid($xeTable, row)];
        return rowRest && !!rowRest.expandLoaded;
      },
      clearRowExpandLoaded(row) {
        const { fullAllDataRowIdData, rowExpandLazyLoadedMaps } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { lazy } = expandOpts;
        const rowid = getRowid($xeTable, row);
        const rowRest = fullAllDataRowIdData[rowid];
        if (lazy && rowRest) {
          rowRest.expandLoaded = false;
          delete rowExpandLazyLoadedMaps[rowid];
        }
        reactData.rowExpandedFlag++;
        return nextTick();
      },
      /**
       * 重新懒加载展开行，并展开内容
       * @param {Row} row 行对象
       */
      reloadRowExpand(row) {
        const { rowExpandLazyLoadedMaps } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { lazy } = expandOpts;
        const rowid = getRowid($xeTable, row);
        if (lazy && !rowExpandLazyLoadedMaps[rowid]) {
          $xeTable.clearRowExpandLoaded(row).then(() => handleAsyncRowExpand(row));
        }
        return nextTick();
      },
      reloadExpandContent(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["reloadExpandContent", "reloadRowExpand"]);
        }
        return $xeTable.reloadRowExpand(row);
      },
      /**
       * 切换展开行
       */
      toggleRowExpand(row) {
        return $xeTable.setRowExpand(row, !$xeTable.isRowExpandByRow(row));
      },
      /**
       * 设置所有行的展开与否
       * @param {Boolean} expanded 是否展开
       */
      setAllRowExpand(expanded) {
        const treeOpts = computeTreeOpts.value;
        const { tableFullData, tableFullTreeData } = internalData;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let expandedRows = [];
        if (props.treeConfig) {
          import_xe_utils8.default.eachTree(tableFullTreeData, (row) => {
            expandedRows.push(row);
          }, { children: childrenField });
        } else {
          expandedRows = tableFullData;
        }
        return tableMethods.setRowExpand(expandedRows, expanded);
      },
      /**
       * 设置展开行，二个参数设置这一行展开与否
       * 支持单行
       * 支持多行
       * @param {Array/Row} rows 行数据
       * @param {Boolean} expanded 是否展开
       */
      setRowExpand(rows, expanded) {
        const { expandColumn } = reactData;
        let { fullAllDataRowIdData, rowExpandedMaps, rowExpandLazyLoadedMaps } = internalData;
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        const expandOpts = computeExpandOpts.value;
        const { reserve, lazy, accordion, toggleMethod } = expandOpts;
        const lazyRests = [];
        const columnIndex = $xeTable.getColumnIndex(expandColumn);
        const $columnIndex = $xeTable.getVMColumnIndex(expandColumn);
        if (rows) {
          if (!import_xe_utils8.default.isArray(rows)) {
            rows = [rows];
          }
          if (accordion) {
            rowExpandedMaps = {};
            internalData.rowExpandedMaps = rowExpandedMaps;
            rows = rows.slice(rows.length - 1, rows.length);
          }
          const validRows = toggleMethod ? rows.filter((row) => toggleMethod({ $table: $xeTable, expanded, column: expandColumn, columnIndex, $columnIndex, row, rowIndex: tableMethods.getRowIndex(row), $rowIndex: tableMethods.getVMRowIndex(row) })) : rows;
          if (expanded) {
            validRows.forEach((row) => {
              const rowid = handleGetRowId(row);
              if (!rowExpandedMaps[rowid]) {
                const rowRest = fullAllDataRowIdData[rowid];
                const isLoad = lazy && !rowRest.expandLoaded && !rowExpandLazyLoadedMaps[rowid];
                if (isLoad) {
                  lazyRests.push(handleAsyncRowExpand(row));
                } else {
                  rowExpandedMaps[rowid] = row;
                }
              }
            });
          } else {
            validRows.forEach((item) => {
              const rowid = handleGetRowId(item);
              if (rowExpandedMaps[rowid]) {
                delete rowExpandedMaps[rowid];
              }
            });
          }
          if (reserve) {
            validRows.forEach((row) => handleRowExpandReserve(row, expanded));
          }
        }
        reactData.rowExpandedFlag++;
        return Promise.all(lazyRests).then(() => nextTick()).then(() => $xeTable.recalculate(true)).then(() => {
          updateRowOffsetTop();
          updateRowExpandStyle();
          handleRowExpandScroll();
          return $xeTable.updateCellAreas();
        });
      },
      /**
       * 判断行是否为展开状态
       * @param {Row} row 行对象
       */
      isRowExpandByRow(row) {
        const { rowExpandedFlag } = reactData;
        const { rowExpandedMaps } = internalData;
        const rowid = getRowid($xeTable, row);
        return !!rowExpandedFlag && !!rowExpandedMaps[rowid];
      },
      isExpandByRow(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["isExpandByRow", "isRowExpandByRow"]);
        }
        return tableMethods.isRowExpandByRow(row);
      },
      /**
       * 手动清空展开行状态，数据会恢复成未展开的状态
       */
      clearRowExpand() {
        const { tableFullData } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { reserve } = expandOpts;
        const expList = $xeTable.getRowExpandRecords();
        internalData.rowExpandedMaps = {};
        reactData.rowExpandedFlag++;
        if (reserve) {
          tableFullData.forEach((row) => handleRowExpandReserve(row, false));
        }
        return nextTick().then(() => {
          if (expList.length) {
            return $xeTable.recalculate(true);
          }
        }).then(() => {
          updateRowOffsetTop();
          updateRowExpandStyle();
          handleRowExpandScroll();
          return $xeTable.updateCellAreas();
        });
      },
      clearRowExpandReserve() {
        internalData.rowExpandedReserveRowMap = {};
        return nextTick();
      },
      getRowExpandRecords() {
        const rest = [];
        import_xe_utils8.default.each(internalData.rowExpandedMaps, (item) => {
          if (item) {
            rest.push(item);
          }
        });
        return rest;
      },
      getTreeExpandRecords() {
        const rest = [];
        import_xe_utils8.default.each(internalData.treeExpandedMaps, (item) => {
          if (item) {
            rest.push(item);
          }
        });
        return rest;
      },
      /**
       * 判断树节点是否懒加载完成
       * @param {Row} row 行对象
       */
      isTreeExpandLoaded(row) {
        const { fullAllDataRowIdData } = internalData;
        const rowRest = fullAllDataRowIdData[getRowid($xeTable, row)];
        return rowRest && !!rowRest.treeLoaded;
      },
      clearTreeExpandLoaded(rows) {
        const { fullAllDataRowIdData, treeExpandedMaps } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform } = treeOpts;
        if (rows) {
          if (!import_xe_utils8.default.isArray(rows)) {
            rows = [rows];
          }
          rows.forEach((row) => {
            const rowid = getRowid($xeTable, row);
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              rowRest.treeLoaded = false;
              if (treeExpandedMaps[rowid]) {
                delete treeExpandedMaps[rowid];
              }
            }
          });
        } else {
          import_xe_utils8.default.each(fullAllDataRowIdData, (rowRest) => {
            rowRest.treeLoaded = false;
          });
        }
        internalData.treeExpandedMaps = {};
        reactData.treeExpandedFlag++;
        if (transform) {
          handleVirtualTreeToList();
          return $xeTable.handleTableData();
        }
        return nextTick();
      },
      /**
       * 重新懒加载树节点，并展开该节点
       * @param {Row} row 行对象
       */
      reloadTreeExpand(row) {
        const { treeExpandLazyLoadedMaps } = internalData;
        const treeOpts = computeTreeOpts.value;
        const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
        const { transform, lazy } = treeOpts;
        const rowid = getRowid($xeTable, row);
        if (lazy && row[hasChildField] && !treeExpandLazyLoadedMaps[rowid]) {
          return tableMethods.clearTreeExpandLoaded(row).then(() => {
            return handleAsyncTreeExpandChilds(row);
          }).then(() => {
            if (transform) {
              handleVirtualTreeToList();
              return tablePrivateMethods.handleTableData();
            }
          }).then(() => {
            return tableMethods.recalculate();
          });
        }
        return nextTick();
      },
      reloadTreeChilds(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["reloadTreeChilds", "reloadTreeExpand"]);
        }
        return tableMethods.reloadTreeExpand(row);
      },
      /**
       * 切换/展开树节点
       */
      toggleTreeExpand(row) {
        return tableMethods.setTreeExpand(row, !tableMethods.isTreeExpandByRow(row));
      },
      /**
       * 设置所有树节点的展开与否
       * @param {Boolean} expanded 是否展开
       */
      setAllTreeExpand(expanded) {
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform, lazy } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const expandeds = [];
        import_xe_utils8.default.eachTree(tableFullData, (row) => {
          const rowChildren = row[childrenField];
          if (lazy || rowChildren && rowChildren.length) {
            expandeds.push(row);
          }
        }, { children: childrenField });
        return tableMethods.setTreeExpand(expandeds, expanded).then(() => {
          if (transform) {
            handleVirtualTreeToList();
            return tableMethods.recalculate();
          }
        });
      },
      /**
       * 设置展开树形节点，二个参数设置这一行展开与否
       * 支持单行
       * 支持多行
       * @param {Array/Row} rows 行数据
       * @param {Boolean} expanded 是否展开
       */
      setTreeExpand(rows, expanded) {
        const treeOpts = computeTreeOpts.value;
        const { transform } = treeOpts;
        if (rows) {
          if (!import_xe_utils8.default.isArray(rows)) {
            rows = [rows];
          }
          if (rows.length) {
            if (transform) {
              return handleVirtualTreeExpand(rows, expanded);
            } else {
              return handleBaseTreeExpand(rows, expanded);
            }
          }
        }
        return nextTick();
      },
      /**
       * 判断行是否为树形节点展开状态
       * @param {Row} row 行对象
       */
      isTreeExpandByRow(row) {
        const { treeExpandedFlag } = reactData;
        const { treeExpandedMaps } = internalData;
        return !!treeExpandedFlag && !!treeExpandedMaps[getRowid($xeTable, row)];
      },
      /**
       * 手动清空树形节点的展开状态，数据会恢复成未展开的状态
       */
      clearTreeExpand() {
        const { tableFullTreeData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const { transform, reserve } = treeOpts;
        const expList = $xeTable.getTreeExpandRecords();
        internalData.treeExpandedMaps = {};
        reactData.treeExpandedFlag++;
        if (reserve) {
          import_xe_utils8.default.eachTree(tableFullTreeData, (row) => handleTreeExpandReserve(row, false), { children: childrenField });
        }
        return $xeTable.handleTableData().then(() => {
          if (transform) {
            handleVirtualTreeToList();
            return $xeTable.handleTableData();
          }
        }).then(() => {
          if (expList.length) {
            return $xeTable.recalculate();
          }
        });
      },
      clearTreeExpandReserve() {
        internalData.treeExpandedReserveRowMap = {};
        return nextTick();
      },
      /**
       * 获取表格的滚动状态
       */
      getScroll() {
        const { scrollXLoad, scrollYLoad } = reactData;
        const { elemStore } = internalData;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        return {
          virtualX: scrollXLoad,
          virtualY: scrollYLoad,
          scrollTop: bodyScrollElem ? bodyScrollElem.scrollTop : 0,
          scrollLeft: bodyScrollElem ? bodyScrollElem.scrollLeft : 0
        };
      },
      /**
       * 如果有滚动条，则滚动到对应的位置
       * @param {Number} scrollLeft 左距离
       * @param {Number} scrollTop 上距离
       */
      scrollTo(scrollLeft, scrollTop) {
        const { elemStore } = internalData;
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
        const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
        const xHandleEl = refScrollXHandleElem.value;
        const yHandleEl = refScrollYHandleElem.value;
        internalData.intoRunScroll = true;
        if (import_xe_utils8.default.isNumber(scrollLeft)) {
          setScrollLeft(xHandleEl, scrollLeft);
          setScrollLeft(bodyScrollElem, scrollLeft);
          setScrollLeft(headerScrollElem, scrollLeft);
          setScrollLeft(footerScrollElem, scrollLeft);
        }
        if (import_xe_utils8.default.isNumber(scrollTop)) {
          setScrollTop(yHandleEl, scrollTop);
          setScrollTop(bodyScrollElem, scrollTop);
          setScrollTop(leftScrollElem, scrollTop);
          setScrollTop(rightScrollElem, scrollTop);
        }
        if (reactData.scrollXLoad || reactData.scrollYLoad) {
          return new Promise((resolve) => {
            setTimeout(() => {
              nextTick(() => {
                internalData.intoRunScroll = false;
                resolve();
              });
            }, 30);
          });
        }
        return nextTick();
      },
      /**
       * 如果有滚动条，则滚动到对应的行
       * @param {Row} row 行对象
       * @param {ColumnInfo} fieldOrColumn 列配置
       */
      scrollToRow(row, fieldOrColumn) {
        const { isAllOverflow, scrollYLoad, scrollXLoad } = reactData;
        const rest = [];
        if (row) {
          if (props.treeConfig) {
            rest.push(tablePrivateMethods.scrollToTreeRow(row));
          } else {
            rest.push(rowToVisible($xeTable, row));
          }
        }
        if (fieldOrColumn) {
          rest.push(handleScrollToRowColumn(fieldOrColumn, row));
        }
        return Promise.all(rest).then(() => {
          if (row) {
            if (!isAllOverflow && (scrollYLoad || scrollXLoad)) {
              calcCellHeight();
              calcCellWidth();
            }
            return nextTick();
          }
        });
      },
      /**
       * 如果有滚动条，则滚动到对应的列
       */
      scrollToColumn(fieldOrColumn) {
        const { fullColumnIdData } = internalData;
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column && fullColumnIdData[column.id]) {
          return colToVisible($xeTable, column);
        }
        return nextTick();
      },
      /**
       * 手动清除滚动相关信息，还原到初始状态
       */
      clearScroll() {
        const { elemStore, scrollXStore, scrollYStore } = internalData;
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
        const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
        const xHandleEl = refScrollXHandleElem.value;
        const yHandleEl = refScrollYHandleElem.value;
        internalData.intoRunScroll = true;
        setScrollLeft(xHandleEl, 0);
        setScrollLeft(bodyScrollElem, 0);
        setScrollLeft(headerScrollElem, 0);
        setScrollLeft(footerScrollElem, 0);
        setScrollTop(yHandleEl, 0);
        setScrollTop(bodyScrollElem, 0);
        setScrollTop(leftScrollElem, 0);
        setScrollTop(rightScrollElem, 0);
        scrollXStore.startIndex = 0;
        scrollXStore.visibleStartIndex = 0;
        scrollXStore.endIndex = scrollXStore.visibleSize;
        scrollXStore.visibleEndIndex = scrollXStore.visibleSize;
        scrollYStore.startIndex = 0;
        scrollYStore.visibleStartIndex = 0;
        scrollYStore.endIndex = scrollYStore.visibleSize;
        scrollYStore.visibleEndIndex = scrollYStore.visibleSize;
        return nextTick().then(() => {
          internalData.intoRunScroll = false;
        });
      },
      /**
       * 更新表尾合计
       */
      updateFooter() {
        const { showFooter, footerData, footerMethod } = props;
        const { visibleColumn, afterFullData } = internalData;
        let footData = [];
        if (showFooter && footerData && footerData.length) {
          footData = footerData.slice(0);
        } else if (showFooter && footerMethod) {
          footData = visibleColumn.length ? footerMethod({ columns: visibleColumn, data: afterFullData, $table: $xeTable, $grid: $xeGrid }) : [];
        }
        reactData.footerTableData = footData;
        return nextTick();
      },
      /**
       * 更新列状态 updateStatus({ row, column }, cellValue)
       * 如果组件值 v-model 发生 change 时，调用改函数用于更新某一列编辑状态
       * 如果单元格配置了校验规则，则会进行校验
       */
      updateStatus(slotParams, cellValue) {
        return nextTick().then(() => {
          const { editRules } = props;
          if (slotParams && editRules) {
            return $xeTable.handleCellRuleUpdateStatus("change", slotParams, cellValue);
          }
        });
      },
      /**
       * 设置合并单元格
       * @param {TableMergeConfig[]} merges { row: Row|number, column: ColumnInfo|number, rowspan: number, colspan: number }
       */
      setMergeCells(merges) {
        if (props.spanMethod) {
          errLog("vxe.error.errConflicts", ["merge-cells", "span-method"]);
        }
        setMerges(merges, reactData.mergeList, internalData.afterFullData);
        return nextTick().then(() => {
          tableMethods.updateCellAreas();
          return updateStyle();
        });
      },
      /**
       * 移除单元格合并
       * @param {TableMergeConfig[]} merges 多个或数组 [{row:Row|number, col:ColumnInfo|number}]
       */
      removeMergeCells(merges) {
        if (props.spanMethod) {
          errLog("vxe.error.errConflicts", ["merge-cells", "span-method"]);
        }
        const rest = removeMerges(merges, reactData.mergeList, internalData.afterFullData);
        return nextTick().then(() => {
          tableMethods.updateCellAreas();
          updateStyle();
          return rest;
        });
      },
      /**
       * 获取所有被合并的单元格
       */
      getMergeCells() {
        return reactData.mergeList.slice(0);
      },
      /**
       * 清除所有单元格合并
       */
      clearMergeCells() {
        reactData.mergeList = [];
        return nextTick().then(() => {
          return updateStyle();
        });
      },
      setMergeFooterItems(merges) {
        if (props.footerSpanMethod) {
          errLog("vxe.error.errConflicts", ["merge-footer-items", "footer-span-method"]);
        }
        setMerges(merges, reactData.mergeFooterList);
        return nextTick().then(() => {
          tableMethods.updateCellAreas();
          return updateStyle();
        });
      },
      removeMergeFooterItems(merges) {
        if (props.footerSpanMethod) {
          errLog("vxe.error.errConflicts", ["merge-footer-items", "footer-span-method"]);
        }
        const rest = removeMerges(merges, reactData.mergeFooterList);
        return nextTick().then(() => {
          tableMethods.updateCellAreas();
          updateStyle();
          return rest;
        });
      },
      /**
       * 获取所有被合并的表尾
       */
      getMergeFooterItems() {
        return reactData.mergeFooterList.slice(0);
      },
      /**
       * 清除所有表尾合并
       */
      clearMergeFooterItems() {
        reactData.mergeFooterList = [];
        return nextTick().then(() => {
          return updateStyle();
        });
      },
      updateCellAreas() {
        const { mouseConfig } = props;
        const mouseOpts = computeMouseOpts.value;
        if (mouseConfig && mouseOpts.area && $xeTable.handleRecalculateCellAreaEvent) {
          return $xeTable.handleRecalculateCellAreaEvent();
        }
        return nextTick();
      },
      getCustomStoreData() {
        const { id } = props;
        const customOpts = computeCustomOpts.value;
        const { collectColumn } = internalData;
        const { storage, checkMethod } = customOpts;
        const isAllCustom = storage === true;
        const storageOpts = isAllCustom ? {} : Object.assign({}, storage || {});
        const isCustomResizable = isAllCustom || storageOpts.resizable;
        const isCustomVisible = isAllCustom || storageOpts.visible;
        const isCustomFixed = isAllCustom || storageOpts.fixed;
        const isCustomSort = isAllCustom || storageOpts.sort;
        const resizableData = {};
        const sortData = {};
        const visibleData = {};
        const fixedData = {};
        const storeData = {
          resizableData: void 0,
          sortData: void 0,
          visibleData: void 0,
          fixedData: void 0
        };
        if (!id) {
          errLog("vxe.error.reqProp", ["id"]);
          return storeData;
        }
        let hasResizable = 0;
        let hasSort = 0;
        let hasFixed = 0;
        let hasVisible = 0;
        import_xe_utils8.default.eachTree(collectColumn, (column, index, items, path, parentColumn) => {
          const colKey = column.getKey();
          if (!colKey) {
            errLog("vxe.error.reqProp", [`${column.getTitle() || column.type || ""} -> column.field=?`]);
            return;
          }
          if (!parentColumn) {
            if (isCustomSort) {
              hasSort = 1;
              sortData[colKey] = column.renderSortNumber;
            }
            if (isCustomFixed && column.fixed !== column.defaultFixed) {
              hasFixed = 1;
              fixedData[colKey] = column.fixed;
            }
          }
          if (isCustomResizable && column.resizeWidth) {
            hasResizable = 1;
            resizableData[colKey] = column.renderWidth;
          }
          if (isCustomVisible && (!checkMethod || checkMethod({ column }))) {
            if (!column.visible && column.defaultVisible) {
              hasVisible = 1;
              visibleData[colKey] = false;
            } else if (column.visible && !column.defaultVisible) {
              hasVisible = 1;
              visibleData[colKey] = true;
            }
          }
        });
        if (hasResizable) {
          storeData.resizableData = resizableData;
        }
        if (hasSort) {
          storeData.sortData = sortData;
        }
        if (hasFixed) {
          storeData.fixedData = fixedData;
        }
        if (hasVisible) {
          storeData.visibleData = visibleData;
        }
        return storeData;
      },
      focus() {
        internalData.isActivated = true;
        return nextTick();
      },
      blur() {
        internalData.isActivated = false;
        return nextTick();
      },
      /**
       * 连接工具栏
       * @param $toolbar
       */
      connect($toolbar) {
        if ($toolbar) {
          $xeToolbar = $toolbar;
          $xeToolbar.syncUpdate({ collectColumn: internalData.collectColumn, $table: $xeTable });
        } else {
          errLog("vxe.error.barUnableLink");
        }
        return nextTick();
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { editStore, ctxMenuStore, filterStore, customStore } = reactData;
      const { mouseConfig, editRules } = props;
      const el = refElem.value;
      const editOpts = computeEditOpts.value;
      const validOpts = computeValidOpts.value;
      const areaOpts = computeAreaOpts.value;
      const { actived } = editStore;
      const $validTooltip = refValidTooltip.value;
      const tableFilter = refTableFilter.value;
      const tableCustom = refTableCustom.value;
      const tableMenu = refTableMenu.value;
      if (tableFilter) {
        if (getEventTargetNode(evnt, el, "vxe-cell--filter").flag) {
        } else if (getEventTargetNode(evnt, tableFilter.$el).flag) {
        } else {
          if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
            tablePrivateMethods.preventEvent(evnt, "event.clearFilter", filterStore.args, tableMethods.closeFilter);
          }
        }
      }
      if (tableCustom) {
        if (customStore.btnEl === evnt.target || getEventTargetNode(evnt, document.body, "vxe-toolbar-custom-target").flag) {
        } else if (getEventTargetNode(evnt, tableCustom.$el).flag) {
        } else {
          if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
            tablePrivateMethods.preventEvent(evnt, "event.clearCustom", {}, () => {
              if ($xeTable.closeCustom) {
                $xeTable.closeCustom();
              }
            });
          }
        }
      }
      if (actived.row) {
        if (!(editOpts.autoClear === false)) {
          const cell = actived.args.cell;
          if (!cell || !getEventTargetNode(evnt, cell).flag) {
            if ($validTooltip && getEventTargetNode(evnt, $validTooltip.$el).flag) {
            } else if (!internalData._lastCallTime || internalData._lastCallTime + 50 < Date.now()) {
              if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
                tablePrivateMethods.preventEvent(evnt, "event.clearEdit", actived.args, () => {
                  let isClear;
                  if (editOpts.mode === "row") {
                    const rowTargetNode = getEventTargetNode(evnt, el, "vxe-body--row");
                    const rowNodeRest = rowTargetNode.flag ? tableMethods.getRowNode(rowTargetNode.targetElem) : null;
                    isClear = rowNodeRest ? !$xeTable.eqRow(rowNodeRest.item, actived.args.row) : false;
                  } else {
                    isClear = !getEventTargetNode(evnt, el, "col--edit").flag;
                  }
                  if (!isClear) {
                    isClear = getEventTargetNode(evnt, el, "vxe-header--row").flag;
                  }
                  if (!isClear) {
                    isClear = getEventTargetNode(evnt, el, "vxe-footer--row").flag;
                  }
                  if (!isClear && props.height && !reactData.overflowY) {
                    const bodyWrapperElem = evnt.target;
                    if (hasClass(bodyWrapperElem, "vxe-table--body-wrapper")) {
                      isClear = evnt.offsetY < bodyWrapperElem.clientHeight;
                    }
                  }
                  if (isClear || // 如果点击了当前表格之外
                  !getEventTargetNode(evnt, el).flag) {
                    setTimeout(() => {
                      $xeTable.handleClearEdit(evnt).then(() => {
                        if (!internalData.isActivated && editRules && validOpts.autoClear) {
                          reactData.validErrorMaps = {};
                        }
                      });
                    });
                  }
                });
              }
            }
          }
        }
      } else if (mouseConfig) {
        if (!getEventTargetNode(evnt, el).flag && !($xeGrid && getEventTargetNode(evnt, $xeGrid.getRefMaps().refElem.value).flag) && !(tableMenu && getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) && !($xeToolbar && getEventTargetNode(evnt, $xeToolbar.getRefMaps().refElem.value).flag)) {
          if ($xeTable.clearSelected) {
            $xeTable.clearSelected();
          }
          if (areaOpts.autoClear) {
            if ($xeTable.getCellAreas) {
              const cellAreas = $xeTable.getCellAreas();
              if (cellAreas && cellAreas.length && !getEventTargetNode(evnt, document.body, "vxe-table--ignore-areas-clear").flag) {
                tablePrivateMethods.preventEvent(evnt, "event.clearAreas", {}, () => {
                  $xeTable.clearCellAreas();
                  $xeTable.clearCopyCellArea();
                  dispatchEvent("clear-cell-area-selection", { cellAreas }, evnt);
                });
              }
            }
          }
        }
      }
      if ($xeTable.closeMenu) {
        if (ctxMenuStore.visible && tableMenu && !getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) {
          $xeTable.closeMenu();
        }
      }
      const isActivated = getEventTargetNode(evnt, $xeGrid ? $xeGrid.getRefMaps().refElem.value : el).flag;
      if (!isActivated && editRules && validOpts.autoClear) {
        reactData.validErrorMaps = {};
      }
      internalData.isActivated = isActivated;
    };
    const handleGlobalBlurEvent = () => {
      tableMethods.closeFilter();
      if ($xeTable.closeMenu) {
        $xeTable.closeMenu();
      }
    };
    const handleGlobalMousewheelEvent = () => {
      tableMethods.closeTooltip();
      if ($xeTable.closeMenu) {
        $xeTable.closeMenu();
      }
    };
    const keydownEvent = (evnt) => {
      const { mouseConfig, keyboardConfig } = props;
      const { filterStore, ctxMenuStore, editStore } = reactData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
      if (isEsc) {
        tablePrivateMethods.preventEvent(evnt, "event.keydown", null, () => {
          dispatchEvent("keydown-start", {}, evnt);
          if (keyboardConfig && mouseConfig && mouseOpts.area && $xeTable.handleKeyboardCellAreaEvent) {
            $xeTable.handleKeyboardCellAreaEvent(evnt);
          } else if (actived.row || filterStore.visible || ctxMenuStore.visible) {
            evnt.stopPropagation();
            if ($xeTable.closeMenu) {
              $xeTable.closeMenu();
            }
            tableMethods.closeFilter();
            if (keyboardConfig && keyboardOpts.isEsc) {
              if (actived.row) {
                const params = actived.args;
                $xeTable.handleClearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick(() => $xeTable.handleSelected(params, evnt));
                }
              }
            }
          }
          dispatchEvent("keydown", {}, evnt);
          dispatchEvent("keydown-end", {}, evnt);
        });
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      if (internalData.isActivated) {
        tablePrivateMethods.preventEvent(evnt, "event.keydown", null, () => {
          const { mouseConfig, keyboardConfig, treeConfig, editConfig, highlightCurrentRow } = props;
          const { ctxMenuStore, editStore, currentRow } = reactData;
          const { afterFullData } = internalData;
          const isMenu = computeIsMenu.value;
          const bodyMenu = computeBodyMenu.value;
          const keyboardOpts = computeKeyboardOpts.value;
          const mouseOpts = computeMouseOpts.value;
          const editOpts = computeEditOpts.value;
          const treeOpts = computeTreeOpts.value;
          const menuList = computeMenuList.value;
          const rowOpts = computeRowOpts.value;
          const { selected, actived } = editStore;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          const keyCode = evnt.keyCode;
          const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
          const hasBackspaceKey = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.BACKSPACE);
          const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
          const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
          const isSpacebar = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR);
          const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
          const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
          const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
          const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
          const hasDeleteKey = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
          const isF2 = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.F2);
          const isContextMenu = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.CONTEXT_MENU);
          const hasMetaKey = evnt.metaKey;
          const hasCtrlKey = evnt.ctrlKey;
          const hasShiftKey = evnt.shiftKey;
          const isAltKey = evnt.altKey;
          const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
          const operCtxMenu = isMenu && ctxMenuStore.visible && (isEnter || isSpacebar || operArrow);
          const isEditStatus = isEnableConf(editConfig) && actived.column && actived.row;
          const beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;
          if (operCtxMenu) {
            evnt.preventDefault();
            if (ctxMenuStore.showChild && hasChildrenList(ctxMenuStore.selected)) {
              $xeTable.moveCtxMenu(evnt, ctxMenuStore, "selectChild", isLeftArrow, false, ctxMenuStore.selected.children);
            } else {
              $xeTable.moveCtxMenu(evnt, ctxMenuStore, "selected", isRightArrow, true, menuList);
            }
          } else if (keyboardConfig && mouseConfig && mouseOpts.area && $xeTable.handleKeyboardCellAreaEvent) {
            $xeTable.handleKeyboardCellAreaEvent(evnt);
          } else if (isEsc) {
            if ($xeTable.closeMenu) {
              $xeTable.closeMenu();
            }
            tableMethods.closeFilter();
            if (keyboardConfig && keyboardOpts.isEsc) {
              if (actived.row) {
                const params = actived.args;
                $xeTable.handleClearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick(() => $xeTable.handleSelected(params, evnt));
                }
              }
            }
          } else if (isSpacebar && keyboardConfig && keyboardOpts.isChecked && selected.row && selected.column && (selected.column.type === "checkbox" || selected.column.type === "radio")) {
            evnt.preventDefault();
            if (selected.column.type === "checkbox") {
              tablePrivateMethods.handleToggleCheckRowEvent(evnt, selected.args);
            } else {
              tablePrivateMethods.triggerRadioRowEvent(evnt, selected.args);
            }
          } else if (isF2 && isEnableConf(editConfig)) {
            if (!isEditStatus) {
              if (selected.row && selected.column) {
                evnt.preventDefault();
                $xeTable.handleEdit(selected.args, evnt);
              }
            }
          } else if (isContextMenu) {
            internalData._keyCtx = selected.row && selected.column && bodyMenu.length;
            clearTimeout(internalData.keyCtxTimeout);
            internalData.keyCtxTimeout = setTimeout(() => {
              internalData._keyCtx = false;
            }, 1e3);
          } else if (isEnter && !isAltKey && keyboardConfig && keyboardOpts.isEnter && (selected.row || actived.row || treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow)) {
            const { isLastEnterAppendRow, beforeEnterMethod, enterMethod } = keyboardOpts;
            if (hasCtrlKey) {
              if (actived.row) {
                const params = actived.args;
                $xeTable.handleClearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick(() => {
                    $xeTable.handleSelected(params, evnt);
                  });
                }
              }
            } else {
              if (selected.row || actived.row) {
                const activeParams = selected.row ? selected.args : actived.args;
                if (hasShiftKey) {
                  if (keyboardOpts.enterToTab) {
                    $xeTable.moveTabSelected(activeParams, hasShiftKey, evnt);
                  } else {
                    $xeTable.moveEnterSelected(activeParams, isLeftArrow, true, isRightArrow, false, evnt);
                  }
                } else {
                  if (keyboardOpts.enterToTab) {
                    $xeTable.moveTabSelected(activeParams, hasShiftKey, evnt);
                  } else {
                    const activeRow = selected.row || actived.row;
                    const activeColumn = selected.column || actived.column;
                    const _rowIndex = $xeTable.getVTRowIndex(activeRow);
                    const etrParams = {
                      row: activeRow,
                      rowIndex: $xeTable.getRowIndex(activeRow),
                      $rowIndex: $xeTable.getVMRowIndex(activeRow),
                      _rowIndex,
                      column: activeColumn,
                      columnIndex: $xeTable.getColumnIndex(activeColumn),
                      $columnIndex: $xeTable.getVMColumnIndex(activeColumn),
                      _columnIndex: $xeTable.getVTColumnIndex(activeColumn),
                      $table: $xeTable
                    };
                    if (!beforeEnterMethod || beforeEnterMethod(etrParams) !== false) {
                      if (isLastEnterAppendRow) {
                        if (_rowIndex >= afterFullData.length - 1) {
                          $xeTable.insertAt({}, -1).then(({ row: newRow }) => {
                            $xeTable.scrollToRow(newRow, activeColumn);
                            $xeTable.handleSelected(Object.assign(Object.assign({}, activeParams), { row: newRow }), evnt);
                          });
                          $xeTable.dispatchEvent("enter-append-row", etrParams, evnt);
                          return;
                        }
                      }
                      $xeTable.moveEnterSelected(activeParams, isLeftArrow, false, isRightArrow, true, evnt);
                      if (enterMethod) {
                        enterMethod(etrParams);
                      }
                    }
                  }
                }
              } else if (treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {
                const childrens = currentRow[childrenField];
                if (childrens && childrens.length) {
                  evnt.preventDefault();
                  const targetRow = childrens[0];
                  const params = {
                    $table: $xeTable,
                    row: targetRow,
                    rowIndex: tableMethods.getRowIndex(targetRow),
                    $rowIndex: tableMethods.getVMRowIndex(targetRow)
                  };
                  tableMethods.setTreeExpand(currentRow, true).then(() => tableMethods.scrollToRow(targetRow)).then(() => tablePrivateMethods.triggerCurrentRowEvent(evnt, params));
                }
              }
            }
          } else if (operArrow && keyboardConfig && keyboardOpts.isArrow) {
            if (!isEditStatus) {
              if (selected.row && selected.column) {
                $xeTable.moveArrowSelected(selected.args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt);
              }
            }
          } else if (isTab && keyboardConfig && keyboardOpts.isTab) {
            if (selected.row || selected.column) {
              $xeTable.moveTabSelected(selected.args, hasShiftKey, evnt);
            } else if (actived.row || actived.column) {
              $xeTable.moveTabSelected(actived.args, hasShiftKey, evnt);
            }
          } else if (keyboardConfig && keyboardOpts.isDel && hasDeleteKey && isEnableConf(editConfig) && (selected.row || selected.column)) {
            if (!isEditStatus) {
              const { delMethod } = keyboardOpts;
              const params = {
                row: selected.row,
                rowIndex: tableMethods.getRowIndex(selected.row),
                column: selected.column,
                columnIndex: tableMethods.getColumnIndex(selected.column),
                $table: $xeTable,
                $grid: $xeGrid
              };
              if (!beforeEditMethod || beforeEditMethod(params)) {
                if (delMethod) {
                  delMethod(params);
                } else {
                  setCellValue(selected.row, selected.column, null);
                }
                tableMethods.updateFooter();
                dispatchEvent("cell-delete-value", params, evnt);
              }
            }
          } else if (hasBackspaceKey && keyboardConfig && keyboardOpts.isBack && isEnableConf(editConfig) && (selected.row || selected.column)) {
            if (!isEditStatus) {
              const { backMethod } = keyboardOpts;
              if (keyboardOpts.isDel && isEnableConf(editConfig) && (selected.row || selected.column)) {
                const params = {
                  row: selected.row,
                  rowIndex: tableMethods.getRowIndex(selected.row),
                  column: selected.column,
                  columnIndex: tableMethods.getColumnIndex(selected.column),
                  $table: $xeTable,
                  $grid: $xeGrid
                };
                if (!beforeEditMethod || beforeEditMethod(params)) {
                  if (backMethod) {
                    backMethod(params);
                  } else {
                    setCellValue(selected.row, selected.column, null);
                    $xeTable.handleEdit(selected.args, evnt);
                  }
                  dispatchEvent("cell-backspace-value", params, evnt);
                }
              }
            }
          } else if (hasBackspaceKey && keyboardConfig && treeConfig && keyboardOpts.isBack && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {
            const { parent: parentRow } = import_xe_utils8.default.findTree(internalData.afterTreeFullData, (item) => item === currentRow, { children: childrenField });
            if (parentRow) {
              evnt.preventDefault();
              const params = {
                row: parentRow,
                rowIndex: tableMethods.getRowIndex(parentRow),
                $rowIndex: tableMethods.getVMRowIndex(parentRow),
                $table: $xeTable,
                $grid: $xeGrid
              };
              tableMethods.setTreeExpand(parentRow, false).then(() => tableMethods.scrollToRow(parentRow)).then(() => tablePrivateMethods.triggerCurrentRowEvent(evnt, params));
            }
          } else if (keyboardConfig && isEnableConf(editConfig) && keyboardOpts.isEdit && !hasCtrlKey && !hasMetaKey && (isSpacebar || keyCode >= 48 && keyCode <= 57 || keyCode >= 65 && keyCode <= 90 || keyCode >= 96 && keyCode <= 111 || keyCode >= 186 && keyCode <= 192 || keyCode >= 219 && keyCode <= 222)) {
            const { editMode, editMethod } = keyboardOpts;
            if (selected.column && selected.row && isEnableConf(selected.column.editRender)) {
              const beforeEditMethod2 = editOpts.beforeEditMethod || editOpts.activeMethod;
              const params = {
                row: selected.row,
                rowIndex: tableMethods.getRowIndex(selected.row),
                column: selected.column,
                columnIndex: tableMethods.getColumnIndex(selected.column),
                $table: $xeTable,
                $grid: $xeGrid
              };
              if (!beforeEditMethod2 || beforeEditMethod2(Object.assign(Object.assign({}, selected.args), { $table: $xeTable, $grid: $xeGrid }))) {
                if (editMethod) {
                  editMethod(params);
                } else {
                  if (editMode !== "insert") {
                    setCellValue(selected.row, selected.column, null);
                  }
                  $xeTable.handleEdit(selected.args, evnt);
                }
              }
            }
          }
          dispatchEvent("keydown", {}, evnt);
        });
      }
    };
    const handleGlobalPasteEvent = (evnt) => {
      const { keyboardConfig, mouseConfig } = props;
      const { editStore, filterStore } = reactData;
      const { isActivated } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xeTable.handlePasteCellAreaEvent) {
            $xeTable.handlePasteCellAreaEvent(evnt);
          }
        }
        dispatchEvent("paste", {}, evnt);
      }
    };
    const handleGlobalCopyEvent = (evnt) => {
      const { keyboardConfig, mouseConfig } = props;
      const { editStore, filterStore } = reactData;
      const { isActivated } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xeTable.handleCopyCellAreaEvent) {
            $xeTable.handleCopyCellAreaEvent(evnt);
          }
        }
        dispatchEvent("copy", {}, evnt);
      }
    };
    const handleGlobalCutEvent = (evnt) => {
      const { keyboardConfig, mouseConfig } = props;
      const { editStore, filterStore } = reactData;
      const { isActivated } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xeTable.handleCutCellAreaEvent) {
            $xeTable.handleCutCellAreaEvent(evnt);
          }
        }
        dispatchEvent("cut", {}, evnt);
      }
    };
    const handleGlobalResizeEvent = () => {
      if ($xeTable.closeMenu) {
        $xeTable.closeMenu();
      }
      const el = refElem.value;
      if (!el || !el.clientWidth) {
        return nextTick();
      }
      tableMethods.recalculate(true);
      tableMethods.updateCellAreas();
    };
    const handleTargetEnterEvent = (isClear) => {
      const $tooltip = refTooltip.value;
      clearTimeout(internalData.tooltipTimeout);
      if (isClear) {
        tableMethods.closeTooltip();
      } else {
        if ($tooltip && $tooltip.setActived) {
          $tooltip.setActived(true);
        }
      }
    };
    const clearDragStatus = () => {
      const { dragRow, dragCol } = reactData;
      if (dragRow || dragCol) {
        clearColDropOrigin();
        clearRowDropOrigin();
        hideDropTip();
        reactData.dragRow = null;
        reactData.dragCol = null;
        reactData.isDragColMove = false;
        reactData.isDragRowMove = false;
      }
    };
    const clearRowDropOrigin = () => {
      const el = refElem.value;
      if (el) {
        const clss = "row--drag-origin";
        import_xe_utils8.default.arrayEach(el.querySelectorAll(`.${clss}`), (elem) => {
          elem.draggable = false;
          removeClass(elem, clss);
        });
      }
    };
    const updateRowDropOrigin = (row) => {
      const el = refElem.value;
      if (el) {
        const clss = "row--drag-origin";
        const rowid = getRowid($xeTable, row);
        import_xe_utils8.default.arrayEach(el.querySelectorAll(`[rowid="${rowid}"]`), (elem) => {
          addClass(elem, clss);
        });
      }
    };
    const updateRowDropTipContent = (tdEl) => {
      const { dragConfig } = props;
      const { dragRow } = reactData;
      const rowDragOpts = computeRowDragOpts.value;
      const { tooltipMethod } = rowDragOpts;
      const rTooltipMethod = tooltipMethod || (dragConfig ? dragConfig.rowTooltipMethod : null);
      let tipContent = "";
      if (rTooltipMethod) {
        tipContent = `${rTooltipMethod({
          row: dragRow
        }) || ""}`;
      } else {
        tipContent = getI18n6("vxe.table.dragTip", [tdEl.textContent || ""]);
      }
      reactData.dragTipText = tipContent;
    };
    const updateColDropOrigin = (column) => {
      const el = refElem.value;
      if (el) {
        const colQuerys = [];
        import_xe_utils8.default.eachTree([column], (item) => {
          colQuerys.push(`[colid="${item.id}"]`);
        });
        const clss = "col--drag-origin";
        import_xe_utils8.default.arrayEach(el.querySelectorAll(colQuerys.join(",")), (elem) => {
          addClass(elem, clss);
        });
      }
    };
    const clearColDropOrigin = () => {
      const el = refElem.value;
      if (el) {
        const clss = "col--drag-origin";
        import_xe_utils8.default.arrayEach(el.querySelectorAll(`.${clss}`), (elem) => {
          elem.draggable = false;
          removeClass(elem, clss);
        });
      }
    };
    const updateColDropTipContent = (tdEl) => {
      const { dragCol } = reactData;
      const columnDragOpts = computeColumnDragOpts.value;
      const { tooltipMethod } = columnDragOpts;
      let tipContent = "";
      if (tooltipMethod) {
        tipContent = `${tooltipMethod({
          column: dragCol
        }) || ""}`;
      } else {
        tipContent = getI18n6("vxe.table.dragTip", [tdEl.textContent || ""]);
      }
      reactData.dragTipText = tipContent;
    };
    const showDropTip = (evnt, trEl, thEl, showLine, dragPos) => {
      const el = refElem.value;
      if (!el) {
        return;
      }
      const { overflowX, scrollbarWidth, overflowY, scrollbarHeight } = reactData;
      const { prevDragToChild } = internalData;
      const wrapperRect = el.getBoundingClientRect();
      const osbWidth = overflowY ? scrollbarWidth : 0;
      const osbHeight = overflowX ? scrollbarHeight : 0;
      const tableWrapperWidth = el.clientWidth;
      const tableWrapperHeight = el.clientHeight;
      if (trEl) {
        const rdLineEl = refDragRowLineElem.value;
        if (rdLineEl) {
          if (showLine) {
            const scrollbarYToLeft = computeScrollbarYToLeft.value;
            const trRect = trEl.getBoundingClientRect();
            let trHeight = trEl.clientHeight;
            const offsetTop = Math.max(1, trRect.y - wrapperRect.y);
            if (offsetTop + trHeight > tableWrapperHeight - osbHeight) {
              trHeight = tableWrapperHeight - offsetTop - osbHeight;
            }
            rdLineEl.style.display = "block";
            rdLineEl.style.left = `${scrollbarYToLeft ? osbWidth : 0}px`;
            rdLineEl.style.top = `${offsetTop}px`;
            rdLineEl.style.height = `${trHeight}px`;
            rdLineEl.style.width = `${tableWrapperWidth - osbWidth}px`;
            rdLineEl.setAttribute("drag-pos", dragPos);
            rdLineEl.setAttribute("drag-to-child", prevDragToChild ? "y" : "n");
          } else {
            rdLineEl.style.display = "";
          }
        }
      } else if (thEl) {
        const cdLineEl = refDragColLineElem.value;
        if (cdLineEl) {
          if (showLine) {
            const scrollbarXToTop = computeScrollbarXToTop.value;
            const leftContainerElem = refLeftContainer.value;
            const leftContainerWidth = leftContainerElem ? leftContainerElem.clientWidth : 0;
            const rightContainerElem = refRightContainer.value;
            const rightContainerWidth = rightContainerElem ? rightContainerElem.clientWidth : 0;
            const thRect = thEl.getBoundingClientRect();
            let thWidth = thEl.clientWidth;
            const offsetTop = Math.max(0, thRect.y - wrapperRect.y);
            const startX = leftContainerWidth;
            let offsetLeft = thRect.x - wrapperRect.x;
            if (offsetLeft < startX) {
              thWidth -= startX - offsetLeft;
              offsetLeft = startX;
            }
            const endX = tableWrapperWidth - rightContainerWidth - (rightContainerWidth ? 0 : osbWidth);
            if (offsetLeft + thWidth > endX) {
              thWidth = endX - offsetLeft;
            }
            cdLineEl.style.display = "block";
            cdLineEl.style.top = `${offsetTop}px`;
            cdLineEl.style.left = `${offsetLeft}px`;
            cdLineEl.style.width = `${thWidth}px`;
            if (prevDragToChild) {
              cdLineEl.style.height = `${thRect.height}px`;
            } else {
              cdLineEl.style.height = `${tableWrapperHeight - offsetTop - (scrollbarXToTop ? 0 : osbHeight)}px`;
            }
            cdLineEl.setAttribute("drag-pos", dragPos);
            cdLineEl.setAttribute("drag-to-child", prevDragToChild ? "y" : "n");
          } else {
            cdLineEl.style.display = "";
          }
        }
      }
      const rdTipEl = refDragTipElem.value;
      if (rdTipEl) {
        rdTipEl.style.display = "block";
        rdTipEl.style.top = `${Math.min(el.clientHeight - el.scrollTop - rdTipEl.clientHeight, evnt.clientY - wrapperRect.y)}px`;
        rdTipEl.style.left = `${Math.min(el.clientWidth - el.scrollLeft - rdTipEl.clientWidth - 16, evnt.clientX - wrapperRect.x)}px`;
        rdTipEl.setAttribute("drag-status", showLine ? prevDragToChild ? "sub" : "normal" : "disabled");
      }
    };
    const hideDropTip = () => {
      const rdTipEl = refDragTipElem.value;
      const rdLineEl = refDragRowLineElem.value;
      const cdLineEl = refDragColLineElem.value;
      if (rdTipEl) {
        rdTipEl.style.display = "";
      }
      if (rdLineEl) {
        rdLineEl.style.display = "";
      }
      if (cdLineEl) {
        cdLineEl.style.display = "";
      }
    };
    const handleTooltip = (evnt, tdEl, overflowElem, tipElem, params) => {
      const tipOverEl = overflowElem || tdEl;
      if (!tipOverEl) {
        return nextTick();
      }
      params.cell = tdEl;
      const { tooltipStore } = reactData;
      const tooltipOpts = computeTooltipOpts.value;
      const { column, row } = params;
      const { showAll, contentMethod } = tooltipOpts;
      const customContent = contentMethod ? contentMethod(params) : null;
      const useCustom = contentMethod && !import_xe_utils8.default.eqNull(customContent);
      const content = useCustom ? customContent : import_xe_utils8.default.toString(column.type === "html" ? tipOverEl.innerText : tipOverEl.textContent).trim();
      const isOver = tipOverEl.scrollWidth > tipOverEl.clientWidth;
      if (content && (showAll || useCustom || isOver)) {
        Object.assign(tooltipStore, {
          row,
          column,
          visible: true,
          currOpts: {}
        });
        nextTick(() => {
          const $tooltip = refTooltip.value;
          if ($tooltip && $tooltip.open) {
            $tooltip.open(isOver ? tipOverEl : tipElem, formatText(content));
          }
        });
      }
      return nextTick();
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if ($xeGrid) {
          return $xeGrid.callSlot(slotFunc, params);
        }
        if (import_xe_utils8.default.isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    tablePrivateMethods = {
      getSetupOptions() {
        return getConfig2();
      },
      updateAfterDataIndex,
      callSlot,
      /**
       * 获取父容器元素
       */
      getParentElem() {
        const el = refElem.value;
        if ($xeGrid) {
          const gridEl = $xeGrid.getRefMaps().refElem.value;
          return gridEl ? gridEl.parentNode : null;
        }
        return el ? el.parentNode : null;
      },
      /**
       * 获取父容器的高度
       */
      getParentHeight() {
        const { height } = props;
        const el = refElem.value;
        if (el) {
          const parentElem = el.parentNode;
          const parentPaddingSize = height === "100%" || height === "auto" ? getPaddingTopBottomSize(parentElem) : 0;
          let parentWrapperHeight = 0;
          if (parentElem) {
            if ($xeGrid && hasClass(parentElem, "vxe-grid--table-wrapper")) {
              parentWrapperHeight = $xeGrid.getParentHeight();
            } else {
              parentWrapperHeight = parentElem.clientHeight;
            }
          }
          return Math.floor(parentWrapperHeight - parentPaddingSize);
        }
        return 0;
      },
      /**
       * 获取需要排除的高度
       * 但渲染表格高度时，需要排除工具栏或分页等相关组件的高度
       * 如果存在表尾合计滚动条，则需要排除滚动条高度
       */
      getExcludeHeight() {
        return $xeGrid ? $xeGrid.getExcludeHeight() : 0;
      },
      /**
       * 定义行数据中的列属性，如果不存在则定义
       * @param {Row} records 行数据
       */
      defineField(records) {
        const { treeConfig } = props;
        const expandOpts = computeExpandOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const rowkey = getRowkey($xeTable);
        if (!import_xe_utils8.default.isArray(records)) {
          records = [records];
        }
        return records.map((record) => {
          internalData.tableFullColumn.forEach((column) => {
            const { field, editRender } = column;
            if (field && !import_xe_utils8.default.has(record, field) && !record[field]) {
              let cellValue = null;
              if (editRender) {
                const { defaultValue } = editRender;
                if (import_xe_utils8.default.isFunction(defaultValue)) {
                  cellValue = defaultValue({ column });
                } else if (!import_xe_utils8.default.isUndefined(defaultValue)) {
                  cellValue = defaultValue;
                }
              }
              import_xe_utils8.default.set(record, field, cellValue);
            }
          });
          const otherFields = [radioOpts.labelField, checkboxOpts.checkField, checkboxOpts.labelField, expandOpts.labelField];
          otherFields.forEach((key) => {
            if (key && eqEmptyValue(import_xe_utils8.default.get(record, key))) {
              import_xe_utils8.default.set(record, key, null);
            }
          });
          if (treeConfig && treeOpts.lazy && import_xe_utils8.default.isUndefined(record[childrenField])) {
            record[childrenField] = null;
          }
          if (eqEmptyValue(import_xe_utils8.default.get(record, rowkey))) {
            import_xe_utils8.default.set(record, rowkey, getRowUniqueId());
          }
          return record;
        });
      },
      handleTableData(force) {
        const { scrollYLoad } = reactData;
        const { scrollYStore, fullDataRowIdData } = internalData;
        let fullList = internalData.afterFullData;
        if (force) {
          updateAfterFullData();
          fullList = handleVirtualTreeToList();
        }
        const tableData = scrollYLoad ? fullList.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullList.slice(0);
        tableData.forEach((row, $index) => {
          const rowid = getRowid($xeTable, row);
          const rest = fullDataRowIdData[rowid];
          if (rest) {
            rest.$index = $index;
          }
        });
        reactData.tableData = tableData;
        return nextTick();
      },
      /**
       * 更新数据行的 Map
       */
      cacheRowMap() {
        const { treeConfig } = props;
        const { fullAllDataRowIdData, tableFullData, tableFullTreeData, treeExpandedMaps } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
        const { lazy } = treeOpts;
        const fullAllDataRowIdMaps = Object.assign({}, fullAllDataRowIdData);
        const fullDataRowIdMaps = {};
        const { handleUpdateRowId } = createHandleUpdateRowId($xeTable);
        const handleRowCache = (row, index, items, currIndex, parentRow, rowid, level, seq) => {
          let rowRest = fullAllDataRowIdMaps[rowid];
          if (!rowRest) {
            rowRest = { row, rowid, seq, index: -1, _index: -1, $index: -1, treeIndex: index, items, parent: parentRow, level, height: 0, resizeHeight: 0, oTop: 0, expandHeight: 0 };
            fullDataRowIdMaps[rowid] = rowRest;
            fullAllDataRowIdMaps[rowid] = rowRest;
          }
          rowRest.treeLoaded = false;
          rowRest.expandLoaded = false;
          rowRest.row = row;
          rowRest.items = items;
          rowRest.parent = parentRow;
          rowRest.level = level;
          rowRest.index = currIndex;
          rowRest.treeIndex = index;
          fullDataRowIdMaps[rowid] = rowRest;
          fullAllDataRowIdMaps[rowid] = rowRest;
        };
        if (treeConfig) {
          import_xe_utils8.default.eachTree(tableFullTreeData, (row, index, items, path, parentRow, nodes) => {
            const rowid = handleUpdateRowId(row);
            if (treeConfig && lazy) {
              if (row[hasChildField] && row[childrenField] === void 0) {
                row[childrenField] = null;
              }
              if (treeExpandedMaps[rowid]) {
                if (!row[childrenField] || !row[childrenField].length) {
                  delete treeExpandedMaps[rowid];
                }
              }
            }
            handleRowCache(row, index, items, parentRow ? -1 : index, parentRow, rowid, nodes.length - 1, toTreePathSeq(path));
          }, { children: childrenField });
        } else {
          tableFullData.forEach((row, index, items) => {
            handleRowCache(row, index, items, index, null, handleUpdateRowId(row), 0, index + 1);
          });
        }
        internalData.fullDataRowIdData = fullDataRowIdMaps;
        internalData.fullAllDataRowIdData = fullAllDataRowIdMaps;
        reactData.treeExpandedFlag++;
      },
      cacheSourceMap(fullData) {
        const { treeConfig } = props;
        const treeOpts = computeTreeOpts.value;
        const sourceData = import_xe_utils8.default.clone(fullData, true);
        const { handleUpdateRowId } = createHandleUpdateRowId($xeTable);
        const sourceRowIdData = {};
        const handleSourceRow = (row) => {
          const rowid = handleUpdateRowId(row);
          sourceRowIdData[rowid] = row;
        };
        if (treeConfig) {
          const childrenField = treeOpts.children || treeOpts.childrenField;
          import_xe_utils8.default.eachTree(sourceData, handleSourceRow, { children: treeOpts.transform ? treeOpts.mapChildrenField : childrenField });
        } else {
          sourceData.forEach(handleSourceRow);
        }
        internalData.sourceDataRowIdData = sourceRowIdData;
        internalData.tableSourceData = sourceData;
      },
      /**
       * 指定列宽的列进行拆分
       */
      analyColumnWidth() {
        const { tableFullColumn } = internalData;
        const columnOpts = computeColumnOpts.value;
        const { width: defaultWidth, minWidth: defaultMinWidth } = columnOpts;
        const resizeList = [];
        const pxList = [];
        const pxMinList = [];
        const autoMinList = [];
        const scaleList = [];
        const scaleMinList = [];
        const autoList = [];
        const remainList = [];
        tableFullColumn.forEach((column) => {
          if (defaultWidth && !column.width) {
            column.width = defaultWidth;
          }
          if (defaultMinWidth && !column.minWidth) {
            column.minWidth = defaultMinWidth;
          }
          if (column.visible) {
            if (column.resizeWidth) {
              resizeList.push(column);
            } else if (column.width === "auto") {
              autoList.push(column);
            } else if (isPx(column.width)) {
              pxList.push(column);
            } else if (isScale(column.width)) {
              scaleList.push(column);
            } else if (isPx(column.minWidth)) {
              pxMinList.push(column);
            } else if (column.minWidth === "auto") {
              autoMinList.push(column);
            } else if (isScale(column.minWidth)) {
              scaleMinList.push(column);
            } else {
              remainList.push(column);
            }
          }
        });
        Object.assign(reactData.columnStore, { resizeList, pxList, pxMinList, autoMinList, scaleList, scaleMinList, autoList, remainList });
      },
      handleColResizeMousedownEvent(evnt, fixedType, params) {
        evnt.stopPropagation();
        evnt.preventDefault();
        const { column } = params;
        const { overflowX, scrollbarHeight } = reactData;
        const { elemStore, visibleColumn } = internalData;
        const resizableOpts = computeResizableOpts.value;
        const osbHeight = overflowX ? scrollbarHeight : 0;
        const tableEl = refElem.value;
        const leftContainerElem = refLeftContainer.value;
        const rightContainerElem = refRightContainer.value;
        const resizeBarElem = refColResizeBar.value;
        if (!resizeBarElem) {
          return;
        }
        const resizeTipElem = resizeBarElem.firstElementChild;
        const scrollbarXToTop = computeScrollbarXToTop.value;
        const { clientX: dragClientX } = evnt;
        const wrapperElem = refElem.value;
        const dragBtnElem = evnt.target;
        let resizeColumn = column;
        if (column.children && column.children.length) {
          import_xe_utils8.default.eachTree(column.children, (childColumn) => {
            resizeColumn = childColumn;
          });
        }
        const cell = dragBtnElem.parentNode;
        const cellParams = Object.assign(params, { cell });
        let dragLeft = 0;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        if (!bodyScrollElem) {
          return;
        }
        const pos = getOffsetPos(dragBtnElem, wrapperElem);
        const dragBtnWidth = dragBtnElem.clientWidth;
        const dragBtnOffsetWidth = Math.floor(dragBtnWidth / 2);
        const minInterval = getColReMinWidth(cellParams) - dragBtnOffsetWidth;
        let dragMinLeft = pos.left - cell.clientWidth + dragBtnWidth + minInterval;
        let dragPosLeft = pos.left + dragBtnOffsetWidth;
        const isLeftFixed = fixedType === "left";
        const isRightFixed = fixedType === "right";
        let fixedOffsetWidth = 0;
        if (isLeftFixed || isRightFixed) {
          const siblingProp = isLeftFixed ? "nextElementSibling" : "previousElementSibling";
          let tempCellElem = cell[siblingProp];
          while (tempCellElem) {
            if (hasClass(tempCellElem, "fixed--hidden")) {
              break;
            } else if (!hasClass(tempCellElem, "col--group")) {
              fixedOffsetWidth += tempCellElem.offsetWidth;
            }
            tempCellElem = tempCellElem[siblingProp];
          }
          if (isRightFixed && rightContainerElem) {
            dragPosLeft = rightContainerElem.offsetLeft + fixedOffsetWidth;
          }
        }
        const updateEvent = (evnt2) => {
          evnt2.stopPropagation();
          evnt2.preventDefault();
          const tableHeight = tableEl.clientHeight;
          const offsetX = evnt2.clientX - dragClientX;
          let left = dragPosLeft + offsetX;
          const scrollLeft = fixedType ? 0 : bodyScrollElem.scrollLeft;
          if (isLeftFixed) {
            left = Math.min(left, (rightContainerElem ? rightContainerElem.offsetLeft : bodyScrollElem.clientWidth) - fixedOffsetWidth - minInterval);
          } else if (isRightFixed) {
            dragMinLeft = (leftContainerElem ? leftContainerElem.clientWidth : 0) + fixedOffsetWidth + minInterval;
            left = Math.min(left, dragPosLeft + cell.clientWidth - minInterval);
          } else {
            dragMinLeft = Math.max(bodyScrollElem.scrollLeft, dragMinLeft);
          }
          dragLeft = Math.max(left, dragMinLeft);
          const resizeBarLeft = Math.max(1, dragLeft - scrollLeft);
          resizeBarElem.style.left = `${resizeBarLeft}px`;
          resizeBarElem.style.top = `${scrollbarXToTop ? osbHeight : 0}px`;
          resizeBarElem.style.height = `${scrollbarXToTop ? tableHeight - osbHeight : tableHeight}px`;
          if (resizableOpts.showDragTip && resizeTipElem) {
            resizeTipElem.textContent = getI18n6("vxe.table.resizeColTip", [resizeColumn.renderWidth + (isRightFixed ? dragPosLeft - dragLeft : dragLeft - dragPosLeft)]);
            const tableWrapperWidth = tableEl.clientWidth;
            const wrapperRect = wrapperElem.getBoundingClientRect();
            const resizeBarWidth = resizeBarElem.clientWidth;
            const resizeTipWidth = resizeTipElem.clientWidth;
            const resizeTipHeight = resizeTipElem.clientHeight;
            let resizeTipLeft = -resizeTipWidth;
            if (resizeBarLeft < resizeTipWidth + resizeBarWidth) {
              resizeTipLeft = 0;
            } else if (resizeBarLeft > tableWrapperWidth) {
              resizeTipLeft += tableWrapperWidth - resizeBarLeft;
            }
            resizeTipElem.style.left = `${resizeTipLeft}px`;
            resizeTipElem.style.top = `${Math.min(tableHeight - resizeTipHeight, Math.max(0, evnt2.clientY - wrapperRect.y - resizeTipHeight / 2))}px`;
          }
          reactData.isDragResize = true;
        };
        reactData.isDragResize = true;
        addClass(tableEl, "col-drag--resize");
        resizeBarElem.style.display = "block";
        document.onmousemove = updateEvent;
        document.onmouseup = function(evnt2) {
          document.onmousemove = null;
          document.onmouseup = null;
          resizeBarElem.style.display = "none";
          internalData._lastResizeTime = Date.now();
          setTimeout(() => {
            reactData.isDragResize = false;
          }, 50);
          const resizeWidth = resizeColumn.renderWidth + (isRightFixed ? dragPosLeft - dragLeft : dragLeft - dragPosLeft);
          const resizeParams = Object.assign(Object.assign({}, params), { resizeWidth, resizeColumn });
          if (resizableOpts.dragMode === "fixed") {
            visibleColumn.forEach((item) => {
              if (item.id !== resizeColumn.id) {
                if (!item.resizeWidth) {
                  item.resizeWidth = item.renderWidth;
                }
              }
            });
          }
          if ($xeTable.handleColResizeCellAreaEvent) {
            $xeTable.handleColResizeCellAreaEvent(evnt2, resizeParams);
          } else {
            resizeColumn.resizeWidth = resizeWidth;
            handleUpdateColResize(evnt2, resizeParams);
          }
          removeClass(tableEl, "col-drag--resize");
        };
        updateEvent(evnt);
        if ($xeTable.closeMenu) {
          $xeTable.closeMenu();
        }
      },
      handleColResizeDblclickEvent(evnt, params) {
        const resizableOpts = computeResizableOpts.value;
        const { isDblclickAutoWidth } = resizableOpts;
        const el = refElem.value;
        if (isDblclickAutoWidth && el) {
          evnt.stopPropagation();
          evnt.preventDefault();
          const { fullColumnIdData } = internalData;
          const { column } = params;
          let resizeColumn = column;
          if (column.children && column.children.length) {
            import_xe_utils8.default.eachTree(column.children, (childColumn) => {
              resizeColumn = childColumn;
            });
          }
          const colid = resizeColumn.id;
          const colRest = fullColumnIdData[colid];
          const dragBtnElem = evnt.target;
          const cell = dragBtnElem.parentNode;
          const cellParams = Object.assign(params, { cell });
          const colMinWidth = getColReMinWidth(cellParams);
          el.setAttribute("data-calc-col", "Y");
          let resizeWidth = calcColumnAutoWidth(resizeColumn, el);
          el.removeAttribute("data-calc-col");
          if (colRest) {
            resizeWidth = Math.max(resizeWidth, colRest.width);
          }
          resizeWidth = Math.max(colMinWidth, resizeWidth);
          const resizeParams = Object.assign(Object.assign({}, params), { resizeWidth, resizeColumn });
          reactData.isDragResize = false;
          internalData._lastResizeTime = Date.now();
          if ($xeTable.handleColResizeDblclickCellAreaEvent) {
            $xeTable.handleColResizeDblclickCellAreaEvent(evnt, resizeParams);
          } else {
            resizeColumn.resizeWidth = resizeWidth;
            handleUpdateColResize(evnt, resizeParams);
          }
        }
      },
      handleRowResizeMousedownEvent(evnt, params) {
        evnt.stopPropagation();
        evnt.preventDefault();
        const { row } = params;
        const { overflowX, scrollbarWidth, overflowY, scrollbarHeight } = reactData;
        const { elemStore, fullAllDataRowIdData } = internalData;
        const osbWidth = overflowY ? scrollbarWidth : 0;
        const osbHeight = overflowX ? scrollbarHeight : 0;
        const scrollbarYToLeft = computeScrollbarYToLeft.value;
        const resizableOpts = computeResizableOpts.value;
        const rowOpts = computeRowOpts.value;
        const cellOpts = computeCellOpts.value;
        const tableEl = refElem.value;
        const resizeBarElem = refRowResizeBar.value;
        if (!resizeBarElem) {
          return;
        }
        const { clientY: dragClientY } = evnt;
        const resizeTipElem = resizeBarElem.firstElementChild;
        const dragBtnElem = evnt.currentTarget;
        const tdEl = dragBtnElem.parentNode;
        const trEl = tdEl.parentNode;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        if (!bodyScrollElem) {
          return;
        }
        const rowid = getRowid($xeTable, row);
        const rowRest = fullAllDataRowIdData[rowid];
        if (!rowRest) {
          return;
        }
        const defaultRowHeight = computeDefaultRowHeight.value;
        const currCellHeight = rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
        const tableRect = tableEl.getBoundingClientRect();
        const trRect = trEl.getBoundingClientRect();
        const targetOffsetY = dragClientY - trRect.y - trEl.clientHeight;
        let resizeHeight = currCellHeight;
        const cellEl = tdEl.querySelector(".vxe-cell");
        let cellMinHeight = 0;
        if (cellEl) {
          const cellStyle = getComputedStyle(cellEl);
          cellMinHeight = Math.max(1, Math.ceil(import_xe_utils8.default.toNumber(cellStyle.paddingTop) + import_xe_utils8.default.toNumber(cellStyle.paddingBottom)));
        }
        const minTop = trRect.y - tableRect.y + cellMinHeight;
        const updateEvent = (evnt2) => {
          evnt2.stopPropagation();
          evnt2.preventDefault();
          const rtWidth = tableEl.clientWidth - osbWidth;
          const tableHeight = tableEl.clientHeight - osbHeight;
          let dragTop = evnt2.clientY - tableRect.y - targetOffsetY;
          if (dragTop < minTop) {
            dragTop = minTop;
          } else {
            resizeHeight = Math.max(cellMinHeight, currCellHeight + evnt2.clientY - dragClientY);
          }
          resizeBarElem.style.left = `${scrollbarYToLeft ? osbWidth : 0}px`;
          resizeBarElem.style.top = `${dragTop}px`;
          resizeBarElem.style.width = `${rtWidth}px`;
          if (resizableOpts.showDragTip && resizeTipElem) {
            resizeTipElem.textContent = getI18n6("vxe.table.resizeRowTip", [resizeHeight]);
            const resizeTipWidth = resizeTipElem.clientWidth;
            const resizeTipHeight = resizeTipElem.clientHeight;
            let resizeBarLeft = Math.max(2, evnt2.clientX - tableRect.x);
            let resizeBarTop = 0;
            if (resizeBarLeft + resizeTipWidth >= rtWidth - 2) {
              resizeBarLeft = rtWidth - resizeTipWidth - 2;
            }
            if (dragTop + resizeTipHeight >= tableHeight) {
              resizeBarTop = tableHeight - (dragTop + resizeTipHeight);
            }
            resizeTipElem.style.left = `${resizeBarLeft}px`;
            resizeTipElem.style.top = `${resizeBarTop}px`;
          }
          reactData.isDragResize = true;
        };
        reactData.isDragResize = true;
        addClass(tableEl, "row-drag--resize");
        resizeBarElem.style.display = "block";
        document.onmousemove = updateEvent;
        document.onmouseup = function(evnt2) {
          document.onmousemove = null;
          document.onmouseup = null;
          resizeBarElem.style.display = "none";
          internalData._lastResizeTime = Date.now();
          setTimeout(() => {
            reactData.isDragResize = false;
          }, 50);
          if (resizeHeight !== currCellHeight) {
            const resizeParams = Object.assign(Object.assign({}, params), { resizeHeight, resizeRow: row });
            internalData.isResizeCellHeight = true;
            if ($xeTable.handleRowResizeCellAreaEvent) {
              $xeTable.handleRowResizeCellAreaEvent(evnt2, resizeParams);
            } else {
              rowRest.resizeHeight = resizeHeight;
              handleUpdateRowResize(evnt2, resizeParams);
              updateRowOffsetTop();
            }
          }
          removeClass(tableEl, "row-drag--resize");
        };
        updateEvent(evnt);
      },
      handleRowResizeDblclickEvent(evnt, params) {
        const resizableOpts = computeResizableOpts.value;
        const { isDblclickAutoHeight } = resizableOpts;
        const el = refElem.value;
        if (isDblclickAutoHeight && el) {
          evnt.stopPropagation();
          evnt.preventDefault();
          const { editStore } = reactData;
          const { fullAllDataRowIdData } = internalData;
          const { actived } = editStore;
          const { row } = params;
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          if (!rowRest) {
            return;
          }
          const handleRsHeight = () => {
            el.setAttribute("data-calc-row", "Y");
            const resizeHeight = calcCellAutoHeight(rowRest, el);
            el.removeAttribute("data-calc-row");
            const resizeParams = Object.assign(Object.assign({}, params), { resizeHeight, resizeRow: row });
            reactData.isDragResize = false;
            internalData._lastResizeTime = Date.now();
            if ($xeTable.handleRowResizeDblclickCellAreaEvent) {
              $xeTable.handleRowResizeDblclickCellAreaEvent(evnt, resizeParams);
            } else {
              rowRest.resizeHeight = resizeHeight;
              handleUpdateRowResize(evnt, resizeParams);
            }
          };
          if (actived.row || actived.column) {
            $xeTable.clearEdit().then(handleRsHeight);
          } else {
            handleRsHeight();
          }
        }
      },
      saveCustomStore(type) {
        const { customConfig } = props;
        const tableId = computeTableId.value;
        const customOpts = computeCustomOpts.value;
        const { updateStore, storage } = customOpts;
        const isAllCustom = storage === true;
        const storageOpts = isAllCustom ? {} : Object.assign({}, storage || {});
        const isCustomResizable = isAllCustom || storageOpts.resizable;
        const isCustomVisible = isAllCustom || storageOpts.visible;
        const isCustomFixed = isAllCustom || storageOpts.fixed;
        const isCustomSort = isAllCustom || storageOpts.sort;
        if (type !== "reset") {
          reactData.isCustomStatus = true;
        }
        if ((customConfig ? isEnableConf(customOpts) : customOpts.enabled) && (isCustomResizable || isCustomVisible || isCustomFixed || isCustomSort)) {
          if (!tableId) {
            errLog("vxe.error.reqProp", ["id"]);
            return nextTick();
          }
          const storeData = type === "reset" ? {
            resizableData: {},
            sortData: {},
            visibleData: {},
            fixedData: {}
          } : tableMethods.getCustomStoreData();
          if (updateStore) {
            return updateStore({
              id: tableId,
              type,
              storeData
            });
          } else {
            setCustomStorageMap(tableId, type === "reset" ? null : storeData);
          }
        }
        return nextTick();
      },
      handleCustom() {
        const { mouseConfig } = props;
        if (mouseConfig) {
          if ($xeTable.clearSelected) {
            $xeTable.clearSelected();
          }
          if ($xeTable.clearCellAreas) {
            $xeTable.clearCellAreas();
            $xeTable.clearCopyCellArea();
          }
        }
        tablePrivateMethods.analyColumnWidth();
        return tableMethods.refreshColumn(true);
      },
      handleUpdateDataQueue() {
        reactData.upDataFlag++;
      },
      handleRefreshColumnQueue() {
        reactData.reColumnFlag++;
      },
      preventEvent(evnt, type, args, next, end) {
        let evntList = interceptor.get(type);
        if (!evntList.length && type === "event.clearEdit") {
          evntList = interceptor.get("event.clearActived");
          if (true) {
            if (evntList.length) {
              warnLog("vxe.error.delEvent", ["event.clearActived", "event.clearEdit"]);
            }
          }
        }
        let rest = null;
        let isStop = false;
        for (let i = 0; i < evntList.length; i++) {
          const func = evntList[i];
          const fnRest = func(Object.assign({ $grid: $xeGrid, $table: $xeTable, $event: evnt }, args));
          if (fnRest === false) {
            isStop = true;
            break;
          } else if (fnRest && fnRest.status === false) {
            rest = fnRest.result;
            isStop = true;
            break;
          }
        }
        if (!isStop) {
          if (next) {
            rest = next();
          }
        }
        if (end) {
          end();
        }
        return rest;
      },
      updateCheckboxStatus() {
        const { treeConfig } = props;
        const { selectCheckboxMaps, treeIndeterminateRowMaps } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, checkStrictly, checkMethod } = checkboxOpts;
        const { afterTreeFullData } = internalData;
        if (checkStrictly) {
          return;
        }
        if (treeConfig) {
          const { handleGetRowId } = createHandleGetRowId($xeTable);
          const childRowMaps = {};
          const childRowList = [];
          import_xe_utils8.default.eachTree(afterTreeFullData, (row) => {
            const rowid = handleGetRowId(row);
            const childList = row[transform ? mapChildrenField : childrenField];
            if (childList && childList.length && !childRowMaps[rowid]) {
              childRowMaps[rowid] = 1;
              childRowList.unshift([row, rowid, childList]);
            }
          }, { children: transform ? mapChildrenField : childrenField });
          childRowList.forEach((vals) => {
            const row = vals[0];
            const rowid = vals[1];
            const childList = vals[2];
            let sLen = 0;
            let hLen = 0;
            let vLen = 0;
            childList.forEach(checkMethod ? (item) => {
              const childRowid = handleGetRowId(item);
              const isSelect = checkField ? import_xe_utils8.default.get(item, checkField) : selectCheckboxMaps[childRowid];
              if (checkMethod({ row: item })) {
                if (isSelect) {
                  sLen++;
                } else if (treeIndeterminateRowMaps[childRowid]) {
                  hLen++;
                }
                vLen++;
              } else {
                if (isSelect) {
                  sLen++;
                } else if (treeIndeterminateRowMaps[childRowid]) {
                  hLen++;
                }
              }
            } : (item) => {
              const childRowid = handleGetRowId(item);
              const isSelect = checkField ? import_xe_utils8.default.get(item, checkField) : selectCheckboxMaps[childRowid];
              if (isSelect) {
                sLen++;
              } else if (treeIndeterminateRowMaps[childRowid]) {
                hLen++;
              }
              vLen++;
            });
            const isSelected = sLen >= vLen;
            const halfSelect = !isSelected && (sLen >= 1 || hLen >= 1);
            if (checkField) {
              import_xe_utils8.default.set(row, checkField, isSelected);
            }
            if (isSelected) {
              if (!checkField) {
                selectCheckboxMaps[rowid] = row;
              }
              if (treeIndeterminateRowMaps[rowid]) {
                delete treeIndeterminateRowMaps[rowid];
              }
            } else {
              if (!checkField) {
                if (selectCheckboxMaps[rowid]) {
                  delete selectCheckboxMaps[rowid];
                }
              }
              if (halfSelect) {
                treeIndeterminateRowMaps[rowid] = row;
              } else {
                if (treeIndeterminateRowMaps[rowid]) {
                  delete treeIndeterminateRowMaps[rowid];
                }
              }
            }
          });
        }
        reactData.updateCheckboxFlag++;
      },
      updateAllCheckboxStatus() {
        const { treeConfig } = props;
        const { afterFullData, afterTreeFullData, checkboxReserveRowMap, selectCheckboxMaps, treeIndeterminateRowMaps } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, checkMethod, showReserveStatus } = checkboxOpts;
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        let sLen = 0;
        let hLen = 0;
        let vLen = 0;
        const rootList = treeConfig ? afterTreeFullData : afterFullData;
        rootList.forEach(checkMethod ? (row) => {
          const childRowid = handleGetRowId(row);
          const selected = checkField ? import_xe_utils8.default.get(row, checkField) : selectCheckboxMaps[childRowid];
          if (checkMethod({ row })) {
            if (selected) {
              sLen++;
            } else if (treeIndeterminateRowMaps[childRowid]) {
              hLen++;
            }
            vLen++;
          } else {
            if (selected) {
              sLen++;
            } else if (treeIndeterminateRowMaps[childRowid]) {
              hLen++;
            }
          }
        } : (row) => {
          const childRowid = handleGetRowId(row);
          const selected = checkField ? import_xe_utils8.default.get(row, checkField) : selectCheckboxMaps[childRowid];
          if (selected) {
            sLen++;
          } else if (treeIndeterminateRowMaps[childRowid]) {
            hLen++;
          }
          vLen++;
        });
        const isSelected = rootList.length > 0 ? vLen > 0 ? sLen >= vLen : sLen >= rootList.length : false;
        let halfSelect = !isSelected && (sLen >= 1 || hLen >= 1);
        if (!isSelected && !halfSelect && showReserveStatus) {
          halfSelect = !import_xe_utils8.default.isEmpty(checkboxReserveRowMap);
        }
        reactData.isAllSelected = isSelected;
        reactData.isIndeterminate = halfSelect;
      },
      checkSelectionStatus() {
        $xeTable.updateCheckboxStatus();
        $xeTable.updateAllCheckboxStatus();
      },
      /**
       * 切换选中
       * 多选，行选中事件
       */
      handleBatchSelectRows(rows, checked, isForce) {
        const { treeConfig } = props;
        const { selectCheckboxMaps } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, checkStrictly, checkMethod } = checkboxOpts;
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
        if (checkField) {
          if (treeConfig && !checkStrictly) {
            import_xe_utils8.default.eachTree(rows, (row) => {
              if (isForce || (!checkMethod || checkMethod({ row }))) {
                import_xe_utils8.default.set(row, checkField, checked);
                if (indeterminateField) {
                  import_xe_utils8.default.set(row, indeterminateField, false);
                }
                handleCheckboxReserveRow(row, checked);
              }
            }, { children: transform ? mapChildrenField : childrenField });
            reactData.updateCheckboxFlag++;
            return;
          }
          rows.forEach((row) => {
            if (isForce || (!checkMethod || checkMethod({ row }))) {
              import_xe_utils8.default.set(row, checkField, checked);
              handleCheckboxReserveRow(row, checked);
            }
          });
          reactData.updateCheckboxFlag++;
          return;
        }
        if (treeConfig && !checkStrictly) {
          import_xe_utils8.default.eachTree(rows, (row) => {
            const rowid = handleGetRowId(row);
            if (isForce || (!checkMethod || checkMethod({ row }))) {
              if (checked) {
                selectCheckboxMaps[rowid] = row;
              } else {
                if (selectCheckboxMaps[rowid]) {
                  delete selectCheckboxMaps[rowid];
                }
              }
              handleCheckboxReserveRow(row, checked);
            }
          }, { children: transform ? mapChildrenField : childrenField });
          reactData.updateCheckboxFlag++;
          return;
        }
        rows.forEach((row) => {
          const rowid = handleGetRowId(row);
          if (isForce || (!checkMethod || checkMethod({ row }))) {
            if (checked) {
              if (!selectCheckboxMaps[rowid]) {
                selectCheckboxMaps[rowid] = row;
              }
            } else {
              if (selectCheckboxMaps[rowid]) {
                delete selectCheckboxMaps[rowid];
              }
            }
            handleCheckboxReserveRow(row, checked);
            reactData.updateCheckboxFlag++;
          }
        });
      },
      /**
       * 即将移除
       * @deprecated
       */
      handleSelectRow({ row }, checked, isForce) {
        $xeTable.handleBatchSelectRows([row], checked, isForce);
      },
      triggerHeaderTitleEvent(evnt, iconParams, params) {
        const tipContent = iconParams.content || iconParams.message;
        if (tipContent) {
          const { tooltipStore } = reactData;
          const { column } = params;
          const content = getFuncText(tipContent);
          handleTargetEnterEvent(true);
          tooltipStore.row = null;
          tooltipStore.column = column;
          tooltipStore.visible = true;
          tooltipStore.currOpts = iconParams;
          nextTick(() => {
            const $tooltip = refTooltip.value;
            if ($tooltip && $tooltip.open) {
              $tooltip.open(evnt.currentTarget, content);
            }
          });
        }
      },
      /**
       * 触发表头 tooltip 事件
       */
      triggerHeaderTooltipEvent(evnt, params) {
        const { tooltipStore } = reactData;
        const { column } = params;
        handleTargetEnterEvent(true);
        const titleElem = evnt.currentTarget;
        if (!titleElem) {
          return;
        }
        const cellEl = titleElem.parentElement;
        if (!cellEl) {
          return;
        }
        const thEl = cellEl.parentElement;
        if (!thEl) {
          return;
        }
        if (tooltipStore.column !== column || !tooltipStore.visible) {
          handleTooltip(evnt, thEl, thEl.querySelector(".vxe-cell--wrapper"), thEl.querySelector(".vxe-cell--title") || cellEl, params);
        }
      },
      /**
       * 触发单元格 tooltip 事件
       */
      triggerBodyTooltipEvent(evnt, params) {
        const { editConfig } = props;
        const { editStore } = reactData;
        const { tooltipStore } = reactData;
        const editOpts = computeEditOpts.value;
        const { actived } = editStore;
        const { row, column } = params;
        const tdEl = evnt.currentTarget;
        handleTargetEnterEvent(tooltipStore.column !== column || tooltipStore.row !== row);
        if (column.editRender && isEnableConf(editConfig)) {
          if (editOpts.mode === "row" && actived.row === row) {
            return;
          }
          if (actived.row === row && actived.column === column) {
            return;
          }
        }
        if (tooltipStore.column !== column || tooltipStore.row !== row || !tooltipStore.visible) {
          handleTooltip(evnt, tdEl, tdEl.querySelector(".vxe-cell--wrapper"), tdEl.querySelector(".vxe-cell--label") || tdEl.querySelector(".vxe-cell--wrapper"), params);
        }
      },
      /**
       * 触发表尾 tooltip 事件
       */
      triggerFooterTooltipEvent(evnt, params) {
        const { column } = params;
        const { tooltipStore } = reactData;
        const tdEl = evnt.currentTarget;
        handleTargetEnterEvent(tooltipStore.column !== column || !!tooltipStore.row);
        if (tooltipStore.column !== column || !tooltipStore.visible) {
          handleTooltip(evnt, tdEl, tdEl.querySelector(".vxe-cell--wrapper"), tdEl.querySelector(".vxe-cell--label") || tdEl.querySelector(".vxe-cell--wrapper"), params);
        }
      },
      handleTargetLeaveEvent() {
        const tooltipOpts = computeTooltipOpts.value;
        let $tooltip = refTooltip.value;
        if ($tooltip && $tooltip.setActived) {
          $tooltip.setActived(false);
        }
        if (tooltipOpts.enterable) {
          internalData.tooltipTimeout = setTimeout(() => {
            $tooltip = refTooltip.value;
            if ($tooltip && $tooltip.isActived && !$tooltip.isActived()) {
              $xeTable.closeTooltip();
            }
          }, tooltipOpts.leaveDelay);
        } else {
          $xeTable.closeTooltip();
        }
      },
      triggerHeaderCellClickEvent(evnt, params) {
        const { _lastResizeTime } = internalData;
        const sortOpts = computeSortOpts.value;
        const columnOpts = computeColumnOpts.value;
        const currentColumnOpts = computeCurrentColumnOpts.value;
        const { column } = params;
        const cell = evnt.currentTarget;
        const triggerResizable = _lastResizeTime && _lastResizeTime > Date.now() - 300;
        const triggerSort = getEventTargetNode(evnt, cell, "vxe-cell--sort").flag;
        const triggerFilter = getEventTargetNode(evnt, cell, "vxe-cell--filter").flag;
        if (sortOpts.trigger === "cell" && !(triggerResizable || triggerSort || triggerFilter)) {
          $xeTable.triggerSortEvent(evnt, column, getNextSortOrder(column));
        }
        dispatchEvent("header-cell-click", Object.assign({ triggerResizable, triggerSort, triggerFilter, cell }, params), evnt);
        if ((columnOpts.isCurrent || props.highlightCurrentColumn) && (!currentColumnOpts.trigger || ["header", "default"].includes(currentColumnOpts.trigger))) {
          $xeTable.triggerCurrentColumnEvent(evnt, params);
        }
      },
      triggerHeaderCellDblclickEvent(evnt, params) {
        dispatchEvent("header-cell-dblclick", Object.assign({ cell: evnt.currentTarget }, params), evnt);
      },
      /**
       * 列点击事件
       * 如果是单击模式，则激活为编辑状态
       * 如果是双击模式，则单击后选中状态
       */
      triggerCellClickEvent(evnt, params) {
        const { highlightCurrentRow, highlightCurrentColumn, editConfig } = props;
        const { editStore, isDragResize } = reactData;
        if (isDragResize) {
          return;
        }
        const expandOpts = computeExpandOpts.value;
        const editOpts = computeEditOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const keyboardOpts = computeKeyboardOpts.value;
        const rowOpts = computeRowOpts.value;
        const columnOpts = computeColumnOpts.value;
        const currentColumnOpts = computeCurrentColumnOpts.value;
        const { actived, focused } = editStore;
        const { row, column } = params;
        const { type, treeNode } = column;
        const isRadioType = type === "radio";
        const isCheckboxType = type === "checkbox";
        const isExpandType = type === "expand";
        const cell = evnt.currentTarget;
        const triggerRadio = isRadioType && getEventTargetNode(evnt, cell, "vxe-cell--radio").flag;
        const triggerCheckbox = isCheckboxType && getEventTargetNode(evnt, cell, "vxe-cell--checkbox").flag;
        const triggerTreeNode = treeNode && getEventTargetNode(evnt, cell, "vxe-tree--btn-wrapper").flag;
        const triggerExpandNode = isExpandType && getEventTargetNode(evnt, cell, "vxe-table--expanded").flag;
        params = Object.assign({ cell, triggerRadio, triggerCheckbox, triggerTreeNode, triggerExpandNode }, params);
        if (!triggerCheckbox && !triggerRadio) {
          if (!triggerExpandNode && (expandOpts.trigger === "row" || isExpandType && expandOpts.trigger === "cell")) {
            $xeTable.triggerRowExpandEvent(evnt, params);
          }
          if (treeOpts.trigger === "row" || treeNode && treeOpts.trigger === "cell") {
            $xeTable.triggerTreeExpandEvent(evnt, params);
          }
        }
        if (!triggerTreeNode) {
          if (!triggerExpandNode) {
            if (rowOpts.isCurrent || highlightCurrentRow) {
              if (!triggerCheckbox && !triggerRadio) {
                $xeTable.triggerCurrentRowEvent(evnt, params);
              }
            }
            if ((columnOpts.isCurrent || highlightCurrentColumn) && (!currentColumnOpts.trigger || ["cell", "default"].includes(currentColumnOpts.trigger))) {
              if (!triggerCheckbox && !triggerRadio) {
                $xeTable.triggerCurrentColumnEvent(evnt, params);
              }
            }
            if (!triggerRadio && (radioOpts.trigger === "row" || isRadioType && radioOpts.trigger === "cell")) {
              $xeTable.triggerRadioRowEvent(evnt, params);
            }
            if (!triggerCheckbox && (checkboxOpts.trigger === "row" || isCheckboxType && checkboxOpts.trigger === "cell")) {
              $xeTable.handleToggleCheckRowEvent(evnt, params);
            }
          }
          if (isEnableConf(editConfig)) {
            if (keyboardOpts.arrowCursorLock && evnt && editOpts.mode === "cell" && evnt.target && /^input|textarea$/i.test(evnt.target.tagName)) {
              focused.column = column;
              focused.row = row;
            }
            if (editOpts.trigger === "manual") {
              if (actived.args && actived.row === row && column !== actived.column) {
                handleChangeCell(evnt, params);
              }
            } else if (!actived.args || row !== actived.row || column !== actived.column) {
              if (editOpts.trigger === "click") {
                handleChangeCell(evnt, params);
              } else if (editOpts.trigger === "dblclick") {
                if (editOpts.mode === "row" && actived.row === row) {
                  handleChangeCell(evnt, params);
                }
              }
            }
          }
        }
        if (isEnableConf(editConfig) && editOpts.trigger === "dblclick") {
          if (actived.row && actived.column) {
            if (editOpts.mode === "row") {
              if (!$xeTable.eqRow(actived.row, row)) {
                $xeTable.handleClearEdit(evnt);
              }
            } else if (editOpts.mode === "cell") {
              if (!$xeTable.eqRow(actived.row, row) || actived.column.id !== column.id) {
                $xeTable.handleClearEdit(evnt);
              }
            }
          }
        }
        dispatchEvent("cell-click", params, evnt);
      },
      /**
       * 列双击点击事件
       * 如果是双击模式，则激活为编辑状态
       */
      triggerCellDblclickEvent(evnt, params) {
        const { editConfig } = props;
        const { editStore, isDragResize } = reactData;
        if (isDragResize) {
          return;
        }
        const editOpts = computeEditOpts.value;
        const { actived } = editStore;
        const cell = evnt.currentTarget;
        params = Object.assign({ cell }, params);
        if (isEnableConf(editConfig) && editOpts.trigger === "dblclick") {
          if (!actived.args || evnt.currentTarget !== actived.args.cell) {
            if (editOpts.mode === "row") {
              checkValidate("blur").catch((e) => e).then(() => {
                $xeTable.handleEdit(params, evnt).then(() => checkValidate("change")).catch((e) => e);
              });
            } else if (editOpts.mode === "cell") {
              $xeTable.handleEdit(params, evnt).then(() => checkValidate("change")).catch((e) => e);
            }
          }
        }
        dispatchEvent("cell-dblclick", params, evnt);
      },
      handleToggleCheckRowEvent(evnt, params) {
        const { selectCheckboxMaps } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, trigger } = checkboxOpts;
        const { row } = params;
        if (trigger === "manual") {
          return;
        }
        let checked = false;
        if (checkField) {
          checked = !import_xe_utils8.default.get(row, checkField);
        } else {
          checked = !selectCheckboxMaps[getRowid($xeTable, row)];
        }
        if (evnt) {
          $xeTable.triggerCheckRowEvent(evnt, params, checked);
        } else {
          $xeTable.handleBatchSelectRows([row], checked);
          $xeTable.checkSelectionStatus();
        }
      },
      triggerCheckRowEvent(evnt, params, checked) {
        const { row } = params;
        const { afterFullData } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkMethod, trigger } = checkboxOpts;
        if (trigger === "manual") {
          return;
        }
        evnt.stopPropagation();
        if (checkboxOpts.isShiftKey && evnt.shiftKey && !props.treeConfig) {
          const checkboxRecords = $xeTable.getCheckboxRecords();
          if (checkboxRecords.length) {
            const firstRow = checkboxRecords[0];
            const _rowIndex = $xeTable.getVTRowIndex(row);
            const _firstRowIndex = $xeTable.getVTRowIndex(firstRow);
            if (_rowIndex !== _firstRowIndex) {
              $xeTable.setAllCheckboxRow(false);
              const rangeRows = _rowIndex < _firstRowIndex ? afterFullData.slice(_rowIndex, _firstRowIndex + 1) : afterFullData.slice(_firstRowIndex, _rowIndex + 1);
              nextTick(() => {
                handleCheckedCheckboxRow(rangeRows, true, false);
              });
              dispatchEvent("checkbox-range-select", Object.assign({ rangeRecords: rangeRows }, params), evnt);
              return;
            }
          }
        }
        if (!checkMethod || checkMethod({ row })) {
          $xeTable.handleBatchSelectRows([row], checked);
          $xeTable.checkSelectionStatus();
          dispatchEvent("checkbox-change", Object.assign({
            records: () => $xeTable.getCheckboxRecords(),
            reserves: () => $xeTable.getCheckboxReserveRecords(),
            indeterminates: () => $xeTable.getCheckboxIndeterminateRecords(),
            checked
          }, params), evnt);
        }
      },
      /**
       * 多选，选中所有事件
       */
      triggerCheckAllEvent(evnt, value) {
        const checkboxOpts = computeCheckboxOpts.value;
        const { trigger } = checkboxOpts;
        if (trigger === "manual") {
          return;
        }
        if (evnt) {
          evnt.stopPropagation();
        }
        handleCheckAllEvent(evnt, value);
      },
      /**
       * 单选，行选中事件
       */
      triggerRadioRowEvent(evnt, params) {
        const { selectRadioRow: oldValue } = reactData;
        const { row } = params;
        const radioOpts = computeRadioOpts.value;
        const { trigger } = radioOpts;
        if (trigger === "manual") {
          return;
        }
        evnt.stopPropagation();
        let newValue = row;
        let isChange = oldValue !== newValue;
        if (isChange) {
          handleCheckedRadioRow(newValue);
        } else if (!radioOpts.strict) {
          isChange = oldValue === newValue;
          if (isChange) {
            newValue = null;
            tableMethods.clearRadioRow();
          }
        }
        if (isChange) {
          dispatchEvent("radio-change", Object.assign({ oldValue, newValue }, params), evnt);
        }
      },
      triggerCurrentColumnEvent(evnt, params) {
        const columnOpts = computeColumnOpts.value;
        const { currentMethod } = columnOpts;
        const { column } = params;
        if (!currentMethod || currentMethod({ column })) {
          tableMethods.setCurrentColumn(column);
        }
      },
      triggerCurrentRowEvent(evnt, params) {
        const { currentRow: oldValue } = reactData;
        const rowOpts = computeRowOpts.value;
        const { currentMethod } = rowOpts;
        const { row: newValue } = params;
        const isChange = oldValue !== newValue;
        if (!currentMethod || currentMethod({ row: newValue })) {
          tableMethods.setCurrentRow(newValue);
          if (isChange) {
            dispatchEvent("current-change", Object.assign({ oldValue, newValue }, params), evnt);
          }
        }
      },
      /**
       * 展开行事件
       */
      triggerRowExpandEvent(evnt, params) {
        const { expandColumn: column } = reactData;
        const { rowExpandLazyLoadedMaps } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { row } = params;
        const { lazy, trigger } = expandOpts;
        if (trigger === "manual") {
          return;
        }
        evnt.stopPropagation();
        const rowid = getRowid($xeTable, row);
        if (!lazy || !rowExpandLazyLoadedMaps[rowid]) {
          const expanded = !$xeTable.isRowExpandByRow(row);
          const columnIndex = $xeTable.getColumnIndex(column);
          const $columnIndex = $xeTable.getVMColumnIndex(column);
          $xeTable.setRowExpand(row, expanded);
          dispatchEvent("toggle-row-expand", {
            expanded,
            column,
            columnIndex,
            $columnIndex,
            row,
            rowIndex: $xeTable.getRowIndex(row),
            $rowIndex: $xeTable.getVMRowIndex(row)
          }, evnt);
        }
      },
      /**
       * 展开树节点事件
       */
      triggerTreeExpandEvent(evnt, params) {
        const { treeExpandLazyLoadedMaps } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { row, column } = params;
        const { lazy, trigger } = treeOpts;
        if (trigger === "manual") {
          return;
        }
        evnt.stopPropagation();
        const rowid = getRowid($xeTable, row);
        if (!lazy || !treeExpandLazyLoadedMaps[rowid]) {
          const expanded = !$xeTable.isTreeExpandByRow(row);
          const columnIndex = $xeTable.getColumnIndex(column);
          const $columnIndex = $xeTable.getVMColumnIndex(column);
          $xeTable.setTreeExpand(row, expanded);
          dispatchEvent("toggle-tree-expand", { expanded, column, columnIndex, $columnIndex, row }, evnt);
        }
      },
      handleColumnSortEvent(evnt, column) {
        const { mouseConfig } = props;
        const mouseOpts = computeMouseOpts.value;
        const { field, sortable } = column;
        if (sortable) {
          const params = { $table: $xeTable, $event: evnt, column, field, property: field, order: column.order, sortList: tableMethods.getSortColumns(), sortTime: column.sortTime };
          if (mouseConfig && mouseOpts.area && $xeTable.handleSortEvent) {
            $xeTable.handleSortEvent(evnt, params);
          }
          dispatchEvent("sort-change", params, evnt);
        }
      },
      /**
       * 点击排序事件
       */
      triggerSortEvent(evnt, column, order) {
        const sortOpts = computeSortOpts.value;
        const { multiple, allowClear } = sortOpts;
        const { field, sortable } = column;
        if (sortable) {
          if (!order || column.order === order) {
            if (allowClear) {
              tableMethods.clearSort(multiple ? column : null);
            }
          } else {
            tableMethods.sort({ field, order });
          }
          $xeTable.handleColumnSortEvent(evnt, column);
        }
      },
      handleCellRuleUpdateStatus(type, cellParams, cellValue) {
        const { validStore } = reactData;
        const { row, column } = cellParams;
        if ($xeTable.hasCellRules) {
          if ($xeTable.hasCellRules(type, row, column)) {
            const cell = $xeTable.getCellElement(row, column);
            if (cell) {
              const customVal = !import_xe_utils8.default.isUndefined(cellValue);
              return $xeTable.validCellRules(type, row, column, cellValue).then(() => {
                if (customVal && validStore.visible) {
                  setCellValue(row, column, cellValue);
                }
                $xeTable.clearValidate(row, column);
              }).catch(({ rule }) => {
                if (customVal) {
                  setCellValue(row, column, cellValue);
                }
                $xeTable.showValidTooltip({ rule, row, column, cell });
              });
            }
          }
        }
        return nextTick();
      },
      /**
       * 表头单元格按下事件
       */
      triggerHeaderCellMousedownEvent(evnt, params) {
        const { mouseConfig } = props;
        const mouseOpts = computeMouseOpts.value;
        const columnOpts = computeColumnOpts.value;
        const columnDragOpts = computeColumnDragOpts.value;
        const { trigger, isCrossDrag, isPeerDrag, disabledMethod } = columnDragOpts;
        const cell = evnt.currentTarget;
        const triggerInput = cell && cell.tagName && cell.tagName.toLowerCase() === "input";
        const triggerCheckbox = getEventTargetNode(evnt, cell, "vxe-cell--checkbox").flag;
        const triggerSort = getEventTargetNode(evnt, cell, "vxe-cell--sort").flag;
        const triggerFilter = getEventTargetNode(evnt, cell, "vxe-cell--filter").flag;
        let triggerDrag = false;
        const isColDragCell = columnOpts.drag && trigger === "cell";
        if (!(triggerInput || triggerCheckbox || triggerSort || triggerFilter)) {
          const { column } = params;
          if (isColDragCell && !column.fixed && (isCrossDrag || isPeerDrag || !column.parentId) && !(disabledMethod && disabledMethod(params))) {
            triggerDrag = true;
            $xeTable.handleHeaderCellDragMousedownEvent(evnt, params);
          }
        }
        if (!triggerDrag && mouseConfig && mouseOpts.area && $xeTable.handleHeaderCellAreaEvent) {
          $xeTable.handleHeaderCellAreaEvent(evnt, Object.assign({ cell, triggerSort, triggerFilter }, params));
        }
        $xeTable.focus();
        if ($xeTable.closeMenu) {
          $xeTable.closeMenu();
        }
      },
      /**
       * 单元格按下事件
       */
      triggerCellMousedownEvent(evnt, params) {
        const { column } = params;
        const { type, treeNode } = column;
        const isRadioType = type === "radio";
        const isCheckboxType = type === "checkbox";
        const isExpandType = type === "expand";
        const rowOpts = computeRowOpts.value;
        const rowDragOpts = computeRowDragOpts.value;
        const { trigger, isCrossDrag, isPeerDrag, disabledMethod } = rowDragOpts;
        const cell = evnt.currentTarget;
        params.cell = cell;
        const triggerInput = cell && cell.tagName && cell.tagName.toLowerCase() === "input";
        const triggerRadio = isRadioType && getEventTargetNode(evnt, cell, "vxe-cell--radio").flag;
        const triggerCheckbox = isCheckboxType && getEventTargetNode(evnt, cell, "vxe-cell--checkbox").flag;
        const triggerTreeNode = treeNode && getEventTargetNode(evnt, cell, "vxe-tree--btn-wrapper").flag;
        const triggerExpandNode = isExpandType && getEventTargetNode(evnt, cell, "vxe-table--expanded").flag;
        let isColDragCell = false;
        if (rowOpts.drag) {
          isColDragCell = trigger === "row" || column.dragSort && trigger === "cell";
        }
        let triggerDrag = false;
        if (!(triggerInput || triggerRadio || triggerCheckbox || triggerTreeNode || triggerExpandNode)) {
          if (isColDragCell && (isCrossDrag || isPeerDrag || !params.level) && !(disabledMethod && disabledMethod(params))) {
            triggerDrag = true;
            $xeTable.handleCellDragMousedownEvent(evnt, params);
          }
        }
        if (!triggerDrag && $xeTable.handleCellMousedownEvent) {
          $xeTable.handleCellMousedownEvent(evnt, params);
        }
        $xeTable.focus();
        $xeTable.closeFilter();
        if ($xeTable.closeMenu) {
          $xeTable.closeMenu();
        }
      },
      triggerCellMouseupEvent() {
        clearDragStatus();
      },
      /**
       * 行拖拽
       */
      handleRowDragDragstartEvent(evnt) {
        if (evnt.dataTransfer) {
          evnt.dataTransfer.setDragImage(getTpImg(), 0, 0);
        }
      },
      handleRowDragSwapEvent(evnt, isSyncRow, dragRow, prevDragRow, prevDragPos, prevDragToChild) {
        const { treeConfig, dragConfig } = props;
        const rowDragOpts = computeRowDragOpts.value;
        const { afterFullData, tableFullData, fullAllDataRowIdData } = internalData;
        const { isPeerDrag, isCrossDrag, isSelfToChildDrag, dragEndMethod, dragToChildMethod } = rowDragOpts;
        const treeOpts = computeTreeOpts.value;
        const { transform, rowField, mapChildrenField, parentField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const dEndMethod = dragEndMethod || (dragConfig ? dragConfig.dragEndMethod : null);
        const dragOffsetIndex = prevDragPos === "bottom" ? 1 : 0;
        const errRest = {
          status: false
        };
        if (prevDragRow && dragRow) {
          if (prevDragRow !== dragRow) {
            const dragParams = {
              oldRow: dragRow,
              newRow: prevDragRow,
              dragRow,
              dragPos: prevDragPos,
              dragToChild: !!prevDragToChild,
              offsetIndex: dragOffsetIndex
            };
            const isDragToChildFlag = isSelfToChildDrag && dragToChildMethod ? dragToChildMethod(dragParams) : prevDragToChild;
            return Promise.resolve(dEndMethod ? dEndMethod(dragParams) : true).then((status) => {
              if (!status) {
                return errRest;
              }
              let oafIndex = -1;
              let nafIndex = -1;
              if (treeConfig) {
                if (transform) {
                  const oldRowid = getRowid($xeTable, dragRow);
                  const oldRest = fullAllDataRowIdData[oldRowid];
                  const newRowid = getRowid($xeTable, prevDragRow);
                  const newRest = fullAllDataRowIdData[newRowid];
                  if (oldRest && newRest) {
                    const { level: oldLevel } = oldRest;
                    const { level: newLevel } = newRest;
                    const oldAllMaps = {};
                    import_xe_utils8.default.eachTree([dragRow], (item) => {
                      oldAllMaps[getRowid($xeTable, item)] = item;
                    }, { children: mapChildrenField });
                    let isSelfToChildStatus = false;
                    if (oldLevel && newLevel) {
                      if (isPeerDrag && !isCrossDrag) {
                        if (oldRest.row[parentField] !== newRest.row[parentField]) {
                          return errRest;
                        }
                      } else {
                        if (!isCrossDrag) {
                          return errRest;
                        }
                        if (oldAllMaps[newRowid]) {
                          isSelfToChildStatus = true;
                          if (!(isCrossDrag && isSelfToChildDrag)) {
                            if (VxeUI.modal) {
                              VxeUI.modal.message({
                                status: "error",
                                content: getI18n6("vxe.error.treeDragChild")
                              });
                            }
                            return errRest;
                          }
                        }
                      }
                    } else if (oldLevel) {
                      if (!isCrossDrag) {
                        return errRest;
                      }
                    } else if (newLevel) {
                      if (!isCrossDrag) {
                        return errRest;
                      }
                      if (oldAllMaps[newRowid]) {
                        isSelfToChildStatus = true;
                        if (!(isCrossDrag && isSelfToChildDrag)) {
                          if (VxeUI.modal) {
                            VxeUI.modal.message({
                              status: "error",
                              content: getI18n6("vxe.error.treeDragChild")
                            });
                          }
                          return errRest;
                        }
                      }
                    } else {
                    }
                    const fullList = import_xe_utils8.default.toTreeArray(internalData.afterTreeFullData, {
                      key: rowField,
                      parentKey: parentField,
                      children: mapChildrenField
                    });
                    const otfIndex = $xeTable.findRowIndexOf(fullList, dragRow);
                    fullList.splice(otfIndex, 1);
                    const ptfIndex = $xeTable.findRowIndexOf(fullList, prevDragRow);
                    const ntfIndex = ptfIndex + dragOffsetIndex;
                    fullList.splice(ntfIndex, 0, dragRow);
                    if (isSelfToChildStatus && (isCrossDrag && isSelfToChildDrag)) {
                      import_xe_utils8.default.each(dragRow[childrenField], (childRow) => {
                        childRow[parentField] = dragRow[parentField];
                      });
                    }
                    dragRow[parentField] = isDragToChildFlag ? prevDragRow[rowField] : prevDragRow[parentField];
                    internalData.tableFullTreeData = import_xe_utils8.default.toArrayTree(fullList, {
                      key: rowField,
                      parentKey: parentField,
                      children: childrenField,
                      mapChildren: mapChildrenField
                    });
                  }
                }
              } else {
                oafIndex = $xeTable.findRowIndexOf(afterFullData, dragRow);
                const otfIndex = $xeTable.findRowIndexOf(tableFullData, dragRow);
                afterFullData.splice(oafIndex, 1);
                tableFullData.splice(otfIndex, 1);
                const pafIndex = $xeTable.findRowIndexOf(afterFullData, prevDragRow);
                const ptfIndex = $xeTable.findRowIndexOf(tableFullData, prevDragRow);
                nafIndex = pafIndex + dragOffsetIndex;
                const ntfIndex = ptfIndex + dragOffsetIndex;
                afterFullData.splice(nafIndex, 0, dragRow);
                tableFullData.splice(ntfIndex, 0, dragRow);
              }
              reactData.isDragRowMove = true;
              $xeTable.handleTableData(treeConfig && transform);
              $xeTable.cacheRowMap(false);
              updateScrollYStatus();
              if (!(treeConfig && transform)) {
                $xeTable.updateAfterDataIndex();
              }
              $xeTable.checkSelectionStatus();
              if (reactData.scrollYLoad) {
                $xeTable.updateScrollYSpace();
              }
              if (evnt) {
                dispatchEvent("row-dragend", {
                  oldRow: dragRow,
                  newRow: prevDragRow,
                  dragRow,
                  dragPos: prevDragPos,
                  dragToChild: isDragToChildFlag,
                  offsetIndex: dragOffsetIndex,
                  _index: {
                    newIndex: nafIndex,
                    oldIndex: oafIndex
                  }
                }, evnt);
              }
              return nextTick().then(() => {
                $xeTable.updateCellAreas();
                $xeTable.recalculate();
              }).then(() => {
                return {
                  status: true
                };
              });
            }).catch(() => {
              return errRest;
            });
          }
        }
        return Promise.resolve(errRest);
      },
      handleRowDragDragendEvent(evnt) {
        const { treeConfig } = props;
        const { fullAllDataRowIdData, prevDragToChild } = internalData;
        const { dragRow } = reactData;
        const treeOpts = computeTreeOpts.value;
        const { lazy } = treeOpts;
        const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
        const { prevDragRow, prevDragPos } = internalData;
        if (treeConfig && lazy && prevDragToChild) {
          const newRowid = getRowid($xeTable, prevDragRow);
          const rowRest = fullAllDataRowIdData[newRowid];
          if (prevDragRow[hasChildField]) {
            if (rowRest && rowRest.treeLoaded) {
              $xeTable.handleRowDragSwapEvent(evnt, true, dragRow, prevDragRow, prevDragPos, prevDragToChild);
            }
          } else {
            $xeTable.handleRowDragSwapEvent(evnt, true, dragRow, prevDragRow, prevDragPos, prevDragToChild);
          }
        } else {
          $xeTable.handleRowDragSwapEvent(evnt, true, dragRow, prevDragRow, prevDragPos, prevDragToChild);
        }
        hideDropTip();
        clearRowDropOrigin();
        internalData.prevDragToChild = false;
        reactData.dragRow = null;
        reactData.dragCol = null;
        setTimeout(() => {
          reactData.isDragRowMove = false;
        }, 500);
      },
      handleRowDragDragoverEvent(evnt) {
        const { treeConfig } = props;
        const { fullAllDataRowIdData } = internalData;
        const { dragRow } = reactData;
        const treeOpts = computeTreeOpts.value;
        const { lazy, transform, parentField } = treeOpts;
        const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
        const rowDragOpts = computeRowDragOpts.value;
        const { isPeerDrag, isCrossDrag, isToChildDrag } = rowDragOpts;
        if (!dragRow) {
          evnt.preventDefault();
          return;
        }
        const hasCtrlKey = evnt.ctrlKey;
        const trEl = evnt.currentTarget;
        const rowid = trEl.getAttribute("rowid") || "";
        const rest = fullAllDataRowIdData[rowid];
        if (rest) {
          const row = rest.row;
          const rowid2 = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid2];
          evnt.preventDefault();
          const { dragRow: dragRow2 } = reactData;
          const offsetY = evnt.clientY - trEl.getBoundingClientRect().y;
          const dragPos = offsetY < trEl.clientHeight / 2 ? "top" : "bottom";
          internalData.prevDragToChild = !!(treeConfig && transform && (isCrossDrag && isToChildDrag) && hasCtrlKey);
          internalData.prevDragRow = row;
          internalData.prevDragPos = dragPos;
          if ($xeTable.eqRow(dragRow2, row) || hasCtrlKey && treeConfig && lazy && row[hasChildField] && rowRest && !rowRest.treeLoaded || !isCrossDrag && treeConfig && transform && (isPeerDrag ? dragRow2[parentField] !== row[parentField] : rest.level)) {
            showDropTip(evnt, trEl, null, false, dragPos);
            return;
          }
          showDropTip(evnt, trEl, null, true, dragPos);
          dispatchEvent("row-dragover", {
            oldRow: dragRow2,
            targetRow: row,
            dragPos
          }, evnt);
        }
      },
      handleCellDragMousedownEvent(evnt, params) {
        var _a;
        evnt.stopPropagation();
        const { dragConfig } = props;
        const rowDragOpts = computeRowDragOpts.value;
        const { trigger, dragStartMethod } = rowDragOpts;
        const { row } = params;
        const dragEl = evnt.currentTarget;
        const tdEl = trigger === "cell" || trigger === "row" ? dragEl : (_a = dragEl.parentElement) === null || _a === void 0 ? void 0 : _a.parentElement;
        const trEl = tdEl.parentElement;
        const dStartMethod = dragStartMethod || (dragConfig ? dragConfig.dragStartMethod : null);
        clearRowDropOrigin();
        if (dStartMethod && !dStartMethod(params)) {
          trEl.draggable = false;
          reactData.dragRow = null;
          reactData.dragCol = null;
          hideDropTip();
          return;
        }
        reactData.dragRow = row;
        reactData.dragCol = null;
        trEl.draggable = true;
        updateRowDropOrigin(row);
        updateRowDropTipContent(tdEl);
        dispatchEvent("row-dragstart", params, evnt);
      },
      handleCellDragMouseupEvent() {
        clearDragStatus();
      },
      /**
       * 列拖拽
       */
      handleHeaderCellDragDragstartEvent(evnt) {
        if (evnt.dataTransfer) {
          evnt.dataTransfer.setDragImage(getTpImg(), 0, 0);
        }
      },
      handleColDragSwapColumn() {
        handleUpdateColumn();
        parseColumns(false).then(() => {
          $xeTable.updateCellAreas();
          $xeTable.saveCustomStore("update:sort");
        });
      },
      handleColDragSwapEvent(evnt, isSyncColumn, dragCol, prevDragCol, prevDragPos, prevDragToChild) {
        const { mouseConfig } = props;
        const columnDragOpts = computeColumnDragOpts.value;
        const { isPeerDrag, isCrossDrag, isSelfToChildDrag, isToChildDrag, dragEndMethod, dragToChildMethod } = columnDragOpts;
        const { collectColumn } = internalData;
        const dragOffsetIndex = prevDragPos === "right" ? 1 : 0;
        const errRest = {
          status: false
        };
        if (prevDragCol && dragCol) {
          if (prevDragCol !== dragCol) {
            const dragColumn = dragCol;
            const newColumn = prevDragCol;
            const dragParams = {
              oldColumn: dragColumn,
              newColumn,
              dragColumn,
              dragPos: prevDragPos,
              dragToChild: !!prevDragToChild,
              offsetIndex: dragOffsetIndex
            };
            const isDragToChildFlag = isSelfToChildDrag && dragToChildMethod ? dragToChildMethod(dragParams) : prevDragToChild;
            return Promise.resolve(dragEndMethod ? dragEndMethod(dragParams) : true).then((status) => {
              if (!status) {
                return errRest;
              }
              let oafIndex = -1;
              let nafIndex = -1;
              const oldAllMaps = {};
              import_xe_utils8.default.eachTree([dragColumn], (column) => {
                oldAllMaps[column.id] = column;
              });
              let isSelfToChildStatus = false;
              if (dragColumn.parentId && newColumn.parentId) {
                if (isPeerDrag && !isCrossDrag) {
                  if (dragColumn.parentId !== newColumn.parentId) {
                    return errRest;
                  }
                } else {
                  if (!isCrossDrag) {
                    return errRest;
                  }
                  if (oldAllMaps[newColumn.id]) {
                    isSelfToChildStatus = true;
                    if (!(isCrossDrag && isSelfToChildDrag)) {
                      if (VxeUI.modal) {
                        VxeUI.modal.message({
                          status: "error",
                          content: getI18n6("vxe.error.treeDragChild")
                        });
                      }
                      return errRest;
                    }
                  }
                }
              } else if (dragColumn.parentId) {
                if (!isCrossDrag) {
                  return errRest;
                }
              } else if (newColumn.parentId) {
                if (!isCrossDrag) {
                  return errRest;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!(isCrossDrag && isSelfToChildDrag)) {
                    if (VxeUI.modal) {
                      VxeUI.modal.message({
                        status: "error",
                        content: getI18n6("vxe.error.treeDragChild")
                      });
                    }
                    return errRest;
                  }
                }
              } else {
              }
              const oldewMatchRest = import_xe_utils8.default.findTree(collectColumn, (item) => item.id === dragColumn.id);
              if (isSelfToChildStatus && (isCrossDrag && isSelfToChildDrag)) {
                if (oldewMatchRest) {
                  const { items: oCols, index: oIndex } = oldewMatchRest;
                  const childList = dragColumn.children || [];
                  childList.forEach((column) => {
                    column.parentId = dragColumn.parentId;
                  });
                  oCols.splice(oIndex, 1, ...childList);
                  dragColumn.children = [];
                }
              } else {
                if (oldewMatchRest) {
                  const { items: oCols, index: oIndex, parent: oParent } = oldewMatchRest;
                  oCols.splice(oIndex, 1);
                  if (!oParent) {
                    oafIndex = oIndex;
                  }
                }
              }
              const newMatchRest = import_xe_utils8.default.findTree(collectColumn, (item) => item.id === newColumn.id);
              if (newMatchRest) {
                const { items: nCols, index: nIndex, parent: nParent } = newMatchRest;
                if (isCrossDrag && isToChildDrag && isDragToChildFlag) {
                  dragColumn.parentId = newColumn.id;
                  newColumn.children = (newColumn.children || []).concat([dragColumn]);
                } else {
                  dragColumn.parentId = newColumn.parentId;
                  nCols.splice(nIndex + dragOffsetIndex, 0, dragColumn);
                }
                if (!nParent) {
                  nafIndex = nIndex;
                }
              }
              import_xe_utils8.default.eachTree(collectColumn, (column, index, items, path, parentColumn) => {
                if (!parentColumn) {
                  const sortIndex = index + 1;
                  column.renderSortNumber = sortIndex;
                }
              });
              reactData.isDragColMove = true;
              if (mouseConfig) {
                if ($xeTable.clearSelected) {
                  $xeTable.clearSelected();
                }
                if ($xeTable.clearCellAreas) {
                  $xeTable.clearCellAreas();
                  $xeTable.clearCopyCellArea();
                }
              }
              if (evnt) {
                dispatchEvent("column-dragend", {
                  oldColumn: dragColumn,
                  newColumn,
                  dragColumn,
                  dragPos: prevDragPos,
                  dragToChild: isDragToChildFlag,
                  offsetIndex: dragOffsetIndex,
                  _index: {
                    newIndex: nafIndex,
                    oldIndex: oafIndex
                  }
                }, evnt);
              }
              if (isSyncColumn) {
                $xeTable.handleColDragSwapColumn();
              }
              return {
                status: true
              };
            }).catch(() => {
              return errRest;
            });
          }
        }
        return Promise.resolve(errRest);
      },
      handleHeaderCellDragDragendEvent(evnt) {
        const { dragCol } = reactData;
        const { prevDragCol, prevDragPos, prevDragToChild } = internalData;
        $xeTable.handleColDragSwapEvent(evnt, true, dragCol, prevDragCol, prevDragPos, prevDragToChild);
        hideDropTip();
        clearColDropOrigin();
        internalData.prevDragToChild = false;
        reactData.dragRow = null;
        reactData.dragCol = null;
        setTimeout(() => {
          reactData.isDragColMove = false;
          $xeTable.recalculate().then(() => {
            loadScrollXData();
          });
        }, 500);
      },
      handleHeaderCellDragDragoverEvent(evnt) {
        const { dragCol } = reactData;
        const columnDragOpts = computeColumnDragOpts.value;
        const { isToChildDrag, isPeerDrag, isCrossDrag } = columnDragOpts;
        if (!dragCol) {
          evnt.preventDefault();
          return;
        }
        const hasCtrlKey = evnt.ctrlKey;
        const thEl = evnt.currentTarget;
        const colid = thEl.getAttribute("colid");
        const column = $xeTable.getColumnById(colid);
        if (column) {
          evnt.preventDefault();
          const { clientX } = evnt;
          const offsetX = clientX - thEl.getBoundingClientRect().x;
          const dragPos = offsetX < thEl.clientWidth / 2 ? "left" : "right";
          internalData.prevDragToChild = !!(isCrossDrag && isToChildDrag && hasCtrlKey);
          internalData.prevDragCol = column;
          internalData.prevDragPos = dragPos;
          if (column.fixed || dragCol && dragCol.id === column.id || !isCrossDrag && (isPeerDrag ? dragCol.parentId !== column.parentId : column.parentId)) {
            showDropTip(evnt, null, thEl, false, dragPos);
            return;
          }
          showDropTip(evnt, null, thEl, true, dragPos);
          dispatchEvent("column-dragover", {
            oldColumn: dragCol,
            targetColumn: column,
            dragPos
          }, evnt);
          const el = refElem.value;
          if (!el) {
            return;
          }
          const xHandleEl = refScrollXHandleElem.value;
          const tableBody = refTableBody.value;
          const tableBodyElem = tableBody ? tableBody.$el : null;
          const scrollTargetEl = xHandleEl || tableBodyElem;
          if (scrollTargetEl) {
            const wrapperRect = el.getBoundingClientRect();
            const tableWrapperWidth = el.clientWidth;
            const leftContainerElem = refLeftContainer.value;
            const leftContainerWidth = leftContainerElem ? leftContainerElem.clientWidth : 0;
            const rightContainerElem = refRightContainer.value;
            const rightContainerWidth = rightContainerElem ? rightContainerElem.clientWidth : 0;
            const srartX = wrapperRect.x + leftContainerWidth;
            const endX = wrapperRect.x + tableWrapperWidth - rightContainerWidth;
            const distSize = 28;
            const startDistSize = clientX - srartX;
            const endDistSize = endX - clientX;
            if (startDistSize > 0 && startDistSize <= distSize) {
              const scrollRatio = Math.floor(tableWrapperWidth / (startDistSize > distSize / 2 ? 240 : 120));
              scrollTargetEl.scrollLeft -= scrollRatio * (distSize - startDistSize);
            } else if (endDistSize > 0 && endDistSize <= distSize) {
              const scrollRatio = Math.floor(tableWrapperWidth / (endDistSize > distSize / 2 ? 240 : 120));
              scrollTargetEl.scrollLeft += scrollRatio * (distSize - endDistSize);
            }
          }
        }
      },
      handleHeaderCellDragMousedownEvent(evnt, params) {
        var _a;
        evnt.stopPropagation();
        const columnDragOpts = computeColumnDragOpts.value;
        const { trigger, dragStartMethod } = columnDragOpts;
        const { column } = params;
        const dragEl = evnt.currentTarget;
        const thEl = trigger === "cell" ? dragEl : (_a = dragEl.parentElement) === null || _a === void 0 ? void 0 : _a.parentElement;
        reactData.isDragColMove = false;
        clearColDropOrigin();
        if (dragStartMethod && !dragStartMethod(params)) {
          thEl.draggable = false;
          reactData.dragRow = null;
          reactData.dragCol = null;
          hideDropTip();
          return;
        }
        reactData.dragCol = column;
        reactData.dragRow = null;
        thEl.draggable = true;
        updateColDropOrigin(column);
        updateColDropTipContent(thEl);
        dispatchEvent("column-dragstart", params, evnt);
      },
      handleHeaderCellDragMouseupEvent() {
        clearColDropOrigin();
        hideDropTip();
        reactData.dragRow = null;
        reactData.dragCol = null;
        reactData.isDragColMove = false;
      },
      handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, params) {
        const { highlightHoverRow } = props;
        const { lastScrollLeft, lastScrollTop } = internalData;
        const xHandleEl = refScrollXHandleElem.value;
        const yHandleEl = refScrollYHandleElem.value;
        if (!xHandleEl || !yHandleEl) {
          return;
        }
        const rowOpts = computeRowOpts.value;
        const validTip = refValidTooltip.value;
        const tooltip = refTooltip.value;
        const bodyHeight = yHandleEl.clientHeight;
        const bodyWidth = xHandleEl.clientWidth;
        const scrollHeight = yHandleEl.scrollHeight;
        const scrollWidth = xHandleEl.scrollWidth;
        let isTop = false;
        let isBottom = false;
        let isLeft = false;
        let isRight = false;
        let direction = "";
        let isTopBoundary = false;
        let isBottomBoundary = false;
        let isLeftBoundary = false;
        let isRightBoundary = false;
        if (isRollX) {
          const xThreshold = computeScrollXThreshold.value;
          isLeft = scrollLeft <= 0;
          if (!isLeft) {
            isRight = scrollLeft + bodyWidth >= scrollWidth;
          }
          if (scrollLeft > lastScrollLeft) {
            direction = "right";
            if (scrollLeft + bodyWidth >= scrollWidth - xThreshold) {
              isRightBoundary = true;
            }
          } else {
            direction = "left";
            if (scrollLeft <= xThreshold) {
              isLeftBoundary = true;
            }
          }
          $xeTable.checkScrolling();
          internalData.lastScrollLeft = scrollLeft;
        }
        if (isRollY) {
          const yThreshold = computeScrollYThreshold.value;
          isTop = scrollTop <= 0;
          if (!isTop) {
            isBottom = scrollTop + bodyHeight >= scrollHeight;
          }
          if (scrollTop > lastScrollTop) {
            direction = "bottom";
            if (scrollTop + bodyHeight >= scrollHeight - yThreshold) {
              isBottomBoundary = true;
            }
          } else {
            direction = "top";
            if (scrollTop <= yThreshold) {
              isTopBoundary = true;
            }
          }
          internalData.lastScrollTop = scrollTop;
        }
        reactData.isDragColMove = false;
        reactData.isDragRowMove = false;
        reactData.lastScrollTime = Date.now();
        const evntParams = Object.assign({
          scrollTop,
          scrollLeft,
          bodyHeight,
          bodyWidth,
          scrollHeight,
          scrollWidth,
          isX: isRollX,
          isY: isRollY,
          isTop,
          isBottom,
          isLeft,
          isRight,
          direction
        }, params);
        updateRowExpandStyle();
        checkLastSyncScroll(isRollX, isRollY);
        if (rowOpts.isHover || highlightHoverRow) {
          $xeTable.clearHoverRow();
        }
        if (validTip && validTip.reactData.visible) {
          validTip.close();
        }
        if (tooltip && tooltip.reactData.visible) {
          tooltip.close();
        }
        if (isBottomBoundary || isTopBoundary || isRightBoundary || isLeftBoundary) {
          dispatchEvent("scroll-boundary", evntParams, evnt);
        }
        dispatchEvent("scroll", evntParams, evnt);
      },
      /**
       * 横向 X 可视渲染事件处理
       */
      triggerScrollXEvent() {
        const virtualXOpts = computeVirtualXOpts.value;
        if (virtualXOpts.immediate) {
          loadScrollXData();
        } else {
          lazyScrollXData();
        }
      },
      /**
       * 纵向 Y 可视渲染事件处理
       */
      triggerScrollYEvent() {
        const virtualYOpts = computeVirtualYOpts.value;
        if (virtualYOpts.immediate) {
          loadScrollYData();
        } else {
          lazyScrollYData();
        }
      },
      triggerBodyScrollEvent(evnt, fixedType) {
        const { scrollYLoad, scrollXLoad } = reactData;
        const { elemStore, intoRunScroll, lastScrollTop, lastScrollLeft, inWheelScroll, inVirtualScroll, inHeaderScroll, inBodyScroll, scrollRenderType, inFooterScroll } = internalData;
        if (inWheelScroll || inVirtualScroll || inHeaderScroll || inFooterScroll) {
          return;
        }
        const xHandleEl = refScrollXHandleElem.value;
        const yHandleEl = refScrollYHandleElem.value;
        const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        const rowExpandEl = refRowExpandElem.value;
        if (intoRunScroll) {
          return;
        }
        if (!bodyScrollElem) {
          return;
        }
        if (!xHandleEl) {
          return;
        }
        if (!yHandleEl) {
          return;
        }
        if (inBodyScroll) {
          if (scrollRenderType !== fixedType) {
            return;
          }
        }
        let scrollTop = yHandleEl.scrollTop;
        let scrollLeft = xHandleEl.scrollLeft;
        if (leftScrollElem && fixedType === "left") {
          scrollTop = leftScrollElem.scrollTop;
        } else if (rightScrollElem && fixedType === "right") {
          scrollTop = rightScrollElem.scrollTop;
        } else {
          scrollTop = bodyScrollElem.scrollTop;
          scrollLeft = bodyScrollElem.scrollLeft;
        }
        const isRollX = scrollLeft !== lastScrollLeft;
        const isRollY = scrollTop !== lastScrollTop;
        internalData.inBodyScroll = true;
        internalData.scrollRenderType = fixedType;
        if (isRollY) {
          if (fixedType === "left") {
            setScrollTop(bodyScrollElem, scrollTop);
            setScrollTop(rightScrollElem, scrollTop);
          } else if (fixedType === "right") {
            setScrollTop(bodyScrollElem, scrollTop);
            setScrollTop(leftScrollElem, scrollTop);
          } else {
            setScrollTop(leftScrollElem, scrollTop);
            setScrollTop(rightScrollElem, scrollTop);
          }
          setScrollTop(yHandleEl, scrollTop);
          setScrollTop(rowExpandEl, scrollTop);
          if (scrollYLoad) {
            $xeTable.triggerScrollYEvent(evnt);
          }
        }
        if (isRollX) {
          setScrollLeft(xHandleEl, scrollLeft);
          setScrollLeft(headerScrollElem, scrollLeft);
          setScrollLeft(footerScrollElem, scrollLeft);
          if (scrollXLoad) {
            $xeTable.triggerScrollXEvent(evnt);
          }
        }
        $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
          type: "body",
          fixed: fixedType
        });
      },
      triggerHeaderScrollEvent(evnt, fixedType) {
        const { scrollXLoad } = reactData;
        const { elemStore, intoRunScroll, inWheelScroll, inVirtualScroll, inBodyScroll, inFooterScroll } = internalData;
        if (inWheelScroll || inVirtualScroll || inBodyScroll || inFooterScroll) {
          return;
        }
        const yHandleEl = refScrollYHandleElem.value;
        const xHandleEl = refScrollXHandleElem.value;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        if (intoRunScroll) {
          return;
        }
        if (!headerScrollElem) {
          return;
        }
        if (!xHandleEl) {
          return;
        }
        if (!yHandleEl) {
          return;
        }
        const scrollTop = yHandleEl.scrollTop;
        const scrollLeft = headerScrollElem.scrollLeft;
        const isRollX = true;
        const isRollY = false;
        internalData.inHeaderScroll = true;
        setScrollLeft(xHandleEl, scrollLeft);
        setScrollLeft(footerScrollElem, scrollLeft);
        setScrollLeft(bodyScrollElem, scrollLeft);
        if (scrollXLoad) {
          $xeTable.triggerScrollXEvent(evnt);
        }
        $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
          type: "header",
          fixed: fixedType
        });
      },
      triggerFooterScrollEvent(evnt, fixedType) {
        const { scrollXLoad } = reactData;
        const { elemStore, intoRunScroll, inWheelScroll, inVirtualScroll, inHeaderScroll, inBodyScroll } = internalData;
        if (inWheelScroll || inVirtualScroll || inHeaderScroll || inBodyScroll) {
          return;
        }
        const yHandleEl = refScrollYHandleElem.value;
        const xHandleEl = refScrollXHandleElem.value;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        if (intoRunScroll) {
          return;
        }
        if (!footerScrollElem) {
          return;
        }
        if (!xHandleEl) {
          return;
        }
        if (!yHandleEl) {
          return;
        }
        const scrollTop = yHandleEl.scrollTop;
        const scrollLeft = footerScrollElem.scrollLeft;
        const isRollX = true;
        const isRollY = false;
        internalData.inFooterScroll = true;
        setScrollLeft(xHandleEl, scrollLeft);
        setScrollLeft(headerScrollElem, scrollLeft);
        setScrollLeft(bodyScrollElem, scrollLeft);
        if (scrollXLoad) {
          $xeTable.triggerScrollXEvent(evnt);
        }
        $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
          type: "footer",
          fixed: fixedType
        });
      },
      triggerBodyWheelEvent(evnt) {
        const { target, deltaY, deltaX, shiftKey } = evnt;
        if (target && /^textarea$/i.test(target.tagName)) {
          return;
        }
        const { highlightHoverRow } = props_default;
        const { scrollXLoad, scrollYLoad, expandColumn } = reactData;
        const leftFixedWidth = computeLeftFixedWidth.value;
        const rightFixedWidth = computeRightFixedWidth.value;
        if (!(leftFixedWidth || rightFixedWidth || expandColumn)) {
          return;
        }
        const { elemStore, lastScrollTop, lastScrollLeft } = internalData;
        const rowOpts = computeRowOpts.value;
        const xHandleEl = refScrollXHandleElem.value;
        const yHandleEl = refScrollYHandleElem.value;
        const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
        const rowExpandEl = refRowExpandElem.value;
        if (!xHandleEl) {
          return;
        }
        if (!yHandleEl) {
          return;
        }
        if (!bodyScrollElem) {
          return;
        }
        const wheelSpeed = getWheelSpeed(reactData.lastScrollTime);
        const deltaTop = shiftKey ? 0 : Math.ceil(deltaY * wheelSpeed);
        const deltaLeft = shiftKey ? Math.ceil((shiftKey ? deltaY || deltaX : deltaX) * wheelSpeed) : 0;
        const isTopWheel = deltaTop < 0;
        const currScrollTop = bodyScrollElem.scrollTop;
        if (isTopWheel ? currScrollTop <= 0 : currScrollTop >= bodyScrollElem.scrollHeight - bodyScrollElem.clientHeight) {
          return;
        }
        const scrollTop = currScrollTop + deltaTop;
        const scrollLeft = bodyScrollElem.scrollLeft + deltaLeft;
        const isRollX = scrollLeft !== lastScrollLeft;
        const isRollY = scrollTop !== lastScrollTop;
        if (rowOpts.isHover || highlightHoverRow) {
          $xeTable.clearHoverRow();
        }
        if (isRollX) {
          evnt.preventDefault();
          internalData.inWheelScroll = true;
          wheelScrollLeftTo(scrollLeft, (offsetLeft) => {
            internalData.inWheelScroll = true;
            const currLeftNum = offsetLeft;
            setScrollLeft(xHandleEl, currLeftNum);
            setScrollLeft(bodyScrollElem, currLeftNum);
            setScrollLeft(headerScrollElem, currLeftNum);
            setScrollLeft(footerScrollElem, currLeftNum);
            if (scrollXLoad) {
              $xeTable.triggerScrollXEvent(evnt);
            }
            $xeTable.handleScrollEvent(evnt, isRollY, isRollX, bodyScrollElem.scrollTop, currLeftNum, {
              type: "table",
              fixed: ""
            });
          });
        }
        if (isRollY) {
          evnt.preventDefault();
          internalData.inWheelScroll = true;
          wheelScrollTopTo(scrollTop - currScrollTop, (offsetTop) => {
            internalData.inWheelScroll = true;
            const currTopNum = bodyScrollElem.scrollTop + offsetTop;
            setScrollTop(yHandleEl, currTopNum);
            setScrollTop(bodyScrollElem, currTopNum);
            setScrollTop(leftScrollElem, currTopNum);
            setScrollTop(rightScrollElem, currTopNum);
            setScrollTop(rowExpandEl, currTopNum);
            if (scrollYLoad) {
              $xeTable.triggerScrollYEvent(evnt);
            }
            $xeTable.handleScrollEvent(evnt, isRollY, isRollX, currTopNum, bodyScrollElem.scrollLeft, {
              type: "table",
              fixed: ""
            });
          });
        }
      },
      triggerVirtualScrollXEvent(evnt) {
        const { scrollXLoad } = reactData;
        const { elemStore, inWheelScroll, lastScrollTop, inHeaderScroll, inBodyScroll, inFooterScroll } = internalData;
        if (inHeaderScroll || inBodyScroll || inFooterScroll) {
          return;
        }
        if (inWheelScroll) {
          return;
        }
        const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const footerScrollElem = getRefElem(elemStore["main-footer-scroll"]);
        const yHandleEl = refScrollYHandleElem.value;
        const wrapperEl = evnt.currentTarget;
        const { scrollLeft } = wrapperEl;
        const yBodyEl = yHandleEl || bodyScrollElem;
        let scrollTop = 0;
        if (yBodyEl) {
          scrollTop = yBodyEl.scrollTop;
        }
        const isRollX = true;
        const isRollY = scrollTop !== lastScrollTop;
        internalData.inVirtualScroll = true;
        setScrollLeft(bodyScrollElem, scrollLeft);
        setScrollLeft(headerScrollElem, scrollLeft);
        setScrollLeft(footerScrollElem, scrollLeft);
        if (scrollXLoad) {
          $xeTable.triggerScrollXEvent(evnt);
        }
        $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
          type: "table",
          fixed: ""
        });
      },
      triggerVirtualScrollYEvent(evnt) {
        const { scrollYLoad } = reactData;
        const { elemStore, inWheelScroll, lastScrollLeft, inHeaderScroll, inBodyScroll, inFooterScroll } = internalData;
        if (inHeaderScroll || inBodyScroll || inFooterScroll) {
          return;
        }
        if (inWheelScroll) {
          return;
        }
        const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
        const rowExpandEl = refRowExpandElem.value;
        const xHandleEl = refScrollXHandleElem.value;
        const wrapperEl = evnt.currentTarget;
        const { scrollTop } = wrapperEl;
        const xBodyEl = xHandleEl || bodyScrollElem;
        let scrollLeft = 0;
        if (xBodyEl) {
          scrollLeft = xBodyEl.scrollLeft;
        }
        const isRollX = scrollLeft !== lastScrollLeft;
        const isRollY = true;
        internalData.inVirtualScroll = true;
        setScrollTop(bodyScrollElem, scrollTop);
        setScrollTop(leftScrollElem, scrollTop);
        setScrollTop(rightScrollElem, scrollTop);
        setScrollTop(rowExpandEl, scrollTop);
        if (scrollYLoad) {
          $xeTable.triggerScrollYEvent(evnt);
        }
        $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
          type: "table",
          fixed: ""
        });
      },
      /**
       * 对于树形结构中，可以直接滚动到指定深层节点中
       * 对于某些特定的场景可能会用到，比如定位到某一节点
       * @param {Row} row 行对象
       */
      scrollToTreeRow(row) {
        const { treeConfig } = props;
        const { tableFullData } = internalData;
        const rests = [];
        if (treeConfig) {
          const treeOpts = computeTreeOpts.value;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          const matchObj = import_xe_utils8.default.findTree(tableFullData, (item) => $xeTable.eqRow(item, row), { children: childrenField });
          if (matchObj) {
            const nodes = matchObj.nodes;
            nodes.forEach((row2, index) => {
              if (index < nodes.length - 1 && !tableMethods.isTreeExpandByRow(row2)) {
                rests.push(tableMethods.setTreeExpand(row2, true));
              }
            });
          }
        }
        return Promise.all(rests).then(() => rowToVisible($xeTable, row));
      },
      updateScrollYStatus,
      // 更新横向 X 可视渲染上下剩余空间大小
      updateScrollXSpace() {
        const { isGroup, scrollXLoad, overflowX, scrollXWidth } = reactData;
        const { visibleColumn, scrollXStore, elemStore, fullColumnIdData } = internalData;
        const tableBody = refTableBody.value;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        if (tableBodyElem) {
          const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
          const bodyTableElem = getRefElem(elemStore["main-body-table"]);
          const headerTableElem = getRefElem(elemStore["main-header-table"]);
          const footerTableElem = getRefElem(elemStore["main-footer-table"]);
          let xSpaceLeft = 0;
          const firstColumn = visibleColumn[scrollXStore.startIndex];
          if (firstColumn) {
            const colRest = fullColumnIdData[firstColumn.id] || {};
            xSpaceLeft = colRest.oLeft;
          }
          let clientWidth = 0;
          if (bodyScrollElem) {
            clientWidth = bodyScrollElem.clientWidth;
          }
          let isScrollXBig = false;
          let ySpaceWidth = scrollXWidth;
          if (scrollXWidth > maxXWidth) {
            if (bodyScrollElem && bodyTableElem && bodyScrollElem.scrollLeft + clientWidth >= maxXWidth) {
              xSpaceLeft = maxXWidth - bodyTableElem.clientWidth;
            } else {
              xSpaceLeft = (maxXWidth - clientWidth) * (xSpaceLeft / (scrollXWidth - clientWidth));
            }
            ySpaceWidth = maxXWidth;
            isScrollXBig = true;
          }
          let marginLeft = "";
          if (scrollXLoad && overflowX) {
            marginLeft = `${xSpaceLeft}px`;
          }
          if (headerTableElem) {
            headerTableElem.style.marginLeft = isGroup ? "" : marginLeft;
          }
          if (bodyTableElem) {
            bodyTableElem.style.marginLeft = marginLeft;
          }
          if (footerTableElem) {
            footerTableElem.style.marginLeft = marginLeft;
          }
          reactData.isScrollXBig = isScrollXBig;
          const containerList = ["main"];
          containerList.forEach((name) => {
            const layoutList = ["header", "body", "footer"];
            layoutList.forEach((layout) => {
              const xSpaceElem = getRefElem(elemStore[`${name}-${layout}-xSpace`]);
              if (xSpaceElem) {
                xSpaceElem.style.width = scrollXLoad ? `${ySpaceWidth}px` : "";
              }
            });
          });
          const scrollXSpaceEl = refScrollXSpaceElem.value;
          if (scrollXSpaceEl) {
            scrollXSpaceEl.style.width = `${ySpaceWidth}px`;
          }
          nextTick(() => {
            updateStyle();
          });
        }
      },
      // 更新纵向 Y 可视渲染上下剩余空间大小
      updateScrollYSpace() {
        const { isAllOverflow, scrollYLoad, expandColumn } = reactData;
        const { scrollYStore, elemStore, isResizeCellHeight, afterFullData, fullAllDataRowIdData, rowExpandedMaps } = internalData;
        const { startIndex } = scrollYStore;
        const expandOpts = computeExpandOpts.value;
        const rowOpts = computeRowOpts.value;
        const cellOpts = computeCellOpts.value;
        const defaultRowHeight = computeDefaultRowHeight.value;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const bodyTableElem = getRefElem(elemStore["main-body-table"]);
        const containerList = ["main", "left", "right"];
        let ySpaceTop = 0;
        let scrollYHeight = 0;
        let isScrollYBig = false;
        if (scrollYLoad) {
          const isCustomCellHeight = isResizeCellHeight || cellOpts.height || rowOpts.height;
          if (!isCustomCellHeight && !expandColumn && isAllOverflow) {
            scrollYHeight = afterFullData.length * defaultRowHeight;
            if (scrollYHeight > maxYHeight) {
              isScrollYBig = true;
            }
            ySpaceTop = Math.max(0, startIndex * defaultRowHeight);
          } else {
            const firstRow = afterFullData[startIndex];
            let rowid = getRowid($xeTable, firstRow);
            let rowRest = fullAllDataRowIdData[rowid] || {};
            ySpaceTop = rowRest.oTop;
            const lastRow = afterFullData[afterFullData.length - 1];
            rowid = getRowid($xeTable, lastRow);
            rowRest = fullAllDataRowIdData[rowid] || {};
            scrollYHeight = rowRest.oTop + (rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight);
            if (expandColumn && rowExpandedMaps[rowid]) {
              scrollYHeight += rowRest.expandHeight || expandOpts.height || 0;
            }
            if (scrollYHeight > maxYHeight) {
              isScrollYBig = true;
            }
          }
        } else {
          if (bodyTableElem) {
            scrollYHeight = bodyTableElem.clientHeight;
          }
        }
        let clientHeight = 0;
        if (bodyScrollElem) {
          clientHeight = bodyScrollElem.clientHeight;
        }
        let ySpaceHeight = scrollYHeight;
        let scrollYTop = ySpaceTop;
        if (isScrollYBig) {
          if (bodyScrollElem && bodyTableElem && bodyScrollElem.scrollTop + clientHeight >= maxYHeight) {
            scrollYTop = maxYHeight - bodyTableElem.clientHeight;
          } else {
            scrollYTop = (maxYHeight - clientHeight) * (ySpaceTop / (scrollYHeight - clientHeight));
          }
          ySpaceHeight = maxYHeight;
        }
        containerList.forEach((name) => {
          const layoutList = ["header", "body", "footer"];
          const tableElem = getRefElem(elemStore[`${name}-body-table`]);
          if (tableElem) {
            tableElem.style.marginTop = scrollYTop ? `${scrollYTop}px` : "";
          }
          layoutList.forEach((layout) => {
            const ySpaceElem = getRefElem(elemStore[`${name}-${layout}-ySpace`]);
            if (ySpaceElem) {
              ySpaceElem.style.height = ySpaceHeight ? `${ySpaceHeight}px` : "";
            }
          });
        });
        const scrollYSpaceEl = refScrollYSpaceElem.value;
        if (scrollYSpaceEl) {
          scrollYSpaceEl.style.height = ySpaceHeight ? `${ySpaceHeight}px` : "";
        }
        const rowExpandYSpaceEl = refRowExpandYSpaceElem.value;
        if (rowExpandYSpaceEl) {
          rowExpandYSpaceEl.style.height = ySpaceHeight ? `${ySpaceHeight}px` : "";
        }
        reactData.scrollYTop = scrollYTop;
        reactData.scrollYHeight = scrollYHeight;
        reactData.isScrollYBig = isScrollYBig;
        return nextTick().then(() => {
          updateStyle();
        });
      },
      updateScrollXData() {
        const { isAllOverflow } = reactData;
        handleTableColumn();
        $xeTable.updateScrollYSpace();
        return nextTick().then(() => {
          handleTableColumn();
          $xeTable.updateScrollXSpace();
          if (!isAllOverflow) {
            $xeTable.updateScrollYSpace();
          }
        });
      },
      updateScrollYData() {
        $xeTable.handleTableData();
        $xeTable.updateScrollYSpace();
        return nextTick().then(() => {
          $xeTable.handleTableData();
          $xeTable.updateScrollYSpace();
        });
      },
      /**
       * 处理固定列的显示状态
       */
      checkScrolling() {
        const { elemStore } = internalData;
        const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
        const leftContainerElem = refLeftContainer.value;
        const rightContainerElem = refRightContainer.value;
        const xHandleEl = refScrollXHandleElem.value;
        const bodtTargetEl = xHandleEl || bodyScrollElem;
        if (bodtTargetEl) {
          if (leftContainerElem) {
            if (bodtTargetEl.scrollLeft > 0) {
              addClass(leftContainerElem, "scrolling--middle");
            } else {
              removeClass(leftContainerElem, "scrolling--middle");
            }
          }
          if (rightContainerElem) {
            if (bodtTargetEl.clientWidth < bodtTargetEl.scrollWidth - Math.ceil(bodtTargetEl.scrollLeft)) {
              addClass(rightContainerElem, "scrolling--middle");
            } else {
              removeClass(rightContainerElem, "scrolling--middle");
            }
          }
        }
      },
      updateZindex() {
        if (props.zIndex) {
          internalData.tZindex = props.zIndex;
        } else if (internalData.tZindex < getLastZIndex()) {
          internalData.tZindex = nextZIndex();
        }
      },
      handleCheckedCheckboxRow,
      /**
       * 行 hover 事件
       */
      triggerHoverEvent(evnt, { row }) {
        tablePrivateMethods.setHoverRow(row);
      },
      setHoverRow(row) {
        const rowid = getRowid($xeTable, row);
        const el = refElem.value;
        tablePrivateMethods.clearHoverRow();
        if (el) {
          import_xe_utils8.default.arrayEach(el.querySelectorAll(`.vxe-body--row[rowid="${rowid}"]`), (elem) => addClass(elem, "row--hover"));
        }
        internalData.hoverRow = row;
      },
      clearHoverRow() {
        const el = refElem.value;
        if (el) {
          import_xe_utils8.default.arrayEach(el.querySelectorAll(".vxe-body--row.row--hover"), (elem) => removeClass(elem, "row--hover"));
        }
        internalData.hoverRow = null;
      },
      /**
       * 已废弃，被 getCellElement 替换
       * @deprecated
       */
      getCell(row, column) {
        return tableMethods.getCellElement(row, column);
      },
      findRowIndexOf(list, row) {
        return row ? import_xe_utils8.default.findIndexOf(list, (item) => $xeTable.eqRow(item, row)) : -1;
      },
      eqRow(row1, row2) {
        if (row1 && row2) {
          if (row1 === row2) {
            return true;
          }
          return getRowid($xeTable, row1) === getRowid($xeTable, row2);
        }
        return false;
      }
    };
    "openExport,openPrint,exportData,openImport,importData,saveFile,readFile,importByFile,print".split(",").forEach((name) => {
      $xeTable[name] = function() {
        errLog("vxe.error.reqModule", ["VxeTableExportModule"]);
      };
    });
    "clearValidate,fullValidate,validate".split(",").forEach((name) => {
      $xeTable[name] = function() {
        errLog("vxe.error.reqModule", ["VxeTableValidatorModule"]);
      };
    });
    Object.assign($xeTable, tableMethods, tablePrivateMethods);
    const renderFixed = (fixedType) => {
      const { showHeader, showFooter } = props;
      const { tableData, tableColumn, tableGroupColumn, columnStore, footerTableData } = reactData;
      const isFixedLeft = fixedType === "left";
      const fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;
      return h("div", {
        ref: isFixedLeft ? refLeftContainer : refRightContainer,
        class: `vxe-table--fixed-${fixedType}-wrapper`
      }, [
        showHeader ? h(header_default, {
          ref: isFixedLeft ? refTableLeftHeader : refTableRightHeader,
          fixedType,
          tableData,
          tableColumn,
          tableGroupColumn,
          fixedColumn
        }) : renderEmptyElement5($xeTable),
        h(body_default, {
          ref: isFixedLeft ? refTableLeftBody : refTableRightBody,
          fixedType,
          tableData,
          tableColumn,
          fixedColumn
        }),
        showFooter ? h(footer_default, {
          ref: isFixedLeft ? refTableLeftFooter : refTableRightFooter,
          footerTableData,
          tableColumn,
          fixedColumn,
          fixedType
        }) : renderEmptyElement5($xeTable)
      ]);
    };
    const renderEmptyBody = () => {
      const emptyOpts = computeEmptyOpts.value;
      const params = { $table: $xeTable };
      if (slots.empty) {
        return slots.empty(params);
      } else {
        const compConf = emptyOpts.name ? renderer5.get(emptyOpts.name) : null;
        const rtEmptyView = compConf ? compConf.renderTableEmpty || compConf.renderTableEmptyView || compConf.renderEmpty : null;
        if (rtEmptyView) {
          return getSlotVNs(rtEmptyView(emptyOpts, params));
        }
      }
      return getFuncText(props.emptyText) || getI18n6("vxe.table.emptyText");
    };
    const renderDragTipContents = () => {
      const { dragConfig } = props;
      const { dragRow, dragCol, dragTipText } = reactData;
      const columnDragOpts = computeColumnDragOpts.value;
      const rowDragOpts = computeRowDragOpts.value;
      const rowDragSlots = rowDragOpts.slots || {};
      const rTipSlot = rowDragSlots.tip || (dragConfig && dragConfig.slots ? dragConfig.slots.rowTip : null);
      const columnDragSlots = columnDragOpts.slots || {};
      const cTipSlot = columnDragSlots.tip;
      if (dragRow && rTipSlot) {
        return callSlot(rTipSlot, { row: dragRow });
      }
      if (dragCol && cTipSlot) {
        return callSlot(cTipSlot, { column: dragCol });
      }
      return [h("span", dragTipText)];
    };
    const renderDragTip = () => {
      const { dragRow, dragCol } = reactData;
      const rowOpts = computeRowOpts.value;
      const columnOpts = computeColumnOpts.value;
      const rowDragOpts = computeRowDragOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      if (rowOpts.drag || columnOpts.drag) {
        return h("div", {
          class: "vxe-table--drag-wrapper"
        }, [
          h("div", {
            ref: refDragRowLineElem,
            class: ["vxe-table--drag-row-line", {
              "is--guides": rowDragOpts.showGuidesStatus
            }]
          }),
          h("div", {
            ref: refDragColLineElem,
            class: ["vxe-table--drag-col-line", {
              "is--guides": columnDragOpts.showGuidesStatus
            }]
          }),
          dragRow && rowDragOpts.showDragTip || dragCol && columnDragOpts.showDragTip ? h("div", {
            ref: refDragTipElem,
            class: "vxe-table--drag-sort-tip"
          }, [
            h("div", {
              class: "vxe-table--drag-sort-tip-wrapper"
            }, [
              h("div", {
                class: "vxe-table--drag-sort-tip-status"
              }, [
                h("span", {
                  class: ["vxe-table--drag-sort-tip-normal-status", dragRow ? getIcon6().TABLE_DRAG_STATUS_ROW : getIcon6().TABLE_DRAG_STATUS_COLUMN]
                }),
                h("span", {
                  class: ["vxe-table--drag-sort-tip-sub-status", getIcon6().TABLE_DRAG_STATUS_SUB_ROW]
                }),
                h("span", {
                  class: ["vxe-table--drag-sort-tip-disabled-status", getIcon6().TABLE_DRAG_DISABLED]
                })
              ]),
              h("div", {
                class: "vxe-table--drag-sort-tip-content"
              }, renderDragTipContents())
            ])
          ]) : renderEmptyElement5($xeTable)
        ]);
      }
      return renderEmptyElement5($xeTable);
    };
    const renderRowExpandedVNs = () => {
      const { treeConfig } = props;
      const { expandColumn } = reactData;
      const tableRowExpandedList = computeTableRowExpandedList.value;
      const expandOpts = computeExpandOpts.value;
      const { mode } = expandOpts;
      if (mode !== "fixed") {
        return renderEmptyElement5($xeTable);
      }
      const expandVNs = [
        h("div", {
          key: "repY",
          ref: refRowExpandYSpaceElem
        })
      ];
      if (expandColumn) {
        const { handleGetRowId } = createHandleGetRowId($xeTable);
        tableRowExpandedList.forEach((row) => {
          const expandOpts2 = computeExpandOpts.value;
          const { height: expandHeight, padding } = expandOpts2;
          const { fullAllDataRowIdData } = internalData;
          const treeOpts = computeTreeOpts.value;
          const { transform, seqMode } = treeOpts;
          const cellStyle = {};
          const rowid = handleGetRowId(row);
          const rest = fullAllDataRowIdData[rowid];
          let rowLevel = 0;
          let seq = -1;
          let _rowIndex = 0;
          const rowIndex = $xeTable.getRowIndex(row);
          const $rowIndex = $xeTable.getVMRowIndex(row);
          if (rest) {
            rowLevel = rest.level;
            if (treeConfig && transform && seqMode === "increasing") {
              seq = rest._index + 1;
            } else {
              seq = rest.seq;
            }
            _rowIndex = rest._index;
          }
          if (expandHeight) {
            cellStyle.height = `${expandHeight}px`;
          }
          if (treeConfig) {
            cellStyle.paddingLeft = `${rowLevel * treeOpts.indent + 30}px`;
          }
          const expandParams = { $table: $xeTable, seq, column: expandColumn, fixed: "", type: "body", level: rowLevel, row, rowIndex, $rowIndex, _rowIndex };
          expandVNs.push(h("div", {
            key: rowid,
            class: ["vxe-body--row-expanded-cell", {
              "is--padding": padding,
              "is--ellipsis": expandHeight
            }],
            rowid,
            style: cellStyle
          }, expandColumn.renderData(expandParams)));
        });
      }
      return h("div", {
        ref: refRowExpandElem,
        class: "vxe-table--row-expanded-wrapper"
      }, expandVNs);
    };
    const renderScrollX = () => {
      return h("div", {
        key: "vsx",
        ref: refScrollXVirtualElem,
        class: "vxe-table--scroll-x-virtual"
      }, [
        h("div", {
          ref: refScrollXLeftCornerElem,
          class: "vxe-table--scroll-x-left-corner"
        }),
        h("div", {
          ref: refScrollXWrapperElem,
          class: "vxe-table--scroll-x-wrapper"
        }, [
          h("div", {
            ref: refScrollXHandleElem,
            class: "vxe-table--scroll-x-handle",
            onScroll: $xeTable.triggerVirtualScrollXEvent
          }, [
            h("div", {
              ref: refScrollXSpaceElem,
              class: "vxe-table--scroll-x-space"
            })
          ])
        ]),
        h("div", {
          ref: refScrollXRightCornerElem,
          class: "vxe-table--scroll-x-right-corner"
        })
      ]);
    };
    const renderScrollY = () => {
      return h("div", {
        ref: refScrollYVirtualElem,
        class: "vxe-table--scroll-y-virtual"
      }, [
        h("div", {
          ref: refScrollYTopCornerElem,
          class: "vxe-table--scroll-y-top-corner"
        }),
        h("div", {
          ref: refScrollYWrapperElem,
          class: "vxe-table--scroll-y-wrapper"
        }, [
          h("div", {
            ref: refScrollYHandleElem,
            class: "vxe-table--scroll-y-handle",
            onScroll: $xeTable.triggerVirtualScrollYEvent
          }, [
            h("div", {
              ref: refScrollYSpaceElem,
              class: "vxe-table--scroll-y-space"
            })
          ])
        ]),
        h("div", {
          ref: refScrollYBottomCornerElem,
          class: "vxe-table--scroll-y-bottom-corner"
        })
      ]);
    };
    const renderViewport = () => {
      const { showHeader, showFooter } = props;
      const { overflowX, tableData, tableColumn, tableGroupColumn, footerTableData, columnStore } = reactData;
      const { leftList, rightList } = columnStore;
      return h("div", {
        ref: refTableViewportElem,
        class: "vxe-table--viewport-wrapper"
      }, [
        h("div", {
          class: "vxe-table--main-wrapper"
        }, [
          /**
           * 表头
           */
          showHeader ? h(header_default, {
            ref: refTableHeader,
            tableData,
            tableColumn,
            tableGroupColumn
          }) : renderEmptyElement5($xeTable),
          /**
           * 表体
           */
          h(body_default, {
            ref: refTableBody,
            tableData,
            tableColumn
          }),
          /**
           * 表尾
           */
          showFooter ? h(footer_default, {
            ref: refTableFooter,
            footerTableData,
            tableColumn
          }) : renderEmptyElement5($xeTable)
        ]),
        h("div", {
          class: "vxe-table--fixed-wrapper"
        }, [
          leftList && leftList.length && overflowX ? renderFixed("left") : renderEmptyElement5($xeTable),
          rightList && rightList.length && overflowX ? renderFixed("right") : renderEmptyElement5($xeTable)
        ]),
        renderRowExpandedVNs()
      ]);
    };
    const renderBody = () => {
      const scrollbarYToLeft = computeScrollbarYToLeft.value;
      return h("div", {
        class: "vxe-table--layout-wrapper"
      }, scrollbarYToLeft ? [
        renderScrollY(),
        renderViewport()
      ] : [
        renderViewport(),
        renderScrollY()
      ]);
    };
    const renderVN = () => {
      const { loading, stripe, showHeader, height, treeConfig, mouseConfig, showFooter, highlightCell, highlightHoverRow, highlightHoverColumn, editConfig, editRules } = props;
      const { isGroup, overflowX, overflowY, scrollXLoad, scrollYLoad, tableData, initStore, columnStore, filterStore, customStore } = reactData;
      const { leftList, rightList } = columnStore;
      const loadingSlot = slots.loading;
      const tableTipConfig = computeTableTipConfig.value;
      const validTipConfig = computeValidTipConfig.value;
      const validOpts = computeValidOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const treeOpts = computeTreeOpts.value;
      const rowOpts = computeRowOpts.value;
      const columnOpts = computeColumnOpts.value;
      const vSize = computeSize.value;
      const tableBorder = computeTableBorder.value;
      const mouseOpts = computeMouseOpts.value;
      const areaOpts = computeAreaOpts.value;
      const loadingOpts = computeLoadingOpts.value;
      const isMenu = computeIsMenu.value;
      const currLoading = reactData.isColLoading || reactData.isRowLoading || loading;
      const resizableOpts = computeResizableOpts.value;
      const isArea = mouseConfig && mouseOpts.area;
      const columnDragOpts = computeColumnDragOpts.value;
      const scrollbarXToTop = computeScrollbarXToTop.value;
      const scrollbarYToLeft = computeScrollbarYToLeft.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-table", "vxe-table--render-default", `tid_${xID}`, `border--${tableBorder}`, `sx-pos--${scrollbarXToTop ? "top" : "bottom"}`, `sy-pos--${scrollbarYToLeft ? "left" : "right"}`, {
          [`size--${vSize}`]: vSize,
          [`valid-msg--${validOpts.msgMode}`]: !!editRules,
          "vxe-editable": !!editConfig,
          "old-cell-valid": editRules && getConfig2().cellVaildMode === "obsolete",
          "cell--highlight": highlightCell,
          "cell--selected": mouseConfig && mouseOpts.selected,
          "cell--area": isArea,
          "header-cell--area": isArea && areaOpts.selectCellByHeader,
          "body-cell--area": isArea && areaOpts.selectCellByBody,
          "row--highlight": rowOpts.isHover || highlightHoverRow,
          "column--highlight": columnOpts.isHover || highlightHoverColumn,
          "checkbox--range": checkboxOpts.range,
          "col--drag-cell": columnOpts.drag && columnDragOpts.trigger === "cell",
          "is--header": showHeader,
          "is--footer": showFooter,
          "is--group": isGroup,
          "is--tree-line": treeConfig && (treeOpts.showLine || treeOpts.line),
          "is--fixed-left": leftList.length,
          "is--fixed-right": rightList.length,
          "is--animat": !!props.animat,
          "is--round": props.round,
          "is--stripe": !treeConfig && stripe,
          "is--loading": currLoading,
          "is--empty": !currLoading && !tableData.length,
          "is--scroll-y": overflowY,
          "is--scroll-x": overflowX,
          "is--virtual-x": scrollXLoad,
          "is--virtual-y": scrollYLoad
        }],
        spellcheck: false,
        onKeydown: keydownEvent
      }, [
        /**
         * 隐藏列
         */
        h("div", {
          class: "vxe-table-slots"
        }, slots.default ? slots.default({}) : []),
        h("div", {
          ref: refVarElem,
          class: "vxe-table-vars"
        }, [
          h("div", {
            class: "vxe-table-var-default"
          }),
          h("div", {
            class: "vxe-table-var-medium"
          }),
          h("div", {
            class: "vxe-table-var-small"
          }),
          h("div", {
            class: "vxe-table-var-mini"
          })
        ]),
        h("div", {
          key: "tw",
          class: "vxe-table--render-wrapper"
        }, scrollbarXToTop ? [
          renderScrollX(),
          renderBody()
        ] : [
          renderBody(),
          renderScrollX()
        ]),
        /**
         * 空数据
         */
        h("div", {
          key: "tn",
          ref: refEmptyPlaceholder,
          class: "vxe-table--empty-placeholder"
        }, [
          h("div", {
            class: "vxe-table--empty-content"
          }, renderEmptyBody())
        ]),
        /**
         * 边框线
         */
        h("div", {
          key: "tl",
          class: "vxe-table--border-line"
        }),
        /**
         * 列宽线
         */
        h("div", {
          key: "tcl",
          ref: refColResizeBar,
          class: "vxe-table--resizable-col-bar"
        }, resizableOpts.showDragTip ? [
          h("div", {
            class: "vxe-table--resizable-number-tip"
          })
        ] : []),
        /**
         * 行高线
         */
        h("div", {
          key: "trl",
          ref: refRowResizeBar,
          class: "vxe-table--resizable-row-bar"
        }, resizableOpts.showDragTip ? [
          h("div", {
            class: "vxe-table--resizable-number-tip"
          })
        ] : []),
        /**
         * 加载中
         */
        VxeUILoadingComponent ? h(VxeUILoadingComponent, {
          key: "lg",
          class: "vxe-table--loading",
          modelValue: currLoading,
          icon: loadingOpts.icon,
          text: loadingOpts.text
        }, loadingSlot ? {
          default: () => callSlot(loadingSlot, { $table: $xeTable, $grid: $xeGrid, loading: currLoading })
        } : {}) : loadingSlot ? h("div", {
          class: ["vxe-loading--custom-wrapper", {
            "is--visible": currLoading
          }]
        }, callSlot(loadingSlot, { $table: $xeTable, $grid: $xeGrid, loading: currLoading })) : renderEmptyElement5($xeTable),
        /**
         * 自定义列
         */
        initStore.custom ? h(panel_default, {
          key: "cs",
          ref: refTableCustom,
          customStore
        }) : renderEmptyElement5($xeTable),
        /**
         * 筛选
         */
        initStore.filter ? h(panel_default2, {
          key: "tf",
          ref: refTableFilter,
          filterStore
        }) : renderEmptyElement5($xeTable),
        /**
         * 导入
         */
        initStore.import && props.importConfig ? h(import_panel_default, {
          key: "it",
          defaultOptions: reactData.importParams,
          storeData: reactData.importStore
        }) : renderEmptyElement5($xeTable),
        /**
         * 导出
         */
        initStore.export && (props.exportConfig || props.printConfig) ? h(export_panel_default, {
          key: "et",
          defaultOptions: reactData.exportParams,
          storeData: reactData.exportStore
        }) : renderEmptyElement5($xeTable),
        /**
         * 快捷菜单
         */
        isMenu ? h(panel_default3, {
          key: "tm",
          ref: refTableMenu
        }) : renderEmptyElement5($xeTable),
        /**
         * 拖拽排序提示
         */
        renderDragTip(),
        /**
         * 提示相关
         */
        VxeUITooltipComponent ? h("div", {}, [
          /**
           * 通用提示
           */
          h(VxeUITooltipComponent, {
            key: "ctp",
            ref: refCommTooltip,
            isArrow: false,
            enterable: false
          }),
          /**
            * 工具提示
            */
          h(VxeUITooltipComponent, {
            key: "btp",
            ref: refTooltip,
            theme: tableTipConfig.theme,
            enterable: tableTipConfig.enterable,
            enterDelay: tableTipConfig.enterDelay,
            leaveDelay: tableTipConfig.leaveDelay
          }),
          /**
            * 校验提示
            */
          props.editRules && validOpts.showMessage && (validOpts.message === "default" ? !height : validOpts.message === "tooltip") ? h(VxeUITooltipComponent, {
            key: "vtp",
            ref: refValidTooltip,
            class: [{
              "old-cell-valid": editRules && getConfig2().cellVaildMode === "obsolete"
            }, "vxe-table--valid-error"],
            theme: validTipConfig.theme,
            enterable: validTipConfig.enterable,
            enterDelay: validTipConfig.enterDelay,
            leaveDelay: validTipConfig.leaveDelay
          }) : renderEmptyElement5($xeTable)
        ]) : renderEmptyElement5($xeTable)
      ]);
    };
    const dataFlag = ref(0);
    watch(() => props.data ? props.data.length : -1, () => {
      dataFlag.value++;
    });
    watch(() => props.data, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      const { initStatus } = internalData;
      const value = props.data || [];
      if (value && value.length >= 5e4) {
        warnLog("vxe.error.errLargeData", ["loadData(data), reloadData(data)"]);
      }
      loadTableData(value, false).then(() => {
        const { scrollXLoad, scrollYLoad, expandColumn } = reactData;
        const expandOpts = computeExpandOpts.value;
        internalData.inited = true;
        internalData.initStatus = true;
        if (!initStatus) {
          handleLoadDefaults();
        }
        if ((scrollXLoad || scrollYLoad) && (expandColumn && expandOpts.mode !== "fixed")) {
          warnLog("vxe.error.scrollErrProp", ["column.type=expand"]);
        }
        return tableMethods.recalculate();
      });
    });
    const staticColumnFlag = ref(0);
    watch(() => reactData.staticColumns.length, () => {
      staticColumnFlag.value++;
    });
    watch(() => reactData.staticColumns, () => {
      staticColumnFlag.value++;
    });
    watch(staticColumnFlag, () => {
      handleColumn(import_xe_utils8.default.clone(reactData.staticColumns));
    });
    const tableColumnFlag = ref(0);
    watch(() => reactData.tableColumn.length, () => {
      tableColumnFlag.value++;
    });
    watch(() => reactData.tableColumn, () => {
      tableColumnFlag.value++;
    });
    watch(tableColumnFlag, () => {
      tablePrivateMethods.analyColumnWidth();
    });
    watch(() => reactData.upDataFlag, () => {
      nextTick(() => {
        tableMethods.updateData();
      });
    });
    watch(() => reactData.reColumnFlag, () => {
      nextTick(() => {
        tableMethods.refreshColumn();
      });
    });
    const reScrollFlag = ref(0);
    watch(computeSize, () => {
      reScrollFlag.value++;
    });
    watch(() => props.showHeader, () => {
      reScrollFlag.value++;
    });
    watch(() => props.showFooter, () => {
      reScrollFlag.value++;
    });
    watch(() => reactData.overflowX, () => {
      reScrollFlag.value++;
    });
    watch(() => reactData.overflowY, () => {
      reScrollFlag.value++;
    });
    watch(reScrollFlag, () => {
      nextTick(() => {
        tableMethods.recalculate(true).then(() => tableMethods.refreshScroll());
      });
    });
    const reLayoutFlag = ref(0);
    watch(() => props.height, () => {
      reLayoutFlag.value++;
    });
    watch(() => props.maxHeight, () => {
      reLayoutFlag.value++;
    });
    watch(computeScrollbarXToTop, () => {
      reLayoutFlag.value++;
    });
    watch(computeScrollbarYToLeft, () => {
      reLayoutFlag.value++;
    });
    watch(() => VxeUI.getLanguage(), () => {
      reLayoutFlag.value++;
    });
    watch(reLayoutFlag, () => {
      nextTick(() => tableMethods.recalculate(true));
    });
    const footFlag = ref(0);
    watch(() => props.footerData ? props.footerData.length : -1, () => {
      footFlag.value++;
    });
    watch(() => props.footerData, () => {
      footFlag.value++;
    });
    watch(footFlag, () => {
      tableMethods.updateFooter();
    });
    watch(() => props.syncResize, (value) => {
      if (value) {
        handleUpdateResize();
        nextTick(() => {
          handleUpdateResize();
          setTimeout(() => handleUpdateResize());
        });
      }
    });
    const mergeCellFlag = ref(0);
    watch(() => props.mergeCells ? props.mergeCells.length : -1, () => {
      mergeCellFlag.value++;
    });
    watch(() => props.mergeCells, () => {
      mergeCellFlag.value++;
    });
    watch(mergeCellFlag, () => {
      tableMethods.clearMergeCells();
      nextTick(() => {
        if (props.mergeCells) {
          tableMethods.setMergeCells(props.mergeCells);
        }
      });
    });
    const mergeFooterItemFlag = ref(0);
    watch(() => props.mergeFooterItems ? props.mergeFooterItems.length : -1, () => {
      mergeFooterItemFlag.value++;
    });
    watch(() => props.mergeFooterItems, () => {
      mergeFooterItemFlag.value++;
    });
    watch(mergeFooterItemFlag, () => {
      tableMethods.clearMergeFooterItems();
      nextTick(() => {
        if (props.mergeFooterItems) {
          tableMethods.setMergeFooterItems(props.mergeFooterItems);
        }
      });
    });
    if ($xeTabs) {
      watch(() => $xeTabs ? $xeTabs.reactData.resizeFlag : null, () => {
        handleGlobalResizeEvent();
      });
    }
    hooks.forEach((options) => {
      const { setupTable } = options;
      if (setupTable) {
        const hookRest = setupTable($xeTable);
        if (hookRest && import_xe_utils8.default.isObject(hookRest)) {
          Object.assign($xeTable, hookRest);
        }
      }
    });
    tablePrivateMethods.preventEvent(null, "created", { $table: $xeTable });
    let resizeObserver;
    onActivated(() => {
      tableMethods.recalculate().then(() => tableMethods.refreshScroll());
      tablePrivateMethods.preventEvent(null, "activated", { $table: $xeTable });
    });
    onDeactivated(() => {
      internalData.isActivated = false;
      tablePrivateMethods.preventEvent(null, "deactivated", { $table: $xeTable });
    });
    onMounted(() => {
      const columnOpts = computeColumnOpts.value;
      const rowOpts = computeRowOpts.value;
      const customOpts = computeCustomOpts.value;
      if (columnOpts.drag || rowOpts.drag || customOpts.allowSort) {
        initTpImg();
      }
      nextTick(() => {
        const { data, exportConfig, importConfig, treeConfig, showOverflow } = props;
        const { scrollXStore, scrollYStore } = internalData;
        const editOpts = computeEditOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const expandOpts = computeExpandOpts.value;
        const rowOpts2 = computeRowOpts.value;
        const customOpts2 = computeCustomOpts.value;
        const mouseOpts = computeMouseOpts.value;
        const exportOpts = computeExportOpts.value;
        const importOpts = computeImportOpts.value;
        if (props.rowId) {
          warnLog("vxe.error.delProp", ["row-id", "row-config.keyField"]);
        }
        if (props.rowKey) {
          warnLog("vxe.error.delProp", ["row-key", "row-config.useKey"]);
        }
        if (props.columnKey) {
          warnLog("vxe.error.delProp", ["column-id", "column-config.useKey"]);
        }
        if (!(props.rowId || rowOpts2.keyField) && (checkboxOpts.reserve || checkboxOpts.checkRowKeys || radioOpts.reserve || radioOpts.checkRowKey || expandOpts.expandRowKeys || treeOpts.expandRowKeys)) {
          warnLog("vxe.error.reqProp", ["row-config.keyField"]);
        }
        if (props.editConfig && (editOpts.showStatus || editOpts.showUpdateStatus || editOpts.showInsertStatus) && !props.keepSource) {
          warnLog("vxe.error.reqProp", ["keep-source"]);
        }
        if (treeConfig && (treeOpts.showLine || treeOpts.line) && (!(props.rowKey || rowOpts2.useKey) || !showOverflow)) {
          warnLog("vxe.error.reqProp", ["row-config.useKey | show-overflow"]);
        }
        if (treeConfig && !treeOpts.transform && props.stripe) {
          warnLog("vxe.error.noTree", ["stripe"]);
        }
        if (props.showFooter && !(props.footerMethod || props.footerData)) {
          warnLog("vxe.error.reqProp", ["footer-data | footer-method"]);
        }
        if (rowOpts2.height) {
          warnLog("vxe.error.delProp", ["row-config.height", "cell-config.height"]);
        }
        if (props.highlightCurrentRow) {
          warnLog("vxe.error.delProp", ["highlight-current-row", "row-config.isCurrent"]);
        }
        if (props.highlightHoverRow) {
          warnLog("vxe.error.delProp", ["highlight-hover-row", "row-config.isHover"]);
        }
        if (props.highlightCurrentColumn) {
          warnLog("vxe.error.delProp", ["highlight-current-column", "column-config.isCurrent"]);
        }
        if (props.highlightHoverColumn) {
          warnLog("vxe.error.delProp", ["highlight-hover-column", "column-config.isHover"]);
        }
        if (importConfig && importOpts.types && !importOpts.importMethod && !import_xe_utils8.default.includeArrays(import_xe_utils8.default.keys(importOpts._typeMaps), importOpts.types)) {
          warnLog("vxe.error.errProp", [`export-config.types=${importOpts.types.join(",")}`, importOpts.types.filter((type) => import_xe_utils8.default.includes(import_xe_utils8.default.keys(importOpts._typeMaps), type)).join(",") || import_xe_utils8.default.keys(importOpts._typeMaps).join(",")]);
        }
        if (exportConfig && exportOpts.types && !exportOpts.exportMethod && !import_xe_utils8.default.includeArrays(import_xe_utils8.default.keys(exportOpts._typeMaps), exportOpts.types)) {
          warnLog("vxe.error.errProp", [`export-config.types=${exportOpts.types.join(",")}`, exportOpts.types.filter((type) => import_xe_utils8.default.includes(import_xe_utils8.default.keys(exportOpts._typeMaps), type)).join(",") || import_xe_utils8.default.keys(exportOpts._typeMaps).join(",")]);
        }
        if (!props.id) {
          if ((props.customConfig ? isEnableConf(customOpts2) : customOpts2.enabled) && customOpts2.storage) {
            errLog("vxe.error.reqProp", ["id"]);
          }
        }
        if (props.treeConfig && checkboxOpts.range) {
          errLog("vxe.error.noTree", ["checkbox-config.range"]);
        }
        if (rowOpts2.height && !props.showOverflow) {
          warnLog("vxe.error.notProp", ["table.show-overflow"]);
        }
        if (!$xeTable.handleCellAreaMousedownEvent) {
          if (props.areaConfig) {
            warnLog("vxe.error.notProp", ["area-config"]);
          }
          if (props.clipConfig) {
            warnLog("vxe.error.notProp", ["clip-config"]);
          }
          if (props.fnrConfig) {
            warnLog("vxe.error.notProp", ["fnr-config"]);
          }
          if (mouseOpts.area) {
            errLog("vxe.error.notProp", ["mouse-config.area"]);
            return;
          }
        }
        if (treeConfig && rowOpts2.drag && !treeOpts.transform) {
          errLog("vxe.error.notSupportProp", ["column-config.drag", "tree-config.transform=false", "tree-config.transform=true"]);
        }
        if (props.dragConfig) {
          warnLog("vxe.error.delProp", ["drag-config", "row-drag-config"]);
        }
        if (props.treeConfig && treeOpts.children) {
          warnLog("vxe.error.delProp", ["tree-config.children", "tree-config.childrenField"]);
        }
        if (props.treeConfig && treeOpts.line) {
          warnLog("vxe.error.delProp", ["tree-config.line", "tree-config.showLine"]);
        }
        if (mouseOpts.area && mouseOpts.selected) {
          warnLog("vxe.error.errConflicts", ["mouse-config.area", "mouse-config.selected"]);
        }
        if (mouseOpts.area && (props.treeConfig && !treeOpts.transform)) {
          errLog("vxe.error.noTree", ["mouse-config.area"]);
        }
        if (props.editConfig && editOpts.activeMethod) {
          warnLog("vxe.error.delProp", ["edit-config.activeMethod", "edit-config.beforeEditMethod"]);
        }
        if (props.treeConfig && checkboxOpts.isShiftKey) {
          errLog("vxe.error.errConflicts", ["tree-config", "checkbox-config.isShiftKey"]);
        }
        if (checkboxOpts.halfField) {
          warnLog("vxe.error.delProp", ["checkbox-config.halfField", "checkbox-config.indeterminateField"]);
        }
        if (props.editConfig && !$xeTable.insert) {
          errLog("vxe.error.reqModule", ["Edit"]);
        }
        if (props.editRules && !$xeTable.validate) {
          errLog("vxe.error.reqModule", ["Validator"]);
        }
        if ((checkboxOpts.range || props.keyboardConfig || props.mouseConfig) && !$xeTable.handleCellMousedownEvent) {
          errLog("vxe.error.reqModule", ["Keyboard"]);
        }
        if ((props.printConfig || props.importConfig || props.exportConfig) && !$xeTable.exportData) {
          errLog("vxe.error.reqModule", ["Export"]);
        }
        Object.assign(scrollYStore, {
          startIndex: 0,
          endIndex: 0,
          visibleSize: 0
        });
        Object.assign(scrollXStore, {
          startIndex: 0,
          endIndex: 0,
          visibleSize: 0
        });
        loadTableData(data || [], true).then(() => {
          if (data && data.length) {
            internalData.inited = true;
            internalData.initStatus = true;
            handleLoadDefaults();
          }
          handleInitDefaults();
          updateStyle();
        });
        if (props.autoResize) {
          const el = refElem.value;
          const parentEl = tablePrivateMethods.getParentElem();
          resizeObserver = globalResize.create(() => {
            if (props.autoResize) {
              tableMethods.recalculate(true);
            }
          });
          if (el) {
            resizeObserver.observe(el);
          }
          if (parentEl) {
            resizeObserver.observe(parentEl);
          }
        }
      });
      const tableViewportEl = refTableViewportElem.value;
      if (tableViewportEl) {
        tableViewportEl.addEventListener("wheel", $xeTable.triggerBodyWheelEvent, { passive: false });
      }
      globalEvents.on($xeTable, "paste", handleGlobalPasteEvent);
      globalEvents.on($xeTable, "copy", handleGlobalCopyEvent);
      globalEvents.on($xeTable, "cut", handleGlobalCutEvent);
      globalEvents.on($xeTable, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeTable, "blur", handleGlobalBlurEvent);
      globalEvents.on($xeTable, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeTable, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeTable, "resize", handleGlobalResizeEvent);
      globalEvents.on($xeTable, "contextmenu", $xeTable.handleGlobalContextmenuEvent);
      tablePrivateMethods.preventEvent(null, "mounted", { $table: $xeTable });
    });
    onBeforeUnmount(() => {
      const tableViewportEl = refTableViewportElem.value;
      if (tableViewportEl) {
        tableViewportEl.removeEventListener("wheel", $xeTable.triggerBodyWheelEvent);
      }
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      tableMethods.closeFilter();
      if ($xeTable.closeMenu) {
        $xeTable.closeMenu();
      }
      tablePrivateMethods.preventEvent(null, "beforeUnmount", { $table: $xeTable });
    });
    onUnmounted(() => {
      globalEvents.off($xeTable, "paste");
      globalEvents.off($xeTable, "copy");
      globalEvents.off($xeTable, "cut");
      globalEvents.off($xeTable, "mousedown");
      globalEvents.off($xeTable, "blur");
      globalEvents.off($xeTable, "mousewheel");
      globalEvents.off($xeTable, "keydown");
      globalEvents.off($xeTable, "resize");
      globalEvents.off($xeTable, "contextmenu");
      tablePrivateMethods.preventEvent(null, "unmounted", { $table: $xeTable });
    });
    nextTick(() => {
      if (props.loading) {
        if (!VxeUILoadingComponent && !slots.loading) {
          errLog("vxe.error.reqComp", ["vxe-loading"]);
        }
      }
      if (props.showOverflow === true || props.showOverflow === "tooltip" || (props.showHeaderOverflow === true || props.showHeaderOverflow === "tooltip") || (props.showFooterOverflow === true || props.showFooterOverflow === "tooltip") || props.tooltipConfig || props.editRules) {
        if (!VxeUITooltipComponent) {
          errLog("vxe.error.reqComp", ["vxe-tooltip"]);
        }
      }
    });
    provide("$xeColgroup", null);
    provide("$xeTable", $xeTable);
    $xeTable.renderVN = renderVN;
    return $xeTable;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-table/es/table/src/use/cell-view.js
var import_xe_utils9 = __toESM(require_xe_utils());
function useCellView(props) {
  const currColumn = computed(() => {
    const { renderParams } = props;
    return renderParams.column;
  });
  const currRow = computed(() => {
    const { renderParams } = props;
    return renderParams.row;
  });
  const cellOptions = computed(() => {
    const { renderOpts } = props;
    return renderOpts.props || {};
  });
  const cellModel = computed({
    get() {
      const { renderParams } = props;
      const { row, column } = renderParams;
      return import_xe_utils9.default.get(row, column.field);
    },
    set(value) {
      const { renderParams } = props;
      const { row, column } = renderParams;
      return import_xe_utils9.default.set(row, column.field, value);
    }
  });
  return {
    currColumn,
    currRow,
    cellModel,
    cellOptions
  };
}

// node_modules/vxe-table/es/table/module/filter/hook.js
var import_xe_utils10 = __toESM(require_xe_utils());
var { renderer: renderer6, hooks: hooks2 } = VxeUI;
var tableFilterMethodKeys = ["openFilter", "setFilter", "clearFilter", "saveFilterPanel", "resetFilterPanel", "getCheckedFilters", "updateFilterOptionStatus"];
hooks2.add("tableFilterModule", {
  setupTable($xeTable) {
    const { props, reactData, internalData } = $xeTable;
    const { refElem, refTableFilter } = $xeTable.getRefMaps();
    const { computeFilterOpts, computeMouseOpts } = $xeTable.getComputeMaps();
    const handleFilterConfirmFilter = (evnt) => {
      const { filterStore } = reactData;
      filterStore.options.forEach((option) => {
        option.checked = option._checked;
      });
      $xeTable.confirmFilterEvent(evnt);
    };
    const changeRadioOption = (evnt, checked, item) => {
      const { filterStore } = reactData;
      filterStore.options.forEach((option) => {
        option._checked = false;
      });
      item._checked = checked;
      $xeTable.checkFilterOptions();
      handleFilterConfirmFilter(evnt);
    };
    const changeMultipleOption = (evnt, checked, item) => {
      item._checked = checked;
      $xeTable.checkFilterOptions();
    };
    const handleFilterResetFilter = (evnt) => {
      const { filterStore } = reactData;
      $xeTable.handleClearFilter(filterStore.column);
      $xeTable.confirmFilterEvent(evnt);
    };
    const filterPrivateMethods = {
      checkFilterOptions() {
        const { filterStore } = reactData;
        filterStore.isAllSelected = filterStore.options.every((item) => item._checked);
        filterStore.isIndeterminate = !filterStore.isAllSelected && filterStore.options.some((item) => item._checked);
      },
      /**
       * 点击筛选事件
       * 当筛选图标被点击时触发
       * 更新选项是否全部状态
       * 打开筛选面板
       * @param {Event} evnt 事件
       * @param {ColumnInfo} column 列配置
       * @param {Object} params 参数
       */
      triggerFilterEvent(evnt, column, params) {
        const { initStore, filterStore } = reactData;
        const { elemStore } = internalData;
        if (filterStore.column === column && filterStore.visible) {
          filterStore.visible = false;
        } else {
          const { clientY, pageX } = evnt;
          const el = refElem.value;
          const tableRect = el.getBoundingClientRect();
          const targetElem = evnt.target;
          const { visibleWidth } = getDomNode();
          const { filters, filterMultiple, filterRender } = column;
          const compConf = isEnableConf(filterRender) ? renderer6.get(filterRender.name) : null;
          const frMethod = column.filterRecoverMethod || (compConf ? compConf.tableFilterRecoverMethod || compConf.filterRecoverMethod : null);
          internalData._currFilterParams = params;
          Object.assign(filterStore, {
            multiple: filterMultiple,
            options: filters,
            column,
            style: null
          });
          filterStore.options.forEach((option) => {
            const { _checked, checked } = option;
            option._checked = checked;
            if (!checked && _checked !== checked) {
              if (frMethod) {
                frMethod({ option, column, $table: $xeTable });
              }
            }
          });
          this.checkFilterOptions();
          filterStore.visible = true;
          initStore.filter = true;
          nextTick(() => {
            const headerScrollElem = getRefElem(elemStore["main-header-scroll"]);
            if (!headerScrollElem) {
              return;
            }
            const tableFilter = refTableFilter.value;
            const filterWrapperElem = tableFilter ? tableFilter.$el : null;
            if (!filterWrapperElem) {
              return;
            }
            const filterWidth = filterWrapperElem.offsetWidth;
            const filterHeadElem = filterWrapperElem.querySelector(".vxe-table--filter-header");
            const filterFootElem = filterWrapperElem.querySelector(".vxe-table--filter-footer");
            const centerWidth = filterWidth / 2;
            const minMargin = 10;
            const maxLeft = el.clientWidth - filterWidth - minMargin;
            let left, right;
            const thEl = targetElem.offsetParent;
            const trEl = thEl.offsetParent;
            const style = {
              top: `${targetElem.offsetTop + thEl.offsetTop + targetElem.offsetHeight}px`
            };
            const maxHeight = Math.max(40, el.clientHeight - (clientY - tableRect.y) - (filterHeadElem ? filterHeadElem.clientHeight : 0) - (filterFootElem ? filterFootElem.clientHeight : 0) - 14);
            if (column.fixed === "left") {
              left = targetElem.offsetLeft + thEl.offsetLeft - centerWidth;
            } else if (column.fixed === "right") {
              right = thEl.offsetWidth - targetElem.offsetLeft + (trEl.offsetWidth - trEl.offsetLeft) - column.renderWidth - centerWidth;
            } else {
              left = targetElem.offsetLeft + thEl.offsetLeft - centerWidth - headerScrollElem.scrollLeft;
            }
            if (left) {
              const overflowWidth = pageX + filterWidth - centerWidth + minMargin - visibleWidth;
              if (overflowWidth > 0) {
                left -= overflowWidth;
              }
              style.left = `${Math.min(maxLeft, Math.max(minMargin, left))}px`;
            } else if (right) {
              const overflowWidth = pageX + filterWidth - centerWidth + minMargin - visibleWidth;
              if (overflowWidth > 0) {
                right += overflowWidth;
              }
              style.right = `${Math.max(minMargin, right)}px`;
            }
            filterStore.style = style;
            filterStore.maxHeight = maxHeight;
          });
        }
        $xeTable.dispatchEvent("filter-visible", { column, field: column.field, property: column.field, filterList: $xeTable.getCheckedFilters(), visible: filterStore.visible }, evnt);
      },
      handleClearFilter(column) {
        if (column) {
          const { filters, filterRender } = column;
          if (filters) {
            const compConf = isEnableConf(filterRender) ? renderer6.get(filterRender.name) : null;
            const frMethod = column.filterResetMethod || (compConf ? compConf.tableFilterResetMethod || compConf.filterResetMethod : null);
            filters.forEach((item) => {
              item._checked = false;
              item.checked = false;
              if (!frMethod) {
                item.data = import_xe_utils10.default.clone(item.resetValue, true);
              }
            });
            if (frMethod) {
              frMethod({ options: filters, column, $table: $xeTable });
            }
          }
        }
      },
      handleColumnConfirmFilter(column, evnt) {
        const { mouseConfig } = props;
        const { scrollXLoad: oldScrollXLoad, scrollYLoad: oldScrollYLoad } = reactData;
        const filterOpts = computeFilterOpts.value;
        const mouseOpts = computeMouseOpts.value;
        const { field } = column;
        const values = [];
        const datas = [];
        column.filters.forEach((item) => {
          if (item.checked) {
            values.push(item.value);
            datas.push(item.data);
          }
        });
        const filterList = $xeTable.getCheckedFilters();
        const params = { $table: $xeTable, $event: evnt, column, field, property: field, values, datas, filters: filterList, filterList };
        if (!filterOpts.remote) {
          $xeTable.handleTableData(true);
          $xeTable.checkSelectionStatus();
        }
        if (mouseConfig && mouseOpts.area && $xeTable.handleFilterEvent) {
          $xeTable.handleFilterEvent(evnt, params);
        }
        if (evnt) {
          $xeTable.dispatchEvent("filter-change", params, evnt);
        }
        $xeTable.closeFilter();
        return $xeTable.updateFooter().then(() => {
          const { scrollXLoad, scrollYLoad } = reactData;
          if (oldScrollXLoad || scrollXLoad || (oldScrollYLoad || scrollYLoad)) {
            if (oldScrollXLoad || scrollXLoad) {
              $xeTable.updateScrollXSpace();
            }
            if (oldScrollYLoad || scrollYLoad) {
              $xeTable.updateScrollYSpace();
            }
            return $xeTable.refreshScroll();
          }
        }).then(() => {
          $xeTable.updateCellAreas();
          return $xeTable.recalculate(true);
        }).then(() => {
          setTimeout(() => $xeTable.recalculate(), 50);
        });
      },
      /**
       * 确认筛选
       * 当筛选面板中的确定按钮被按下时触发
       * @param {Event} evnt 事件
       */
      confirmFilterEvent(evnt) {
        const { filterStore } = reactData;
        const { column } = filterStore;
        $xeTable.handleColumnConfirmFilter(column, evnt);
      },
      handleFilterChangeRadioOption: changeRadioOption,
      handleFilterChangeMultipleOption: changeMultipleOption,
      // 筛选发生改变
      handleFilterChangeOption(evnt, checked, item) {
        const { filterStore } = reactData;
        if (filterStore.multiple) {
          changeMultipleOption(evnt, checked, item);
        } else {
          changeRadioOption(evnt, checked, item);
        }
      },
      handleFilterConfirmFilter,
      handleFilterResetFilter
    };
    const filterMethods = {
      /**
       * 手动弹出筛选面板
       * @param column
       */
      openFilter(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column && column.filters) {
          const { elemStore } = internalData;
          const { fixed } = column;
          return $xeTable.scrollToColumn(column).then(() => {
            const headerWrapperElem = getRefElem(elemStore[`${fixed || "main"}-header-wrapper`] || elemStore["main-header-wrapper"]);
            if (headerWrapperElem) {
              const filterBtnElem = headerWrapperElem.querySelector(`.vxe-header--column.${column.id} .vxe-filter--btn`);
              triggerEvent(filterBtnElem, "click");
            }
          });
        }
        return nextTick();
      },
      /**
       * 修改筛选条件列表
       * @param {ColumnInfo} fieldOrColumn 列或字段名
       * @param {Array} options 选项
       */
      setFilter(fieldOrColumn, options, isUpdate) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column && column.filters) {
          column.filters = toFilters(options || []);
          if (isUpdate) {
            return $xeTable.handleColumnConfirmFilter(column, new Event("click"));
          }
        }
        return nextTick();
      },
      /**
       * 清空指定列的筛选条件
       * 如果为空则清空所有列的筛选条件
       * @param {String} fieldOrColumn 列或字段名
       */
      clearFilter(fieldOrColumn) {
        const { filterStore } = reactData;
        const { tableFullColumn } = internalData;
        const filterOpts = computeFilterOpts.value;
        let column;
        if (fieldOrColumn) {
          column = handleFieldOrColumn($xeTable, fieldOrColumn);
          if (column) {
            filterPrivateMethods.handleClearFilter(column);
          }
        } else {
          tableFullColumn.forEach(filterPrivateMethods.handleClearFilter);
        }
        if (!fieldOrColumn || column !== filterStore.column) {
          Object.assign(filterStore, {
            isAllSelected: false,
            isIndeterminate: false,
            style: null,
            options: [],
            column: null,
            multiple: false,
            visible: false
          });
        }
        if (!filterOpts.remote) {
          return $xeTable.updateData();
        }
        return nextTick();
      },
      saveFilterPanel() {
        handleFilterConfirmFilter(null);
        return nextTick();
      },
      resetFilterPanel() {
        handleFilterResetFilter(null);
        return nextTick();
      },
      getCheckedFilters() {
        const { tableFullColumn } = internalData;
        const filterList = [];
        tableFullColumn.forEach((column) => {
          const { field, filters } = column;
          const valueList = [];
          const dataList = [];
          if (filters && filters.length) {
            filters.forEach((item) => {
              if (item.checked) {
                valueList.push(item.value);
                dataList.push(item.data);
              }
            });
            if (valueList.length) {
              filterList.push({ column, field, property: field, values: valueList, datas: dataList });
            }
          }
        });
        return filterList;
      },
      updateFilterOptionStatus(item, checked) {
        item._checked = checked;
        item.checked = checked;
        return nextTick();
      }
    };
    return Object.assign(Object.assign({}, filterMethods), filterPrivateMethods);
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableFilterMethodKeys);
  }
});

// node_modules/vxe-table/es/table/module/menu/hook.js
var import_xe_utils11 = __toESM(require_xe_utils());
var { menus, hooks: hooks3, globalEvents: globalEvents2, GLOBAL_EVENT_KEYS: GLOBAL_EVENT_KEYS2 } = VxeUI;
var tableMenuMethodKeys = ["closeMenu"];
hooks3.add("tableMenuModule", {
  setupTable($xeTable) {
    const { xID, props, reactData, internalData } = $xeTable;
    const { refElem, refTableFilter, refTableMenu } = $xeTable.getRefMaps();
    const { computeMouseOpts, computeIsMenu, computeMenuOpts } = $xeTable.getComputeMaps();
    let menuMethods = {};
    let menuPrivateMethods = {};
    const handleOpenMenuEvent = (evnt, type, params) => {
      const { ctxMenuStore } = reactData;
      const isMenu = computeIsMenu.value;
      const menuOpts = computeMenuOpts.value;
      const config = menuOpts[type];
      const visibleMethod = menuOpts.visibleMethod;
      if (config) {
        const { options, disabled } = config;
        if (disabled) {
          evnt.preventDefault();
        } else if (isMenu && options && options.length) {
          params.options = options;
          $xeTable.preventEvent(evnt, "event.showMenu", params, () => {
            if (!visibleMethod || visibleMethod(params)) {
              evnt.preventDefault();
              $xeTable.updateZindex();
              const { scrollTop, scrollLeft, visibleHeight, visibleWidth } = getDomNode();
              let top = evnt.clientY + scrollTop;
              let left = evnt.clientX + scrollLeft;
              const handleVisible = () => {
                internalData._currMenuParams = params;
                Object.assign(ctxMenuStore, {
                  visible: true,
                  list: options,
                  selected: null,
                  selectChild: null,
                  showChild: false,
                  style: {
                    zIndex: internalData.tZindex,
                    top: `${top}px`,
                    left: `${left}px`
                  }
                });
                nextTick(() => {
                  const tableMenu = refTableMenu.value;
                  const ctxElem = tableMenu.getRefMaps().refElem.value;
                  const clientHeight = ctxElem.clientHeight;
                  const clientWidth = ctxElem.clientWidth;
                  const { boundingTop, boundingLeft } = getAbsolutePos(ctxElem);
                  const offsetTop = boundingTop + clientHeight - visibleHeight;
                  const offsetLeft = boundingLeft + clientWidth - visibleWidth;
                  if (offsetTop > -10) {
                    ctxMenuStore.style.top = `${Math.max(scrollTop + 2, top - clientHeight - 2)}px`;
                  }
                  if (offsetLeft > -10) {
                    ctxMenuStore.style.left = `${Math.max(scrollLeft + 2, left - clientWidth - 2)}px`;
                  }
                });
              };
              const { keyboard, row, column } = params;
              if (keyboard && row && column) {
                $xeTable.scrollToRow(row, column).then(() => {
                  const cell = $xeTable.getCellElement(row, column);
                  if (cell) {
                    const { boundingTop, boundingLeft } = getAbsolutePos(cell);
                    top = boundingTop + scrollTop + Math.floor(cell.offsetHeight / 2);
                    left = boundingLeft + scrollLeft + Math.floor(cell.offsetWidth / 2);
                  }
                  handleVisible();
                });
              } else {
                handleVisible();
              }
            } else {
              menuMethods.closeMenu();
            }
          });
        }
      }
      $xeTable.closeFilter();
    };
    menuMethods = {
      /**
       * 关闭快捷菜单
       */
      closeMenu() {
        Object.assign(reactData.ctxMenuStore, {
          visible: false,
          selected: null,
          selectChild: null,
          showChild: false
        });
        return nextTick();
      }
    };
    menuPrivateMethods = {
      /**
       * 处理菜单的移动
       */
      moveCtxMenu(evnt, ctxMenuStore, property, hasOper, operRest, menuList) {
        let selectItem;
        const selectIndex = import_xe_utils11.default.findIndexOf(menuList, (item) => ctxMenuStore[property] === item);
        if (hasOper) {
          if (operRest && hasChildrenList(ctxMenuStore.selected)) {
            ctxMenuStore.showChild = true;
          } else {
            ctxMenuStore.showChild = false;
            ctxMenuStore.selectChild = null;
          }
        } else if (globalEvents2.hasKey(evnt, GLOBAL_EVENT_KEYS2.ARROW_UP)) {
          for (let len = selectIndex - 1; len >= 0; len--) {
            if (menuList[len].visible !== false) {
              selectItem = menuList[len];
              break;
            }
          }
          ctxMenuStore[property] = selectItem || menuList[menuList.length - 1];
        } else if (globalEvents2.hasKey(evnt, GLOBAL_EVENT_KEYS2.ARROW_DOWN)) {
          for (let index = selectIndex + 1; index < menuList.length; index++) {
            if (menuList[index].visible !== false) {
              selectItem = menuList[index];
              break;
            }
          }
          ctxMenuStore[property] = selectItem || menuList[0];
        } else if (ctxMenuStore[property] && (globalEvents2.hasKey(evnt, GLOBAL_EVENT_KEYS2.ENTER) || globalEvents2.hasKey(evnt, GLOBAL_EVENT_KEYS2.SPACEBAR))) {
          menuPrivateMethods.ctxMenuLinkEvent(evnt, ctxMenuStore[property]);
        }
      },
      handleOpenMenuEvent,
      /**
       * 快捷菜单事件处理
       */
      handleGlobalContextmenuEvent(evnt) {
        const { mouseConfig, menuConfig } = props;
        const { editStore, ctxMenuStore } = reactData;
        const { visibleColumn } = internalData;
        const tableFilter = refTableFilter.value;
        const tableMenu = refTableMenu.value;
        const mouseOpts = computeMouseOpts.value;
        const menuOpts = computeMenuOpts.value;
        const el = refElem.value;
        const { selected } = editStore;
        const layoutList = ["header", "body", "footer"];
        if (isEnableConf(menuConfig)) {
          if (ctxMenuStore.visible && tableMenu && getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) {
            evnt.preventDefault();
            return;
          }
          if (internalData._keyCtx) {
            const type = "body";
            const params = { type, $table: $xeTable, keyboard: true, columns: visibleColumn.slice(0), $event: evnt };
            if (mouseConfig && mouseOpts.area) {
              const activeArea = $xeTable.getActiveCellArea();
              if (activeArea && activeArea.row && activeArea.column) {
                params.row = activeArea.row;
                params.column = activeArea.column;
                handleOpenMenuEvent(evnt, type, params);
                return;
              }
            } else if (mouseConfig && mouseOpts.selected) {
              if (selected.row && selected.column) {
                params.row = selected.row;
                params.column = selected.column;
                handleOpenMenuEvent(evnt, type, params);
                return;
              }
            }
          }
          for (let index = 0; index < layoutList.length; index++) {
            const layout = layoutList[index];
            const columnTargetNode = getEventTargetNode(evnt, el, `vxe-${layout}--column`, (target) => {
              return target.parentNode.parentNode.parentNode.getAttribute("xid") === xID;
            });
            const params = { type: layout, $table: $xeTable, columns: visibleColumn.slice(0), $event: evnt };
            if (columnTargetNode.flag) {
              const cell = columnTargetNode.targetElem;
              const columnNodeRest = $xeTable.getColumnNode(cell);
              const column = columnNodeRest ? columnNodeRest.item : null;
              let typePrefix = `${layout}-`;
              if (column) {
                Object.assign(params, { column, columnIndex: $xeTable.getColumnIndex(column), cell });
              }
              if (layout === "body") {
                const rowNodeRest = $xeTable.getRowNode(cell.parentNode);
                const row = rowNodeRest ? rowNodeRest.item : null;
                typePrefix = "";
                if (row) {
                  params.row = row;
                  params.rowIndex = $xeTable.getRowIndex(row);
                }
              }
              const eventType = `${typePrefix}cell-menu`;
              handleOpenMenuEvent(evnt, layout, params);
              $xeTable.dispatchEvent(eventType, params, evnt);
              return;
            } else if (getEventTargetNode(evnt, el, `vxe-table--${layout}-wrapper`, (target) => target.getAttribute("xid") === xID).flag) {
              if (menuOpts.trigger === "cell") {
                evnt.preventDefault();
              } else {
                handleOpenMenuEvent(evnt, layout, params);
              }
              return;
            }
          }
        }
        if (tableFilter && !getEventTargetNode(evnt, tableFilter.$el).flag) {
          $xeTable.closeFilter();
        }
        menuMethods.closeMenu();
      },
      ctxMenuMouseoverEvent(evnt, item, child) {
        const menuElem = evnt.currentTarget;
        const { ctxMenuStore } = reactData;
        evnt.preventDefault();
        evnt.stopPropagation();
        ctxMenuStore.selected = item;
        ctxMenuStore.selectChild = child;
        if (!child) {
          ctxMenuStore.showChild = hasChildrenList(item);
          if (ctxMenuStore.showChild) {
            nextTick(() => {
              const childWrapperElem = menuElem.nextElementSibling;
              if (childWrapperElem) {
                const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(menuElem);
                const posTop = boundingTop + menuElem.offsetHeight;
                const posLeft = boundingLeft + menuElem.offsetWidth;
                let left = "";
                let right = "";
                if (posLeft + childWrapperElem.offsetWidth > visibleWidth - 10) {
                  left = "auto";
                  right = `${menuElem.offsetWidth}px`;
                }
                let top = "";
                let bottom = "";
                if (posTop + childWrapperElem.offsetHeight > visibleHeight - 10) {
                  top = "auto";
                  bottom = "0";
                }
                childWrapperElem.style.left = left;
                childWrapperElem.style.right = right;
                childWrapperElem.style.top = top;
                childWrapperElem.style.bottom = bottom;
              }
            });
          }
        }
      },
      ctxMenuMouseoutEvent(evnt, item) {
        const { ctxMenuStore } = reactData;
        if (!item.children) {
          ctxMenuStore.selected = null;
        }
        ctxMenuStore.selectChild = null;
      },
      /**
       * 快捷菜单点击事件
       */
      ctxMenuLinkEvent(evnt, menu) {
        const $xeGrid = $xeTable.xeGrid;
        if (!menu.disabled && (menu.code || !menu.children || !menu.children.length)) {
          const gMenuOpts = menus.get(menu.code);
          const params = Object.assign({}, internalData._currMenuParams, { menu, $table: $xeTable, $grid: $xeGrid, $event: evnt });
          const tmMethod = gMenuOpts ? gMenuOpts.tableMenuMethod || gMenuOpts.menuMethod : null;
          if (tmMethod) {
            tmMethod(params, evnt);
          }
          $xeTable.dispatchEvent("menu-click", params, evnt);
          menuMethods.closeMenu();
        }
      }
    };
    return Object.assign(Object.assign({}, menuMethods), menuPrivateMethods);
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableMenuMethodKeys);
  }
});

// node_modules/vxe-table/es/table/module/edit/hook.js
var import_xe_utils12 = __toESM(require_xe_utils());
var { getConfig: getConfig3, renderer: renderer7, hooks: hooks4, getI18n: getI18n7 } = VxeUI;
var tableEditMethodKeys = ["insert", "insertAt", "insertNextAt", "insertChild", "insertChildAt", "insertChildNextAt", "remove", "removeCheckboxRow", "removeRadioRow", "removeCurrentRow", "getRecordset", "getInsertRecords", "getRemoveRecords", "getUpdateRecords", "getEditRecord", "getActiveRecord", "getSelectedCell", "clearEdit", "clearActived", "clearSelected", "isEditByRow", "isActiveByRow", "setEditRow", "setActiveRow", "setEditCell", "setActiveCell", "setSelectCell"];
hooks4.add("tableEditModule", {
  setupTable($xeTable) {
    const { props, reactData, internalData } = $xeTable;
    const { refElem } = $xeTable.getRefMaps();
    const { computeMouseOpts, computeEditOpts, computeCheckboxOpts, computeTreeOpts, computeValidOpts } = $xeTable.getComputeMaps();
    const browseObj2 = import_xe_utils12.default.browse();
    let editMethods = {};
    let editPrivateMethods = {};
    const getEditColumnModel = (row, column) => {
      const { model, editRender } = column;
      if (editRender) {
        model.value = getCellValue(row, column);
        model.update = false;
      }
    };
    const setEditColumnModel = (row, column) => {
      const { model, editRender } = column;
      if (editRender && model.update) {
        setCellValue(row, column, model.value);
        model.update = false;
        model.value = null;
      }
    };
    const removeCellSelectedClass = () => {
      const el = refElem.value;
      if (el) {
        const cell = el.querySelector(".col--selected");
        if (cell) {
          removeClass(cell, "col--selected");
        }
      }
    };
    const syncActivedCell = () => {
      const { editStore, tableColumn } = reactData;
      const editOpts = computeEditOpts.value;
      const { actived } = editStore;
      const { row, column } = actived;
      if (row || column) {
        if (editOpts.mode === "row") {
          tableColumn.forEach((column2) => setEditColumnModel(row, column2));
        } else {
          setEditColumnModel(row, column);
        }
      }
    };
    const insertTreeRow = (newRecords, isAppend) => {
      const { tableFullTreeData, afterFullData, fullDataRowIdData, fullAllDataRowIdData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { rowField, parentField, mapChildrenField } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const funcName = isAppend ? "push" : "unshift";
      newRecords.forEach((item) => {
        const parentRowId = item[parentField];
        const rowid = getRowid($xeTable, item);
        const matchObj = parentRowId ? import_xe_utils12.default.findTree(tableFullTreeData, (item2) => parentRowId === item2[rowField], { children: mapChildrenField }) : null;
        if (matchObj) {
          const { item: parentRow } = matchObj;
          const parentRest = fullAllDataRowIdData[getRowid($xeTable, parentRow)];
          const parentLevel = parentRest ? parentRest.level : 0;
          let parentChilds = parentRow[childrenField];
          let mapChilds = parentRow[mapChildrenField];
          if (!import_xe_utils12.default.isArray(parentChilds)) {
            parentChilds = parentRow[childrenField] = [];
          }
          if (!import_xe_utils12.default.isArray(mapChilds)) {
            mapChilds = parentRow[childrenField] = [];
          }
          parentChilds[funcName](item);
          mapChilds[funcName](item);
          const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, treeIndex: -1, items: parentChilds, parent: parentRow, level: parentLevel + 1, height: 0, resizeHeight: 0, oTop: 0, expandHeight: 0 };
          fullDataRowIdData[rowid] = rest;
          fullAllDataRowIdData[rowid] = rest;
        } else {
          if (true) {
            if (parentRowId) {
              warnLog("vxe.error.unableInsert");
            }
          }
          afterFullData[funcName](item);
          tableFullTreeData[funcName](item);
          const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, treeIndex: -1, items: tableFullTreeData, parent: null, level: 0, height: 0, resizeHeight: 0, oTop: 0, expandHeight: 0 };
          fullDataRowIdData[rowid] = rest;
          fullAllDataRowIdData[rowid] = rest;
        }
      });
    };
    const handleInsertRowAt = (records, targetRow, isInsertNextRow) => {
      const { treeConfig } = props;
      const { mergeList } = reactData;
      const { tableFullTreeData, afterFullData, tableFullData, fullDataRowIdData, fullAllDataRowIdData, insertRowMaps } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { transform, rowField, mapChildrenField } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      if (!import_xe_utils12.default.isArray(records)) {
        records = [records];
      }
      const newRecords = reactive($xeTable.defineField(records.map((record) => Object.assign(treeConfig && transform ? { [mapChildrenField]: [], [childrenField]: [] } : {}, record))));
      if (import_xe_utils12.default.eqNull(targetRow)) {
        if (treeConfig && transform) {
          insertTreeRow(newRecords, false);
        } else {
          newRecords.forEach((item) => {
            const rowid = getRowid($xeTable, item);
            const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, treeIndex: -1, items: afterFullData, parent: null, level: 0, height: 0, resizeHeight: 0, oTop: 0, expandHeight: 0 };
            fullDataRowIdData[rowid] = rest;
            fullAllDataRowIdData[rowid] = rest;
            afterFullData.unshift(item);
            tableFullData.unshift(item);
          });
          mergeList.forEach((mergeItem) => {
            const { row: mergeRowIndex } = mergeItem;
            if (mergeRowIndex > 0) {
              mergeItem.row = mergeRowIndex + newRecords.length;
            }
          });
        }
      } else {
        if (targetRow === -1) {
          if (treeConfig && transform) {
            insertTreeRow(newRecords, true);
          } else {
            newRecords.forEach((item) => {
              const rowid = getRowid($xeTable, item);
              const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, treeIndex: -1, $index: -1, items: afterFullData, parent: null, level: 0, height: 0, resizeHeight: 0, oTop: 0, expandHeight: 0 };
              fullDataRowIdData[rowid] = rest;
              fullAllDataRowIdData[rowid] = rest;
              afterFullData.push(item);
              tableFullData.push(item);
            });
            mergeList.forEach((mergeItem) => {
              const { row: mergeRowIndex, rowspan: mergeRowspan } = mergeItem;
              if (mergeRowIndex + mergeRowspan > afterFullData.length) {
                mergeItem.rowspan = mergeRowspan + newRecords.length;
              }
            });
          }
        } else {
          if (treeConfig && transform) {
            const matchMapObj = import_xe_utils12.default.findTree(tableFullTreeData, (item) => targetRow[rowField] === item[rowField], { children: mapChildrenField });
            if (matchMapObj) {
              const { parent: parentRow } = matchMapObj;
              const parentMapChilds = parentRow ? parentRow[mapChildrenField] : tableFullTreeData;
              const parentRest = fullAllDataRowIdData[getRowid($xeTable, parentRow)];
              const parentLevel = parentRest ? parentRest.level : 0;
              newRecords.forEach((item, i) => {
                const rowid = getRowid($xeTable, item);
                if (true) {
                  if (item[treeOpts.parentField]) {
                    if (parentRow && item[treeOpts.parentField] !== parentRow[rowField]) {
                      errLog("vxe.error.errProp", [`${treeOpts.parentField}=${item[treeOpts.parentField]}`, `${treeOpts.parentField}=${parentRow[rowField]}`]);
                    }
                  }
                }
                if (parentRow) {
                  item[treeOpts.parentField] = parentRow[rowField];
                }
                let targetIndex = matchMapObj.index + i;
                if (isInsertNextRow) {
                  targetIndex = targetIndex + 1;
                }
                parentMapChilds.splice(targetIndex, 0, item);
                const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, treeIndex: -1, items: parentMapChilds, parent: parentRow, level: parentLevel + 1, height: 0, resizeHeight: 0, oTop: 0, expandHeight: 0 };
                fullDataRowIdData[rowid] = rest;
                fullAllDataRowIdData[rowid] = rest;
              });
              if (parentRow) {
                const matchObj = import_xe_utils12.default.findTree(tableFullTreeData, (item) => targetRow[rowField] === item[rowField], { children: childrenField });
                if (matchObj) {
                  const parentChilds = matchObj.items;
                  let targetIndex = matchObj.index;
                  if (isInsertNextRow) {
                    targetIndex = targetIndex + 1;
                  }
                  parentChilds.splice(targetIndex, 0, ...newRecords);
                }
              }
            } else {
              if (true) {
                warnLog("vxe.error.unableInsert");
              }
              insertTreeRow(newRecords, true);
            }
          } else {
            if (treeConfig) {
              throw new Error(getI18n7("vxe.error.noTree", ["insert"]));
            }
            let afIndex = -1;
            if (import_xe_utils12.default.isNumber(targetRow)) {
              if (targetRow < afterFullData.length) {
                afIndex = targetRow;
              }
            } else {
              afIndex = $xeTable.findRowIndexOf(afterFullData, targetRow);
            }
            if (isInsertNextRow) {
              afIndex = Math.min(afterFullData.length, afIndex + 1);
            }
            if (afIndex === -1) {
              throw new Error(getI18n7("vxe.error.unableInsert"));
            }
            afterFullData.splice(afIndex, 0, ...newRecords);
            const tfIndex = $xeTable.findRowIndexOf(tableFullData, targetRow);
            if (tfIndex > -1) {
              tableFullData.splice(tfIndex + (isInsertNextRow ? 1 : 0), 0, ...newRecords);
            } else {
              tableFullData.push(...newRecords);
            }
            mergeList.forEach((mergeItem) => {
              const { row: mergeRowIndex, rowspan: mergeRowspan } = mergeItem;
              if (mergeRowIndex > afIndex) {
                mergeItem.row = mergeRowIndex + newRecords.length;
              } else if (mergeRowIndex + mergeRowspan > afIndex) {
                mergeItem.rowspan = mergeRowspan + newRecords.length;
              }
            });
          }
        }
      }
      newRecords.forEach((newRow) => {
        const rowid = getRowid($xeTable, newRow);
        insertRowMaps[rowid] = newRow;
      });
      reactData.insertRowFlag++;
      $xeTable.cacheRowMap(false);
      $xeTable.updateScrollYStatus();
      $xeTable.handleTableData(treeConfig && transform);
      if (!(treeConfig && transform)) {
        $xeTable.updateAfterDataIndex();
      }
      $xeTable.updateFooter();
      $xeTable.checkSelectionStatus();
      if (reactData.scrollYLoad) {
        $xeTable.updateScrollYSpace();
      }
      return nextTick().then(() => {
        $xeTable.updateCellAreas();
        return $xeTable.recalculate();
      }).then(() => {
        return {
          row: newRecords.length ? newRecords[newRecords.length - 1] : null,
          rows: newRecords
        };
      });
    };
    const handleInsertChildRowAt = (records, parentRow, targetRow, isInsertNextRow) => {
      const { treeConfig } = props;
      const treeOpts = computeTreeOpts.value;
      const { transform, rowField, parentField } = treeOpts;
      if (treeConfig && transform) {
        if (!import_xe_utils12.default.isArray(records)) {
          records = [records];
        }
        return handleInsertRowAt(records.map((item) => Object.assign({}, item, { [parentField]: parentRow[rowField] })), targetRow, isInsertNextRow);
      } else {
        errLog("vxe.error.errProp", ["tree-config.transform=false", "tree-config.transform=true"]);
      }
      return Promise.resolve({ row: null, rows: [] });
    };
    const handleClearEdit = (evnt, targetRow) => {
      const { editStore } = reactData;
      const { actived, focused } = editStore;
      const { row, column } = actived;
      const validOpts = computeValidOpts.value;
      if (row || column) {
        if (targetRow && getRowid($xeTable, targetRow) !== getRowid($xeTable, row)) {
          return nextTick();
        }
        syncActivedCell();
        actived.args = null;
        actived.row = null;
        actived.column = null;
        $xeTable.updateFooter();
        $xeTable.dispatchEvent("edit-closed", {
          row,
          rowIndex: $xeTable.getRowIndex(row),
          $rowIndex: $xeTable.getVMRowIndex(row),
          column,
          columnIndex: $xeTable.getColumnIndex(column),
          $columnIndex: $xeTable.getVMColumnIndex(column)
        }, evnt || null);
      }
      focused.row = null;
      focused.column = null;
      if (validOpts.autoClear) {
        if (validOpts.msgMode !== "full" || getConfig3().cellVaildMode === "obsolete") {
          if ($xeTable.clearValidate) {
            return $xeTable.clearValidate();
          }
        }
      }
      return nextTick().then(() => $xeTable.updateCellAreas());
    };
    const handleEditActive = (params, evnt, isFocus, isPos) => {
      const $xeGrid = $xeTable.xeGrid;
      const { editConfig, mouseConfig } = props;
      const { editStore, tableColumn } = reactData;
      const editOpts = computeEditOpts.value;
      const { mode } = editOpts;
      const { actived, focused } = editStore;
      const { row, column } = params;
      const { editRender } = column;
      const cell = params.cell || $xeTable.getCellElement(row, column);
      const beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;
      params.cell = cell;
      if (cell && isEnableConf(editConfig) && isEnableConf(editRender)) {
        if (!$xeTable.isPendingByRow(row)) {
          if (actived.row !== row || (mode === "cell" ? actived.column !== column : false)) {
            let type = "edit-disabled";
            if (!beforeEditMethod || beforeEditMethod(Object.assign(Object.assign({}, params), { $table: $xeTable, $grid: $xeGrid }))) {
              if (mouseConfig) {
                $xeTable.clearSelected();
                if ($xeTable.clearCellAreas) {
                  $xeTable.clearCellAreas();
                  $xeTable.clearCopyCellArea();
                }
              }
              $xeTable.closeTooltip();
              if (actived.column) {
                handleClearEdit(evnt);
              }
              type = "edit-activated";
              column.renderHeight = cell.offsetHeight;
              actived.args = params;
              actived.row = row;
              actived.column = column;
              if (mode === "row") {
                tableColumn.forEach((column2) => getEditColumnModel(row, column2));
              } else {
                getEditColumnModel(row, column);
              }
              const afterEditMethod = editOpts.afterEditMethod;
              nextTick(() => {
                if (isFocus) {
                  $xeTable.handleFocus(params, evnt);
                }
                if (afterEditMethod) {
                  afterEditMethod(Object.assign(Object.assign({}, params), { $table: $xeTable, $grid: $xeGrid }));
                }
              });
            }
            $xeTable.dispatchEvent(type, {
              row,
              rowIndex: $xeTable.getRowIndex(row),
              $rowIndex: $xeTable.getVMRowIndex(row),
              column,
              columnIndex: $xeTable.getColumnIndex(column),
              $columnIndex: $xeTable.getVMColumnIndex(column)
            }, evnt);
            if (type === "edit-activated") {
              $xeTable.dispatchEvent("edit-actived", {
                row,
                rowIndex: $xeTable.getRowIndex(row),
                $rowIndex: $xeTable.getVMRowIndex(row),
                column,
                columnIndex: $xeTable.getColumnIndex(column),
                $columnIndex: $xeTable.getVMColumnIndex(column)
              }, evnt);
            }
          } else {
            const { column: oldColumn } = actived;
            if (mouseConfig) {
              $xeTable.clearSelected();
              if ($xeTable.clearCellAreas) {
                $xeTable.clearCellAreas();
                $xeTable.clearCopyCellArea();
              }
            }
            if (oldColumn !== column) {
              const { model: oldModel } = oldColumn;
              if (oldModel.update) {
                setCellValue(row, oldColumn, oldModel.value);
              }
              if ($xeTable.clearValidate) {
                $xeTable.clearValidate(row, column);
              }
            }
            column.renderHeight = cell.offsetHeight;
            actived.args = params;
            actived.column = column;
            if (isPos) {
              setTimeout(() => {
                $xeTable.handleFocus(params, evnt);
              });
            }
          }
          focused.column = null;
          focused.row = null;
          $xeTable.focus();
        }
      }
      return nextTick();
    };
    const handleEditCell = (row, fieldOrColumn, isPos) => {
      const { editConfig } = props;
      const column = import_xe_utils12.default.isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
      if (row && column && isEnableConf(editConfig) && isEnableConf(column.editRender)) {
        return Promise.resolve(isPos ? $xeTable.scrollToRow(row, column) : null).then(() => {
          const cell = $xeTable.getCellElement(row, column);
          if (cell) {
            handleEditActive({
              row,
              rowIndex: $xeTable.getRowIndex(row),
              column,
              columnIndex: $xeTable.getColumnIndex(column),
              cell,
              $table: $xeTable
            }, null, isPos, isPos);
            internalData._lastCallTime = Date.now();
          }
          return nextTick();
        });
      }
      return nextTick();
    };
    editMethods = {
      /**
       * 往表格中插入临时数据
       *
       * @param {*} records
       */
      insert(records) {
        return handleInsertRowAt(records, null);
      },
      /**
       * 往表格指定行中插入临时数据
       * 如果 row 为空则从插入到顶部，如果为树结构，则插入到目标节点顶部
       * 如果 row 为 -1 则从插入到底部，如果为树结构，则插入到目标节点底部
       * 如果 row 为有效行则插入到该行的位置，如果为树结构，则有插入到效的目标节点该行的位置
       * @param {Object/Array} records 新的数据
       * @param {Row} targetRow 指定行
       */
      insertAt(records, targetRow) {
        return handleInsertRowAt(records, targetRow);
      },
      insertNextAt(records, targetRow) {
        return handleInsertRowAt(records, targetRow, true);
      },
      insertChild(records, parentRow) {
        return handleInsertChildRowAt(records, parentRow, null);
      },
      insertChildAt(records, parentRow, targetRow) {
        return handleInsertChildRowAt(records, parentRow, targetRow);
      },
      insertChildNextAt(records, parentRow, targetRow) {
        return handleInsertChildRowAt(records, parentRow, targetRow, true);
      },
      /**
       * 删除指定行数据
       * 如果传 row 则删除一行
       * 如果传 rows 则删除多行
       * 如果为空则删除所有
       */
      remove(rows) {
        const { treeConfig } = props;
        const { mergeList, editStore } = reactData;
        const { tableFullTreeData, selectCheckboxMaps, afterFullData, tableFullData, pendingRowMaps, insertRowMaps, removeRowMaps } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const treeOpts = computeTreeOpts.value;
        const { transform, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const { actived } = editStore;
        const { checkField } = checkboxOpts;
        let delList = [];
        if (!rows) {
          rows = tableFullData;
        } else if (!import_xe_utils12.default.isArray(rows)) {
          rows = [rows];
        }
        rows.forEach((row) => {
          if (!$xeTable.isInsertByRow(row)) {
            const rowid = getRowid($xeTable, row);
            removeRowMaps[rowid] = row;
          }
        });
        if (!checkField) {
          rows.forEach((row) => {
            const rowid = getRowid($xeTable, row);
            if (selectCheckboxMaps[rowid]) {
              delete selectCheckboxMaps[rowid];
            }
          });
          reactData.updateCheckboxFlag++;
        }
        if (tableFullData === rows) {
          rows = delList = tableFullData.slice(0);
          internalData.tableFullData = [];
          internalData.afterFullData = [];
          $xeTable.clearMergeCells();
        } else {
          if (treeConfig && transform) {
            rows.forEach((row) => {
              const rowid = getRowid($xeTable, row);
              const matchMapObj = import_xe_utils12.default.findTree(tableFullTreeData, (item) => rowid === getRowid($xeTable, item), { children: mapChildrenField });
              if (matchMapObj) {
                const rItems = matchMapObj.items.splice(matchMapObj.index, 1);
                delList.push(rItems[0]);
              }
              const matchObj = import_xe_utils12.default.findTree(tableFullTreeData, (item) => rowid === getRowid($xeTable, item), { children: childrenField });
              if (matchObj) {
                matchObj.items.splice(matchObj.index, 1);
              }
              const afIndex = $xeTable.findRowIndexOf(afterFullData, row);
              if (afIndex > -1) {
                afterFullData.splice(afIndex, 1);
              }
            });
          } else {
            rows.forEach((row) => {
              const tfIndex = $xeTable.findRowIndexOf(tableFullData, row);
              if (tfIndex > -1) {
                const rItems = tableFullData.splice(tfIndex, 1);
                delList.push(rItems[0]);
              }
              const afIndex = $xeTable.findRowIndexOf(afterFullData, row);
              if (afIndex > -1) {
                mergeList.forEach((mergeItem) => {
                  const { row: mergeRowIndex, rowspan: mergeRowspan } = mergeItem;
                  if (mergeRowIndex > afIndex) {
                    mergeItem.row = mergeRowIndex - 1;
                  } else if (mergeRowIndex + mergeRowspan > afIndex) {
                    mergeItem.rowspan = mergeRowspan - 1;
                  }
                });
                afterFullData.splice(afIndex, 1);
              }
            });
          }
        }
        if (actived.row && $xeTable.findRowIndexOf(rows, actived.row) > -1) {
          editMethods.clearEdit();
        }
        rows.forEach((row) => {
          const rowid = getRowid($xeTable, row);
          if (insertRowMaps[rowid]) {
            delete insertRowMaps[rowid];
          }
          if (pendingRowMaps[rowid]) {
            delete pendingRowMaps[rowid];
          }
        });
        reactData.removeRowFlag++;
        reactData.insertRowFlag++;
        reactData.pendingRowFlag++;
        $xeTable.updateFooter();
        $xeTable.cacheRowMap(false);
        $xeTable.handleTableData(treeConfig && transform);
        if (!(treeConfig && transform)) {
          $xeTable.updateAfterDataIndex();
        }
        $xeTable.checkSelectionStatus();
        if (reactData.scrollYLoad) {
          $xeTable.updateScrollYSpace();
        }
        return nextTick().then(() => {
          $xeTable.updateCellAreas();
          return $xeTable.recalculate();
        }).then(() => {
          return { row: delList.length ? delList[delList.length - 1] : null, rows: delList };
        });
      },
      /**
       * 删除复选框选中的数据
       */
      removeCheckboxRow() {
        return editMethods.remove($xeTable.getCheckboxRecords()).then((params) => {
          $xeTable.clearCheckboxRow();
          return params;
        });
      },
      /**
       * 删除单选框选中的数据
       */
      removeRadioRow() {
        const radioRecord = $xeTable.getRadioRecord();
        return editMethods.remove(radioRecord || []).then((params) => {
          $xeTable.clearRadioRow();
          return params;
        });
      },
      /**
       * 删除当前行选中的数据
       */
      removeCurrentRow() {
        const currentRecord = $xeTable.getCurrentRecord();
        return editMethods.remove(currentRecord || []).then((params) => {
          $xeTable.clearCurrentRow();
          return params;
        });
      },
      /**
       * 获取表格数据集，包含新增、删除、修改、标记
       */
      getRecordset() {
        const removeRecords = editMethods.getRemoveRecords();
        const pendingRecords = $xeTable.getPendingRecords();
        const delRecords = removeRecords.concat(pendingRecords);
        const updateRecords = editMethods.getUpdateRecords().filter((row) => {
          return !delRecords.some((item) => $xeTable.eqRow(item, row));
        });
        return {
          insertRecords: editMethods.getInsertRecords(),
          removeRecords,
          updateRecords,
          pendingRecords
        };
      },
      /**
       * 获取新增的临时数据
       */
      getInsertRecords() {
        const { fullAllDataRowIdData, insertRowMaps } = internalData;
        const insertRecords = [];
        import_xe_utils12.default.each(insertRowMaps, (row, rowid) => {
          if (fullAllDataRowIdData[rowid]) {
            insertRecords.push(row);
          }
        });
        return insertRecords;
      },
      /**
       * 获取已删除的数据
       */
      getRemoveRecords() {
        const { removeRowMaps } = internalData;
        const removeRecords = [];
        import_xe_utils12.default.each(removeRowMaps, (row) => {
          removeRecords.push(row);
        });
        return removeRecords;
      },
      /**
       * 获取更新数据
       * 只精准匹配 row 的更改
       * 如果是树表格，子节点更改状态不会影响父节点的更新状态
       */
      getUpdateRecords() {
        const { keepSource, treeConfig } = props;
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        if (keepSource) {
          syncActivedCell();
          if (treeConfig) {
            return import_xe_utils12.default.filterTree(tableFullData, (row) => $xeTable.isUpdateByRow(row), treeOpts);
          }
          return tableFullData.filter((row) => $xeTable.isUpdateByRow(row));
        }
        return [];
      },
      getActiveRecord() {
        if (true) {
          warnLog("vxe.error.delFunc", ["getActiveRecord", "getEditRecord"]);
        }
        return $xeTable.getEditRecord();
      },
      getEditRecord() {
        const { editStore } = reactData;
        const { afterFullData } = internalData;
        const el = refElem.value;
        const { args, row } = editStore.actived;
        if (args && $xeTable.findRowIndexOf(afterFullData, row) > -1 && el.querySelectorAll(".vxe-body--column.col--active").length) {
          return Object.assign({}, args);
        }
        return null;
      },
      /**
       * 获取选中的单元格
       */
      getSelectedCell() {
        const { editStore } = reactData;
        const { args, column } = editStore.selected;
        if (args && column) {
          return Object.assign({}, args);
        }
        return null;
      },
      clearActived(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["clearActived", "clearEdit"]);
        }
        return $xeTable.clearEdit(row);
      },
      /**
       * 清除激活的编辑
       */
      clearEdit(row) {
        return handleClearEdit(null, row);
      },
      /**
       * 清除所选中源状态
       */
      clearSelected() {
        const { editStore } = reactData;
        const { selected } = editStore;
        selected.row = null;
        selected.column = null;
        removeCellSelectedClass();
        return nextTick();
      },
      isActiveByRow(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["isActiveByRow", "isEditByRow"]);
        }
        return $xeTable.isEditByRow(row);
      },
      /**
       * 判断行是否为激活编辑状态
       * @param {Row} row 行对象
       */
      isEditByRow(row) {
        const { editStore } = reactData;
        return editStore.actived.row === row;
      },
      setActiveRow(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["setActiveRow", "setEditRow"]);
        }
        return editMethods.setEditRow(row);
      },
      /**
       * 激活行编辑
       */
      setEditRow(row, fieldOrColumn) {
        const { visibleColumn } = internalData;
        let column = import_xe_utils12.default.find(visibleColumn, (column2) => isEnableConf(column2.editRender));
        let isPos = false;
        if (fieldOrColumn) {
          isPos = true;
          if (fieldOrColumn !== true) {
            column = import_xe_utils12.default.isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
          }
        }
        return handleEditCell(row, column, isPos);
      },
      setActiveCell(row, fieldOrColumn) {
        if (true) {
          warnLog("vxe.error.delFunc", ["setActiveCell", "setEditCell"]);
        }
        return editMethods.setEditCell(row, fieldOrColumn);
      },
      /**
       * 激活单元格编辑
       */
      setEditCell(row, fieldOrColumn) {
        return handleEditCell(row, fieldOrColumn, true);
      },
      /**
       * 只对 trigger=dblclick 有效，选中单元格
       */
      setSelectCell(row, fieldOrColumn) {
        const { tableData } = reactData;
        const editOpts = computeEditOpts.value;
        const column = import_xe_utils12.default.isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
        if (row && column && editOpts.trigger !== "manual") {
          const rowIndex = $xeTable.findRowIndexOf(tableData, row);
          if (rowIndex > -1 && column) {
            const cell = $xeTable.getCellElement(row, column);
            const params = {
              row,
              rowIndex,
              column,
              columnIndex: $xeTable.getColumnIndex(column),
              cell
            };
            $xeTable.handleSelected(params, {});
          }
        }
        return nextTick();
      }
    };
    editPrivateMethods = {
      /**
       * 处理激活编辑
       */
      handleEdit(params, evnt) {
        return handleEditActive(params, evnt, true, true);
      },
      /**
       * @deprecated
       */
      handleActived(params, evnt) {
        return editPrivateMethods.handleEdit(params, evnt);
      },
      /**
       * 处理取消编辑
       * @param evnt
       * @returns
       */
      handleClearEdit,
      /**
       * 处理聚焦
       */
      handleFocus(params) {
        const { row, column, cell } = params;
        const { editRender } = column;
        const editOpts = computeEditOpts.value;
        if (isEnableConf(editRender)) {
          const compRender = renderer7.get(editRender.name);
          let autoFocus = editRender.autofocus || editRender.autoFocus;
          let autoSelect = editRender.autoSelect || editRender.autoselect;
          let inputElem;
          if (editOpts.autoFocus) {
            if (!autoFocus && compRender) {
              autoFocus = compRender.tableAutoFocus || compRender.tableAutofocus || compRender.autofocus;
            }
            if (!autoSelect && compRender) {
              autoSelect = compRender.tableAutoSelect || compRender.autoselect;
            }
            if (import_xe_utils12.default.isFunction(autoFocus)) {
              inputElem = autoFocus(params);
            } else if (autoFocus) {
              if (autoFocus === true) {
                inputElem = cell.querySelector("input,textarea");
              } else {
                inputElem = cell.querySelector(autoFocus);
              }
              if (inputElem) {
                inputElem.focus();
              }
            }
          }
          if (inputElem) {
            if (autoSelect) {
              inputElem.select();
            } else {
              if (browseObj2.msie) {
                const textRange = inputElem.createTextRange();
                textRange.collapse(false);
                textRange.select();
              }
            }
          } else {
            if (editOpts.autoPos) {
              if (!column.fixed) {
                $xeTable.scrollToRow(row, column);
              }
            }
          }
        }
      },
      /**
       * 处理选中源
       */
      handleSelected(params, evnt) {
        const { mouseConfig } = props;
        const { editStore } = reactData;
        const mouseOpts = computeMouseOpts.value;
        const editOpts = computeEditOpts.value;
        const { actived, selected } = editStore;
        const { row, column } = params;
        const isMouseSelected = mouseConfig && mouseOpts.selected;
        const selectMethod = () => {
          if (isMouseSelected && (selected.row !== row || selected.column !== column)) {
            if (actived.row !== row || (editOpts.mode === "cell" ? actived.column !== column : false)) {
              handleClearEdit(evnt);
              $xeTable.clearSelected();
              if ($xeTable.clearCellAreas) {
                $xeTable.clearCellAreas();
                $xeTable.clearCopyCellArea();
              }
              selected.args = params;
              selected.row = row;
              selected.column = column;
              if (isMouseSelected) {
                editPrivateMethods.addCellSelectedClass();
              }
              $xeTable.focus();
              if (evnt) {
                $xeTable.dispatchEvent("cell-selected", params, evnt);
              }
            }
          }
          return nextTick();
        };
        return selectMethod();
      },
      addCellSelectedClass() {
        const { editStore } = reactData;
        const { selected } = editStore;
        const { row, column } = selected;
        removeCellSelectedClass();
        if (row && column) {
          const cell = $xeTable.getCellElement(row, column);
          if (cell) {
            addClass(cell, "col--selected");
          }
        }
      }
    };
    return Object.assign(Object.assign({}, editMethods), editPrivateMethods);
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableEditMethodKeys);
  }
});

// node_modules/vxe-table/es/table/module/export/hook.js
var import_xe_utils13 = __toESM(require_xe_utils());

// node_modules/vxe-table/es/table/module/export/util.js
var defaultHtmlStyle = 'body{margin:0;padding: 0 1px;color:#333333;font-size:14px;font-family:"Microsoft YaHei",微软雅黑,"MicrosoftJhengHei",华文细黑,STHeiti,MingLiu}body *{-webkit-box-sizing:border-box;box-sizing:border-box}.vxe-table{border-collapse:collapse;text-align:left;border-spacing:0}.vxe-table:not(.is--print){table-layout:fixed}.vxe-table,.vxe-table th,.vxe-table td,.vxe-table td{border-color:#D0D0D0;border-style:solid;border-width:0}.vxe-table.is--print{width:100%}.border--default,.border--full,.border--outer{border-top-width:1px}.border--default,.border--full,.border--outer{border-left-width:1px}.border--outer,.border--default th,.border--default td,.border--full th,.border--full td,.border--outer th,.border--inner th,.border--inner td{border-bottom-width:1px}.border--default,.border--outer,.border--full th,.border--full td{border-right-width:1px}.border--default th,.border--full th,.border--outer th{background-color:#f8f8f9}.vxe-table td>div,.vxe-table th>div{padding:.5em .4em}.col--center{text-align:center}.col--right{text-align:right}.vxe-table:not(.is--print) .col--ellipsis>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-break:break-all}.vxe-table--tree-node{text-align:left}.vxe-table--tree-node-wrapper{position:relative}.vxe-table--tree-icon-wrapper{position:absolute;top:50%;width:1em;height:1em;text-align:center;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.vxe-table--tree-unfold-icon,.vxe-table--tree-fold-icon{position:absolute;width:0;height:0;border-style:solid;border-width:.5em;border-right-color:transparent;border-bottom-color:transparent}.vxe-table--tree-unfold-icon{left:.3em;top:0;border-left-color:#939599;border-top-color:transparent}.vxe-table--tree-fold-icon{left:0;top:.3em;border-left-color:transparent;border-top-color:#939599}.vxe-table--tree-cell{display:block;padding-left:1.5em}.vxe-table input[type="checkbox"]{margin:0}.vxe-table input[type="checkbox"],.vxe-table input[type="radio"],.vxe-table input[type="checkbox"]+span,.vxe-table input[type="radio"]+span{vertical-align:middle;padding-left:0.4em}';
function getExportBlobByContent(content, options) {
  return new Blob([content], { type: `text/${options.type};charset=utf-8;` });
}
function createHtmlPage(opts, content) {
  const { style } = opts;
  return [
    "<!DOCTYPE html><html>",
    "<head>",
    '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">',
    `<title>${opts.sheetName}</title>`,
    '<style media="print">.vxe-page-break-before{page-break-before:always;}.vxe-page-break-after{page-break-after:always;}</style>',
    `<style>${defaultHtmlStyle}</style>`,
    style ? `<style>${style}</style>` : "",
    "</head>",
    `<body>${content}</body>`,
    "</html>"
  ].join("");
}

// node_modules/vxe-table/es/table/module/export/hook.js
var { getI18n: getI18n8, hooks: hooks5, renderer: renderer8 } = VxeUI;
var htmlCellElem;
var csvBOM = "\uFEFF";
var enterSymbol = "\r\n";
function defaultFilterExportColumn(column) {
  return column.field || ["seq", "checkbox", "radio"].indexOf(column.type) > -1;
}
var getConvertColumns = (columns) => {
  const result = [];
  columns.forEach((column) => {
    if (column.childNodes && column.childNodes.length) {
      result.push(column);
      result.push(...getConvertColumns(column.childNodes));
    } else {
      result.push(column);
    }
  });
  return result;
};
var convertToRows = (originColumns) => {
  let maxLevel = 1;
  const traverse = (column, parent) => {
    if (parent) {
      column._level = parent._level + 1;
      if (maxLevel < column._level) {
        maxLevel = column._level;
      }
    }
    if (column.childNodes && column.childNodes.length) {
      let colSpan = 0;
      column.childNodes.forEach((subColumn) => {
        traverse(subColumn, column);
        colSpan += subColumn._colSpan;
      });
      column._colSpan = colSpan;
    } else {
      column._colSpan = 1;
    }
  };
  originColumns.forEach((column) => {
    column._level = 1;
    traverse(column);
  });
  const rows = [];
  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }
  const allColumns = getConvertColumns(originColumns);
  allColumns.forEach((column) => {
    if (column.childNodes && column.childNodes.length) {
      column._rowSpan = 1;
    } else {
      column._rowSpan = maxLevel - column._level + 1;
    }
    rows[column._level - 1].push(column);
  });
  return rows;
};
function toTableBorder(border) {
  if (border === true) {
    return "full";
  }
  if (border) {
    return border;
  }
  return "default";
}
function getBooleanValue(cellValue) {
  return cellValue === "TRUE" || cellValue === "true" || cellValue === true;
}
function getFooterData(opts, footerTableData) {
  const { footerFilterMethod } = opts;
  return footerFilterMethod ? footerTableData.filter((items, index) => footerFilterMethod({ items, $rowIndex: index })) : footerTableData;
}
function getCsvCellTypeLabel(column, cellValue) {
  if (cellValue) {
    if (column.type === "seq") {
      return `	${cellValue}`;
    }
    switch (column.cellType) {
      case "string":
        if (!isNaN(cellValue)) {
          return `	${cellValue}`;
        }
        break;
      case "number":
        break;
      default:
        if (cellValue.length >= 12 && !isNaN(cellValue)) {
          return `	${cellValue}`;
        }
        break;
    }
  }
  return cellValue;
}
function toTxtCellLabel(val) {
  if (/[",\s\n]/.test(val)) {
    return `"${val.replace(/"/g, '""')}"`;
  }
  return val;
}
function getElementsByTagName(elem, qualifiedName) {
  return elem.getElementsByTagName(qualifiedName);
}
function getTxtCellKey(now) {
  return `#${now}@${import_xe_utils13.default.uniqueId()}`;
}
function replaceTxtCell(cell, vMaps) {
  return cell.replace(/#\d+@\d+/g, (key) => import_xe_utils13.default.hasOwnProp(vMaps, key) ? vMaps[key] : key);
}
function getTxtCellValue(val, vMaps) {
  const rest = replaceTxtCell(val, vMaps);
  return rest.replace(/^"+$/g, (qVal) => '"'.repeat(Math.ceil(qVal.length / 2)));
}
function toExportField(tableConf, field) {
  const { fieldMaps, titleMaps } = tableConf;
  if (!fieldMaps[field]) {
    const teCol = titleMaps[field];
    if (teCol && teCol.field) {
      field = teCol.field;
    }
  }
  return field;
}
function parseCsvAndTxt(tableConf, content, cellSeparator) {
  const list = content.split(enterSymbol);
  const rows = [];
  let fields = [];
  if (list.length) {
    const vMaps = {};
    const now = Date.now();
    list.forEach((rVal) => {
      if (rVal) {
        const item = {};
        rVal = rVal.replace(/("")|(\n)/g, (text, dVal) => {
          const key = getTxtCellKey(now);
          vMaps[key] = dVal ? '"' : "\n";
          return key;
        }).replace(/"(.*?)"/g, (text, cVal) => {
          const key = getTxtCellKey(now);
          vMaps[key] = replaceTxtCell(cVal, vMaps);
          return key;
        });
        const cells = rVal.split(cellSeparator);
        if (!fields.length) {
          fields = cells.map((val) => toExportField(tableConf, getTxtCellValue(val.trim(), vMaps)));
        } else {
          cells.forEach((val, colIndex) => {
            if (colIndex < fields.length) {
              item[fields[colIndex]] = getTxtCellValue(val.trim(), vMaps);
            }
          });
          rows.push(item);
        }
      }
    });
  }
  return { fields, rows };
}
function parseCsv(tableConf, content) {
  return parseCsvAndTxt(tableConf, content, ",");
}
function parseTxt(tableConf, content) {
  return parseCsvAndTxt(tableConf, content, "	");
}
function parseHTML(tableConf, content) {
  const domParser = new DOMParser();
  const xmlDoc = domParser.parseFromString(content, "text/html");
  const bodyNodes = getElementsByTagName(xmlDoc, "body");
  const rows = [];
  const fields = [];
  if (bodyNodes.length) {
    const tableNodes = getElementsByTagName(bodyNodes[0], "table");
    if (tableNodes.length) {
      const theadNodes = getElementsByTagName(tableNodes[0], "thead");
      if (theadNodes.length) {
        import_xe_utils13.default.arrayEach(getElementsByTagName(theadNodes[0], "tr"), (rowNode) => {
          import_xe_utils13.default.arrayEach(getElementsByTagName(rowNode, "th"), (cellNode) => {
            fields.push(toExportField(tableConf, cellNode.textContent || ""));
          });
        });
        const tbodyNodes = getElementsByTagName(tableNodes[0], "tbody");
        if (tbodyNodes.length) {
          import_xe_utils13.default.arrayEach(getElementsByTagName(tbodyNodes[0], "tr"), (rowNode) => {
            const item = {};
            import_xe_utils13.default.arrayEach(getElementsByTagName(rowNode, "td"), (cellNode, colIndex) => {
              if (fields[colIndex]) {
                item[fields[colIndex]] = cellNode.textContent || "";
              }
            });
            rows.push(item);
          });
        }
      }
    }
  }
  return { fields, rows };
}
function parseXML(tableConf, content) {
  const domParser = new DOMParser();
  const xmlDoc = domParser.parseFromString(content, "application/xml");
  const sheetNodes = getElementsByTagName(xmlDoc, "Worksheet");
  const rows = [];
  const fields = [];
  if (sheetNodes.length) {
    const tableNodes = getElementsByTagName(sheetNodes[0], "Table");
    if (tableNodes.length) {
      const rowNodes = getElementsByTagName(tableNodes[0], "Row");
      if (rowNodes.length) {
        import_xe_utils13.default.arrayEach(getElementsByTagName(rowNodes[0], "Cell"), (cellNode) => {
          fields.push(toExportField(tableConf, cellNode.textContent || ""));
        });
        import_xe_utils13.default.arrayEach(rowNodes, (rowNode, index) => {
          if (index) {
            const item = {};
            const cellNodes = getElementsByTagName(rowNode, "Cell");
            import_xe_utils13.default.arrayEach(cellNodes, (cellNode, colIndex) => {
              if (fields[colIndex]) {
                item[fields[colIndex]] = cellNode.textContent;
              }
            });
            rows.push(item);
          }
        });
      }
    }
  }
  return { fields, rows };
}
function clearColumnConvert(columns) {
  import_xe_utils13.default.eachTree(columns, (column) => {
    delete column._level;
    delete column._colSpan;
    delete column._rowSpan;
    delete column._children;
    delete column.childNodes;
  }, { children: "children" });
}
var tableExportMethodKeys = ["exportData", "importByFile", "importData", "saveFile", "readFile", "print", "getPrintHtml", "openImport", "closeImport", "openExport", "closeExport", "openPrint", "closePrint"];
hooks5.add("tableExportModule", {
  setupTable($xeTable) {
    const { props, reactData, internalData } = $xeTable;
    const { computeTreeOpts, computePrintOpts, computeExportOpts, computeImportOpts, computeCustomOpts, computeSeqOpts, computeRadioOpts, computeCheckboxOpts, computeColumnOpts } = $xeTable.getComputeMaps();
    const $xeGrid = inject("$xeGrid", null);
    const hasTreeChildren = (row) => {
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      return row[childrenField] && row[childrenField].length;
    };
    const getSeq = (cellValue, row, $rowIndex, column, $columnIndex) => {
      const seqOpts = computeSeqOpts.value;
      const seqMethod = seqOpts.seqMethod || column.seqMethod;
      if (seqMethod) {
        return seqMethod({
          row,
          rowIndex: $xeTable.getRowIndex(row),
          $rowIndex,
          column,
          columnIndex: $xeTable.getColumnIndex(column),
          $columnIndex
        });
      }
      return cellValue;
    };
    function getHeaderTitle(opts, column) {
      const columnOpts = computeColumnOpts.value;
      const headExportMethod = column.headerExportMethod || columnOpts.headerExportMethod;
      return headExportMethod ? headExportMethod({ column, options: opts, $table: $xeTable }) : (opts.original ? column.field : column.getTitle()) || "";
    }
    const toBooleanValue = (cellValue) => {
      return import_xe_utils13.default.isBoolean(cellValue) ? cellValue ? "TRUE" : "FALSE" : cellValue;
    };
    const toStringValue = (cellValue) => {
      return eqEmptyValue(cellValue) ? "" : `${cellValue}`;
    };
    const getBodyLabelData = (opts, columns, datas) => {
      const { isAllExpand, mode } = opts;
      const { treeConfig } = props;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const treeOpts = computeTreeOpts.value;
      const columnOpts = computeColumnOpts.value;
      if (!htmlCellElem) {
        htmlCellElem = document.createElement("div");
      }
      if (treeConfig) {
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const rest = [];
        const expandMaps = /* @__PURE__ */ new Map();
        import_xe_utils13.default.eachTree(datas, (item, $rowIndex, items, path, parent, nodes) => {
          const row = item._row || item;
          const parentRow = parent && parent._row ? parent._row : parent;
          if (isAllExpand || !parentRow || expandMaps.has(parentRow) && $xeTable.isTreeExpandByRow(parentRow)) {
            const hasRowChild = hasTreeChildren(row);
            const item2 = {
              _row: row,
              _level: nodes.length - 1,
              _hasChild: hasRowChild,
              _expand: hasRowChild && $xeTable.isTreeExpandByRow(row)
            };
            columns.forEach((column, $columnIndex) => {
              let cellValue = "";
              const renderOpts = column.editRender || column.cellRender;
              let bodyExportMethod = column.exportMethod || columnOpts.exportMethod;
              if (!bodyExportMethod && renderOpts && renderOpts.name) {
                const compConf = renderer8.get(renderOpts.name);
                if (compConf) {
                  bodyExportMethod = compConf.tableExportMethod || compConf.exportMethod;
                }
              }
              if (!bodyExportMethod) {
                bodyExportMethod = columnOpts.exportMethod;
              }
              if (bodyExportMethod) {
                cellValue = bodyExportMethod({ $table: $xeTable, row, column, options: opts });
              } else {
                switch (column.type) {
                  case "seq": {
                    const seqVal = path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : ".").join("");
                    cellValue = mode === "all" ? seqVal : getSeq(seqVal, row, $rowIndex, column, $columnIndex);
                    break;
                  }
                  case "checkbox":
                    cellValue = toBooleanValue($xeTable.isCheckedByCheckboxRow(row));
                    item2._checkboxLabel = checkboxOpts.labelField ? import_xe_utils13.default.get(row, checkboxOpts.labelField) : "";
                    item2._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({ row });
                    break;
                  case "radio":
                    cellValue = toBooleanValue($xeTable.isCheckedByRadioRow(row));
                    item2._radioLabel = radioOpts.labelField ? import_xe_utils13.default.get(row, radioOpts.labelField) : "";
                    item2._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({ row });
                    break;
                  default:
                    if (opts.original) {
                      cellValue = getCellValue(row, column);
                    } else {
                      cellValue = $xeTable.getCellLabel(row, column);
                      if (column.type === "html") {
                        htmlCellElem.innerHTML = cellValue;
                        cellValue = htmlCellElem.innerText.trim();
                      } else {
                        const cell = $xeTable.getCellElement(row, column);
                        if (cell && !hasClass(cell, "is--progress")) {
                          cellValue = cell.innerText.trim();
                        }
                      }
                    }
                }
              }
              item2[column.id] = toStringValue(cellValue);
            });
            expandMaps.set(row, 1);
            rest.push(Object.assign(item2, row));
          }
        }, { children: childrenField });
        return rest;
      }
      return datas.map((row, $rowIndex) => {
        const item = {
          _row: row
        };
        columns.forEach((column, $columnIndex) => {
          let cellValue = "";
          const renderOpts = column.editRender || column.cellRender;
          let bodyExportMethod = column.exportMethod || columnOpts.exportMethod;
          if (!bodyExportMethod && renderOpts && renderOpts.name) {
            const compConf = renderer8.get(renderOpts.name);
            if (compConf) {
              bodyExportMethod = compConf.tableExportMethod || compConf.exportMethod;
            }
          }
          if (bodyExportMethod) {
            cellValue = bodyExportMethod({ $table: $xeTable, row, column, options: opts });
          } else {
            switch (column.type) {
              case "seq": {
                const seqValue = $rowIndex + 1;
                cellValue = mode === "all" ? seqValue : getSeq(seqValue, row, $rowIndex, column, $columnIndex);
                break;
              }
              case "checkbox":
                cellValue = toBooleanValue($xeTable.isCheckedByCheckboxRow(row));
                item._checkboxLabel = checkboxOpts.labelField ? import_xe_utils13.default.get(row, checkboxOpts.labelField) : "";
                item._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({ row });
                break;
              case "radio":
                cellValue = toBooleanValue($xeTable.isCheckedByRadioRow(row));
                item._radioLabel = radioOpts.labelField ? import_xe_utils13.default.get(row, radioOpts.labelField) : "";
                item._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({ row });
                break;
              default:
                if (opts.original) {
                  cellValue = getCellValue(row, column);
                } else {
                  cellValue = $xeTable.getCellLabel(row, column);
                  if (column.type === "html") {
                    htmlCellElem.innerHTML = cellValue;
                    cellValue = htmlCellElem.innerText.trim();
                  } else {
                    const cell = $xeTable.getCellElement(row, column);
                    if (cell && !hasClass(cell, "is--progress")) {
                      cellValue = cell.innerText.trim();
                    }
                  }
                }
            }
          }
          item[column.id] = toStringValue(cellValue);
        });
        return item;
      });
    };
    const getExportData = (opts) => {
      const { columns, dataFilterMethod } = opts;
      let datas = opts.data;
      if (dataFilterMethod) {
        datas = datas.filter((row, index) => dataFilterMethod({ row, $rowIndex: index }));
      }
      return getBodyLabelData(opts, columns, datas);
    };
    const getFooterCellValue = (opts, row, column) => {
      const columnOpts = computeColumnOpts.value;
      const renderOpts = column.editRender || column.cellRender;
      let footLabelMethod = column.footerExportMethod;
      if (!footLabelMethod && renderOpts && renderOpts.name) {
        const compConf = renderer8.get(renderOpts.name);
        if (compConf) {
          footLabelMethod = compConf.tableFooterExportMethod || compConf.footerExportMethod;
        }
      }
      if (!footLabelMethod) {
        footLabelMethod = columnOpts.footerExportMethod;
      }
      const _columnIndex = $xeTable.getVTColumnIndex(column);
      if (footLabelMethod) {
        return footLabelMethod({ $table: $xeTable, items: row, itemIndex: _columnIndex, row, _columnIndex, column, options: opts });
      }
      if (import_xe_utils13.default.isArray(row)) {
        return import_xe_utils13.default.toValueString(row[_columnIndex]);
      }
      return import_xe_utils13.default.get(row, column.field);
    };
    const toCsv = (opts, columns, datas) => {
      let content = csvBOM;
      if (opts.isHeader) {
        content += columns.map((column) => toTxtCellLabel(getHeaderTitle(opts, column))).join(",") + enterSymbol;
      }
      datas.forEach((row) => {
        content += columns.map((column) => toTxtCellLabel(getCsvCellTypeLabel(column, row[column.id]))).join(",") + enterSymbol;
      });
      if (opts.isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData(opts, footerTableData);
        footers.forEach((row) => {
          content += columns.map((column) => toTxtCellLabel(getFooterCellValue(opts, row, column))).join(",") + enterSymbol;
        });
      }
      return content;
    };
    const toTxt = (opts, columns, datas) => {
      let content = "";
      if (opts.isHeader) {
        content += columns.map((column) => toTxtCellLabel(getHeaderTitle(opts, column))).join("	") + enterSymbol;
      }
      datas.forEach((row) => {
        content += columns.map((column) => toTxtCellLabel(row[column.id])).join("	") + enterSymbol;
      });
      if (opts.isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData(opts, footerTableData);
        footers.forEach((row) => {
          content += columns.map((column) => toTxtCellLabel(getFooterCellValue(opts, row, column))).join("	") + enterSymbol;
        });
      }
      return content;
    };
    const hasEllipsis = (column, property, allColumnOverflow) => {
      const columnOverflow = column[property];
      const headOverflow = import_xe_utils13.default.isUndefined(columnOverflow) || import_xe_utils13.default.isNull(columnOverflow) ? allColumnOverflow : columnOverflow;
      const showEllipsis = headOverflow === "ellipsis";
      const showTitle = headOverflow === "title";
      const showTooltip = headOverflow === true || headOverflow === "tooltip";
      let isEllipsis = showTitle || showTooltip || showEllipsis;
      const { scrollXLoad, scrollYLoad } = reactData;
      if ((scrollXLoad || scrollYLoad) && !isEllipsis) {
        isEllipsis = true;
      }
      return isEllipsis;
    };
    const toHtml = (opts, columns, datas) => {
      const { id, border, treeConfig, headerAlign: allHeaderAlign, align: allAlign, footerAlign: allFooterAlign, showOverflow: allColumnOverflow, showHeaderOverflow: allColumnHeaderOverflow } = props;
      const { isAllSelected, isIndeterminate, mergeList } = reactData;
      const treeOpts = computeTreeOpts.value;
      const { print: isPrint, isHeader, isFooter, isColgroup, isMerge, colgroups, original } = opts;
      const allCls = "check-all";
      const clss = [
        "vxe-table",
        `border--${toTableBorder(border)}`,
        isPrint ? "is--print" : "",
        isHeader ? "is--header" : ""
      ].filter((cls) => cls);
      const tables = [
        `<table class="${clss.join(" ")}" border="0" cellspacing="0" cellpadding="0">`,
        `<colgroup>${columns.map((column) => `<col style="width:${column.renderWidth}px">`).join("")}</colgroup>`
      ];
      if (isHeader) {
        tables.push("<thead>");
        if (isColgroup && !original) {
          colgroups.forEach((cols) => {
            tables.push(`<tr>${cols.map((column) => {
              const headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;
              const classNames = hasEllipsis(column, "showHeaderOverflow", allColumnHeaderOverflow) ? ["col--ellipsis"] : [];
              const cellTitle = getHeaderTitle(opts, column);
              let childWidth = 0;
              let countChild = 0;
              import_xe_utils13.default.eachTree([column], (item) => {
                if (!item.childNodes || !column.childNodes.length) {
                  countChild++;
                }
                childWidth += item.renderWidth;
              }, { children: "childNodes" });
              const cellWidth = childWidth - countChild;
              if (headAlign) {
                classNames.push(`col--${headAlign}`);
              }
              if (column.type === "checkbox") {
                return `<th class="${classNames.join(" ")}" colspan="${column._colSpan}" rowspan="${column._rowSpan}"><div ${isPrint ? "" : `style="width: ${cellWidth}px"`}><input type="checkbox" class="${allCls}" ${isAllSelected ? "checked" : ""}><span>${cellTitle}</span></div></th>`;
              }
              return `<th class="${classNames.join(" ")}" colspan="${column._colSpan}" rowspan="${column._rowSpan}" title="${cellTitle}"><div ${isPrint ? "" : `style="width: ${cellWidth}px"`}><span>${formatText(cellTitle, true)}</span></div></th>`;
            }).join("")}</tr>`);
          });
        } else {
          tables.push(`<tr>${columns.map((column) => {
            const headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;
            const classNames = hasEllipsis(column, "showHeaderOverflow", allColumnHeaderOverflow) ? ["col--ellipsis"] : [];
            const cellTitle = getHeaderTitle(opts, column);
            if (headAlign) {
              classNames.push(`col--${headAlign}`);
            }
            if (column.type === "checkbox") {
              return `<th class="${classNames.join(" ")}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="checkbox" class="${allCls}" ${isAllSelected ? "checked" : ""}><span>${cellTitle}</span></div></th>`;
            }
            return `<th class="${classNames.join(" ")}" title="${cellTitle}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><span>${formatText(cellTitle, true)}</span></div></th>`;
          }).join("")}</tr>`);
        }
        tables.push("</thead>");
      }
      if (datas.length) {
        tables.push("<tbody>");
        if (treeConfig) {
          datas.forEach((item) => {
            tables.push("<tr>" + columns.map((column) => {
              const cellAlign = column.align || allAlign;
              const classNames = hasEllipsis(column, "showOverflow", allColumnOverflow) ? ["col--ellipsis"] : [];
              const cellValue = item[column.id];
              if (cellAlign) {
                classNames.push(`col--${cellAlign}`);
              }
              if (column.treeNode) {
                let treeIcon = "";
                if (item._hasChild) {
                  treeIcon = `<i class="${item._expand ? "vxe-table--tree-fold-icon" : "vxe-table--tree-unfold-icon"}"></i>`;
                }
                classNames.push("vxe-table--tree-node");
                if (column.type === "radio") {
                  return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell"><input type="radio" name="radio_${id}" ${item._radioDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._radioLabel}</span></div></div></div></td>`;
                } else if (column.type === "checkbox") {
                  return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell"><input type="checkbox" ${item._checkboxDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._checkboxLabel}</span></div></div></div></td>`;
                }
                return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell">${cellValue}</div></div></div></td>`;
              }
              if (column.type === "radio") {
                return `<td class="${classNames.join(" ")}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="radio" name="radio_${id}" ${item._radioDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._radioLabel}</span></div></td>`;
              } else if (column.type === "checkbox") {
                return `<td class="${classNames.join(" ")}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="checkbox" ${item._checkboxDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._checkboxLabel}</span></div></td>`;
              }
              return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join("") + "</tr>");
          });
        } else {
          datas.forEach((item) => {
            tables.push("<tr>" + columns.map((column) => {
              const cellAlign = column.align || allAlign;
              const classNames = hasEllipsis(column, "showOverflow", allColumnOverflow) ? ["col--ellipsis"] : [];
              const cellValue = item[column.id];
              let rowSpan = 1;
              let colSpan = 1;
              if (isMerge && mergeList.length) {
                const _rowIndex = $xeTable.getVTRowIndex(item._row);
                const _columnIndex = $xeTable.getVTColumnIndex(column);
                const spanRest = mergeBodyMethod(mergeList, _rowIndex, _columnIndex);
                if (spanRest) {
                  const { rowspan, colspan } = spanRest;
                  if (!rowspan || !colspan) {
                    return "";
                  }
                  if (rowspan > 1) {
                    rowSpan = rowspan;
                  }
                  if (colspan > 1) {
                    colSpan = colspan;
                  }
                }
              }
              if (cellAlign) {
                classNames.push(`col--${cellAlign}`);
              }
              if (column.type === "radio") {
                return `<td class="${classNames.join(" ")}" rowspan="${rowSpan}" colspan="${colSpan}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="radio" name="radio_${id}" ${item._radioDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._radioLabel}</span></div></td>`;
              } else if (column.type === "checkbox") {
                return `<td class="${classNames.join(" ")}" rowspan="${rowSpan}" colspan="${colSpan}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="checkbox" ${item._checkboxDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._checkboxLabel}</span></div></td>`;
              }
              return `<td class="${classNames.join(" ")}" rowspan="${rowSpan}" colspan="${colSpan}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join("") + "</tr>");
          });
        }
        tables.push("</tbody>");
      }
      if (isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData(opts, footerTableData);
        if (footers.length) {
          tables.push("<tfoot>");
          footers.forEach((row) => {
            tables.push(`<tr>${columns.map((column) => {
              const footAlign = column.footerAlign || column.align || allFooterAlign || allAlign;
              const classNames = hasEllipsis(column, "showOverflow", allColumnOverflow) ? ["col--ellipsis"] : [];
              const cellValue = getFooterCellValue(opts, row, column);
              if (footAlign) {
                classNames.push(`col--${footAlign}`);
              }
              return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join("")}</tr>`);
          });
          tables.push("</tfoot>");
        }
      }
      const script = !isAllSelected && isIndeterminate ? `<script>(function(){var a=document.querySelector(".${allCls}");if(a){a.indeterminate=true}})()<\/script>` : "";
      tables.push("</table>", script);
      return isPrint ? tables.join("") : createHtmlPage(opts, tables.join(""));
    };
    const toXML = (opts, columns, datas) => {
      let xml = [
        '<?xml version="1.0"?>',
        '<?mso-application progid="Excel.Sheet"?>',
        '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" xmlns:html="http://www.w3.org/TR/REC-html40">',
        '<DocumentProperties xmlns="urn:schemas-microsoft-com:office:office">',
        "<Version>16.00</Version>",
        "</DocumentProperties>",
        '<ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel">',
        "<WindowHeight>7920</WindowHeight>",
        "<WindowWidth>21570</WindowWidth>",
        "<WindowTopX>32767</WindowTopX>",
        "<WindowTopY>32767</WindowTopY>",
        "<ProtectStructure>False</ProtectStructure>",
        "<ProtectWindows>False</ProtectWindows>",
        "</ExcelWorkbook>",
        `<Worksheet ss:Name="${opts.sheetName}">`,
        "<Table>",
        columns.map((column) => `<Column ss:Width="${column.renderWidth}"/>`).join("")
      ].join("");
      if (opts.isHeader) {
        xml += `<Row>${columns.map((column) => `<Cell><Data ss:Type="String">${getHeaderTitle(opts, column)}</Data></Cell>`).join("")}</Row>`;
      }
      datas.forEach((row) => {
        xml += "<Row>" + columns.map((column) => `<Cell><Data ss:Type="String">${row[column.id]}</Data></Cell>`).join("") + "</Row>";
      });
      if (opts.isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData(opts, footerTableData);
        footers.forEach((row) => {
          xml += `<Row>${columns.map((column) => `<Cell><Data ss:Type="String">${getFooterCellValue(opts, row, column)}</Data></Cell>`).join("")}</Row>`;
        });
      }
      return `${xml}</Table></Worksheet></Workbook>`;
    };
    const getContent = (opts, columns, datas) => {
      if (columns.length) {
        switch (opts.type) {
          case "csv":
            return toCsv(opts, columns, datas);
          case "txt":
            return toTxt(opts, columns, datas);
          case "html":
            return toHtml(opts, columns, datas);
          case "xml":
            return toXML(opts, columns, datas);
        }
      }
      return "";
    };
    const downloadFile = (opts, content) => {
      const { filename, type, download } = opts;
      if (!download) {
        const blob = getExportBlobByContent(content, opts);
        return Promise.resolve({ type, content, blob });
      }
      if (VxeUI.saveFile) {
        VxeUI.saveFile({ filename, type, content }).then(() => {
          if (opts.message !== false) {
            if (VxeUI.modal) {
              VxeUI.modal.message({ content: getI18n8("vxe.table.expSuccess"), status: "success" });
            }
          }
        });
      }
    };
    const handleExport = (opts) => {
      const { remote, columns, colgroups, exportMethod, afterExportMethod } = opts;
      return new Promise((resolve) => {
        if (remote) {
          const params = { options: opts, $table: $xeTable, $grid: $xeGrid };
          resolve(exportMethod ? exportMethod(params) : params);
        } else {
          const datas = getExportData(opts);
          resolve($xeTable.preventEvent(null, "event.export", { options: opts, columns, colgroups, datas }, () => {
            return downloadFile(opts, getContent(opts, columns, datas));
          }));
        }
      }).then((params) => {
        clearColumnConvert(columns);
        if (!opts.print) {
          if (afterExportMethod) {
            afterExportMethod({ status: true, options: opts, $table: $xeTable, $grid: $xeGrid });
          }
        }
        return Object.assign({ status: true }, params);
      }).catch(() => {
        clearColumnConvert(columns);
        if (!opts.print) {
          if (afterExportMethod) {
            afterExportMethod({ status: false, options: opts, $table: $xeTable, $grid: $xeGrid });
          }
        }
        const params = { status: false };
        return Promise.reject(params);
      });
    };
    const handleImport = (content, opts) => {
      const { tableFullColumn, _importResolve, _importReject } = internalData;
      let rest = { fields: [], rows: [] };
      const tableFieldMaps = {};
      const tableTitleMaps = {};
      tableFullColumn.forEach((column) => {
        const field = column.field;
        const title = column.getTitle();
        if (field) {
          tableFieldMaps[field] = column;
        }
        if (title) {
          tableTitleMaps[column.getTitle()] = column;
        }
      });
      const tableConf = {
        fieldMaps: tableFieldMaps,
        titleMaps: tableTitleMaps
      };
      switch (opts.type) {
        case "csv":
          rest = parseCsv(tableConf, content);
          break;
        case "txt":
          rest = parseTxt(tableConf, content);
          break;
        case "html":
          rest = parseHTML(tableConf, content);
          break;
        case "xml":
          rest = parseXML(tableConf, content);
          break;
      }
      const { fields, rows } = rest;
      const status = fields.some((field) => tableFieldMaps[field] || tableTitleMaps[field]);
      if (status) {
        $xeTable.createData(rows).then((data) => {
          let loadRest;
          if (opts.mode === "insert" || opts.mode === "insertBottom") {
            loadRest = $xeTable.insertAt(data, -1);
          }
          if (opts.mode === "insertTop") {
            loadRest = $xeTable.insert(data);
          } else {
            loadRest = $xeTable.reloadData(data);
          }
          if (opts.message !== false) {
            if (VxeUI.modal) {
              VxeUI.modal.message({ content: getI18n8("vxe.table.impSuccess", [rows.length]), status: "success" });
            }
          }
          return loadRest.then(() => {
            if (_importResolve) {
              _importResolve({ status: true });
            }
          });
        });
      } else if (opts.message !== false) {
        if (VxeUI.modal) {
          VxeUI.modal.message({ content: getI18n8("vxe.error.impFields"), status: "error" });
        }
        if (_importReject) {
          _importReject({ status: false });
        }
      }
    };
    const handleFileImport = (file, opts) => {
      const { importMethod, afterImportMethod } = opts;
      const { type, filename } = parseFile(file);
      const importOpts = computeImportOpts.value;
      if (!importMethod && !import_xe_utils13.default.includes(import_xe_utils13.default.keys(importOpts._typeMaps), type)) {
        if (opts.message !== false) {
          if (VxeUI.modal) {
            VxeUI.modal.message({ content: getI18n8("vxe.error.notType", [type]), status: "error" });
          }
        }
        const params = { status: false };
        return Promise.reject(params);
      }
      const rest = new Promise((resolve, reject) => {
        const _importResolve = (params) => {
          resolve(params);
          internalData._importResolve = null;
          internalData._importReject = null;
        };
        const _importReject = (params) => {
          reject(params);
          internalData._importResolve = null;
          internalData._importReject = null;
        };
        internalData._importResolve = _importResolve;
        internalData._importReject = _importReject;
        if (window.FileReader) {
          const options = Object.assign({ mode: "insertTop" }, opts, { type, filename });
          if (options.remote) {
            if (importMethod) {
              Promise.resolve(importMethod({ file, options, $table: $xeTable })).then(() => {
                _importResolve({ status: true });
              }).catch(() => {
                _importResolve({ status: true });
              });
            } else {
              _importResolve({ status: true });
            }
          } else {
            const { tableFullColumn } = internalData;
            $xeTable.preventEvent(null, "event.import", { file, options, columns: tableFullColumn }, () => {
              const reader = new FileReader();
              reader.onerror = () => {
                errLog("vxe.error.notType", [type]);
                _importReject({ status: false });
              };
              reader.onload = (e) => {
                handleImport(e.target.result, options);
              };
              reader.readAsText(file, options.encoding || "UTF-8");
            });
          }
        } else {
          errLog("vxe.error.notExp");
          _importResolve({ status: true });
        }
      });
      return rest.then(() => {
        if (afterImportMethod) {
          afterImportMethod({ status: true, options: opts, $table: $xeTable });
        }
      }).catch((e) => {
        if (afterImportMethod) {
          afterImportMethod({ status: false, options: opts, $table: $xeTable });
        }
        return Promise.reject(e);
      });
    };
    const handleFilterColumns = (exportOpts, column, columns) => {
      return columns.some((item) => {
        if (isColumnInfo(item)) {
          return column.id === item.id;
        } else if (import_xe_utils13.default.isString(item)) {
          return column.field === item;
        } else {
          const colid = item.id || item.colId;
          const type = item.type;
          const field = item.field;
          if (colid) {
            return column.id === colid;
          } else if (field && type) {
            return column.field === field && column.type === type;
          } else if (field) {
            return column.field === field;
          } else if (type) {
            return column.type === type;
          }
        }
        return false;
      });
    };
    const handleFilterFields = (exportOpts, column, includeFields, excludeFields) => {
      if (excludeFields) {
        if (import_xe_utils13.default.includes(excludeFields, column.field)) {
          return false;
        }
      }
      if (includeFields) {
        if (import_xe_utils13.default.includes(includeFields, column.field)) {
          return true;
        }
        return false;
      }
      return exportOpts.original ? column.field : defaultFilterExportColumn(column);
    };
    const handleExportAndPrint = (options, isPrint) => {
      const { treeConfig, showHeader, showFooter } = props;
      const { initStore, mergeList, mergeFooterList, isGroup, footerTableData, exportStore, exportParams } = reactData;
      const { collectColumn } = internalData;
      const exportOpts = computeExportOpts.value;
      const hasTree = treeConfig;
      const customOpts = computeCustomOpts.value;
      const selectRecords = $xeTable.getCheckboxRecords();
      const proxyOpts = $xeGrid ? $xeGrid.getComputeMaps().computeProxyOpts.value : {};
      const hasFooter = !!footerTableData.length;
      const hasMerge = !!(mergeList.length || mergeFooterList.length);
      const defOpts = Object.assign({
        message: true,
        isHeader: showHeader,
        isFooter: showFooter,
        isColgroup: isGroup,
        isMerge: hasMerge,
        useStyle: true,
        current: "current",
        modes: (proxyOpts.ajax && proxyOpts.ajax.queryAll ? ["all"] : []).concat(["current", "selected", "empty"])
      }, options);
      const types = defOpts.types || import_xe_utils13.default.keys(exportOpts._typeMaps);
      const modes = defOpts.modes || [];
      const checkMethod = customOpts.checkMethod;
      const exportColumns = collectColumn.slice(0);
      const { columns, excludeFields, includeFields } = defOpts;
      const typeList = types.map((value) => {
        return {
          value,
          label: getI18n8(`vxe.export.types.${value}`)
        };
      });
      const modeList = modes.map((item) => {
        if (item && item.value) {
          return {
            value: item.value,
            label: item.label || item.value
          };
        }
        return {
          value: item,
          label: getI18n8(`vxe.export.modes.${item}`)
        };
      });
      import_xe_utils13.default.eachTree(exportColumns, (column, index, items, path, parent) => {
        const isColGroup = column.children && column.children.length;
        let isChecked = false;
        if (columns && columns.length) {
          isChecked = handleFilterColumns(defOpts, column, columns);
        } else if (excludeFields || includeFields) {
          isChecked = handleFilterFields(defOpts, column, includeFields, excludeFields);
        } else {
          isChecked = column.visible && (isColGroup || defaultFilterExportColumn(column));
        }
        column.checked = isChecked;
        column.halfChecked = false;
        column.disabled = parent && parent.disabled || (checkMethod ? !checkMethod({ column }) : false);
      });
      Object.assign(exportStore, {
        columns: exportColumns,
        typeList,
        modeList,
        hasFooter,
        hasMerge,
        hasTree,
        isPrint,
        hasColgroup: isGroup,
        visible: true
      });
      Object.assign(exportParams, {
        mode: selectRecords.length ? "selected" : "current"
      }, defOpts);
      const { filename, sheetName, mode, type } = exportParams;
      if (filename) {
        if (import_xe_utils13.default.isFunction(filename)) {
          exportParams.filename = filename({
            options: defOpts,
            $table: $xeTable,
            $grid: $xeGrid
          });
        } else {
          exportParams.filename = `${filename}`;
        }
      }
      if (sheetName) {
        if (import_xe_utils13.default.isFunction(sheetName)) {
          exportParams.sheetName = sheetName({
            options: defOpts,
            $table: $xeTable,
            $grid: $xeGrid
          });
        } else {
          exportParams.sheetName = `${sheetName}`;
        }
      }
      if (!modeList.some((item) => item.value === mode)) {
        exportParams.mode = modeList[0].value;
      }
      if (!typeList.some((item) => item.value === type)) {
        exportParams.type = typeList[0].value;
      }
      initStore.export = true;
      return nextTick();
    };
    const handleCloseExport = () => {
      if (VxeUI.modal) {
        return VxeUI.modal.close("VXE_EXPORT_MODAL");
      }
      return Promise.resolve();
    };
    const exportMethods = {
      /**
       * 导出文件，支持 csv/html/xml/txt
       * 如果是树表格，则默认是导出所有节点
       * 如果是启用了虚拟滚动，则只能导出数据源，可以配合 dataFilterMethod 函数转换数据
       * @param {Object} options 参数
       */
      exportData(options) {
        const { treeConfig, showHeader, showFooter } = props;
        const { mergeList, mergeFooterList, isGroup } = reactData;
        const { tableFullColumn, afterFullData, collectColumn } = internalData;
        const exportOpts = computeExportOpts.value;
        const treeOpts = computeTreeOpts.value;
        const proxyOpts = $xeGrid ? $xeGrid.getComputeMaps().computeProxyOpts.value : {};
        const hasMerge = !!(mergeList.length || mergeFooterList.length);
        const opts = Object.assign({
          message: true,
          isHeader: showHeader,
          isFooter: showFooter,
          isColgroup: isGroup,
          isMerge: hasMerge,
          useStyle: true,
          current: "current",
          modes: (proxyOpts.ajax && proxyOpts.ajax.queryAll ? ["all"] : []).concat(["current", "selected", "empty"]),
          download: true,
          type: "csv"
          // filename: '',
          // sheetName: '',
          // original: false,
          // isAllExpand: false,
          // data: null,
          // remote: false,
          // dataFilterMethod: null,
          // footerFilterMethod: null,
          // exportMethod: null,
          // columnFilterMethod: null,
          // beforeExportMethod: null,
          // afterExportMethod: null
        }, exportOpts, options);
        let { filename, sheetName, type, mode, columns, original, columnFilterMethod, beforeExportMethod, includeFields, excludeFields } = opts;
        let groups = [];
        const selectRecords = $xeTable.getCheckboxRecords();
        if (!mode) {
          mode = selectRecords.length ? "selected" : "current";
        }
        const customCols = columns && columns.length ? columns : import_xe_utils13.default.searchTree(collectColumn, (column) => {
          const isColGroup = column.children && column.children.length;
          let isChecked = false;
          if (columns && columns.length) {
            isChecked = handleFilterColumns(opts, column, columns);
          } else if (excludeFields || includeFields) {
            isChecked = handleFilterFields(opts, column, includeFields, excludeFields);
          } else {
            isChecked = column.visible && (isColGroup || defaultFilterExportColumn(column));
          }
          return isChecked;
        }, { children: "children", mapChildren: "childNodes", original: true });
        const handleOptions = Object.assign({}, opts, { filename: "", sheetName: "" });
        if (!customCols && !columnFilterMethod) {
          handleOptions.columnFilterMethod = ({ column }) => {
            if (excludeFields) {
              if (import_xe_utils13.default.includes(excludeFields, column.field)) {
                return false;
              }
            }
            if (includeFields) {
              if (import_xe_utils13.default.includes(includeFields, column.field)) {
                return true;
              }
              return false;
            }
            return original ? column.field : defaultFilterExportColumn(column);
          };
        }
        if (customCols) {
          handleOptions._isCustomColumn = true;
          groups = import_xe_utils13.default.searchTree(import_xe_utils13.default.mapTree(customCols, (item) => {
            let targetColumn;
            if (item) {
              if (isColumnInfo(item)) {
                targetColumn = item;
              } else if (import_xe_utils13.default.isString(item)) {
                targetColumn = $xeTable.getColumnByField(item);
              } else {
                const colid = item.id || item.colId;
                const type2 = item.type;
                const field = item.field;
                if (colid) {
                  targetColumn = $xeTable.getColumnById(colid);
                } else if (field && type2) {
                  targetColumn = tableFullColumn.find((column) => column.field === field && column.type === type2);
                } else if (field) {
                  targetColumn = $xeTable.getColumnByField(field);
                } else if (type2) {
                  targetColumn = tableFullColumn.find((column) => column.type === type2);
                }
              }
              return targetColumn || {};
            }
          }, {
            children: "childNodes",
            mapChildren: "_children"
          }), (column, index) => isColumnInfo(column) && (!columnFilterMethod || columnFilterMethod({ column, $columnIndex: index })), {
            children: "_children",
            mapChildren: "childNodes",
            original: true
          });
        } else {
          groups = import_xe_utils13.default.searchTree(isGroup ? collectColumn : tableFullColumn, (column, index) => column.visible && (!columnFilterMethod || columnFilterMethod({ column, $columnIndex: index })), { children: "children", mapChildren: "childNodes", original: true });
        }
        const cols = [];
        import_xe_utils13.default.eachTree(groups, (column) => {
          const isColGroup = column.children && column.children.length;
          if (!isColGroup) {
            cols.push(column);
          }
        }, { children: "childNodes" });
        handleOptions.columns = cols;
        handleOptions.colgroups = convertToRows(groups);
        if (filename) {
          if (import_xe_utils13.default.isFunction(filename)) {
            handleOptions.filename = filename({
              options: opts,
              $table: $xeTable,
              $grid: $xeGrid
            });
          } else {
            handleOptions.filename = `${filename}`;
          }
        }
        if (!handleOptions.filename) {
          handleOptions.filename = getI18n8(handleOptions.original ? "vxe.table.expOriginFilename" : "vxe.table.expFilename", [import_xe_utils13.default.toDateString(Date.now(), "yyyyMMddHHmmss")]);
        }
        if (sheetName) {
          if (import_xe_utils13.default.isFunction(sheetName)) {
            handleOptions.sheetName = sheetName({
              options: opts,
              $table: $xeTable,
              $grid: $xeGrid
            });
          } else {
            handleOptions.sheetName = `${sheetName}`;
          }
        }
        if (!handleOptions.sheetName) {
          handleOptions.sheetName = document.title || "";
        }
        if (!handleOptions.exportMethod && !import_xe_utils13.default.includes(import_xe_utils13.default.keys(exportOpts._typeMaps), type)) {
          errLog("vxe.error.notType", [type]);
          if (true) {
            if (["xlsx", "pdf"].includes(type)) {
              warnLog("vxe.error.reqPlugin", [4, "plugin-export-xlsx"]);
            }
          }
          const params = { status: false };
          return Promise.reject(params);
        }
        if (!handleOptions.print) {
          if (beforeExportMethod) {
            beforeExportMethod({ options: handleOptions, $table: $xeTable, $grid: $xeGrid });
          }
        }
        if (!handleOptions.data) {
          handleOptions.data = [];
          if (mode === "selected") {
            if (["html", "pdf"].indexOf(type) > -1 && treeConfig) {
              handleOptions.data = import_xe_utils13.default.searchTree($xeTable.getTableData().fullData, (item) => $xeTable.findRowIndexOf(selectRecords, item) > -1, Object.assign({}, treeOpts, { data: "_row" }));
            } else {
              handleOptions.data = selectRecords;
            }
          } else if (mode === "all") {
            if (true) {
              if (!$xeGrid) {
                warnLog("vxe.error.errProp", ["all", "mode=current,selected"]);
              }
            }
            if ($xeGrid && !handleOptions.remote) {
              const gridReactData = $xeGrid.reactData;
              const { computeProxyOpts } = $xeGrid.getComputeMaps();
              const proxyOpts2 = computeProxyOpts.value;
              const { sortData } = gridReactData;
              const { beforeQueryAll, afterQueryAll, ajax = {} } = proxyOpts2;
              const resConfigs = proxyOpts2.response || proxyOpts2.props || {};
              const ajaxMethods = ajax.queryAll;
              const queryAllSuccessMethods = ajax.queryAllSuccess;
              const queryAllErrorMethods = ajax.queryAllError;
              if (true) {
                if (!ajaxMethods) {
                  warnLog("vxe.error.notFunc", ["proxy-config.ajax.queryAll"]);
                }
              }
              if (ajaxMethods) {
                const params = {
                  $table: $xeTable,
                  $grid: $xeGrid,
                  sort: sortData.length ? sortData[0] : {},
                  sorts: sortData,
                  filters: gridReactData.filterData,
                  form: gridReactData.formData,
                  options: handleOptions
                };
                return Promise.resolve((beforeQueryAll || ajaxMethods)(params)).then((rest) => {
                  const listProp = resConfigs.list;
                  handleOptions.data = (listProp ? import_xe_utils13.default.isFunction(listProp) ? listProp({ data: rest, $grid: $xeGrid }) : import_xe_utils13.default.get(rest, listProp) : rest) || [];
                  if (afterQueryAll) {
                    afterQueryAll(params);
                  }
                  if (queryAllSuccessMethods) {
                    queryAllSuccessMethods(Object.assign(Object.assign({}, params), { response: rest }));
                  }
                  return handleExport(handleOptions);
                }).catch((rest) => {
                  if (queryAllErrorMethods) {
                    queryAllErrorMethods(Object.assign(Object.assign({}, params), { response: rest }));
                  }
                });
              }
            }
          }
          if (mode === "current") {
            handleOptions.data = afterFullData;
          }
        }
        return handleExport(handleOptions);
      },
      importByFile(file, options) {
        const opts = Object.assign({}, options);
        const { beforeImportMethod } = opts;
        if (beforeImportMethod) {
          beforeImportMethod({ options: opts, $table: $xeTable });
        }
        return handleFileImport(file, opts);
      },
      importData(options) {
        const importOpts = computeImportOpts.value;
        const opts = Object.assign({
          types: import_xe_utils13.default.keys(importOpts._typeMaps)
          // beforeImportMethod: null,
          // afterImportMethod: null
        }, importOpts, options);
        const { beforeImportMethod, afterImportMethod } = opts;
        if (beforeImportMethod) {
          beforeImportMethod({ options: opts, $table: $xeTable });
        }
        return VxeUI.readFile(opts).catch((e) => {
          if (afterImportMethod) {
            afterImportMethod({ status: false, options: opts, $table: $xeTable });
          }
          return Promise.reject(e);
        }).then((params) => {
          const { file } = params;
          return handleFileImport(file, opts);
        });
      },
      saveFile(options) {
        return VxeUI.saveFile(options);
      },
      readFile(options) {
        return VxeUI.readFile(options);
      },
      print(options) {
        const printOpts = computePrintOpts.value;
        const opts = Object.assign({
          original: false
          // beforePrintMethod
        }, printOpts, options, {
          type: "html",
          download: false,
          remote: false,
          print: true
        });
        const { sheetName } = opts;
        let printTitle = "";
        if (sheetName) {
          if (import_xe_utils13.default.isFunction(sheetName)) {
            printTitle = sheetName({
              options: opts,
              $table: $xeTable,
              $grid: $xeGrid
            });
          } else {
            printTitle = `${sheetName}`;
          }
        }
        if (!printTitle) {
          printTitle = document.title || "";
        }
        const beforePrintMethod = opts.beforePrintMethod;
        const tableHtml = opts.html || opts.content;
        return new Promise((resolve, reject) => {
          if (VxeUI.print) {
            if (tableHtml) {
              resolve(VxeUI.print({
                title: printTitle,
                html: tableHtml,
                customStyle: opts.style,
                beforeMethod: beforePrintMethod ? ({ html }) => {
                  return beforePrintMethod({
                    html,
                    content: html,
                    options: opts,
                    $table: $xeTable
                  });
                } : void 0
              }));
            } else {
              resolve(exportMethods.exportData(opts).then(({ content }) => {
                return VxeUI.print({
                  title: printTitle,
                  html: content,
                  customStyle: opts.style,
                  beforeMethod: beforePrintMethod ? ({ html }) => {
                    return beforePrintMethod({
                      html,
                      content: html,
                      options: opts,
                      $table: $xeTable
                    });
                  } : void 0
                });
              }));
            }
          } else {
            const e = { status: false };
            reject(e);
          }
        });
      },
      getPrintHtml(options) {
        const printOpts = computePrintOpts.value;
        const opts = Object.assign({
          original: false
          // beforePrintMethod
        }, printOpts, options, {
          type: "html",
          download: false,
          remote: false,
          print: true
        });
        return $xeTable.exportData(opts).then(({ content }) => {
          return {
            html: content
          };
        });
      },
      closeImport() {
        if (VxeUI.modal) {
          return VxeUI.modal.close("VXE_IMPORT_MODAL");
        }
        return Promise.resolve();
      },
      openImport(options) {
        const { treeConfig, importConfig } = props;
        const { initStore, importStore, importParams } = reactData;
        const importOpts = computeImportOpts.value;
        const defOpts = Object.assign({
          mode: "insertTop",
          message: true,
          types: import_xe_utils13.default.keys(importOpts._typeMaps),
          modes: ["insertTop", "covering"]
        }, importOpts, options);
        const types = defOpts.types || [];
        const modes = defOpts.modes || [];
        const isTree = !!treeConfig;
        if (isTree) {
          if (defOpts.message) {
            if (VxeUI.modal) {
              VxeUI.modal.message({ content: getI18n8("vxe.error.treeNotImp"), status: "error" });
            }
          }
          return;
        }
        if (!importConfig) {
          errLog("vxe.error.reqProp", ["import-config"]);
        }
        const typeList = types.map((value) => {
          return {
            value,
            label: getI18n8(`vxe.export.types.${value}`)
          };
        });
        const modeList = modes.map((item) => {
          if (item && item.value) {
            return {
              value: item.value,
              label: item.label || item.value
            };
          }
          return {
            value: item,
            label: getI18n8(`vxe.import.modes.${item}`)
          };
        });
        Object.assign(importStore, {
          file: null,
          type: "",
          filename: "",
          modeList,
          typeList,
          visible: true
        });
        Object.assign(importParams, defOpts);
        if (!modeList.some((item) => item.value === importParams.mode)) {
          importParams.mode = modeList[0].value;
        }
        initStore.import = true;
      },
      closeExport: handleCloseExport,
      openExport(options) {
        const exportOpts = computeExportOpts.value;
        const defOpts = Object.assign({
          message: true,
          types: import_xe_utils13.default.keys(exportOpts._typeMaps)
        }, exportOpts, options);
        if (!props.exportConfig) {
          errLog("vxe.error.reqProp", ["export-config"]);
        }
        handleExportAndPrint(defOpts);
      },
      closePrint: handleCloseExport,
      openPrint(options) {
        const printOpts = computePrintOpts.value;
        const defOpts = Object.assign({
          message: true
        }, printOpts, options);
        if (!props.printConfig) {
          errLog("vxe.error.reqProp", ["print-config"]);
        }
        handleExportAndPrint(defOpts, true);
      }
    };
    return exportMethods;
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableExportMethodKeys);
  }
});

// node_modules/vxe-table/es/table/module/keyboard/hook.js
var import_xe_utils14 = __toESM(require_xe_utils());
var { hooks: hooks6 } = VxeUI;
var browseObj = import_xe_utils14.default.browse();
function getTargetOffset(target, container) {
  let offsetTop = 0;
  let offsetLeft = 0;
  const triggerCheckboxLabel = !browseObj.firefox && hasClass(target, "vxe-checkbox--label");
  if (triggerCheckboxLabel) {
    const checkboxLabelStyle = getComputedStyle(target);
    offsetTop -= import_xe_utils14.default.toNumber(checkboxLabelStyle.paddingTop);
    offsetLeft -= import_xe_utils14.default.toNumber(checkboxLabelStyle.paddingLeft);
  }
  while (target && target !== container) {
    offsetTop += target.offsetTop;
    offsetLeft += target.offsetLeft;
    target = target.offsetParent;
    if (triggerCheckboxLabel) {
      const checkboxStyle = getComputedStyle(target);
      offsetTop -= import_xe_utils14.default.toNumber(checkboxStyle.paddingTop);
      offsetLeft -= import_xe_utils14.default.toNumber(checkboxStyle.paddingLeft);
    }
  }
  return { offsetTop, offsetLeft };
}
hooks6.add("tableKeyboardModule", {
  setupTable($xeTable) {
    const { props, reactData, internalData } = $xeTable;
    const { refElem } = $xeTable.getRefMaps();
    const { computeEditOpts, computeCheckboxOpts, computeMouseOpts, computeTreeOpts, computeRowOpts, computeColumnOpts, computeCellOpts, computeDefaultRowHeight, computeCurrentRowOpts, computeCurrentColumnOpts } = $xeTable.getComputeMaps();
    function getCheckboxRangeRows(evnt, params, targetTrElem, trRect, offsetClientTop, moveRange) {
      const { showOverflow } = props;
      const { fullAllDataRowIdData, isResizeCellHeight } = internalData;
      const rowOpts = computeRowOpts.value;
      const cellOpts = computeCellOpts.value;
      const defaultRowHeight = computeDefaultRowHeight.value;
      const { row } = params;
      let countHeight = 0;
      let rangeRows = [];
      let moveSize = 0;
      const isDown = moveRange > 0;
      const { scrollYLoad } = reactData;
      const { afterFullData } = internalData;
      if (isDown) {
        moveSize = offsetClientTop + moveRange;
      } else {
        moveSize = trRect.height - offsetClientTop + Math.abs(moveRange);
      }
      if (scrollYLoad) {
        const _rowIndex = $xeTable.getVTRowIndex(row);
        const isCustomCellHeight = isResizeCellHeight || cellOpts.height || rowOpts.height;
        if (!isCustomCellHeight && showOverflow) {
          if (isDown) {
            rangeRows = afterFullData.slice(_rowIndex, _rowIndex + Math.ceil(moveSize / defaultRowHeight));
          } else {
            rangeRows = afterFullData.slice(_rowIndex - Math.floor(moveSize / defaultRowHeight), _rowIndex + 1);
          }
        } else {
          if (isDown) {
            for (let i = _rowIndex; i < afterFullData.length; i++) {
              const item = afterFullData[i];
              const rowid = $xeTable.getRowid(item);
              const rowRest = fullAllDataRowIdData[rowid] || {};
              countHeight += rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
              rangeRows.push(item);
              if (countHeight > moveSize) {
                return rangeRows;
              }
            }
          } else {
            for (let len = _rowIndex; len >= 0; len--) {
              const item = afterFullData[len];
              const rowid = $xeTable.getRowid(item);
              const rowRest = fullAllDataRowIdData[rowid] || {};
              countHeight += rowRest.resizeHeight || cellOpts.height || rowOpts.height || rowRest.height || defaultRowHeight;
              rangeRows.push(item);
              if (countHeight > moveSize) {
                return rangeRows;
              }
            }
          }
        }
      } else {
        const siblingProp = isDown ? "next" : "previous";
        while (targetTrElem && countHeight < moveSize) {
          const rowNodeRest = $xeTable.getRowNode(targetTrElem);
          if (rowNodeRest) {
            rangeRows.push(rowNodeRest.item);
            countHeight += targetTrElem.offsetHeight;
            targetTrElem = targetTrElem[`${siblingProp}ElementSibling`];
          }
        }
      }
      return rangeRows;
    }
    const handleCheckboxRangeEvent = (evnt, params) => {
      const { elemStore } = internalData;
      const bodyScrollElem = getRefElem(elemStore["main-body-scroll"]);
      const leftScrollElem = getRefElem(elemStore["left-body-scroll"]);
      const rightScrollElem = getRefElem(elemStore["right-body-scroll"]);
      const { column, cell } = params;
      if (column.type === "checkbox") {
        let bodyWrapperElem = bodyScrollElem;
        if (leftScrollElem && column.fixed === "left") {
          bodyWrapperElem = leftScrollElem;
        } else if (rightScrollElem && column.fixed === "right") {
          bodyWrapperElem = rightScrollElem;
        }
        if (!bodyWrapperElem) {
          return;
        }
        const el = refElem.value;
        const disX = evnt.clientX;
        const disY = evnt.clientY;
        const checkboxRangeElem = bodyWrapperElem.querySelector(".vxe-table--checkbox-range");
        const trElem = cell.parentElement;
        const selectRecords = $xeTable.getCheckboxRecords();
        let lastRangeRows = [];
        const marginSize = 1;
        const offsetRest = getTargetOffset(evnt.target, bodyWrapperElem);
        const startTop = offsetRest.offsetTop + evnt.offsetY;
        const startLeft = offsetRest.offsetLeft + evnt.offsetX;
        const startScrollTop = bodyWrapperElem.scrollTop;
        const rowHeight = trElem.offsetHeight;
        const trRect = trElem.getBoundingClientRect();
        const offsetClientTop = disY - trRect.y;
        let mouseScrollTimeout = null;
        let isMouseScrollDown = false;
        let mouseScrollSpaceSize = 1;
        const triggerEvent2 = (type, evnt2) => {
          $xeTable.dispatchEvent(`checkbox-range-${type}`, { records: $xeTable.getCheckboxRecords(), reserves: $xeTable.getCheckboxReserveRecords() }, evnt2);
        };
        const handleChecked = (evnt2) => {
          const { clientX, clientY } = evnt2;
          const offsetLeft = clientX - disX;
          const offsetTop = clientY - disY + (bodyWrapperElem.scrollTop - startScrollTop);
          let rangeHeight = Math.abs(offsetTop);
          let rangeWidth = Math.abs(offsetLeft);
          let rangeTop = startTop;
          let rangeLeft = startLeft;
          if (offsetTop < marginSize) {
            rangeTop += offsetTop;
            if (rangeTop < marginSize) {
              rangeTop = marginSize;
              rangeHeight = startTop;
            }
          } else {
            rangeHeight = Math.min(rangeHeight, bodyWrapperElem.scrollHeight - startTop - marginSize);
          }
          if (offsetLeft < marginSize) {
            rangeLeft += offsetLeft;
            if (rangeWidth > startLeft) {
              rangeLeft = marginSize;
              rangeWidth = startLeft;
            }
          } else {
            rangeWidth = Math.min(rangeWidth, bodyWrapperElem.clientWidth - startLeft - marginSize);
          }
          checkboxRangeElem.style.height = `${rangeHeight}px`;
          checkboxRangeElem.style.width = `${rangeWidth}px`;
          checkboxRangeElem.style.left = `${rangeLeft}px`;
          checkboxRangeElem.style.top = `${rangeTop}px`;
          checkboxRangeElem.style.display = "block";
          const rangeRows = getCheckboxRangeRows(evnt2, params, trElem, trRect, offsetClientTop, offsetTop < marginSize ? -rangeHeight : rangeHeight);
          if (rangeHeight > 10 && rangeRows.length !== lastRangeRows.length) {
            lastRangeRows = rangeRows;
            if (evnt2.ctrlKey) {
              rangeRows.forEach((row) => {
                $xeTable.handleBatchSelectRows([row], selectRecords.indexOf(row) === -1);
              });
            } else {
              $xeTable.setAllCheckboxRow(false);
              $xeTable.handleCheckedCheckboxRow(rangeRows, true, false);
            }
            triggerEvent2("change", evnt2);
          }
        };
        const stopMouseScroll = () => {
          clearTimeout(mouseScrollTimeout);
          mouseScrollTimeout = null;
        };
        const startMouseScroll = (evnt2) => {
          stopMouseScroll();
          mouseScrollTimeout = setTimeout(() => {
            if (mouseScrollTimeout) {
              const { scrollLeft, scrollTop, clientHeight, scrollHeight } = bodyWrapperElem;
              const topSize = Math.ceil(mouseScrollSpaceSize * 50 / rowHeight);
              if (isMouseScrollDown) {
                if (scrollTop + clientHeight < scrollHeight) {
                  $xeTable.scrollTo(scrollLeft, scrollTop + topSize);
                  startMouseScroll(evnt2);
                  handleChecked(evnt2);
                } else {
                  stopMouseScroll();
                }
              } else {
                if (scrollTop) {
                  $xeTable.scrollTo(scrollLeft, scrollTop - topSize);
                  startMouseScroll(evnt2);
                  handleChecked(evnt2);
                } else {
                  stopMouseScroll();
                }
              }
            }
          }, 50);
        };
        addClass(el, "drag--range");
        document.onmousemove = (evnt2) => {
          evnt2.preventDefault();
          evnt2.stopPropagation();
          const { clientY } = evnt2;
          const { boundingTop } = getAbsolutePos(bodyWrapperElem);
          if (clientY < boundingTop) {
            isMouseScrollDown = false;
            mouseScrollSpaceSize = boundingTop - clientY;
            if (!mouseScrollTimeout) {
              startMouseScroll(evnt2);
            }
          } else if (clientY > boundingTop + bodyWrapperElem.clientHeight) {
            isMouseScrollDown = true;
            mouseScrollSpaceSize = clientY - boundingTop - bodyWrapperElem.clientHeight;
            if (!mouseScrollTimeout) {
              startMouseScroll(evnt2);
            }
          } else if (mouseScrollTimeout) {
            stopMouseScroll();
          }
          handleChecked(evnt2);
        };
        document.onmouseup = (evnt2) => {
          stopMouseScroll();
          removeClass(el, "drag--range");
          checkboxRangeElem.removeAttribute("style");
          document.onmousemove = null;
          document.onmouseup = null;
          triggerEvent2("end", evnt2);
        };
        triggerEvent2("start", evnt);
      }
    };
    const handleCellMousedownEvent = (evnt, params) => {
      const { editConfig, checkboxConfig, mouseConfig } = props;
      const checkboxOpts = computeCheckboxOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const editOpts = computeEditOpts.value;
      if (mouseConfig && mouseOpts.area && $xeTable.handleCellAreaMousedownEvent) {
        return $xeTable.handleCellAreaMousedownEvent(evnt, params);
      } else {
        if (checkboxConfig && checkboxOpts.range) {
          handleCheckboxRangeEvent(evnt, params);
        }
        if (mouseConfig && mouseOpts.selected) {
          if (!editConfig || editOpts.mode === "cell") {
            $xeTable.handleSelected(params, evnt);
          }
        }
      }
    };
    const handleMoveSelected = (evnt, args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow) => {
      const { afterFullData, visibleColumn } = internalData;
      const params = Object.assign({}, args);
      const _rowIndex = $xeTable.getVTRowIndex(params.row);
      const _columnIndex = $xeTable.getVTColumnIndex(params.column);
      evnt.preventDefault();
      if (isUpArrow && _rowIndex > 0) {
        params.rowIndex = _rowIndex - 1;
        params.row = afterFullData[params.rowIndex];
      } else if (isDwArrow && _rowIndex < afterFullData.length - 1) {
        params.rowIndex = _rowIndex + 1;
        params.row = afterFullData[params.rowIndex];
      } else if (isLeftArrow && _columnIndex) {
        params.columnIndex = _columnIndex - 1;
        params.column = visibleColumn[params.columnIndex];
      } else if (isRightArrow && _columnIndex < visibleColumn.length - 1) {
        params.columnIndex = _columnIndex + 1;
        params.column = visibleColumn[params.columnIndex];
      }
      $xeTable.scrollToRow(params.row, params.column).then(() => {
        params.cell = $xeTable.getCellElement(params.row, params.column);
        $xeTable.handleSelected(params, evnt);
      });
      return params;
    };
    const keyboardMethods = {
      // 处理 Tab 键移动
      moveTabSelected(args, isLeft, evnt) {
        const { editConfig } = props;
        const { afterFullData, visibleColumn } = internalData;
        const editOpts = computeEditOpts.value;
        const rowOpts = computeRowOpts.value;
        const currentRowOpts = computeCurrentRowOpts.value;
        const columnOpts = computeColumnOpts.value;
        const currentColumnOpts = computeCurrentColumnOpts.value;
        let targetRow;
        let targetRowIndex;
        let targetColumnIndex;
        const params = Object.assign({}, args);
        const _rowIndex = $xeTable.getVTRowIndex(params.row);
        const _columnIndex = $xeTable.getVTColumnIndex(params.column);
        evnt.preventDefault();
        if (isLeft) {
          if (_columnIndex <= 0) {
            if (_rowIndex > 0) {
              targetRowIndex = _rowIndex - 1;
              targetRow = afterFullData[targetRowIndex];
              targetColumnIndex = visibleColumn.length - 1;
            }
          } else {
            targetColumnIndex = _columnIndex - 1;
          }
        } else {
          if (_columnIndex >= visibleColumn.length - 1) {
            if (_rowIndex < afterFullData.length - 1) {
              targetRowIndex = _rowIndex + 1;
              targetRow = afterFullData[targetRowIndex];
              targetColumnIndex = 0;
            }
          } else {
            targetColumnIndex = _columnIndex + 1;
          }
        }
        const targetColumn = visibleColumn[targetColumnIndex];
        if (targetColumn) {
          if (targetRow) {
            params.rowIndex = targetRowIndex;
            params.row = targetRow;
          } else {
            params.rowIndex = _rowIndex;
          }
          params.columnIndex = targetColumnIndex;
          params.column = targetColumn;
          params.cell = $xeTable.getCellElement(params.row, params.column);
          if (rowOpts.isCurrent && currentRowOpts.isFollowSelected) {
            $xeTable.triggerCurrentRowEvent(evnt, params);
          }
          if (columnOpts.isCurrent && currentColumnOpts.isFollowSelected) {
            $xeTable.triggerCurrentColumnEvent(evnt, params);
          }
          if (editConfig) {
            if (editOpts.trigger === "click" || editOpts.trigger === "dblclick") {
              if (editOpts.mode === "row") {
                $xeTable.handleEdit(params, evnt);
              } else {
                $xeTable.scrollToRow(params.row, params.column).then(() => {
                  $xeTable.handleSelected(params, evnt);
                });
              }
            }
          } else {
            $xeTable.scrollToRow(params.row, params.column).then(() => {
              $xeTable.handleSelected(params, evnt);
            });
          }
        }
      },
      // 处理当前行方向键移动
      moveCurrentRow(isUpArrow, isDwArrow, evnt) {
        const { treeConfig } = props;
        const { currentRow } = reactData;
        const { afterFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let targetRow;
        if (currentRow) {
          if (treeConfig) {
            const { index, items } = import_xe_utils14.default.findTree(afterFullData, (item) => item === currentRow, { children: childrenField });
            if (isUpArrow && index > 0) {
              targetRow = items[index - 1];
            } else if (isDwArrow && index < items.length - 1) {
              targetRow = items[index + 1];
            }
          } else {
            const _rowIndex = $xeTable.getVTRowIndex(currentRow);
            if (isUpArrow && _rowIndex > 0) {
              targetRow = afterFullData[_rowIndex - 1];
            } else if (isDwArrow && _rowIndex < afterFullData.length - 1) {
              targetRow = afterFullData[_rowIndex + 1];
            }
          }
        } else {
          targetRow = afterFullData[0];
        }
        if (targetRow) {
          evnt.preventDefault();
          const params = {
            $table: $xeTable,
            row: targetRow,
            rowIndex: $xeTable.getRowIndex(targetRow),
            $rowIndex: $xeTable.getVMRowIndex(targetRow)
          };
          $xeTable.scrollToRow(targetRow).then(() => $xeTable.triggerCurrentRowEvent(evnt, params));
        }
      },
      // 处理当前列方向键移动
      moveCurrentColumn(isLeftArrow, isRightArrow, evnt) {
        const { currentColumn } = reactData;
        const { visibleColumn } = internalData;
        let targetCol = null;
        if (currentColumn) {
          const _columnIndex = $xeTable.getVTColumnIndex(currentColumn);
          if (isLeftArrow && _columnIndex > 0) {
            targetCol = visibleColumn[_columnIndex - 1];
          } else if (isRightArrow && _columnIndex < visibleColumn.length - 1) {
            targetCol = visibleColumn[_columnIndex + 1];
          }
        } else {
          targetCol = visibleColumn[0];
        }
        if (targetCol) {
          evnt.preventDefault();
          const params = {
            $table: $xeTable,
            column: targetCol,
            columnIndex: $xeTable.getColumnIndex(targetCol),
            $columnIndex: $xeTable.getVMColumnIndex(targetCol)
          };
          $xeTable.scrollToColumn(targetCol).then(() => $xeTable.triggerCurrentColumnEvent(evnt, params));
        }
      },
      // 处理可编辑方向键移动
      moveArrowSelected(args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt) {
        const { highlightCurrentRow, highlightCurrentColumn } = props;
        const rowOpts = computeRowOpts.value;
        const columnOpts = computeColumnOpts.value;
        handleMoveSelected(evnt, args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow);
        if ((isUpArrow || isDwArrow) && (rowOpts.isCurrent || highlightCurrentRow)) {
          $xeTable.moveCurrentRow(isUpArrow, isDwArrow, evnt);
        }
        if ((isLeftArrow || isRightArrow) && (columnOpts.isCurrent || highlightCurrentColumn)) {
          $xeTable.moveCurrentColumn(isLeftArrow, isRightArrow, evnt);
        }
      },
      moveEnterSelected(args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt) {
        const rowOpts = computeRowOpts.value;
        const currentRowOpts = computeCurrentRowOpts.value;
        const columnOpts = computeColumnOpts.value;
        const currentColumnOpts = computeCurrentColumnOpts.value;
        const params = handleMoveSelected(evnt, args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow);
        if (rowOpts.isCurrent && currentRowOpts.isFollowSelected) {
          $xeTable.triggerCurrentRowEvent(evnt, params);
        }
        if (columnOpts.isCurrent && currentColumnOpts.isFollowSelected) {
          $xeTable.triggerCurrentColumnEvent(evnt, params);
        }
      },
      // 已废弃，待删除
      moveSelected(args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt) {
        handleMoveSelected(evnt, args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow);
      },
      handleCellMousedownEvent
    };
    return keyboardMethods;
  }
});

// node_modules/vxe-table/es/table/module/validator/hook.js
var import_xe_utils15 = __toESM(require_xe_utils());
var { getConfig: getConfig4, validators, hooks: hooks7 } = VxeUI;
var Rule = class {
  constructor(rule) {
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.max,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }
  /**
   * 获取校验不通过的消息
   * 支持国际化翻译
   */
  get content() {
    return getFuncText(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
};
var tableValidatorMethodKeys = ["fullValidate", "validate", "fullValidateField", "validateField", "clearValidate"];
hooks7.add("tableValidatorModule", {
  setupTable($xeTable) {
    const { props, reactData, internalData } = $xeTable;
    const { refValidTooltip } = $xeTable.getRefMaps();
    const { computeValidOpts, computeTreeOpts, computeEditOpts } = $xeTable.getComputeMaps();
    let validatorMethods = {};
    let validatorPrivateMethods = {};
    let validRuleErr;
    const handleValidError = (params) => {
      return new Promise((resolve) => {
        const validOpts = computeValidOpts.value;
        if (validOpts.autoPos === false) {
          $xeTable.dispatchEvent("valid-error", params, null);
          resolve();
        } else {
          $xeTable.handleEdit(params, { type: "valid-error", trigger: "call" }).then(() => {
            resolve(validatorPrivateMethods.showValidTooltip(params));
          });
        }
      });
    };
    const handleErrMsgMode = (validErrMaps) => {
      const validOpts = computeValidOpts.value;
      if (validOpts.msgMode === "single") {
        const keys = Object.keys(validErrMaps);
        const resMaps = {};
        if (keys.length) {
          const firstKey = keys[0];
          resMaps[firstKey] = validErrMaps[firstKey];
        }
        return resMaps;
      }
      return validErrMaps;
    };
    const beginValidate = (rows, cols, cb, isFull) => {
      const validRest = {};
      const { editRules, treeConfig } = props;
      const { afterFullData, pendingRowMaps, removeRowMaps } = internalData;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const validOpts = computeValidOpts.value;
      let validList;
      if (rows === true) {
        validList = afterFullData;
      } else if (rows) {
        if (import_xe_utils15.default.isFunction(rows)) {
          cb = rows;
        } else {
          validList = import_xe_utils15.default.isArray(rows) ? rows : [rows];
        }
      }
      if (!validList) {
        if ($xeTable.getInsertRecords) {
          validList = $xeTable.getInsertRecords().concat($xeTable.getUpdateRecords());
        } else {
          validList = [];
        }
      }
      const rowValidErrs = [];
      internalData._lastCallTime = Date.now();
      validRuleErr = false;
      validatorMethods.clearValidate();
      const validErrMaps = {};
      if (editRules) {
        const columns = cols && cols.length ? cols : $xeTable.getColumns();
        const handleVaild = (row) => {
          const rowid = getRowid($xeTable, row);
          if (removeRowMaps[rowid]) {
            return;
          }
          if (pendingRowMaps[rowid]) {
            return;
          }
          if (isFull || !validRuleErr) {
            const colVailds = [];
            columns.forEach((column) => {
              const field = import_xe_utils15.default.isString(column) ? column : column.field;
              if ((isFull || !validRuleErr) && import_xe_utils15.default.has(editRules, field)) {
                colVailds.push(validatorPrivateMethods.validCellRules("all", row, column).catch(({ rule, rules }) => {
                  const rest = {
                    rule,
                    rules,
                    rowIndex: $xeTable.getRowIndex(row),
                    row,
                    columnIndex: $xeTable.getColumnIndex(column),
                    column,
                    field,
                    $table: $xeTable
                  };
                  if (!validRest[field]) {
                    validRest[field] = [];
                  }
                  validErrMaps[`${getRowid($xeTable, row)}:${column.id}`] = {
                    column,
                    row,
                    rule,
                    content: rule.content
                  };
                  validRest[field].push(rest);
                  if (!isFull) {
                    validRuleErr = true;
                    return Promise.reject(rest);
                  }
                }));
              }
            });
            rowValidErrs.push(Promise.all(colVailds));
          }
        };
        if (treeConfig) {
          import_xe_utils15.default.eachTree(validList, handleVaild, { children: childrenField });
        } else {
          validList.forEach(handleVaild);
        }
        return Promise.all(rowValidErrs).then(() => {
          const ruleProps = Object.keys(validRest);
          reactData.validErrorMaps = handleErrMsgMode(validErrMaps);
          return nextTick().then(() => {
            if (ruleProps.length) {
              return Promise.reject(validRest[ruleProps[0]][0]);
            }
            if (cb) {
              cb();
            }
          });
        }).catch((firstErrParams) => {
          return new Promise((resolve, reject) => {
            const finish = () => {
              nextTick(() => {
                if (cb) {
                  cb(validRest);
                  resolve();
                } else {
                  if (getConfig4().validToReject === "obsolete") {
                    reject(validRest);
                  } else {
                    resolve(validRest);
                  }
                }
              });
            };
            const posAndFinish = () => {
              firstErrParams.cell = $xeTable.getCellElement(firstErrParams.row, firstErrParams.column);
              scrollToView(firstErrParams.cell);
              handleValidError(firstErrParams).then(finish);
            };
            if (validOpts.autoPos === false) {
              finish();
            } else {
              const row = firstErrParams.row;
              const column = firstErrParams.column;
              $xeTable.scrollToRow(row, column).then(posAndFinish);
            }
          });
        });
      } else {
        reactData.validErrorMaps = {};
      }
      return nextTick().then(() => {
        if (cb) {
          cb();
        }
      });
    };
    validatorMethods = {
      /**
       * 完整校验行，和 validate 的区别就是会给有效数据中的每一行进行校验
       */
      fullValidate(rows, cb) {
        if (true) {
          if (import_xe_utils15.default.isFunction(cb)) {
            warnLog("vxe.error.notValidators", ["fullValidate(rows, callback)", "fullValidate(rows)"]);
          }
        }
        return beginValidate(rows, null, cb, true);
      },
      /**
       * 快速校验行，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）
       */
      validate(rows, cb) {
        return beginValidate(rows, null, cb);
      },
      /**
       * 完整校验单元格，和 validateField 的区别就是会给有效数据中的每一行进行校验
       */
      fullValidateField(rows, fieldOrColumn) {
        const colList = (import_xe_utils15.default.isArray(fieldOrColumn) ? fieldOrColumn : fieldOrColumn ? [fieldOrColumn] : []).map((column) => handleFieldOrColumn($xeTable, column));
        if (colList.length) {
          return beginValidate(rows, colList, null, true);
        }
        return nextTick();
      },
      /**
       * 快速校验单元格，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）
       */
      validateField(rows, fieldOrColumn) {
        const colList = (import_xe_utils15.default.isArray(fieldOrColumn) ? fieldOrColumn : fieldOrColumn ? [fieldOrColumn] : []).map((column) => handleFieldOrColumn($xeTable, column));
        if (colList.length) {
          return beginValidate(rows, colList, null);
        }
        return nextTick();
      },
      clearValidate(rows, fieldOrColumn) {
        const { validErrorMaps } = reactData;
        const validTip = refValidTooltip.value;
        const validOpts = computeValidOpts.value;
        const rowList = import_xe_utils15.default.isArray(rows) ? rows : rows ? [rows] : [];
        const colList = (import_xe_utils15.default.isArray(fieldOrColumn) ? fieldOrColumn : fieldOrColumn ? [fieldOrColumn] : []).map((column) => handleFieldOrColumn($xeTable, column));
        let validErrMaps = {};
        if (validTip && validTip.reactData.visible) {
          validTip.close();
        }
        if (validOpts.msgMode === "single") {
          reactData.validErrorMaps = {};
          return nextTick();
        }
        if (rowList.length && colList.length) {
          validErrMaps = Object.assign({}, validErrorMaps);
          rowList.forEach((row) => {
            colList.forEach((column) => {
              const validKey = `${getRowid($xeTable, row)}:${column.id}`;
              if (validErrMaps[validKey]) {
                delete validErrMaps[validKey];
              }
            });
          });
        } else if (rowList.length) {
          const rowIdList = rowList.map((row) => `${getRowid($xeTable, row)}`);
          import_xe_utils15.default.each(validErrorMaps, (item, key) => {
            if (rowIdList.indexOf(key.split(":")[0]) > -1) {
              validErrMaps[key] = item;
            }
          });
        } else if (colList.length) {
          const colidList = colList.map((column) => `${column.id}`);
          import_xe_utils15.default.each(validErrorMaps, (item, key) => {
            if (colidList.indexOf(key.split(":")[1]) > -1) {
              validErrMaps[key] = item;
            }
          });
        }
        reactData.validErrorMaps = validErrMaps;
        return nextTick();
      }
    };
    const validErrorRuleValue = (rule, val) => {
      const { type, min, max, pattern } = rule;
      const isNumType = type === "number";
      const numVal = isNumType ? import_xe_utils15.default.toNumber(val) : import_xe_utils15.default.getSize(val);
      if (isNumType && isNaN(val)) {
        return true;
      }
      if (!import_xe_utils15.default.eqNull(min) && numVal < import_xe_utils15.default.toNumber(min)) {
        return true;
      }
      if (!import_xe_utils15.default.eqNull(max) && numVal > import_xe_utils15.default.toNumber(max)) {
        return true;
      }
      if (pattern && !(import_xe_utils15.default.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
        return true;
      }
      return false;
    };
    validatorPrivateMethods = {
      /**
       * 校验数据
       * 按表格行、列顺序依次校验（同步或异步）
       * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列
       * 如果校验失败则，触发回调或者Promise<不通过列的错误消息>
       * 如果是传回调方式这返回一个校验不通过列的错误消息
       *
       * rule 配置：
       *  required=Boolean 是否必填
       *  min=Number 最小长度
       *  max=Number 最大长度
       *  validator=Function({ cellValue, rule, rules, row, column, rowIndex, columnIndex }) 自定义校验，接收一个 Promise
       *  trigger=blur|change 触发方式（除非特殊场景，否则默认为空就行）
       */
      validCellRules(validType, row, column, val) {
        const $xeGrid = $xeTable.xeGrid;
        const { editRules } = props;
        const { field } = column;
        const errorRules = [];
        const syncValidList = [];
        if (field && editRules) {
          const rules = import_xe_utils15.default.get(editRules, field);
          if (rules) {
            const cellValue = import_xe_utils15.default.isUndefined(val) ? import_xe_utils15.default.get(row, field) : val;
            rules.forEach((rule) => {
              const { type, trigger, required, validator } = rule;
              if (validType === "all" || !trigger || validType === trigger) {
                if (validator) {
                  const validParams = {
                    cellValue,
                    rule,
                    rules,
                    row,
                    rowIndex: $xeTable.getRowIndex(row),
                    column,
                    columnIndex: $xeTable.getColumnIndex(column),
                    field: column.field,
                    $table: $xeTable,
                    $grid: $xeGrid
                  };
                  let customValid;
                  if (import_xe_utils15.default.isString(validator)) {
                    const gvItem = validators.get(validator);
                    if (gvItem) {
                      const tcvMethod = gvItem.tableCellValidatorMethod || gvItem.cellValidatorMethod;
                      if (tcvMethod) {
                        customValid = tcvMethod(validParams);
                      } else {
                        if (true) {
                          warnLog("vxe.error.notValidators", [validator]);
                        }
                      }
                    } else {
                      errLog("vxe.error.notValidators", [validator]);
                    }
                  } else {
                    customValid = validator(validParams);
                  }
                  if (customValid) {
                    if (import_xe_utils15.default.isError(customValid)) {
                      validRuleErr = true;
                      errorRules.push(new Rule({ type: "custom", trigger, content: customValid.message, rule: new Rule(rule) }));
                    } else if (customValid.catch) {
                      syncValidList.push(customValid.catch((e) => {
                        validRuleErr = true;
                        errorRules.push(new Rule({ type: "custom", trigger, content: e && e.message ? e.message : rule.content || rule.message, rule: new Rule(rule) }));
                      }));
                    }
                  }
                } else {
                  const isArrType = type === "array";
                  const isArrVal = import_xe_utils15.default.isArray(cellValue);
                  let hasEmpty = true;
                  if (isArrType || isArrVal) {
                    hasEmpty = !isArrVal || !cellValue.length;
                  } else if (import_xe_utils15.default.isString(cellValue)) {
                    hasEmpty = eqEmptyValue(cellValue.trim());
                  } else {
                    hasEmpty = eqEmptyValue(cellValue);
                  }
                  if (required ? hasEmpty || validErrorRuleValue(rule, cellValue) : !hasEmpty && validErrorRuleValue(rule, cellValue)) {
                    validRuleErr = true;
                    errorRules.push(new Rule(rule));
                  }
                }
              }
            });
          }
        }
        return Promise.all(syncValidList).then(() => {
          if (errorRules.length) {
            const rest = { rules: errorRules, rule: errorRules[0] };
            return Promise.reject(rest);
          }
        });
      },
      hasCellRules(type, row, column) {
        const { editRules } = props;
        const { field } = column;
        if (field && editRules) {
          const rules = import_xe_utils15.default.get(editRules, field);
          return rules && !!import_xe_utils15.default.find(rules, (rule) => type === "all" || !rule.trigger || type === rule.trigger);
        }
        return false;
      },
      /**
       * 触发校验
       */
      triggerValidate(type) {
        const { editConfig, editRules } = props;
        const { editStore } = reactData;
        const { actived } = editStore;
        const editOpts = computeEditOpts.value;
        const validOpts = computeValidOpts.value;
        if (editRules && validOpts.msgMode === "single") {
          reactData.validErrorMaps = {};
        }
        if (editConfig && editRules && actived.row) {
          const { row, column, cell } = actived.args;
          if (validatorPrivateMethods.hasCellRules(type, row, column)) {
            return validatorPrivateMethods.validCellRules(type, row, column).then(() => {
              if (editOpts.mode === "row") {
                validatorMethods.clearValidate(row, column);
              }
            }).catch(({ rule }) => {
              if (!rule.trigger || type === rule.trigger) {
                const rest = { rule, row, column, cell };
                validatorPrivateMethods.showValidTooltip(rest);
                return Promise.reject(rest);
              }
              return Promise.resolve();
            });
          }
        }
        return Promise.resolve();
      },
      /**
       * 弹出校验错误提示
       */
      showValidTooltip(params) {
        const { height } = props;
        const { tableData, validStore, validErrorMaps } = reactData;
        const { rule, row, column, cell } = params;
        const validOpts = computeValidOpts.value;
        const validTip = refValidTooltip.value;
        const content = rule.content;
        validStore.visible = true;
        if (validOpts.msgMode === "single") {
          reactData.validErrorMaps = {
            [`${getRowid($xeTable, row)}:${column.id}`]: {
              column,
              row,
              rule,
              content
            }
          };
        } else {
          reactData.validErrorMaps = Object.assign({}, validErrorMaps, {
            [`${getRowid($xeTable, row)}:${column.id}`]: {
              column,
              row,
              rule,
              content
            }
          });
        }
        $xeTable.dispatchEvent("valid-error", params, null);
        if (validTip) {
          if (validTip && (validOpts.message === "tooltip" || validOpts.message === "default" && !height && tableData.length < 2)) {
            return validTip.open(cell, content);
          }
        }
        return nextTick();
      }
    };
    return Object.assign(Object.assign({}, validatorMethods), validatorPrivateMethods);
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableValidatorMethodKeys);
  }
});

// node_modules/vxe-table/es/table/module/custom/hook.js
var import_xe_utils16 = __toESM(require_xe_utils());
var tableCustomMethodKeys = ["openCustom", "closeCustom", "saveCustom", "cancelCustom", "resetCustom", "toggleCustomAllCheckbox", "setCustomAllCheckbox"];
VxeUI.hooks.add("tableCustomModule", {
  setupTable($xeTable) {
    const { reactData, internalData } = $xeTable;
    const { computeCustomOpts } = $xeTable.getComputeMaps();
    const { refElem } = $xeTable.getRefMaps();
    const $xeGrid = $xeTable.xeGrid;
    const calcMaxHeight = () => {
      const { customStore } = reactData;
      const el = refElem.value;
      let tableHeight = 0;
      if (el) {
        tableHeight = el.clientHeight - 28;
      }
      customStore.maxHeight = Math.max(88, tableHeight);
    };
    const openCustom = () => {
      const { initStore, customStore } = reactData;
      customStore.visible = true;
      initStore.custom = true;
      handleUpdateCustomColumn();
      checkCustomStatus();
      calcMaxHeight();
      return nextTick().then(() => calcMaxHeight());
    };
    const handleUpdateCustomColumn = () => {
      const { customStore } = reactData;
      const { collectColumn } = internalData;
      if (customStore.visible) {
        const sortMaps = {};
        const fixedMaps = {};
        const visibleMaps = {};
        import_xe_utils16.default.eachTree(collectColumn, (column) => {
          const colid = column.getKey();
          column.renderFixed = column.fixed;
          column.renderVisible = column.visible;
          column.renderResizeWidth = column.renderWidth;
          sortMaps[colid] = column.renderSortNumber;
          fixedMaps[colid] = column.fixed;
          visibleMaps[colid] = column.visible;
        });
        customStore.oldSortMaps = sortMaps;
        customStore.oldFixedMaps = fixedMaps;
        customStore.oldVisibleMaps = visibleMaps;
        reactData.customColumnList = collectColumn.slice(0);
      }
    };
    const closeCustom = () => {
      const { customStore } = reactData;
      const customOpts = computeCustomOpts.value;
      if (customStore.visible) {
        customStore.visible = false;
        if (!customOpts.immediate) {
          $xeTable.handleCustom();
        }
      }
      return nextTick();
    };
    const saveCustom = () => {
      const { customColumnList } = reactData;
      const customOpts = computeCustomOpts.value;
      const { allowVisible, allowSort, allowFixed, allowResizable } = customOpts;
      import_xe_utils16.default.eachTree(customColumnList, (column, index, items, path, parentColumn) => {
        if (parentColumn) {
          column.fixed = parentColumn.fixed;
        } else {
          if (allowSort) {
            const sortIndex = index + 1;
            column.renderSortNumber = sortIndex;
          }
          if (allowFixed) {
            column.fixed = column.renderFixed;
          }
        }
        if (allowResizable) {
          if (column.renderVisible && (!column.children || column.children.length)) {
            if (column.renderResizeWidth !== column.renderWidth) {
              column.resizeWidth = column.renderResizeWidth;
              column.renderWidth = column.renderResizeWidth;
            }
          }
        }
        if (allowVisible) {
          column.visible = column.renderVisible;
        }
      });
      reactData.isCustomStatus = true;
      reactData.isDragColMove = true;
      setTimeout(() => {
        reactData.isDragColMove = false;
      }, 1e3);
      return $xeTable.saveCustomStore("confirm");
    };
    const cancelCustom = () => {
      const { customColumnList, customStore } = reactData;
      const { oldSortMaps, oldFixedMaps, oldVisibleMaps } = customStore;
      const customOpts = computeCustomOpts.value;
      const { allowVisible, allowSort, allowFixed, allowResizable } = customOpts;
      import_xe_utils16.default.eachTree(customColumnList, (column) => {
        const colid = column.getKey();
        const visible = !!oldVisibleMaps[colid];
        const fixed = oldFixedMaps[colid] || "";
        if (allowVisible) {
          column.renderVisible = visible;
          column.visible = visible;
        }
        if (allowFixed) {
          column.renderFixed = fixed;
          column.fixed = fixed;
        }
        if (allowSort) {
          column.renderSortNumber = oldSortMaps[colid] || 0;
        }
        if (allowResizable) {
          column.renderResizeWidth = column.renderWidth;
        }
      }, { children: "children" });
      return nextTick();
    };
    const setCustomAllCheckbox = (checked) => {
      const { customStore } = reactData;
      const { customColumnList } = reactData;
      const customOpts = computeCustomOpts.value;
      const { checkMethod, visibleMethod } = customOpts;
      const isAll = !!checked;
      if (customOpts.immediate) {
        import_xe_utils16.default.eachTree(customColumnList, (column) => {
          if (visibleMethod && !visibleMethod({ column })) {
            return;
          }
          if (checkMethod && !checkMethod({ column })) {
            return;
          }
          column.visible = isAll;
          column.renderVisible = isAll;
          column.halfVisible = false;
        });
        customStore.isAll = isAll;
        reactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore("update:visible");
      } else {
        import_xe_utils16.default.eachTree(customColumnList, (column) => {
          if (visibleMethod && !visibleMethod({ column })) {
            return;
          }
          if (checkMethod && !checkMethod({ column })) {
            return;
          }
          column.renderVisible = isAll;
          column.halfVisible = false;
        });
        customStore.isAll = isAll;
      }
      $xeTable.checkCustomStatus();
      return nextTick();
    };
    const customMethods = {
      openCustom,
      closeCustom,
      saveCustom,
      cancelCustom,
      resetCustom(options) {
        const { collectColumn } = internalData;
        const customOpts = computeCustomOpts.value;
        const { checkMethod } = customOpts;
        const opts = Object.assign({
          visible: true,
          resizable: options === true,
          fixed: options === true,
          sort: options === true
        }, options);
        import_xe_utils16.default.eachTree(collectColumn, (column) => {
          if (opts.resizable) {
            column.resizeWidth = 0;
          }
          if (opts.fixed) {
            column.fixed = column.defaultFixed;
          }
          if (opts.sort) {
            column.renderSortNumber = column.sortNumber;
          }
          if (!checkMethod || checkMethod({ column })) {
            column.visible = column.defaultVisible;
          }
          column.renderResizeWidth = column.renderWidth;
        });
        reactData.isCustomStatus = false;
        $xeTable.saveCustomStore("reset");
        return $xeTable.handleCustom();
      },
      toggleCustomAllCheckbox() {
        const { customStore } = reactData;
        const isAll = !customStore.isAll;
        return setCustomAllCheckbox(isAll);
      },
      setCustomAllCheckbox
    };
    const checkCustomStatus = () => {
      const { customStore } = reactData;
      const { collectColumn } = internalData;
      const customOpts = computeCustomOpts.value;
      const { checkMethod } = customOpts;
      customStore.isAll = collectColumn.every((column) => (checkMethod ? !checkMethod({ column }) : false) || column.renderVisible);
      customStore.isIndeterminate = !customStore.isAll && collectColumn.some((column) => (!checkMethod || checkMethod({ column })) && (column.renderVisible || column.halfVisible));
    };
    const emitCustomEvent = (type, evnt) => {
      const comp = $xeGrid || $xeTable;
      comp.dispatchEvent("custom", { type }, evnt);
    };
    const customPrivateMethods = {
      checkCustomStatus,
      emitCustomEvent,
      triggerCustomEvent(evnt) {
        const { customStore } = $xeTable.reactData;
        if (customStore.visible) {
          closeCustom();
          emitCustomEvent("close", evnt);
        } else {
          customStore.btnEl = evnt.target;
          openCustom();
          emitCustomEvent("open", evnt);
        }
      },
      customOpenEvent(evnt) {
        const { customStore } = reactData;
        if (!customStore.visible) {
          customStore.activeBtn = true;
          customStore.btnEl = evnt.target;
          $xeTable.openCustom();
          $xeTable.emitCustomEvent("open", evnt);
        }
      },
      customCloseEvent(evnt) {
        const { customStore } = reactData;
        if (customStore.visible) {
          customStore.activeBtn = false;
          $xeTable.closeCustom();
          $xeTable.emitCustomEvent("close", evnt);
        }
      },
      handleUpdateCustomColumn
    };
    return Object.assign(Object.assign({}, customMethods), customPrivateMethods);
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableCustomMethodKeys);
  }
});

// node_modules/vxe-table/es/table/render/index.js
var import_xe_utils17 = __toESM(require_xe_utils());
var { getConfig: getConfig5, renderer: renderer9, getI18n: getI18n9, getComponent } = VxeUI;
var componentDefaultModelProp = "modelValue";
var defaultCompProps = {};
function handleDefaultValue(value, defaultVal, initVal) {
  return import_xe_utils17.default.eqNull(value) ? import_xe_utils17.default.eqNull(defaultVal) ? initVal : defaultVal : value;
}
function parseDate(value, props) {
  return value && props.valueFormat ? import_xe_utils17.default.toStringDate(value, props.valueFormat) : value;
}
function getFormatDate(value, props, defaultFormat) {
  const { dateConfig = {} } = props;
  return import_xe_utils17.default.toDateString(parseDate(value, props), dateConfig.labelFormat || defaultFormat);
}
function getLabelFormatDate(value, props) {
  return getFormatDate(value, props, getI18n9(`vxe.input.date.labelFormat.${props.type || "date"}`));
}
function getOldComponentName(name) {
  return `vxe-${name.replace("$", "")}`;
}
function getDefaultComponent({ name }) {
  return getComponent(name);
}
function getOldComponent({ name }) {
  return resolveComponent(getOldComponentName(name));
}
function handleConfirmFilter(params, checked, option) {
  const { $panel } = params;
  $panel.changeOption({}, checked, option);
}
function getNativeAttrs(renderOpts) {
  let { name, attrs } = renderOpts;
  if (name === "input") {
    attrs = Object.assign({ type: "text" }, attrs);
  }
  return attrs;
}
function getInputImmediateModel(renderOpts) {
  const { name, immediate, props } = renderOpts;
  if (!immediate) {
    if (name === "VxeInput" || name === "$input") {
      const { type } = props || {};
      return !(!type || type === "text" || type === "number" || type === "integer" || type === "float");
    }
    if (name === "input" || name === "textarea" || name === "$textarea") {
      return false;
    }
    return true;
  }
  return immediate;
}
function getCellEditProps(renderOpts, params, value, defaultProps) {
  return import_xe_utils17.default.assign({ immediate: getInputImmediateModel(renderOpts) }, defaultCompProps, defaultProps, renderOpts.props, { [componentDefaultModelProp]: value });
}
function getCellEditFilterProps(renderOpts, params, value, defaultProps) {
  return import_xe_utils17.default.assign({}, defaultCompProps, defaultProps, renderOpts.props, { [componentDefaultModelProp]: value });
}
function isImmediateCell(renderOpts, params) {
  return params.$type === "cell" || getInputImmediateModel(renderOpts);
}
function getCellLabelVNs(renderOpts, params, cellLabel, opts) {
  const { placeholder } = renderOpts;
  return [
    h("span", {
      class: ["vxe-cell--label", opts ? opts.class : ""]
    }, placeholder && isEmptyValue(cellLabel) ? [
      h("span", {
        class: "vxe-cell--placeholder"
      }, formatText(getFuncText(placeholder), 1))
    ] : formatText(cellLabel, 1))
  ];
}
function getNativeElementOns(renderOpts, params, eFns) {
  const { events } = renderOpts;
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const { model: modelFunc, change: changeFunc, blur: blurFunc } = eFns || {};
  const isSameEvent = changeEvent === modelEvent;
  const ons = {};
  if (events) {
    import_xe_utils17.default.objectEach(events, (func, key) => {
      ons[getOnName(key)] = function(...args) {
        func(params, ...args);
      };
    });
  }
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (isSameEvent && changeFunc) {
        changeFunc(targetEvnt);
      }
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (!isSameEvent && changeFunc) {
    ons[getOnName(changeEvent)] = function(evnt) {
      changeFunc(evnt);
      if (events && events[changeEvent]) {
        events[changeEvent](params, evnt);
      }
    };
  }
  if (blurFunc) {
    ons[getOnName(blurEvent)] = function(evnt) {
      blurFunc(evnt);
      if (events && events[blurEvent]) {
        events[blurEvent](params, evnt);
      }
    };
  }
  return ons;
}
var blurEvent = "blur";
function getComponentOns(renderOpts, params, eFns) {
  const { events } = renderOpts;
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const { model: modelFunc, change: changeFunc, blur: blurFunc } = eFns || {};
  const ons = {};
  import_xe_utils17.default.objectEach(events, (func, key) => {
    ons[getOnName(key)] = function(...args) {
      if (!import_xe_utils17.default.isFunction(func)) {
        errLog("vxe.error.errFunc", [func]);
      }
      func(params, ...args);
    };
  });
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (changeFunc) {
    ons[getOnName(changeEvent)] = function(...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  if (blurFunc) {
    ons[getOnName(blurEvent)] = function(...args) {
      blurFunc(...args);
      if (events && events[blurEvent]) {
        events[blurEvent](params, ...args);
      }
    };
  }
  return ons;
}
function getEditOns(renderOpts, params) {
  const { $table, row, column } = params;
  const { name } = renderOpts;
  const { model } = column;
  const isImmediate = isImmediateCell(renderOpts, params);
  return getComponentOns(renderOpts, params, {
    model(cellValue) {
      model.update = true;
      model.value = cellValue;
      if (isImmediate) {
        setCellValue(row, column, cellValue);
      }
    },
    change(eventParams) {
      if (!isImmediate && name && ["VxeInput", "VxeNumberInput", "VxeTextarea", "$input", "$textarea"].includes(name)) {
        const cellValue = eventParams.value;
        model.update = true;
        model.value = cellValue;
        $table.updateStatus(params, cellValue);
      } else {
        $table.updateStatus(params);
      }
    },
    blur() {
      if (isImmediate) {
        $table.handleCellRuleUpdateStatus("blur", params);
      } else {
        $table.handleCellRuleUpdateStatus("blur", params, model.value);
      }
    }
  });
}
function getFilterOns(renderOpts, params, option) {
  return getComponentOns(renderOpts, params, {
    model(value) {
      option.data = value;
    },
    change() {
      handleConfirmFilter(params, !import_xe_utils17.default.eqNull(option.data), option);
    },
    blur() {
      handleConfirmFilter(params, !import_xe_utils17.default.eqNull(option.data), option);
    }
  });
}
function getNativeEditOns(renderOpts, params) {
  const { $table, row, column } = params;
  const { model } = column;
  return getNativeElementOns(renderOpts, params, {
    model(evnt) {
      const targetEl = evnt.target;
      if (targetEl) {
        const cellValue = targetEl.value;
        if (isImmediateCell(renderOpts, params)) {
          setCellValue(row, column, cellValue);
        } else {
          model.update = true;
          model.value = cellValue;
        }
      }
    },
    change(evnt) {
      const targetEl = evnt.target;
      if (targetEl) {
        const cellValue = targetEl.value;
        $table.updateStatus(params, cellValue);
      }
    },
    blur(evnt) {
      const targetEl = evnt.target;
      if (targetEl) {
        const cellValue = targetEl.value;
        $table.updateStatus(params, cellValue);
      }
    }
  });
}
function getNativeFilterOns(renderOpts, params, option) {
  return getNativeElementOns(renderOpts, params, {
    model(evnt) {
      const targetEl = evnt.target;
      if (targetEl) {
        option.data = targetEl.value;
      }
    },
    change() {
      handleConfirmFilter(params, !import_xe_utils17.default.eqNull(option.data), option);
    },
    blur() {
      handleConfirmFilter(params, !import_xe_utils17.default.eqNull(option.data), option);
    }
  });
}
function nativeEditRender(renderOpts, params) {
  const { row, column } = params;
  const { name } = renderOpts;
  const cellValue = isImmediateCell(renderOpts, params) ? getCellValue(row, column) : column.model.value;
  return [
    h(name, Object.assign(Object.assign(Object.assign({ class: `vxe-default-${name}` }, getNativeAttrs(renderOpts)), { value: cellValue }), getNativeEditOns(renderOpts, params)))
  ];
}
function buttonCellRender(renderOpts, params) {
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
  ];
}
function defaultEditRender(renderOpts, params) {
  const { row, column } = params;
  const cellValue = getCellValue(row, column);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue)), getEditOns(renderOpts, params)))
  ];
}
function radioAndCheckboxEditRender(renderOpts, params) {
  const { options } = renderOpts;
  const { row, column } = params;
  const cellValue = getCellValue(row, column);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ options }, getCellEditProps(renderOpts, params, cellValue)), getEditOns(renderOpts, params)))
  ];
}
function oldEditRender(renderOpts, params) {
  const { row, column } = params;
  const cellValue = getCellValue(row, column);
  return [
    h(getOldComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue)), getEditOns(renderOpts, params)))
  ];
}
function oldButtonEditRender(renderOpts, params) {
  return [
    h(getComponent("vxe-button"), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
  ];
}
function oldButtonsEditRender(renderOpts, params) {
  return renderOpts.children.map((childRenderOpts) => oldButtonEditRender(childRenderOpts, params)[0]);
}
function renderNativeOptgroups(renderOpts, params, renderOptionsMethods) {
  const { optionGroups, optionGroupProps = {} } = renderOpts;
  const groupOptions = optionGroupProps.options || "options";
  const groupLabel = optionGroupProps.label || "label";
  return optionGroups.map((group, gIndex) => {
    return h("optgroup", {
      key: gIndex,
      label: group[groupLabel]
    }, renderOptionsMethods(group[groupOptions], renderOpts, params));
  });
}
function renderNativeOptions(options, renderOpts, params) {
  const { optionProps = {} } = renderOpts;
  const { row, column } = params;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const disabledProp = optionProps.disabled || "disabled";
  const cellValue = isImmediateCell(renderOpts, params) ? getCellValue(row, column) : column.model.value;
  return options.map((option, oIndex) => {
    return h("option", {
      key: oIndex,
      value: option[valueProp],
      disabled: option[disabledProp],
      /* eslint-disable eqeqeq */
      selected: option[valueProp] == cellValue
    }, option[labelProp]);
  });
}
function nativeFilterRender(renderOpts, params) {
  const { column } = params;
  const { name } = renderOpts;
  const attrs = getNativeAttrs(renderOpts);
  return column.filters.map((option, oIndex) => {
    return h(name, Object.assign(Object.assign(Object.assign({ key: oIndex, class: `vxe-default-${name}` }, attrs), { value: option.data }), getNativeFilterOns(renderOpts, params, option)));
  });
}
function defaultFilterRender(renderOpts, params) {
  const { column } = params;
  return column.filters.map((option, oIndex) => {
    const optionValue = option.data;
    return h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, renderOpts, optionValue)), getFilterOns(renderOpts, params, option)));
  });
}
function oldFilterRender(renderOpts, params) {
  const { column } = params;
  return column.filters.map((option, oIndex) => {
    const optionValue = option.data;
    return h(getOldComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, renderOpts, optionValue)), getFilterOns(renderOpts, params, option)));
  });
}
function handleFilterMethod({ option, row, column }) {
  const { data } = option;
  const cellValue = import_xe_utils17.default.get(row, column.field);
  return cellValue == data;
}
function handleInputFilterMethod({ option, row, column }) {
  const { data } = option;
  const cellValue = import_xe_utils17.default.get(row, column.field);
  return import_xe_utils17.default.toValueString(cellValue).indexOf(data) > -1;
}
function nativeSelectEditRender(renderOpts, params) {
  return [
    h("select", Object.assign(Object.assign({ class: "vxe-default-select" }, getNativeAttrs(renderOpts)), getNativeEditOns(renderOpts, params)), renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeOptions) : renderNativeOptions(renderOpts.options, renderOpts, params))
  ];
}
function defaultSelectEditRender(renderOpts, params) {
  const { row, column } = params;
  const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue, { options, optionProps, optionGroups, optionGroupProps })), getEditOns(renderOpts, params)))
  ];
}
function defaultTableOrTreeSelectEditRender(renderOpts, params) {
  const { row, column } = params;
  const { options, optionProps } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue, { options, optionProps })), getEditOns(renderOpts, params)))
  ];
}
function oldSelectEditRender(renderOpts, params) {
  const { row, column } = params;
  const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [
    h(getOldComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue, { options, optionProps, optionGroups, optionGroupProps })), getEditOns(renderOpts, params)))
  ];
}
function getSelectCellValue(renderOpts, { row, column }) {
  const { options, optionGroups, optionProps = {}, optionGroupProps = {} } = renderOpts;
  const cellValue = import_xe_utils17.default.get(row, column.field);
  let selectItem;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  if (!(cellValue === null || cellValue === void 0)) {
    return import_xe_utils17.default.map(import_xe_utils17.default.isArray(cellValue) ? cellValue : [cellValue], optionGroups ? (value) => {
      const groupOptions = optionGroupProps.options || "options";
      for (let index = 0; index < optionGroups.length; index++) {
        selectItem = import_xe_utils17.default.find(optionGroups[index][groupOptions], (item) => item[valueProp] == value);
        if (selectItem) {
          break;
        }
      }
      return selectItem ? selectItem[labelProp] : value;
    } : (value) => {
      selectItem = import_xe_utils17.default.find(options, (item) => item[valueProp] == value);
      return selectItem ? selectItem[labelProp] : value;
    }).join(", ");
  }
  return "";
}
function handleExportSelectMethod(params) {
  const { row, column, options } = params;
  return options.original ? getCellValue(row, column) : getSelectCellValue(column.editRender || column.cellRender, params);
}
function getTreeSelectCellValue(renderOpts, { row, column }) {
  const { options, optionProps = {} } = renderOpts;
  const cellValue = import_xe_utils17.default.get(row, column.field);
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const childrenProp = optionProps.children || "children";
  if (!(cellValue === null || cellValue === void 0)) {
    const keyMaps = {};
    import_xe_utils17.default.eachTree(options, (item) => {
      keyMaps[import_xe_utils17.default.get(item, valueProp)] = item;
    }, { children: childrenProp });
    return import_xe_utils17.default.map(import_xe_utils17.default.isArray(cellValue) ? cellValue : [cellValue], (value) => {
      const item = keyMaps[value];
      return item ? import_xe_utils17.default.get(item, labelProp) : item;
    }).join(", ");
  }
  return "";
}
function handleExportTreeSelectMethod(params) {
  const { row, column, options } = params;
  return options.original ? getCellValue(row, column) : getTreeSelectCellValue(column.editRender || column.cellRender, params);
}
function handleNumberCell(renderOpts, params) {
  const { props = {}, showNegativeStatus } = renderOpts;
  const { row, column } = params;
  const { type } = props;
  let cellValue = import_xe_utils17.default.get(row, column.field);
  let isNegative = false;
  if (!isEmptyValue(cellValue)) {
    const numberInputConfig = getConfig5().numberInput || {};
    if (type === "float") {
      const autoFill = handleDefaultValue(props.autoFill, numberInputConfig.autoFill, true);
      const digits = handleDefaultValue(props.digits, numberInputConfig.digits, 1);
      cellValue = import_xe_utils17.default.toFixed(import_xe_utils17.default.floor(cellValue, digits), digits);
      if (!autoFill) {
        cellValue = import_xe_utils17.default.toNumber(cellValue);
      }
      if (showNegativeStatus) {
        if (cellValue < 0) {
          isNegative = true;
        }
      }
    } else if (type === "amount") {
      const autoFill = handleDefaultValue(props.autoFill, numberInputConfig.autoFill, true);
      const digits = handleDefaultValue(props.digits, numberInputConfig.digits, 2);
      const showCurrency = handleDefaultValue(props.showCurrency, numberInputConfig.showCurrency, false);
      cellValue = import_xe_utils17.default.toNumber(cellValue);
      if (showNegativeStatus) {
        if (cellValue < 0) {
          isNegative = true;
        }
      }
      cellValue = import_xe_utils17.default.commafy(cellValue, { digits });
      if (!autoFill) {
        const [iStr, dStr] = cellValue.split(".");
        if (dStr) {
          const dRest = dStr.replace(/0+$/, "");
          cellValue = dRest ? [iStr, ".", dRest].join("") : iStr;
        }
      }
      if (showCurrency) {
        cellValue = `${props.currencySymbol || numberInputConfig.currencySymbol || getI18n9("vxe.numberInput.currencySymbol") || ""}${cellValue}`;
      }
    } else {
      if (showNegativeStatus) {
        if (import_xe_utils17.default.toNumber(cellValue) < 0) {
          isNegative = true;
        }
      }
    }
  }
  return getCellLabelVNs(renderOpts, params, cellValue, isNegative ? {
    class: "is--negative"
  } : {});
}
renderer9.mixin({
  input: {
    tableAutoFocus: "input",
    renderTableEdit: nativeEditRender,
    renderTableDefault: nativeEditRender,
    renderTableFilter: nativeFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  textarea: {
    tableAutoFocus: "textarea",
    renderTableEdit: nativeEditRender
  },
  select: {
    renderTableEdit: nativeSelectEditRender,
    renderTableDefault: nativeSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderTableFilter(renderOpts, params) {
      const { column } = params;
      return column.filters.map((option, oIndex) => {
        return h("select", Object.assign(Object.assign({ key: oIndex, class: "vxe-default-select" }, getNativeAttrs(renderOpts)), getNativeFilterOns(renderOpts, params, option)), renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeOptions) : renderNativeOptions(renderOpts.options, renderOpts, params));
      });
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  VxeInput: {
    tableAutoFocus: "input",
    renderTableEdit: defaultEditRender,
    renderTableCell(renderOpts, params) {
      const { props = {} } = renderOpts;
      const { row, column } = params;
      const inputConfig = getConfig5().input || {};
      const digits = props.digits || inputConfig.digits || 2;
      let cellValue = import_xe_utils17.default.get(row, column.field);
      if (cellValue) {
        switch (props.type) {
          case "date":
          case "week":
          case "month":
          case "quarter":
          case "year":
            cellValue = getLabelFormatDate(cellValue, props);
            break;
          case "float":
            cellValue = import_xe_utils17.default.toFixed(import_xe_utils17.default.floor(cellValue, digits), digits);
            break;
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderTableDefault: defaultEditRender,
    renderTableFilter: defaultFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  FormatNumberInput: {
    renderTableDefault: handleNumberCell,
    tableFilterDefaultMethod: handleInputFilterMethod,
    tableExportMethod(params) {
      const { row, column } = params;
      const cellValue = import_xe_utils17.default.get(row, column.field);
      return cellValue;
    }
  },
  VxeNumberInput: {
    tableAutoFocus: "input",
    renderTableEdit: defaultEditRender,
    renderTableCell: handleNumberCell,
    renderTableFooter(renderOpts, params) {
      const { props = {} } = renderOpts;
      const { row, column, _columnIndex } = params;
      const { type } = props;
      const itemValue = import_xe_utils17.default.isArray(row) ? row[_columnIndex] : import_xe_utils17.default.get(row, column.field);
      if (import_xe_utils17.default.isNumber(itemValue)) {
        const numberInputConfig = getConfig5().numberInput || {};
        if (type === "float") {
          const autoFill = handleDefaultValue(props.autoFill, numberInputConfig.autoFill, true);
          const digits = handleDefaultValue(props.digits, numberInputConfig.digits, 1);
          let amountLabel = import_xe_utils17.default.toFixed(import_xe_utils17.default.floor(itemValue, digits), digits);
          if (!autoFill) {
            amountLabel = import_xe_utils17.default.toNumber(amountLabel);
          }
          return amountLabel;
        } else if (type === "amount") {
          const autoFill = handleDefaultValue(props.autoFill, numberInputConfig.autoFill, true);
          const digits = handleDefaultValue(props.digits, numberInputConfig.digits, 2);
          const showCurrency = handleDefaultValue(props.showCurrency, numberInputConfig.showCurrency, false);
          let amountLabel = import_xe_utils17.default.commafy(import_xe_utils17.default.toNumber(itemValue), { digits });
          if (!autoFill) {
            const [iStr, dStr] = amountLabel.split(".");
            if (dStr) {
              const dRest = dStr.replace(/0+$/, "");
              amountLabel = dRest ? [iStr, ".", dRest].join("") : iStr;
            }
          }
          if (showCurrency) {
            amountLabel = `${props.currencySymbol || numberInputConfig.currencySymbol || getI18n9("vxe.numberInput.currencySymbol") || ""}${amountLabel}`;
          }
          return amountLabel;
        }
      }
      return getFuncText(itemValue, 1);
    },
    renderTableDefault: defaultEditRender,
    renderTableFilter: defaultFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod,
    tableExportMethod(params) {
      const { row, column } = params;
      const cellValue = import_xe_utils17.default.get(row, column.field);
      return cellValue;
    }
  },
  VxeDatePicker: {
    tableAutoFocus: "input",
    renderTableEdit: defaultEditRender,
    renderTableCell(renderOpts, params) {
      const { props = {} } = renderOpts;
      const { row, column } = params;
      let cellValue = import_xe_utils17.default.get(row, column.field);
      if (cellValue) {
        if (props.type !== "time") {
          cellValue = getLabelFormatDate(cellValue, props);
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderTableDefault: defaultEditRender,
    renderTableFilter: defaultFilterRender,
    tableFilterDefaultMethod: handleFilterMethod
  },
  VxeTextarea: {
    tableAutoFocus: "textarea",
    renderTableEdit: defaultEditRender,
    renderTableCell(renderOpts, params) {
      const { row, column } = params;
      const cellValue = import_xe_utils17.default.get(row, column.field);
      return getCellLabelVNs(renderOpts, params, cellValue);
    }
  },
  VxeButton: {
    renderTableDefault: buttonCellRender
  },
  VxeButtonGroup: {
    renderTableDefault(renderOpts, params) {
      const { options } = renderOpts;
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ options }, getCellEditProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
      ];
    }
  },
  VxeSelect: {
    tableAutoFocus: "input",
    renderTableEdit: defaultSelectEditRender,
    renderTableDefault: defaultSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderTableFilter(renderOpts, params) {
      const { column } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      return column.filters.map((option, oIndex) => {
        const optionValue = option.data;
        return h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, params, optionValue, { options, optionProps, optionGroups, optionGroupProps })), getFilterOns(renderOpts, params, option)));
      });
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  /**
   * 已废弃，被 FormatSelect 替换
   * @deprecated
   */
  formatOption: {
    renderTableDefault(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    }
  },
  FormatSelect: {
    renderTableDefault(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  VxeTreeSelect: {
    tableAutoFocus: "input",
    renderTableEdit: defaultTableOrTreeSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    },
    tableExportMethod: handleExportTreeSelectMethod
  },
  /**
   * 已废弃，被 FormatTreeSelect 替换
   * @deprecated
   */
  formatTree: {
    renderTableDefault(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    }
  },
  FormatTreeSelect: {
    renderTableDefault(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    },
    tableExportMethod: handleExportTreeSelectMethod
  },
  VxeTableSelect: {
    tableAutoFocus: "input",
    renderTableEdit: defaultTableOrTreeSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    },
    tableExportMethod: handleExportTreeSelectMethod
  },
  VxeColorPicker: {
    tableAutoFocus: "input",
    renderTableEdit(renderOpts, params) {
      const { row, column } = params;
      const { options } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue, { colors: options })), getEditOns(renderOpts, params)))
      ];
    },
    renderTableCell(renderOpts, params) {
      const { row, column } = params;
      const cellValue = import_xe_utils17.default.get(row, column.field);
      return h("span", {
        class: "vxe-color-picker--readonly"
      }, [
        h("div", {
          class: "vxe-color-picker--readonly-color",
          style: {
            backgroundColor: cellValue
          }
        })
      ]);
    }
  },
  VxeIconPicker: {
    tableAutoFocus: "input",
    renderTableEdit(renderOpts, params) {
      const { row, column } = params;
      const { options } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue, { icons: options })), getEditOns(renderOpts, params)))
      ];
    },
    renderTableCell(renderOpts, params) {
      const { row, column } = params;
      const cellValue = import_xe_utils17.default.get(row, column.field);
      return h("i", {
        class: cellValue
      });
    }
  },
  VxeRadioGroup: {
    renderTableDefault: radioAndCheckboxEditRender
  },
  VxeCheckboxGroup: {
    renderTableDefault: radioAndCheckboxEditRender
  },
  VxeSwitch: {
    tableAutoFocus: "button",
    renderTableEdit: defaultEditRender,
    renderTableDefault: defaultEditRender
  },
  VxeUpload: {
    renderTableEdit: defaultEditRender,
    renderTableCell: defaultEditRender,
    renderTableDefault: defaultEditRender
  },
  VxeImage: {
    renderTableDefault(renderOpts, params) {
      const { row, column } = params;
      const { props } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign(Object.assign({}, props), { src: cellValue }), getEditOns(renderOpts, params)))
      ];
    }
  },
  VxeImageGroup: {
    renderTableDefault(renderOpts, params) {
      const { row, column } = params;
      const { props } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign(Object.assign({}, props), { urlList: cellValue }), getEditOns(renderOpts, params)))
      ];
    }
  },
  VxeTextEllipsis: {
    renderTableDefault(renderOpts, params) {
      const { row, column } = params;
      const { props } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign(Object.assign({}, props), { content: cellValue }), getEditOns(renderOpts, params)))
      ];
    }
  },
  VxeRate: {
    renderTableDefault: defaultEditRender
  },
  VxeSlider: {
    renderTableDefault: defaultEditRender
  },
  // 以下已废弃
  $input: {
    tableAutoFocus: ".vxe-input--inner",
    renderTableEdit: oldEditRender,
    renderTableCell(renderOpts, params) {
      var _a;
      const { props = {} } = renderOpts;
      const { row, column } = params;
      const digits = props.digits || ((_a = getConfig5().input) === null || _a === void 0 ? void 0 : _a.digits) || 2;
      let cellValue = import_xe_utils17.default.get(row, column.field);
      if (cellValue) {
        switch (props.type) {
          case "date":
          case "week":
          case "month":
          case "year":
            cellValue = getLabelFormatDate(cellValue, props);
            break;
          case "float":
            cellValue = import_xe_utils17.default.toFixed(import_xe_utils17.default.floor(cellValue, digits), digits);
            break;
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderTableDefault: oldEditRender,
    renderTableFilter: oldFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  $textarea: {
    tableAutoFocus: ".vxe-textarea--inner"
  },
  $button: {
    renderTableDefault: oldButtonEditRender
  },
  $buttons: {
    renderTableDefault: oldButtonsEditRender
  },
  $select: {
    tableAutoFocus: ".vxe-input--inner",
    renderTableEdit: oldSelectEditRender,
    renderTableDefault: oldSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderTableFilter(renderOpts, params) {
      const { column } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      return column.filters.map((option, oIndex) => {
        const optionValue = option.data;
        return h(getOldComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, params, optionValue, { options, optionProps, optionGroups, optionGroupProps })), getFilterOns(renderOpts, params, option)));
      });
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  $radio: {
    tableAutoFocus: ".vxe-radio--input"
  },
  $checkbox: {
    tableAutoFocus: ".vxe-checkbox--input"
  },
  $switch: {
    tableAutoFocus: ".vxe-switch--button",
    renderTableEdit: oldEditRender,
    renderTableDefault: oldEditRender
  }
  // 以上已废弃
});

// node_modules/vxe-table/es/table/index.js
var VxeTable = Object.assign({}, table_default, {
  install(app) {
    app.component(table_default.name, table_default);
  }
});
var tableHandle = {
  useCellView
};
if (VxeUI.dynamicApp) {
  VxeUI.dynamicApp.component(table_default.name, table_default);
}
VxeUI.component(table_default);
VxeUI.tableHandle = tableHandle;
var Table = VxeTable;
var table_default2 = VxeTable;

// node_modules/vxe-table/es/grid/src/grid.js
var import_xe_utils18 = __toESM(require_xe_utils());
var { getConfig: getConfig6, getI18n: getI18n10, commands, hooks: hooks8, useFns: useFns2, createEvent: createEvent2, globalEvents: globalEvents3, GLOBAL_EVENT_KEYS: GLOBAL_EVENT_KEYS3, renderEmptyElement: renderEmptyElement6 } = VxeUI;
var tableComponentPropKeys = Object.keys(props_default);
var tableComponentMethodKeys = ["clearAll", "syncData", "updateData", "loadData", "reloadData", "reloadRow", "loadColumn", "reloadColumn", "getRowNode", "getColumnNode", "getRowIndex", "getVTRowIndex", "getVMRowIndex", "getColumnIndex", "getVTColumnIndex", "getVMColumnIndex", "setRow", "createData", "createRow", "revertData", "clearData", "isRemoveByRow", "isInsertByRow", "isUpdateByRow", "getColumns", "getColumnById", "getColumnByField", "getTableColumn", "getFullColumns", "getData", "getCheckboxRecords", "getParentRow", "getTreeParentRow", "getRowSeq", "getRowById", "getRowid", "getTableData", "getFullData", "setColumnFixed", "clearColumnFixed", "setColumnWidth", "getColumnWidth", "setRowHeightConf", "getRowHeightConf", "setRowHeight", "getRowHeight", "hideColumn", "showColumn", "resetColumn", "refreshColumn", "refreshScroll", "recalculate", "closeTooltip", "isAllCheckboxChecked", "isAllCheckboxIndeterminate", "getCheckboxIndeterminateRecords", "setCheckboxRow", "setCheckboxRowKey", "isCheckedByCheckboxRow", "isCheckedByCheckboxRowKey", "isIndeterminateByCheckboxRow", "isIndeterminateByCheckboxRowKey", "toggleCheckboxRow", "setAllCheckboxRow", "getRadioReserveRecord", "clearRadioReserve", "getCheckboxReserveRecords", "clearCheckboxReserve", "toggleAllCheckboxRow", "clearCheckboxRow", "setCurrentRow", "isCheckedByRadioRow", "isCheckedByRadioRowKey", "setRadioRow", "setRadioRowKey", "clearCurrentRow", "clearRadioRow", "getCurrentRecord", "getRadioRecord", "getCurrentColumn", "setCurrentColumn", "clearCurrentColumn", "setPendingRow", "togglePendingRow", "hasPendingByRow", "isPendingByRow", "getPendingRecords", "clearPendingRow", "sort", "setSort", "clearSort", "isSort", "getSortColumns", "closeFilter", "isFilter", "isActiveFilterByColumn", "isRowExpandLoaded", "clearRowExpandLoaded", "reloadRowExpand", "reloadRowExpand", "toggleRowExpand", "setAllRowExpand", "setRowExpand", "isExpandByRow", "isRowExpandByRow", "clearRowExpand", "clearRowExpandReserve", "getRowExpandRecords", "getTreeExpandRecords", "isTreeExpandLoaded", "clearTreeExpandLoaded", "reloadTreeExpand", "reloadTreeChilds", "toggleTreeExpand", "setAllTreeExpand", "setTreeExpand", "isTreeExpandByRow", "clearTreeExpand", "clearTreeExpandReserve", "getScroll", "scrollTo", "scrollToRow", "scrollToColumn", "clearScroll", "updateFooter", "updateStatus", "setMergeCells", "removeInsertRow", "removeMergeCells", "getMergeCells", "clearMergeCells", "setMergeFooterItems", "removeMergeFooterItems", "getMergeFooterItems", "clearMergeFooterItems", "getCustomStoreData", "openTooltip", "moveColumnTo", "moveRowTo", "getCellLabel", "getCellElement", "focus", "blur", "connect"];
var gridComponentEmits = [
  ...emits_default,
  "page-change",
  "form-submit",
  "form-submit-invalid",
  "form-reset",
  "form-collapse",
  "form-toggle-collapse",
  "proxy-query",
  "proxy-delete",
  "proxy-save",
  "toolbar-button-click",
  "toolbar-tool-click",
  "zoom"
];
var grid_default = defineComponent({
  name: "VxeGrid",
  props: Object.assign(Object.assign({}, props_default), { layouts: Array, columns: Array, pagerConfig: Object, proxyConfig: Object, toolbarConfig: Object, formConfig: Object, zoomConfig: Object, size: {
    type: String,
    default: () => getConfig6().grid.size || getConfig6().size
  } }),
  emits: gridComponentEmits,
  setup(props, context) {
    var _a;
    const { slots, emit } = context;
    const xID = import_xe_utils18.default.uniqueId();
    const VxeUIFormComponent = VxeUI.getComponent("VxeForm");
    const VxeUIPagerComponent = VxeUI.getComponent("VxePager");
    const defaultLayouts = [["Form"], ["Toolbar", "Top", "Table", "Bottom", "Pager"]];
    const { computeSize } = useFns2.useSize(props);
    const reactData = reactive({
      tableLoading: false,
      proxyInited: false,
      isZMax: false,
      tableData: [],
      filterData: [],
      formData: {},
      sortData: [],
      tZindex: 0,
      tablePage: {
        total: 0,
        pageSize: ((_a = getConfig6().pager) === null || _a === void 0 ? void 0 : _a.pageSize) || 10,
        currentPage: 1
      }
    });
    const refElem = ref();
    const refTable = ref();
    const refForm = ref();
    const refToolbar = ref();
    const refPager = ref();
    const refFormWrapper = ref();
    const refToolbarWrapper = ref();
    const refTopWrapper = ref();
    const refBottomWrapper = ref();
    const refPagerWrapper = ref();
    const extendTableMethods = (methodKeys) => {
      const funcs = {};
      methodKeys.forEach((name) => {
        funcs[name] = (...args) => {
          const $xeTable = refTable.value;
          if ($xeTable && $xeTable[name]) {
            return $xeTable[name](...args);
          }
        };
      });
      return funcs;
    };
    const gridExtendTableMethods = extendTableMethods(tableComponentMethodKeys);
    tableComponentMethodKeys.forEach((name) => {
      gridExtendTableMethods[name] = (...args) => {
        const $xeTable = refTable.value;
        if ($xeTable && $xeTable[name]) {
          return $xeTable && $xeTable[name](...args);
        }
      };
    });
    const computeProxyOpts = computed(() => {
      return import_xe_utils18.default.merge({}, import_xe_utils18.default.clone(getConfig6().grid.proxyConfig, true), props.proxyConfig);
    });
    const computeIsRespMsg = computed(() => {
      const proxyOpts = computeProxyOpts.value;
      return import_xe_utils18.default.isBoolean(proxyOpts.message) ? proxyOpts.message : proxyOpts.showResponseMsg;
    });
    const computeIsActiveMsg = computed(() => {
      const proxyOpts = computeProxyOpts.value;
      return proxyOpts.showActiveMsg;
    });
    const computePagerOpts = computed(() => {
      return Object.assign({}, getConfig6().grid.pagerConfig, props.pagerConfig);
    });
    const computeFormOpts = computed(() => {
      return Object.assign({}, getConfig6().grid.formConfig, props.formConfig);
    });
    const computeToolbarOpts = computed(() => {
      return Object.assign({}, getConfig6().grid.toolbarConfig, props.toolbarConfig);
    });
    const computeZoomOpts = computed(() => {
      return Object.assign({}, getConfig6().grid.zoomConfig, props.zoomConfig);
    });
    const computeStyles = computed(() => {
      const { height, maxHeight } = props;
      const { isZMax, tZindex } = reactData;
      const stys = {};
      if (isZMax) {
        stys.zIndex = tZindex;
      } else {
        if (height) {
          stys.height = height === "auto" || height === "100%" ? "100%" : toCssUnit(height);
        }
        if (maxHeight) {
          stys.maxHeight = maxHeight === "auto" || maxHeight === "100%" ? "100%" : toCssUnit(maxHeight);
        }
      }
      return stys;
    });
    const computeTableExtendProps = computed(() => {
      const rest = {};
      const gridProps = props;
      tableComponentPropKeys.forEach((key) => {
        rest[key] = gridProps[key];
      });
      return rest;
    });
    const computeTableProps = computed(() => {
      const { seqConfig, pagerConfig, loading, editConfig, proxyConfig } = props;
      const { isZMax, tableLoading, tablePage } = reactData;
      const tableExtendProps = computeTableExtendProps.value;
      const proxyOpts = computeProxyOpts.value;
      const pagerOpts = computePagerOpts.value;
      const tProps = Object.assign({}, tableExtendProps);
      if (isZMax) {
        if (tableExtendProps.maxHeight) {
          tProps.maxHeight = "100%";
        } else {
          tProps.height = "100%";
        }
      }
      if (proxyConfig && isEnableConf(proxyOpts)) {
        tProps.loading = loading || tableLoading;
        if (pagerConfig && proxyOpts.seq && isEnableConf(pagerOpts)) {
          tProps.seqConfig = Object.assign({}, seqConfig, { startIndex: (tablePage.currentPage - 1) * tablePage.pageSize });
        }
      }
      if (editConfig) {
        tProps.editConfig = Object.assign({}, editConfig);
      }
      return tProps;
    });
    const computeCurrLayoutConf = computed(() => {
      const { layouts } = props;
      let confs = [];
      if (layouts && layouts.length) {
        confs = layouts;
      } else {
        confs = getConfig6().grid.layouts || defaultLayouts;
      }
      let headKeys = [];
      let bodyKeys = [];
      let footKeys = [];
      if (confs.length) {
        if (import_xe_utils18.default.isArray(confs[0])) {
          headKeys = confs[0];
          bodyKeys = confs[1] || [];
          footKeys = confs[2] || [];
        } else {
          bodyKeys = confs;
        }
      }
      return {
        headKeys,
        bodyKeys,
        footKeys
      };
    });
    const computePageConfFlag = computed(() => {
      const pagerOpts = computePagerOpts.value;
      return `${pagerOpts.currentPage}${pagerOpts.pageSize}`;
    });
    const refMaps = {
      refElem,
      refTable,
      refForm,
      refToolbar,
      refPager
    };
    const computeMaps = {
      computeProxyOpts,
      computePagerOpts,
      computeFormOpts,
      computeToolbarOpts,
      computeZoomOpts
    };
    const $xeGrid = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const initToolbar = () => {
      const toolbarOpts = computeToolbarOpts.value;
      if (props.toolbarConfig && isEnableConf(toolbarOpts)) {
        nextTick(() => {
          const $xeTable = refTable.value;
          const $xeToolbar = refToolbar.value;
          if ($xeTable && $xeToolbar) {
            $xeTable.connect($xeToolbar);
          }
        });
      }
    };
    const getFormData = () => {
      const { proxyConfig } = props;
      const { formData } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      return proxyConfig && isEnableConf(proxyOpts) && proxyOpts.form ? formData : formOpts.data;
    };
    const initPages = () => {
      const { tablePage } = reactData;
      const { pagerConfig } = props;
      const pagerOpts = computePagerOpts.value;
      const { currentPage, pageSize } = pagerOpts;
      if (pagerConfig && isEnableConf(pagerOpts)) {
        if (currentPage) {
          tablePage.currentPage = currentPage;
        }
        if (pageSize) {
          tablePage.pageSize = pageSize;
        }
      }
    };
    const triggerPendingEvent = (code) => {
      const isActiveMsg = computeIsActiveMsg.value;
      const $xeTable = refTable.value;
      const selectRecords = $xeTable.getCheckboxRecords();
      if (selectRecords.length) {
        $xeTable.togglePendingRow(selectRecords);
        gridExtendTableMethods.clearCheckboxRow();
      } else {
        if (isActiveMsg) {
          if (VxeUI.modal) {
            VxeUI.modal.message({ id: code, content: getI18n10("vxe.grid.selectOneRecord"), status: "warning" });
          }
        }
      }
    };
    const getRespMsg = (rest, defaultMsg) => {
      const proxyOpts = computeProxyOpts.value;
      const resConfigs = proxyOpts.response || proxyOpts.props || {};
      const messageProp = resConfigs.message;
      let msg;
      if (rest && messageProp) {
        msg = import_xe_utils18.default.isFunction(messageProp) ? messageProp({ data: rest, $grid: $xeGrid }) : import_xe_utils18.default.get(rest, messageProp);
      }
      return msg || getI18n10(defaultMsg);
    };
    const handleDeleteRow = (code, alertKey, callback) => {
      const isActiveMsg = computeIsActiveMsg.value;
      const selectRecords = gridExtendTableMethods.getCheckboxRecords();
      if (isActiveMsg) {
        if (selectRecords.length) {
          if (VxeUI.modal) {
            return VxeUI.modal.confirm({ id: `cfm_${code}`, content: getI18n10(alertKey), escClosable: true }).then((type) => {
              if (type === "confirm") {
                return callback();
              }
            });
          }
        } else {
          if (VxeUI.modal) {
            VxeUI.modal.message({ id: `msg_${code}`, content: getI18n10("vxe.grid.selectOneRecord"), status: "warning" });
          }
        }
      } else {
        if (selectRecords.length) {
          callback();
        }
      }
      return Promise.resolve();
    };
    const pageChangeEvent = (params) => {
      const { proxyConfig } = props;
      const { tablePage } = reactData;
      const { $event, currentPage, pageSize } = params;
      const proxyOpts = computeProxyOpts.value;
      tablePage.currentPage = currentPage;
      tablePage.pageSize = pageSize;
      $xeGrid.dispatchEvent("page-change", params, $event);
      if (proxyConfig && isEnableConf(proxyOpts)) {
        $xeGrid.commitProxy("query").then((rest) => {
          $xeGrid.dispatchEvent("proxy-query", rest, $event);
        });
      }
    };
    const sortChangeEvent = (params) => {
      const $xeTable = refTable.value;
      const { proxyConfig } = props;
      const { computeSortOpts } = $xeTable.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      const sortOpts = computeSortOpts.value;
      if (sortOpts.remote) {
        reactData.sortData = params.sortList;
        if (proxyConfig && isEnableConf(proxyOpts)) {
          reactData.tablePage.currentPage = 1;
          gridMethods.commitProxy("query").then((rest) => {
            gridMethods.dispatchEvent("proxy-query", rest, params.$event);
          });
        }
      }
      gridMethods.dispatchEvent("sort-change", params, params.$event);
    };
    const filterChangeEvent = (params) => {
      const $xeTable = refTable.value;
      const { proxyConfig } = props;
      const { computeFilterOpts } = $xeTable.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      const filterOpts = computeFilterOpts.value;
      if (filterOpts.remote) {
        reactData.filterData = params.filterList;
        if (proxyConfig && isEnableConf(proxyOpts)) {
          reactData.tablePage.currentPage = 1;
          gridMethods.commitProxy("query").then((rest) => {
            gridMethods.dispatchEvent("proxy-query", rest, params.$event);
          });
        }
      }
      gridMethods.dispatchEvent("filter-change", params, params.$event);
    };
    const submitFormEvent = (params) => {
      const { proxyConfig } = props;
      const proxyOpts = computeProxyOpts.value;
      if (reactData.tableLoading) {
        return;
      }
      if (proxyConfig && isEnableConf(proxyOpts)) {
        gridMethods.commitProxy("reload").then((rest) => {
          gridMethods.dispatchEvent("proxy-query", Object.assign(Object.assign({}, rest), { isReload: true }), params.$event);
        });
      }
      gridMethods.dispatchEvent("form-submit", params, params.$event);
    };
    const resetFormEvent = (params) => {
      const { proxyConfig } = props;
      const { $event } = params;
      const proxyOpts = computeProxyOpts.value;
      const $xeTable = refTable.value;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        $xeTable.clearScroll();
        gridMethods.commitProxy("reload").then((rest) => {
          gridMethods.dispatchEvent("proxy-query", Object.assign(Object.assign({}, rest), { isReload: true }), $event);
        });
      }
      gridMethods.dispatchEvent("form-reset", params, $event);
    };
    const submitInvalidEvent = (params) => {
      gridMethods.dispatchEvent("form-submit-invalid", params, params.$event);
    };
    const collapseEvent = (params) => {
      const { $event } = params;
      nextTick(() => gridExtendTableMethods.recalculate(true));
      gridMethods.dispatchEvent("form-toggle-collapse", params, $event);
      gridMethods.dispatchEvent("form-collapse", params, $event);
    };
    const handleZoom = (isMax) => {
      const { isZMax } = reactData;
      if (isMax ? !isZMax : isZMax) {
        reactData.isZMax = !isZMax;
        if (reactData.tZindex < getLastZIndex()) {
          reactData.tZindex = nextZIndex();
        }
      }
      return nextTick().then(() => gridExtendTableMethods.recalculate(true)).then(() => {
        setTimeout(() => gridExtendTableMethods.recalculate(true), 15);
        return reactData.isZMax;
      });
    };
    const getFuncSlot = (optSlots, slotKey) => {
      const funcSlot = optSlots[slotKey];
      if (funcSlot) {
        if (import_xe_utils18.default.isString(funcSlot)) {
          if (slots[funcSlot]) {
            return slots[funcSlot];
          } else {
            errLog("vxe.error.notSlot", [funcSlot]);
          }
        } else {
          return funcSlot;
        }
      }
      return null;
    };
    const getConfigSlot = (slotConfigs) => {
      const slotConf = {};
      import_xe_utils18.default.objectMap(slotConfigs, (slotFunc, slotKey) => {
        if (slotFunc) {
          if (import_xe_utils18.default.isString(slotFunc)) {
            if (slots[slotFunc]) {
              slotConf[slotKey] = slots[slotFunc];
            } else {
              errLog("vxe.error.notSlot", [slotFunc]);
            }
          } else {
            slotConf[slotKey] = slotFunc;
          }
        }
      });
      return slotConf;
    };
    const renderForm = () => {
      const { formConfig, proxyConfig } = props;
      const { formData } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      if (formConfig && isEnableConf(formOpts) || slots.form) {
        let slotVNs = [];
        if (slots.form) {
          slotVNs = slots.form({ $grid: $xeGrid });
        } else {
          if (formOpts.items) {
            const formSlots = {};
            if (!formOpts.inited) {
              formOpts.inited = true;
              const beforeItem = proxyOpts.beforeItem;
              if (proxyOpts && beforeItem) {
                formOpts.items.forEach((item) => {
                  beforeItem({ $grid: $xeGrid, item });
                });
              }
            }
            formOpts.items.forEach((item) => {
              import_xe_utils18.default.each(item.slots, (func) => {
                if (!import_xe_utils18.default.isFunction(func)) {
                  if (slots[func]) {
                    formSlots[func] = slots[func];
                  }
                }
              });
            });
            if (VxeUIFormComponent) {
              slotVNs.push(h(VxeUIFormComponent, Object.assign(Object.assign({ ref: refForm }, Object.assign({}, formOpts, {
                data: proxyConfig && isEnableConf(proxyOpts) && proxyOpts.form ? formData : formOpts.data
              })), { onSubmit: submitFormEvent, onReset: resetFormEvent, onSubmitInvalid: submitInvalidEvent, onCollapse: collapseEvent }), formSlots));
            }
          }
        }
        return h("div", {
          ref: refFormWrapper,
          key: "form",
          class: "vxe-grid--form-wrapper"
        }, slotVNs);
      }
      return renderEmptyElement6($xeGrid);
    };
    const renderToolbar = () => {
      const { toolbarConfig } = props;
      const toolbarOpts = computeToolbarOpts.value;
      if (toolbarConfig && isEnableConf(toolbarOpts) || slots.toolbar) {
        let slotVNs = [];
        if (slots.toolbar) {
          slotVNs = slots.toolbar({ $grid: $xeGrid });
        } else {
          const toolbarOptSlots = toolbarOpts.slots;
          let buttonsSlot;
          let toolsSlot;
          const toolbarSlots = {};
          if (toolbarOptSlots) {
            buttonsSlot = getFuncSlot(toolbarOptSlots, "buttons");
            toolsSlot = getFuncSlot(toolbarOptSlots, "tools");
            if (buttonsSlot) {
              toolbarSlots.buttons = buttonsSlot;
            }
            if (toolsSlot) {
              toolbarSlots.tools = toolsSlot;
            }
          }
          slotVNs.push(h(toolbar_default, Object.assign({ ref: refToolbar }, toolbarOpts), toolbarSlots));
        }
        return h("div", {
          ref: refToolbarWrapper,
          key: "toolbar",
          class: "vxe-grid--toolbar-wrapper"
        }, slotVNs);
      }
      return renderEmptyElement6($xeGrid);
    };
    const renderTop = () => {
      if (slots.top) {
        return h("div", {
          ref: refTopWrapper,
          key: "top",
          class: "vxe-grid--top-wrapper"
        }, slots.top({ $grid: $xeGrid }));
      }
      return renderEmptyElement6($xeGrid);
    };
    const renderTableLeft = () => {
      const leftSlot = slots.left;
      if (leftSlot) {
        return h("div", {
          class: "vxe-grid--left-wrapper"
        }, leftSlot({ $grid: $xeGrid }));
      }
      return renderEmptyElement6($xeGrid);
    };
    const renderTableRight = () => {
      const rightSlot = slots.right;
      if (rightSlot) {
        return h("div", {
          class: "vxe-grid--right-wrapper"
        }, rightSlot({ $grid: $xeGrid }));
      }
      return renderEmptyElement6($xeGrid);
    };
    const renderTable = () => {
      const { proxyConfig } = props;
      const tableProps = computeTableProps.value;
      const proxyOpts = computeProxyOpts.value;
      const tableOns = Object.assign({}, tableCompEvents);
      const emptySlot = slots.empty;
      const loadingSlot = slots.loading;
      const rowDragIconSlot = slots.rowDragIcon || slots["row-drag-icon"];
      const columnDragIconSlot = slots.columnDragIcon || slots["column-drag-icon"];
      if (proxyConfig && isEnableConf(proxyOpts)) {
        if (proxyOpts.sort) {
          tableOns.onSortChange = sortChangeEvent;
        }
        if (proxyOpts.filter) {
          tableOns.onFilterChange = filterChangeEvent;
        }
      }
      const slotObj = {};
      if (emptySlot) {
        slotObj.empty = emptySlot;
      }
      if (loadingSlot) {
        slotObj.loading = loadingSlot;
      }
      if (rowDragIconSlot) {
        slotObj.rowDragIcon = rowDragIconSlot;
      }
      if (columnDragIconSlot) {
        slotObj.columnDragIcon = columnDragIconSlot;
      }
      return h("div", {
        class: "vxe-grid--table-wrapper"
      }, [
        h(table_default2, Object.assign(Object.assign({ ref: refTable }, tableProps), tableOns), slotObj)
      ]);
    };
    const renderBottom = () => {
      if (slots.bottom) {
        return h("div", {
          ref: refBottomWrapper,
          key: "bottom",
          class: "vxe-grid--bottom-wrapper"
        }, slots.bottom({ $grid: $xeGrid }));
      }
      return renderEmptyElement6($xeGrid);
    };
    const renderPager = () => {
      const { proxyConfig, pagerConfig } = props;
      const proxyOpts = computeProxyOpts.value;
      const pagerOpts = computePagerOpts.value;
      const pagerSlot = slots.pager;
      if (pagerConfig && isEnableConf(pagerOpts) || slots.pager) {
        return h("div", {
          ref: refPagerWrapper,
          key: "pager",
          class: "vxe-grid--pager-wrapper"
        }, pagerSlot ? pagerSlot({ $grid: $xeGrid }) : [
          VxeUIPagerComponent ? h(VxeUIPagerComponent, Object.assign(Object.assign(Object.assign({ ref: refPager }, pagerOpts), proxyConfig && isEnableConf(proxyOpts) ? reactData.tablePage : {}), { onPageChange: pageChangeEvent }), getConfigSlot(pagerOpts.slots)) : renderEmptyElement6($xeGrid)
        ]);
      }
      return renderEmptyElement6($xeGrid);
    };
    const renderChildLayout = (layoutKeys) => {
      const childVNs = [];
      layoutKeys.forEach((key) => {
        switch (key) {
          case "Form":
            childVNs.push(renderForm());
            break;
          case "Toolbar":
            childVNs.push(renderToolbar());
            break;
          case "Top":
            childVNs.push(renderTop());
            break;
          case "Table":
            childVNs.push(h("div", {
              key: "table",
              class: "vxe-grid--table-container"
            }, [
              renderTableLeft(),
              renderTable(),
              renderTableRight()
            ]));
            break;
          case "Bottom":
            childVNs.push(renderBottom());
            break;
          case "Pager":
            childVNs.push(renderPager());
            break;
          default:
            errLog("vxe.error.notProp", [`layouts -> ${key}`]);
            break;
        }
      });
      return childVNs;
    };
    const renderLayout = () => {
      const currLayoutConf = computeCurrLayoutConf.value;
      const { headKeys, bodyKeys, footKeys } = currLayoutConf;
      const asideLeftSlot = slots.asideLeft || slots["aside-left"];
      const asideRightSlot = slots.asideRight || slots["aside-right"];
      return [
        h("div", {
          class: "vxe-grid--layout-header-wrapper"
        }, renderChildLayout(headKeys)),
        h("div", {
          class: "vxe-grid--layout-body-wrapper"
        }, [
          asideLeftSlot ? h("div", {
            class: "vxe-grid--layout-aside-left-wrapper"
          }, asideLeftSlot({})) : renderEmptyElement6($xeGrid),
          h("div", {
            class: "vxe-grid--layout-body-content-wrapper"
          }, renderChildLayout(bodyKeys)),
          asideRightSlot ? h("div", {
            class: "vxe-grid--layout-aside-right-wrapper"
          }, asideRightSlot({})) : renderEmptyElement6($xeGrid)
        ]),
        h("div", {
          class: "vxe-grid--layout-footer-wrapper"
        }, renderChildLayout(footKeys))
      ];
    };
    const tableCompEvents = {};
    emits_default.forEach((name) => {
      const type = import_xe_utils18.default.camelCase(`on-${name}`);
      tableCompEvents[type] = (...args) => emit(name, ...args);
    });
    const initProxy = () => {
      const { proxyConfig, formConfig } = props;
      const { proxyInited } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        if (formConfig && isEnableConf(formOpts) && proxyOpts.form && formOpts.items) {
          const fData = {};
          formOpts.items.forEach((item) => {
            const { field, itemRender } = item;
            if (field) {
              let itemValue = null;
              if (itemRender) {
                const { defaultValue } = itemRender;
                if (import_xe_utils18.default.isFunction(defaultValue)) {
                  itemValue = defaultValue({ item });
                } else if (!import_xe_utils18.default.isUndefined(defaultValue)) {
                  itemValue = defaultValue;
                }
              }
              fData[field] = itemValue;
            }
          });
          reactData.formData = fData;
        }
        if (!proxyInited) {
          reactData.proxyInited = true;
          if (proxyOpts.autoLoad !== false) {
            nextTick().then(() => gridMethods.commitProxy("_init")).then((rest) => {
              gridMethods.dispatchEvent("proxy-query", Object.assign(Object.assign({}, rest), { isInited: true }), new Event("init"));
            });
          }
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const zoomOpts = computeZoomOpts.value;
      const isEsc = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS3.ESCAPE);
      if (isEsc && reactData.isZMax && zoomOpts.escRestore !== false) {
        gridPrivateMethods.triggerZoomEvent(evnt);
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent2(evnt, { $grid: $xeGrid }, params));
    };
    const gridMethods = {
      dispatchEvent,
      getEl() {
        return refElem.value;
      },
      /**
       * 提交指令，支持 code 或 button
       * @param {String/Object} code 字符串或对象
       */
      commitProxy(proxyTarget, ...args) {
        const { toolbarConfig, pagerConfig, editRules, validConfig } = props;
        const { tablePage } = reactData;
        const isActiveMsg = computeIsActiveMsg.value;
        const isRespMsg = computeIsRespMsg.value;
        const proxyOpts = computeProxyOpts.value;
        const pagerOpts = computePagerOpts.value;
        const toolbarOpts = computeToolbarOpts.value;
        const { beforeQuery, afterQuery, beforeDelete, afterDelete, beforeSave, afterSave, ajax = {} } = proxyOpts;
        const resConfigs = proxyOpts.response || proxyOpts.props || {};
        const $xeTable = refTable.value;
        const formData = getFormData();
        let button = null;
        let code = null;
        if (import_xe_utils18.default.isString(proxyTarget)) {
          const { buttons } = toolbarOpts;
          const matchObj = toolbarConfig && isEnableConf(toolbarOpts) && buttons ? import_xe_utils18.default.findTree(buttons, (item) => item.code === proxyTarget, { children: "dropdowns" }) : null;
          button = matchObj ? matchObj.item : null;
          code = proxyTarget;
        } else {
          button = proxyTarget;
          code = button.code;
        }
        const btnParams = button ? button.params : null;
        switch (code) {
          case "insert":
            return $xeTable.insert({});
          case "insert_edit":
            return $xeTable.insert({}).then(({ row }) => $xeTable.setEditRow(row));
          case "insert_actived":
            return $xeTable.insert({}).then(({ row }) => $xeTable.setEditRow(row));
          case "mark_cancel":
            triggerPendingEvent(code);
            break;
          case "remove":
            return handleDeleteRow(code, "vxe.grid.removeSelectRecord", () => $xeTable.removeCheckboxRow());
          case "import":
            $xeTable.importData(btnParams);
            break;
          case "open_import":
            $xeTable.openImport(btnParams);
            break;
          case "export":
            $xeTable.exportData(btnParams);
            break;
          case "open_export":
            $xeTable.openExport(btnParams);
            break;
          case "reset_custom":
            return $xeTable.resetCustom(true);
          case "_init":
          case "reload":
          case "query": {
            const ajaxMethods = ajax.query;
            const querySuccessMethods = ajax.querySuccess;
            const queryErrorMethods = ajax.queryError;
            if (ajaxMethods) {
              const isInited = code === "_init";
              const isReload = code === "reload";
              if (!isInited && reactData.tableLoading) {
                return nextTick();
              }
              let sortList = [];
              let filterList = [];
              let pageParams = {};
              if (pagerConfig) {
                if (isInited || isReload) {
                  tablePage.currentPage = 1;
                }
                if (isEnableConf(pagerOpts)) {
                  pageParams = Object.assign({}, tablePage);
                }
              }
              if (isInited) {
                let defaultSort = null;
                if ($xeTable) {
                  const { computeSortOpts } = $xeTable.getComputeMaps();
                  const sortOpts = computeSortOpts.value;
                  defaultSort = sortOpts.defaultSort;
                }
                if (defaultSort) {
                  if (!import_xe_utils18.default.isArray(defaultSort)) {
                    defaultSort = [defaultSort];
                  }
                  sortList = defaultSort.map((item) => {
                    return {
                      field: item.field,
                      property: item.field,
                      order: item.order
                    };
                  });
                }
                if ($xeTable) {
                  filterList = $xeTable.getCheckedFilters();
                }
              } else {
                if ($xeTable) {
                  if (isReload) {
                    $xeTable.clearAll();
                  } else {
                    sortList = $xeTable.getSortColumns();
                    filterList = $xeTable.getCheckedFilters();
                  }
                }
              }
              const commitParams = {
                code,
                button,
                isInited,
                isReload,
                $grid: $xeGrid,
                page: pageParams,
                sort: sortList.length ? sortList[0] : {},
                sorts: sortList,
                filters: filterList,
                form: formData,
                options: ajaxMethods
              };
              reactData.sortData = sortList;
              reactData.filterData = filterList;
              reactData.tableLoading = true;
              return Promise.resolve((beforeQuery || ajaxMethods)(commitParams, ...args)).then((rest) => {
                let tableData = [];
                reactData.tableLoading = false;
                if (rest) {
                  if (pagerConfig && isEnableConf(pagerOpts)) {
                    const totalProp = resConfigs.total;
                    const total = (import_xe_utils18.default.isFunction(totalProp) ? totalProp({ data: rest, $grid: $xeGrid }) : import_xe_utils18.default.get(rest, totalProp || "page.total")) || 0;
                    tablePage.total = import_xe_utils18.default.toNumber(total);
                    const resultProp = resConfigs.result;
                    tableData = (import_xe_utils18.default.isFunction(resultProp) ? resultProp({ data: rest, $grid: $xeGrid }) : import_xe_utils18.default.get(rest, resultProp || "result")) || [];
                    const pageCount = Math.max(Math.ceil(total / tablePage.pageSize), 1);
                    if (tablePage.currentPage > pageCount) {
                      tablePage.currentPage = pageCount;
                    }
                  } else {
                    const listProp = resConfigs.list;
                    tableData = (listProp ? import_xe_utils18.default.isFunction(listProp) ? listProp({ data: rest, $grid: $xeGrid }) : import_xe_utils18.default.get(rest, listProp) : rest) || [];
                  }
                }
                if ($xeTable) {
                  $xeTable.loadData(tableData);
                } else {
                  nextTick(() => {
                    if ($xeTable) {
                      $xeTable.loadData(tableData);
                    }
                  });
                }
                if (afterQuery) {
                  afterQuery(commitParams, ...args);
                }
                if (querySuccessMethods) {
                  querySuccessMethods(Object.assign(Object.assign({}, commitParams), { response: rest }));
                }
                return { status: true };
              }).catch((rest) => {
                reactData.tableLoading = false;
                if (queryErrorMethods) {
                  queryErrorMethods(Object.assign(Object.assign({}, commitParams), { response: rest }));
                }
                return { status: false };
              });
            } else {
              errLog("vxe.error.notFunc", ["proxy-config.ajax.query"]);
            }
            break;
          }
          case "delete": {
            const ajaxMethods = ajax.delete;
            const deleteSuccessMethods = ajax.deleteSuccess;
            const deleteErrorMethods = ajax.deleteError;
            if (ajaxMethods) {
              const selectRecords = gridExtendTableMethods.getCheckboxRecords();
              const removeRecords = selectRecords.filter((row) => !$xeTable.isInsertByRow(row));
              const body = { removeRecords };
              const commitParams = { $grid: $xeGrid, code, button, body, form: formData, options: ajaxMethods };
              if (selectRecords.length) {
                return handleDeleteRow(code, "vxe.grid.deleteSelectRecord", () => {
                  if (!removeRecords.length) {
                    return $xeTable.remove(selectRecords);
                  }
                  reactData.tableLoading = true;
                  return Promise.resolve((beforeDelete || ajaxMethods)(commitParams, ...args)).then((rest) => {
                    reactData.tableLoading = false;
                    $xeTable.setPendingRow(removeRecords, false);
                    if (isRespMsg) {
                      if (VxeUI.modal) {
                        VxeUI.modal.message({ content: getRespMsg(rest, "vxe.grid.delSuccess"), status: "success" });
                      }
                    }
                    if (afterDelete) {
                      afterDelete(commitParams, ...args);
                    } else {
                      gridMethods.commitProxy("query");
                    }
                    if (deleteSuccessMethods) {
                      deleteSuccessMethods(Object.assign(Object.assign({}, commitParams), { response: rest }));
                    }
                    return { status: true };
                  }).catch((rest) => {
                    reactData.tableLoading = false;
                    if (isRespMsg) {
                      if (VxeUI.modal) {
                        VxeUI.modal.message({ id: code, content: getRespMsg(rest, "vxe.grid.operError"), status: "error" });
                      }
                    }
                    if (deleteErrorMethods) {
                      deleteErrorMethods(Object.assign(Object.assign({}, commitParams), { response: rest }));
                    }
                    return { status: false };
                  });
                });
              } else {
                if (isActiveMsg) {
                  if (VxeUI.modal) {
                    VxeUI.modal.message({ id: code, content: getI18n10("vxe.grid.selectOneRecord"), status: "warning" });
                  }
                }
              }
            } else {
              errLog("vxe.error.notFunc", ["proxy-config.ajax.delete"]);
            }
            break;
          }
          case "save": {
            const ajaxMethods = ajax.save;
            const saveSuccessMethods = ajax.saveSuccess;
            const saveErrorMethods = ajax.saveError;
            if (ajaxMethods) {
              const body = $xeTable.getRecordset();
              const { insertRecords, removeRecords, updateRecords, pendingRecords } = body;
              const commitParams = { $grid: $xeGrid, code, button, body, form: formData, options: ajaxMethods };
              if (insertRecords.length) {
                body.pendingRecords = pendingRecords.filter((row) => $xeTable.findRowIndexOf(insertRecords, row) === -1);
              }
              if (pendingRecords.length) {
                body.insertRecords = insertRecords.filter((row) => $xeTable.findRowIndexOf(pendingRecords, row) === -1);
              }
              let restPromise = Promise.resolve();
              if (editRules) {
                restPromise = $xeTable[validConfig && validConfig.msgMode === "full" ? "fullValidate" : "validate"](body.insertRecords.concat(updateRecords));
              }
              return restPromise.then((errMap) => {
                if (errMap) {
                  return;
                }
                if (body.insertRecords.length || removeRecords.length || updateRecords.length || body.pendingRecords.length) {
                  reactData.tableLoading = true;
                  return Promise.resolve((beforeSave || ajaxMethods)(commitParams, ...args)).then((rest) => {
                    reactData.tableLoading = false;
                    $xeTable.clearPendingRow();
                    if (isRespMsg) {
                      if (VxeUI.modal) {
                        VxeUI.modal.message({ content: getRespMsg(rest, "vxe.grid.saveSuccess"), status: "success" });
                      }
                    }
                    if (afterSave) {
                      afterSave(commitParams, ...args);
                    } else {
                      gridMethods.commitProxy("query");
                    }
                    if (saveSuccessMethods) {
                      saveSuccessMethods(Object.assign(Object.assign({}, commitParams), { response: rest }));
                    }
                    return { status: true };
                  }).catch((rest) => {
                    reactData.tableLoading = false;
                    if (isRespMsg) {
                      if (VxeUI.modal) {
                        VxeUI.modal.message({ id: code, content: getRespMsg(rest, "vxe.grid.operError"), status: "error" });
                      }
                    }
                    if (saveErrorMethods) {
                      saveErrorMethods(Object.assign(Object.assign({}, commitParams), { response: rest }));
                    }
                    return { status: false };
                  });
                } else {
                  if (isActiveMsg) {
                    if (VxeUI.modal) {
                      VxeUI.modal.message({ id: code, content: getI18n10("vxe.grid.dataUnchanged"), status: "info" });
                    }
                  }
                }
              });
            } else {
              errLog("vxe.error.notFunc", ["proxy-config.ajax.save"]);
            }
            break;
          }
          default: {
            const gCommandOpts = commands.get(code);
            if (gCommandOpts) {
              const tCommandMethod = gCommandOpts.tableCommandMethod || gCommandOpts.commandMethod;
              if (tCommandMethod) {
                tCommandMethod({ code, button, $grid: $xeGrid, $table: $xeTable }, ...args);
              } else {
                errLog("vxe.error.notCommands", [code]);
              }
            }
          }
        }
        return nextTick();
      },
      zoom() {
        if (reactData.isZMax) {
          return gridMethods.revert();
        }
        return gridMethods.maximize();
      },
      isMaximized() {
        return reactData.isZMax;
      },
      maximize() {
        return handleZoom(true);
      },
      revert() {
        return handleZoom();
      },
      getFormData,
      getFormItems(itemIndex) {
        const formOpts = computeFormOpts.value;
        const { formConfig } = props;
        const { items } = formOpts;
        const itemList = [];
        import_xe_utils18.default.eachTree(formConfig && isEnableConf(formOpts) && items ? items : [], (item) => {
          itemList.push(item);
        }, { children: "children" });
        return import_xe_utils18.default.isUndefined(itemIndex) ? itemList : itemList[itemIndex];
      },
      getProxyInfo() {
        const $xeTable = refTable.value;
        if (props.proxyConfig) {
          const { sortData } = reactData;
          return {
            data: $xeTable ? $xeTable.getFullData() : [],
            filter: reactData.filterData,
            form: getFormData(),
            sort: sortData.length ? sortData[0] : {},
            sorts: sortData,
            pager: reactData.tablePage,
            pendingRecords: $xeTable ? $xeTable.getPendingRecords() : []
          };
        }
        return null;
      }
      // setProxyInfo (options) {
      //   if (props.proxyConfig && options) {
      //     const { pager, form } = options
      //     const proxyOpts = computeProxyOpts.value
      //     if (pager) {
      //       if (pager.currentPage) {
      //         reactData.tablePage.currentPage = Number(pager.currentPage)
      //       }
      //       if (pager.pageSize) {
      //         reactData.tablePage.pageSize = Number(pager.pageSize)
      //       }
      //     }
      //     if (proxyOpts.form && form) {
      //       Object.assign(reactData.formData, form)
      //     }
      //   }
      //   return nextTick()
      // }
    };
    if (true) {
      gridMethods.loadColumn = (columns) => {
        const $xeTable = refTable.value;
        import_xe_utils18.default.eachTree(columns, (column) => {
          if (column.slots) {
            import_xe_utils18.default.each(column.slots, (func) => {
              if (!import_xe_utils18.default.isFunction(func)) {
                if (!slots[func]) {
                  errLog("vxe.error.notSlot", [func]);
                }
              }
            });
          }
        });
        if ($xeTable) {
          return $xeTable.loadColumn(columns);
        }
        return nextTick();
      };
      gridMethods.reloadColumn = (columns) => {
        gridExtendTableMethods.clearAll();
        return gridMethods.loadColumn(columns);
      };
    }
    const gridPrivateMethods = {
      extendTableMethods,
      callSlot(slotFunc, params) {
        if (slotFunc) {
          if (import_xe_utils18.default.isString(slotFunc)) {
            slotFunc = slots[slotFunc] || null;
          }
          if (import_xe_utils18.default.isFunction(slotFunc)) {
            return getSlotVNs(slotFunc(params));
          }
        }
        return [];
      },
      /**
       * 获取需要排除的高度
       */
      getExcludeHeight() {
        const { isZMax } = reactData;
        const el = refElem.value;
        if (el) {
          const formWrapper = refFormWrapper.value;
          const toolbarWrapper = refToolbarWrapper.value;
          const topWrapper = refTopWrapper.value;
          const bottomWrapper = refBottomWrapper.value;
          const pagerWrapper = refPagerWrapper.value;
          const parentEl = el.parentElement;
          const parentPaddingSize = isZMax ? 0 : parentEl ? getPaddingTopBottomSize(parentEl) : 0;
          return parentPaddingSize + getPaddingTopBottomSize(el) + getOffsetHeight(formWrapper) + getOffsetHeight(toolbarWrapper) + getOffsetHeight(topWrapper) + getOffsetHeight(bottomWrapper) + getOffsetHeight(pagerWrapper);
        }
        return 0;
      },
      getParentHeight() {
        const el = refElem.value;
        if (el) {
          const parentEl = el.parentElement;
          return (reactData.isZMax ? getDomNode().visibleHeight : parentEl ? import_xe_utils18.default.toNumber(getComputedStyle(parentEl).height) : 0) - gridPrivateMethods.getExcludeHeight();
        }
        return 0;
      },
      triggerToolbarCommitEvent(params, evnt) {
        const { code } = params;
        return gridMethods.commitProxy(params, evnt).then((rest) => {
          if (code && rest && rest.status && ["query", "reload", "delete", "save"].includes(code)) {
            gridMethods.dispatchEvent(code === "delete" || code === "save" ? `proxy-${code}` : "proxy-query", Object.assign(Object.assign({}, rest), { isReload: code === "reload" }), evnt);
          }
        });
      },
      triggerToolbarBtnEvent(button, evnt) {
        gridPrivateMethods.triggerToolbarCommitEvent(button, evnt);
        gridMethods.dispatchEvent("toolbar-button-click", { code: button.code, button }, evnt);
      },
      triggerToolbarTolEvent(tool, evnt) {
        gridPrivateMethods.triggerToolbarCommitEvent(tool, evnt);
        gridMethods.dispatchEvent("toolbar-tool-click", { code: tool.code, tool }, evnt);
      },
      triggerZoomEvent(evnt) {
        gridMethods.zoom();
        gridMethods.dispatchEvent("zoom", { type: reactData.isZMax ? "max" : "revert" }, evnt);
      }
    };
    Object.assign($xeGrid, gridExtendTableMethods, gridMethods, gridPrivateMethods);
    const columnFlag = ref(0);
    watch(() => props.columns ? props.columns.length : -1, () => {
      columnFlag.value++;
    });
    watch(() => props.columns, () => {
      columnFlag.value++;
    });
    watch(columnFlag, () => {
      nextTick(() => $xeGrid.loadColumn(props.columns || []));
    });
    watch(() => props.toolbarConfig, () => {
      initToolbar();
    });
    watch(computePageConfFlag, () => {
      initPages();
    });
    watch(() => props.proxyConfig, () => {
      initProxy();
    });
    hooks8.forEach((options) => {
      const { setupGrid } = options;
      if (setupGrid) {
        const hookRest = setupGrid($xeGrid);
        if (hookRest && import_xe_utils18.default.isObject(hookRest)) {
          Object.assign($xeGrid, hookRest);
        }
      }
    });
    initPages();
    onMounted(() => {
      nextTick(() => {
        const { columns } = props;
        if (props.formConfig) {
          if (!VxeUIFormComponent) {
            errLog("vxe.error.reqComp", ["vxe-form"]);
          }
        }
        if (props.pagerConfig) {
          if (!VxeUIPagerComponent) {
            errLog("vxe.error.reqComp", ["vxe-pager"]);
          }
        }
        if (columns && columns.length) {
          $xeGrid.loadColumn(columns);
        }
        initToolbar();
        initProxy();
      });
      globalEvents3.on($xeGrid, "keydown", handleGlobalKeydownEvent);
    });
    onUnmounted(() => {
      globalEvents3.off($xeGrid, "keydown");
    });
    const renderVN = () => {
      const vSize = computeSize.value;
      const styles = computeStyles.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-grid", {
          [`size--${vSize}`]: vSize,
          "is--animat": !!props.animat,
          "is--round": props.round,
          "is--maximize": reactData.isZMax,
          "is--loading": props.loading || reactData.tableLoading
        }],
        style: styles
      }, renderLayout());
    };
    $xeGrid.renderVN = renderVN;
    provide("$xeGrid", $xeGrid);
    return $xeGrid;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-table/es/grid/index.js
var VxeGrid = Object.assign({}, grid_default, {
  install(app) {
    app.component(grid_default.name, grid_default);
  }
});
if (VxeUI.dynamicApp) {
  VxeUI.dynamicApp.component(grid_default.name, grid_default);
}
VxeUI.component(grid_default);
var Grid = VxeGrid;
var grid_default2 = VxeGrid;

export {
  VxeTable,
  Table,
  VxeGrid,
  Grid,
  grid_default2 as grid_default
};
//# sourceMappingURL=chunk-BIN7MLKB.js.map
