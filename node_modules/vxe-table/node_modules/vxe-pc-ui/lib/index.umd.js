(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("vue"), require("xe-utils"));
	else if(typeof define === 'function' && define.amd)
		define([, "xe-utils"], factory);
	else if(typeof exports === 'object')
		exports["VxeUI"] = factory(require("vue"), require("xe-utils"));
	else
		root["VxeUI"] = factory(root["Vue"], root["XEUtils"]);
})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__9274__, __WEBPACK_EXTERNAL_MODULE__8871__) {
return /******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 9274:
/***/ (function(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__9274__;

/***/ }),

/***/ 8871:
/***/ (function(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__8871__;

/***/ }),

/***/ 9306:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(4901);
var tryToString = __webpack_require__(6823);

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw new $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 8551:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isObject = __webpack_require__(34);

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw new $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ 9617:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toIndexedObject = __webpack_require__(5397);
var toAbsoluteIndex = __webpack_require__(5610);
var lengthOfArrayLike = __webpack_require__(6198);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    if (length === 0) return !IS_INCLUDES && -1;
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el !== el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value !== value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 4527:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var isArray = __webpack_require__(4376);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Safari < 13 does not throw an error in this case
var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function () {
  // makes no sense without proper strict mode support
  if (this !== undefined) return true;
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).length = 1;
  } catch (error) {
    return error instanceof TypeError;
  }
}();

module.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {
  if (isArray(O) && !getOwnPropertyDescriptor(O, 'length').writable) {
    throw new $TypeError('Cannot set read only .length');
  } return O.length = length;
} : function (O, length) {
  return O.length = length;
};


/***/ }),

/***/ 4576:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ 6955:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var TO_STRING_TAG_SUPPORT = __webpack_require__(2140);
var isCallable = __webpack_require__(4901);
var classofRaw = __webpack_require__(4576);
var wellKnownSymbol = __webpack_require__(8227);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ 7740:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var hasOwn = __webpack_require__(9297);
var ownKeys = __webpack_require__(5031);
var getOwnPropertyDescriptorModule = __webpack_require__(7347);
var definePropertyModule = __webpack_require__(4913);

module.exports = function (target, source, exceptions) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  }
};


/***/ }),

/***/ 6699:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var definePropertyModule = __webpack_require__(4913);
var createPropertyDescriptor = __webpack_require__(6980);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 6980:
/***/ (function(module) {


module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 2106:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var makeBuiltIn = __webpack_require__(283);
var defineProperty = __webpack_require__(4913);

module.exports = function (target, name, descriptor) {
  if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
  if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
  return defineProperty.f(target, name, descriptor);
};


/***/ }),

/***/ 6840:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(4901);
var definePropertyModule = __webpack_require__(4913);
var makeBuiltIn = __webpack_require__(283);
var defineGlobalProperty = __webpack_require__(9433);

module.exports = function (O, key, value, options) {
  if (!options) options = {};
  var simple = options.enumerable;
  var name = options.name !== undefined ? options.name : key;
  if (isCallable(value)) makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple) O[key] = value;
    else defineGlobalProperty(key, value);
  } else {
    try {
      if (!options.unsafe) delete O[key];
      else if (O[key]) simple = true;
    } catch (error) { /* empty */ }
    if (simple) O[key] = value;
    else definePropertyModule.f(O, key, {
      value: value,
      enumerable: false,
      configurable: !options.nonConfigurable,
      writable: !options.nonWritable
    });
  } return O;
};


/***/ }),

/***/ 9433:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ 3724:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
});


/***/ }),

/***/ 4055:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var isObject = __webpack_require__(34);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 6837:
/***/ (function(module) {


var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};


/***/ }),

/***/ 9392:
/***/ (function(module) {


module.exports = typeof navigator != 'undefined' && String(navigator.userAgent) || '';


/***/ }),

/***/ 7388:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var userAgent = __webpack_require__(9392);

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ 8727:
/***/ (function(module) {


// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 6518:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var getOwnPropertyDescriptor = (__webpack_require__(7347).f);
var createNonEnumerableProperty = __webpack_require__(6699);
var defineBuiltIn = __webpack_require__(6840);
var defineGlobalProperty = __webpack_require__(9433);
var copyConstructorProperties = __webpack_require__(7740);
var isForced = __webpack_require__(2796);

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = global[TARGET] && global[TARGET].prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty == typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    defineBuiltIn(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 9039:
/***/ (function(module) {


module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 616:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ 9565:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_BIND = __webpack_require__(616);

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ 350:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var hasOwn = __webpack_require__(9297);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ 9504:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_BIND = __webpack_require__(616);

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ 7751:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var isCallable = __webpack_require__(4901);

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ 5966:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var aCallable = __webpack_require__(9306);
var isNullOrUndefined = __webpack_require__(4117);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),

/***/ 4475:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var check = function (it) {
  return it && it.Math === Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
  check(typeof this == 'object' && this) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 9297:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var toObject = __webpack_require__(8981);

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ 421:
/***/ (function(module) {


module.exports = {};


/***/ }),

/***/ 5917:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var fails = __webpack_require__(9039);
var createElement = __webpack_require__(4055);

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a !== 7;
});


/***/ }),

/***/ 7055:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var fails = __webpack_require__(9039);
var classof = __webpack_require__(4576);

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) === 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ 3706:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var isCallable = __webpack_require__(4901);
var store = __webpack_require__(7629);

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 1181:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var NATIVE_WEAK_MAP = __webpack_require__(8622);
var global = __webpack_require__(4475);
var isObject = __webpack_require__(34);
var createNonEnumerableProperty = __webpack_require__(6699);
var hasOwn = __webpack_require__(9297);
var shared = __webpack_require__(7629);
var sharedKey = __webpack_require__(6119);
var hiddenKeys = __webpack_require__(421);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 4376:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var classof = __webpack_require__(4576);

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) === 'Array';
};


/***/ }),

/***/ 4901:
/***/ (function(module) {


// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
var documentAll = typeof document == 'object' && document.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
module.exports = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ 2796:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var fails = __webpack_require__(9039);
var isCallable = __webpack_require__(4901);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value === POLYFILL ? true
    : value === NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 4117:
/***/ (function(module) {


// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),

/***/ 34:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isCallable = __webpack_require__(4901);

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 6395:
/***/ (function(module) {


module.exports = false;


/***/ }),

/***/ 757:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var getBuiltIn = __webpack_require__(7751);
var isCallable = __webpack_require__(4901);
var isPrototypeOf = __webpack_require__(1625);
var USE_SYMBOL_AS_UID = __webpack_require__(7040);

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ 6198:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toLength = __webpack_require__(8014);

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ 283:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var fails = __webpack_require__(9039);
var isCallable = __webpack_require__(4901);
var hasOwn = __webpack_require__(9297);
var DESCRIPTORS = __webpack_require__(3724);
var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__(350).CONFIGURABLE);
var inspectSource = __webpack_require__(3706);
var InternalStateModule = __webpack_require__(1181);

var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var $String = String;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
var stringSlice = uncurryThis(''.slice);
var replace = uncurryThis(''.replace);
var join = uncurryThis([].join);

var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {
  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;
});

var TEMPLATE = String(String).split('String');

var makeBuiltIn = module.exports = function (value, name, options) {
  if (stringSlice($String(name), 0, 7) === 'Symbol(') {
    name = '[' + replace($String(name), /^Symbol\(([^)]*)\).*$/, '$1') + ']';
  }
  if (options && options.getter) name = 'get ' + name;
  if (options && options.setter) name = 'set ' + name;
  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });
    else value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
    defineProperty(value, 'length', { value: options.arity });
  }
  try {
    if (options && hasOwn(options, 'constructor') && options.constructor) {
      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });
    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable
    } else if (value.prototype) value.prototype = undefined;
  } catch (error) { /* empty */ }
  var state = enforceInternalState(value);
  if (!hasOwn(state, 'source')) {
    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');
  } return value;
};

// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
// eslint-disable-next-line no-extend-native -- required
Function.prototype.toString = makeBuiltIn(function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
}, 'toString');


/***/ }),

/***/ 741:
/***/ (function(module) {


var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ 4913:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var IE8_DOM_DEFINE = __webpack_require__(5917);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(8686);
var anObject = __webpack_require__(8551);
var toPropertyKey = __webpack_require__(6969);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 7347:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var call = __webpack_require__(9565);
var propertyIsEnumerableModule = __webpack_require__(8773);
var createPropertyDescriptor = __webpack_require__(6980);
var toIndexedObject = __webpack_require__(5397);
var toPropertyKey = __webpack_require__(6969);
var hasOwn = __webpack_require__(9297);
var IE8_DOM_DEFINE = __webpack_require__(5917);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ 8480:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var internalObjectKeys = __webpack_require__(1828);
var enumBugKeys = __webpack_require__(8727);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 3717:
/***/ (function(__unused_webpack_module, exports) {


// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 1625:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ 1828:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);
var hasOwn = __webpack_require__(9297);
var toIndexedObject = __webpack_require__(5397);
var indexOf = (__webpack_require__(9617).indexOf);
var hiddenKeys = __webpack_require__(421);

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ 8773:
/***/ (function(__unused_webpack_module, exports) {


var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 4270:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(9565);
var isCallable = __webpack_require__(4901);
var isObject = __webpack_require__(34);

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw new $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 5031:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var getBuiltIn = __webpack_require__(7751);
var uncurryThis = __webpack_require__(9504);
var getOwnPropertyNamesModule = __webpack_require__(8480);
var getOwnPropertySymbolsModule = __webpack_require__(3717);
var anObject = __webpack_require__(8551);

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 7750:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var isNullOrUndefined = __webpack_require__(4117);

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 6119:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var shared = __webpack_require__(5745);
var uid = __webpack_require__(3392);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 7629:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var IS_PURE = __webpack_require__(6395);
var globalThis = __webpack_require__(4475);
var defineGlobalProperty = __webpack_require__(9433);

var SHARED = '__core-js_shared__';
var store = module.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});

(store.versions || (store.versions = [])).push({
  version: '3.37.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2014-2024 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.37.1/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ 5745:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var store = __webpack_require__(7629);

module.exports = function (key, value) {
  return store[key] || (store[key] = value || {});
};


/***/ }),

/***/ 4495:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(7388);
var fails = __webpack_require__(9039);
var global = __webpack_require__(4475);

var $String = global.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol('symbol detection');
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ 5610:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toIntegerOrInfinity = __webpack_require__(1291);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 5397:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(7055);
var requireObjectCoercible = __webpack_require__(7750);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 1291:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var trunc = __webpack_require__(741);

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ 8014:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toIntegerOrInfinity = __webpack_require__(1291);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  var len = toIntegerOrInfinity(argument);
  return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 8981:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var requireObjectCoercible = __webpack_require__(7750);

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 2777:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var call = __webpack_require__(9565);
var isObject = __webpack_require__(34);
var isSymbol = __webpack_require__(757);
var getMethod = __webpack_require__(5966);
var ordinaryToPrimitive = __webpack_require__(4270);
var wellKnownSymbol = __webpack_require__(8227);

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw new $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 6969:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var toPrimitive = __webpack_require__(2777);
var isSymbol = __webpack_require__(757);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ 2140:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var wellKnownSymbol = __webpack_require__(8227);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 655:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var classof = __webpack_require__(6955);

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw new TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),

/***/ 6823:
/***/ (function(module) {


var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 3392:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var uncurryThis = __webpack_require__(9504);

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ 7040:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(4495);

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 8686:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var fails = __webpack_require__(9039);

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype !== 42;
});


/***/ }),

/***/ 2812:
/***/ (function(module) {


var $TypeError = TypeError;

module.exports = function (passed, required) {
  if (passed < required) throw new $TypeError('Not enough arguments');
  return passed;
};


/***/ }),

/***/ 8622:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var isCallable = __webpack_require__(4901);

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),

/***/ 8227:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {


var global = __webpack_require__(4475);
var shared = __webpack_require__(5745);
var hasOwn = __webpack_require__(9297);
var uid = __webpack_require__(3392);
var NATIVE_SYMBOL = __webpack_require__(4495);
var USE_SYMBOL_AS_UID = __webpack_require__(7040);

var Symbol = global.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 4114:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var $ = __webpack_require__(6518);
var toObject = __webpack_require__(8981);
var lengthOfArrayLike = __webpack_require__(6198);
var setArrayLength = __webpack_require__(4527);
var doesNotExceedSafeInteger = __webpack_require__(6837);
var fails = __webpack_require__(9039);

var INCORRECT_TO_LENGTH = fails(function () {
  return [].push.call({ length: 0x100000000 }, 1) !== 4294967297;
});

// V8 <= 121 and Safari <= 15.4; FF < 23 throws InternalError
// https://bugs.chromium.org/p/v8/issues/detail?id=12681
var properErrorOnNonWritableLength = function () {
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty([], 'length', { writable: false }).push();
  } catch (error) {
    return error instanceof TypeError;
  }
};

var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();

// `Array.prototype.push` method
// https://tc39.es/ecma262/#sec-array.prototype.push
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  push: function push(item) {
    var O = toObject(this);
    var len = lengthOfArrayLike(O);
    var argCount = arguments.length;
    doesNotExceedSafeInteger(len + argCount);
    for (var i = 0; i < argCount; i++) {
      O[len] = arguments[i];
      len++;
    }
    setArrayLength(O, len);
    return len;
  }
});


/***/ }),

/***/ 4603:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var defineBuiltIn = __webpack_require__(6840);
var uncurryThis = __webpack_require__(9504);
var toString = __webpack_require__(655);
var validateArgumentsLength = __webpack_require__(2812);

var $URLSearchParams = URLSearchParams;
var URLSearchParamsPrototype = $URLSearchParams.prototype;
var append = uncurryThis(URLSearchParamsPrototype.append);
var $delete = uncurryThis(URLSearchParamsPrototype['delete']);
var forEach = uncurryThis(URLSearchParamsPrototype.forEach);
var push = uncurryThis([].push);
var params = new $URLSearchParams('a=1&a=2&b=3');

params['delete']('a', 1);
// `undefined` case is a Chromium 117 bug
// https://bugs.chromium.org/p/v8/issues/detail?id=14222
params['delete']('b', undefined);

if (params + '' !== 'a=2') {
  defineBuiltIn(URLSearchParamsPrototype, 'delete', function (name /* , value */) {
    var length = arguments.length;
    var $value = length < 2 ? undefined : arguments[1];
    if (length && $value === undefined) return $delete(this, name);
    var entries = [];
    forEach(this, function (v, k) { // also validates `this`
      push(entries, { key: k, value: v });
    });
    validateArgumentsLength(length, 1);
    var key = toString(name);
    var value = toString($value);
    var index = 0;
    var dindex = 0;
    var found = false;
    var entriesLength = entries.length;
    var entry;
    while (index < entriesLength) {
      entry = entries[index++];
      if (found || entry.key === key) {
        found = true;
        $delete(this, entry.key);
      } else dindex++;
    }
    while (dindex < entriesLength) {
      entry = entries[dindex++];
      if (!(entry.key === key && entry.value === value)) append(this, entry.key, entry.value);
    }
  }, { enumerable: true, unsafe: true });
}


/***/ }),

/***/ 7566:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var defineBuiltIn = __webpack_require__(6840);
var uncurryThis = __webpack_require__(9504);
var toString = __webpack_require__(655);
var validateArgumentsLength = __webpack_require__(2812);

var $URLSearchParams = URLSearchParams;
var URLSearchParamsPrototype = $URLSearchParams.prototype;
var getAll = uncurryThis(URLSearchParamsPrototype.getAll);
var $has = uncurryThis(URLSearchParamsPrototype.has);
var params = new $URLSearchParams('a=1');

// `undefined` case is a Chromium 117 bug
// https://bugs.chromium.org/p/v8/issues/detail?id=14222
if (params.has('a', 2) || !params.has('a', undefined)) {
  defineBuiltIn(URLSearchParamsPrototype, 'has', function has(name /* , value */) {
    var length = arguments.length;
    var $value = length < 2 ? undefined : arguments[1];
    if (length && $value === undefined) return $has(this, name);
    var values = getAll(this, name); // also validates `this`
    validateArgumentsLength(length, 1);
    var value = toString($value);
    var index = 0;
    while (index < values.length) {
      if (values[index++] === value) return true;
    } return false;
  }, { enumerable: true, unsafe: true });
}


/***/ }),

/***/ 8721:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


var DESCRIPTORS = __webpack_require__(3724);
var uncurryThis = __webpack_require__(9504);
var defineBuiltInAccessor = __webpack_require__(2106);

var URLSearchParamsPrototype = URLSearchParams.prototype;
var forEach = uncurryThis(URLSearchParamsPrototype.forEach);

// `URLSearchParams.prototype.size` getter
// https://github.com/whatwg/url/pull/734
if (DESCRIPTORS && !('size' in URLSearchParamsPrototype)) {
  defineBuiltInAccessor(URLSearchParamsPrototype, 'size', {
    get: function size() {
      var count = 0;
      forEach(this, function () { count++; });
      return count;
    },
    configurable: true,
    enumerable: true
  });
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "";
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
!function() {
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  Alert: function() { return /* reexport */ Alert; },
  Anchor: function() { return /* reexport */ Anchor; },
  AnchorLink: function() { return /* reexport */ AnchorLink; },
  Avatar: function() { return /* reexport */ Avatar; },
  Badge: function() { return /* reexport */ Badge; },
  Breadcrumb: function() { return /* reexport */ Breadcrumb; },
  BreadcrumbItem: function() { return /* reexport */ BreadcrumbItem; },
  Button: function() { return /* reexport */ Button; },
  ButtonGroup: function() { return /* reexport */ ButtonGroup; },
  Calendar: function() { return /* reexport */ Calendar; },
  Card: function() { return /* reexport */ Card; },
  Carousel: function() { return /* reexport */ Carousel; },
  CarouselItem: function() { return /* reexport */ CarouselItem; },
  Checkbox: function() { return /* reexport */ Checkbox; },
  CheckboxButton: function() { return /* reexport */ CheckboxButton; },
  CheckboxGroup: function() { return /* reexport */ CheckboxGroup; },
  Col: function() { return /* reexport */ Col; },
  Collapse: function() { return /* reexport */ Collapse; },
  CollapsePane: function() { return /* reexport */ CollapsePane; },
  ColorPicker: function() { return /* reexport */ ColorPicker; },
  Countdown: function() { return /* reexport */ Countdown; },
  DatePanel: function() { return /* reexport */ DatePanel; },
  DatePicker: function() { return /* reexport */ DatePicker; },
  DateRangePicker: function() { return /* reexport */ DateRangePicker; },
  Drawer: function() { return /* reexport */ Drawer; },
  DrawerController: function() { return /* reexport */ DrawerController; },
  Empty: function() { return /* reexport */ Empty; },
  Form: function() { return /* reexport */ Form; },
  FormGather: function() { return /* reexport */ FormGather; },
  FormGroup: function() { return /* reexport */ FormGroup; },
  FormItem: function() { return /* reexport */ FormItem; },
  GLOBAL_EVENT_KEYS: function() { return /* reexport */ GLOBAL_EVENT_KEYS; },
  Icon: function() { return /* reexport */ Icon; },
  IconPicker: function() { return /* reexport */ IconPicker; },
  Image: function() { return /* reexport */ image_Image; },
  ImageGroup: function() { return /* reexport */ ImageGroup; },
  ImagePreview: function() { return /* reexport */ ImagePreview; },
  Input: function() { return /* reexport */ Input; },
  LayoutAside: function() { return /* reexport */ LayoutAside; },
  LayoutBody: function() { return /* reexport */ LayoutBody; },
  LayoutContainer: function() { return /* reexport */ LayoutContainer; },
  LayoutFooter: function() { return /* reexport */ LayoutFooter; },
  LayoutHeader: function() { return /* reexport */ LayoutHeader; },
  Link: function() { return /* reexport */ Link; },
  List: function() { return /* reexport */ List; },
  Loading: function() { return /* reexport */ Loading; },
  LoadingController: function() { return /* reexport */ LoadingController; },
  Menu: function() { return /* reexport */ Menu; },
  Modal: function() { return /* reexport */ Modal; },
  ModalController: function() { return /* reexport */ ModalController; },
  NoticeBar: function() { return /* reexport */ NoticeBar; },
  NumberInput: function() { return /* reexport */ NumberInput; },
  Optgroup: function() { return /* reexport */ Optgroup; },
  Option: function() { return /* reexport */ Option; },
  Pager: function() { return /* reexport */ Pager; },
  PasswordInput: function() { return /* reexport */ PasswordInput; },
  Print: function() { return /* reexport */ Print; },
  PrintPageBreak: function() { return /* reexport */ PrintPageBreak; },
  Pulldown: function() { return /* reexport */ Pulldown; },
  Radio: function() { return /* reexport */ Radio; },
  RadioButton: function() { return /* reexport */ RadioButton; },
  RadioGroup: function() { return /* reexport */ RadioGroup; },
  Rate: function() { return /* reexport */ Rate; },
  Result: function() { return /* reexport */ Result; },
  Row: function() { return /* reexport */ Row; },
  Select: function() { return /* reexport */ Select; },
  Slider: function() { return /* reexport */ Slider; },
  Split: function() { return /* reexport */ Split; },
  SplitPane: function() { return /* reexport */ SplitPane; },
  Steps: function() { return /* reexport */ Steps; },
  Switch: function() { return /* reexport */ Switch; },
  TabPane: function() { return /* reexport */ TabPane; },
  TableSelect: function() { return /* reexport */ TableSelect; },
  Tabs: function() { return /* reexport */ Tabs; },
  Tag: function() { return /* reexport */ Tag; },
  Text: function() { return /* reexport */ Text; },
  TextEllipsis: function() { return /* reexport */ TextEllipsis; },
  Textarea: function() { return /* reexport */ Textarea; },
  Tip: function() { return /* reexport */ Tip; },
  Tips: function() { return /* reexport */ Tips; },
  Tooltip: function() { return /* reexport */ Tooltip; },
  Tree: function() { return /* reexport */ Tree; },
  TreeSelect: function() { return /* reexport */ TreeSelect; },
  Upload: function() { return /* reexport */ Upload; },
  VxeAlert: function() { return /* reexport */ VxeAlert; },
  VxeAnchor: function() { return /* reexport */ VxeAnchor; },
  VxeAnchorLink: function() { return /* reexport */ VxeAnchorLink; },
  VxeAvatar: function() { return /* reexport */ VxeAvatar; },
  VxeBadge: function() { return /* reexport */ VxeBadge; },
  VxeBreadcrumb: function() { return /* reexport */ VxeBreadcrumb; },
  VxeBreadcrumbItem: function() { return /* reexport */ VxeBreadcrumbItem; },
  VxeButton: function() { return /* reexport */ VxeButton; },
  VxeButtonGroup: function() { return /* reexport */ VxeButtonGroup; },
  VxeCalendar: function() { return /* reexport */ VxeCalendar; },
  VxeCard: function() { return /* reexport */ VxeCard; },
  VxeCarousel: function() { return /* reexport */ VxeCarousel; },
  VxeCarouselItem: function() { return /* reexport */ VxeCarouselItem; },
  VxeCheckbox: function() { return /* reexport */ VxeCheckbox; },
  VxeCheckboxButton: function() { return /* reexport */ VxeCheckboxButton; },
  VxeCheckboxGroup: function() { return /* reexport */ VxeCheckboxGroup; },
  VxeCol: function() { return /* reexport */ VxeCol; },
  VxeCollapse: function() { return /* reexport */ VxeCollapse; },
  VxeCollapsePane: function() { return /* reexport */ VxeCollapsePane; },
  VxeColorPicker: function() { return /* reexport */ VxeColorPicker; },
  VxeCore: function() { return /* reexport */ VxeCore; },
  VxeCountdown: function() { return /* reexport */ VxeCountdown; },
  VxeDatePanel: function() { return /* reexport */ VxeDatePanel; },
  VxeDatePicker: function() { return /* reexport */ VxeDatePicker; },
  VxeDateRangePicker: function() { return /* reexport */ VxeDateRangePicker; },
  VxeDrawer: function() { return /* reexport */ VxeDrawer; },
  VxeEmpty: function() { return /* reexport */ VxeEmpty; },
  VxeForm: function() { return /* reexport */ VxeForm; },
  VxeFormGather: function() { return /* reexport */ VxeFormGather; },
  VxeFormGroup: function() { return /* reexport */ VxeFormGroup; },
  VxeFormItem: function() { return /* reexport */ VxeFormItem; },
  VxeIcon: function() { return /* reexport */ VxeIcon; },
  VxeIconPicker: function() { return /* reexport */ VxeIconPicker; },
  VxeImage: function() { return /* reexport */ VxeImage; },
  VxeImageGroup: function() { return /* reexport */ VxeImageGroup; },
  VxeImagePreview: function() { return /* reexport */ VxeImagePreview; },
  VxeInput: function() { return /* reexport */ VxeInput; },
  VxeLayoutAside: function() { return /* reexport */ VxeLayoutAside; },
  VxeLayoutBody: function() { return /* reexport */ VxeLayoutBody; },
  VxeLayoutContainer: function() { return /* reexport */ VxeLayoutContainer; },
  VxeLayoutFooter: function() { return /* reexport */ VxeLayoutFooter; },
  VxeLayoutHeader: function() { return /* reexport */ VxeLayoutHeader; },
  VxeLink: function() { return /* reexport */ VxeLink; },
  VxeList: function() { return /* reexport */ VxeList; },
  VxeLoading: function() { return /* reexport */ VxeLoading; },
  VxeMenu: function() { return /* reexport */ VxeMenu; },
  VxeModal: function() { return /* reexport */ VxeModal; },
  VxeNoticeBar: function() { return /* reexport */ VxeNoticeBar; },
  VxeNumberInput: function() { return /* reexport */ VxeNumberInput; },
  VxeOptgroup: function() { return /* reexport */ VxeOptgroup; },
  VxeOption: function() { return /* reexport */ VxeOption; },
  VxePager: function() { return /* reexport */ VxePager; },
  VxePasswordInput: function() { return /* reexport */ VxePasswordInput; },
  VxePrint: function() { return /* reexport */ VxePrint; },
  VxePrintPageBreak: function() { return /* reexport */ VxePrintPageBreak; },
  VxePulldown: function() { return /* reexport */ VxePulldown; },
  VxeRadio: function() { return /* reexport */ VxeRadio; },
  VxeRadioButton: function() { return /* reexport */ VxeRadioButton; },
  VxeRadioGroup: function() { return /* reexport */ VxeRadioGroup; },
  VxeRate: function() { return /* reexport */ VxeRate; },
  VxeResult: function() { return /* reexport */ VxeResult; },
  VxeRow: function() { return /* reexport */ VxeRow; },
  VxeSelect: function() { return /* reexport */ VxeSelect; },
  VxeSlider: function() { return /* reexport */ VxeSlider; },
  VxeSplit: function() { return /* reexport */ VxeSplit; },
  VxeSplitPane: function() { return /* reexport */ VxeSplitPane; },
  VxeSteps: function() { return /* reexport */ VxeSteps; },
  VxeSwitch: function() { return /* reexport */ VxeSwitch; },
  VxeTabPane: function() { return /* reexport */ VxeTabPane; },
  VxeTableSelect: function() { return /* reexport */ VxeTableSelect; },
  VxeTabs: function() { return /* reexport */ VxeTabs; },
  VxeTag: function() { return /* reexport */ VxeTag; },
  VxeText: function() { return /* reexport */ VxeText; },
  VxeTextEllipsis: function() { return /* reexport */ VxeTextEllipsis; },
  VxeTextarea: function() { return /* reexport */ VxeTextarea; },
  VxeTip: function() { return /* reexport */ VxeTip; },
  VxeTooltip: function() { return /* reexport */ VxeTooltip; },
  VxeTree: function() { return /* reexport */ VxeTree; },
  VxeTreeSelect: function() { return /* reexport */ VxeTreeSelect; },
  VxeUI: function() { return /* reexport */ index_esm_VxeUI; },
  VxeUpload: function() { return /* reexport */ VxeUpload; },
  VxeWatermark: function() { return /* reexport */ VxeWatermark; },
  Watermark: function() { return /* reexport */ Watermark; },
  WatermarkController: function() { return /* reexport */ WatermarkController; },
  clipboard: function() { return /* reexport */ clipboard; },
  commands: function() { return /* reexport */ commands; },
  component: function() { return /* reexport */ component; },
  config: function() { return /* reexport */ config; },
  coreVersion: function() { return /* reexport */ coreVersion; },
  createEvent: function() { return /* reexport */ createEvent; },
  "default": function() { return /* binding */ entry_lib; },
  drawer: function() { return /* reexport */ components_drawer; },
  formats: function() { return /* reexport */ formats; },
  getComponent: function() { return /* reexport */ getComponent; },
  getConfig: function() { return /* reexport */ getConfig; },
  getI18n: function() { return /* reexport */ getI18n; },
  getIcon: function() { return /* reexport */ getIcon; },
  getLanguage: function() { return /* reexport */ getLanguage; },
  getTheme: function() { return /* reexport */ getTheme; },
  globalEvents: function() { return /* reexport */ globalEvents; },
  globalResize: function() { return /* reexport */ globalResize; },
  globalStore: function() { return /* reexport */ globalStore; },
  handleCheckInfo: function() { return /* reexport */ handleCheckInfo; },
  hasComponent: function() { return /* reexport */ hasComponent; },
  hasLanguage: function() { return /* reexport */ hasLanguage; },
  hooks: function() { return /* reexport */ hooks; },
  install: function() { return /* reexport */ install; },
  interceptor: function() { return /* reexport */ interceptor; },
  loading: function() { return /* reexport */ components_loading; },
  log: function() { return /* reexport */ log; },
  menus: function() { return /* reexport */ menus; },
  modal: function() { return /* reexport */ components_modal; },
  permission: function() { return /* reexport */ permission; },
  print: function() { return /* reexport */ components_print; },
  readFile: function() { return /* reexport */ readFile; },
  renderCustomIcon: function() { return /* reexport */ renderCustomIcon; },
  renderEmptyElement: function() { return /* reexport */ renderEmptyElement; },
  renderGlobalIcon: function() { return /* reexport */ renderGlobalIcon; },
  renderer: function() { return /* reexport */ renderer; },
  saveFile: function() { return /* reexport */ saveFile; },
  setConfig: function() { return /* reexport */ setConfig; },
  setI18n: function() { return /* reexport */ setI18n; },
  setIcon: function() { return /* reexport */ setIcon; },
  setLanguage: function() { return /* reexport */ setLanguage; },
  setTheme: function() { return /* reexport */ setTheme; },
  setup: function() { return /* reexport */ setup; },
  use: function() { return /* reexport */ use; },
  useFns: function() { return /* reexport */ useFns; },
  usePermission: function() { return /* reexport */ usePermission; },
  useSize: function() { return /* reexport */ useSize; },
  validators: function() { return /* reexport */ validators; },
  version: function() { return /* reexport */ ui_version; },
  watermark: function() { return /* reexport */ components_watermark; }
});

// NAMESPACE OBJECT: ./packages/components.ts
var components_namespaceObject = {};
__webpack_require__.r(components_namespaceObject);
__webpack_require__.d(components_namespaceObject, {
  Alert: function() { return Alert; },
  Anchor: function() { return Anchor; },
  AnchorLink: function() { return AnchorLink; },
  Avatar: function() { return Avatar; },
  Badge: function() { return Badge; },
  Breadcrumb: function() { return Breadcrumb; },
  BreadcrumbItem: function() { return BreadcrumbItem; },
  Button: function() { return Button; },
  ButtonGroup: function() { return ButtonGroup; },
  Calendar: function() { return Calendar; },
  Card: function() { return Card; },
  Carousel: function() { return Carousel; },
  CarouselItem: function() { return CarouselItem; },
  Checkbox: function() { return Checkbox; },
  CheckboxButton: function() { return CheckboxButton; },
  CheckboxGroup: function() { return CheckboxGroup; },
  Col: function() { return Col; },
  Collapse: function() { return Collapse; },
  CollapsePane: function() { return CollapsePane; },
  ColorPicker: function() { return ColorPicker; },
  Countdown: function() { return Countdown; },
  DatePanel: function() { return DatePanel; },
  DatePicker: function() { return DatePicker; },
  DateRangePicker: function() { return DateRangePicker; },
  Drawer: function() { return Drawer; },
  DrawerController: function() { return DrawerController; },
  Empty: function() { return Empty; },
  Form: function() { return Form; },
  FormGather: function() { return FormGather; },
  FormGroup: function() { return FormGroup; },
  FormItem: function() { return FormItem; },
  GLOBAL_EVENT_KEYS: function() { return GLOBAL_EVENT_KEYS; },
  Icon: function() { return Icon; },
  IconPicker: function() { return IconPicker; },
  Image: function() { return image_Image; },
  ImageGroup: function() { return ImageGroup; },
  ImagePreview: function() { return ImagePreview; },
  Input: function() { return Input; },
  LayoutAside: function() { return LayoutAside; },
  LayoutBody: function() { return LayoutBody; },
  LayoutContainer: function() { return LayoutContainer; },
  LayoutFooter: function() { return LayoutFooter; },
  LayoutHeader: function() { return LayoutHeader; },
  Link: function() { return Link; },
  List: function() { return List; },
  Loading: function() { return Loading; },
  LoadingController: function() { return LoadingController; },
  Menu: function() { return Menu; },
  Modal: function() { return Modal; },
  ModalController: function() { return ModalController; },
  NoticeBar: function() { return NoticeBar; },
  NumberInput: function() { return NumberInput; },
  Optgroup: function() { return Optgroup; },
  Option: function() { return Option; },
  Pager: function() { return Pager; },
  PasswordInput: function() { return PasswordInput; },
  Print: function() { return Print; },
  PrintPageBreak: function() { return PrintPageBreak; },
  Pulldown: function() { return Pulldown; },
  Radio: function() { return Radio; },
  RadioButton: function() { return RadioButton; },
  RadioGroup: function() { return RadioGroup; },
  Rate: function() { return Rate; },
  Result: function() { return Result; },
  Row: function() { return Row; },
  Select: function() { return Select; },
  Slider: function() { return Slider; },
  Split: function() { return Split; },
  SplitPane: function() { return SplitPane; },
  Steps: function() { return Steps; },
  Switch: function() { return Switch; },
  TabPane: function() { return TabPane; },
  TableSelect: function() { return TableSelect; },
  Tabs: function() { return Tabs; },
  Tag: function() { return Tag; },
  Text: function() { return Text; },
  TextEllipsis: function() { return TextEllipsis; },
  Textarea: function() { return Textarea; },
  Tip: function() { return Tip; },
  Tips: function() { return Tips; },
  Tooltip: function() { return Tooltip; },
  Tree: function() { return Tree; },
  TreeSelect: function() { return TreeSelect; },
  Upload: function() { return Upload; },
  VxeAlert: function() { return VxeAlert; },
  VxeAnchor: function() { return VxeAnchor; },
  VxeAnchorLink: function() { return VxeAnchorLink; },
  VxeAvatar: function() { return VxeAvatar; },
  VxeBadge: function() { return VxeBadge; },
  VxeBreadcrumb: function() { return VxeBreadcrumb; },
  VxeBreadcrumbItem: function() { return VxeBreadcrumbItem; },
  VxeButton: function() { return VxeButton; },
  VxeButtonGroup: function() { return VxeButtonGroup; },
  VxeCalendar: function() { return VxeCalendar; },
  VxeCard: function() { return VxeCard; },
  VxeCarousel: function() { return VxeCarousel; },
  VxeCarouselItem: function() { return VxeCarouselItem; },
  VxeCheckbox: function() { return VxeCheckbox; },
  VxeCheckboxButton: function() { return VxeCheckboxButton; },
  VxeCheckboxGroup: function() { return VxeCheckboxGroup; },
  VxeCol: function() { return VxeCol; },
  VxeCollapse: function() { return VxeCollapse; },
  VxeCollapsePane: function() { return VxeCollapsePane; },
  VxeColorPicker: function() { return VxeColorPicker; },
  VxeCore: function() { return VxeCore; },
  VxeCountdown: function() { return VxeCountdown; },
  VxeDatePanel: function() { return VxeDatePanel; },
  VxeDatePicker: function() { return VxeDatePicker; },
  VxeDateRangePicker: function() { return VxeDateRangePicker; },
  VxeDrawer: function() { return VxeDrawer; },
  VxeEmpty: function() { return VxeEmpty; },
  VxeForm: function() { return VxeForm; },
  VxeFormGather: function() { return VxeFormGather; },
  VxeFormGroup: function() { return VxeFormGroup; },
  VxeFormItem: function() { return VxeFormItem; },
  VxeIcon: function() { return VxeIcon; },
  VxeIconPicker: function() { return VxeIconPicker; },
  VxeImage: function() { return VxeImage; },
  VxeImageGroup: function() { return VxeImageGroup; },
  VxeImagePreview: function() { return VxeImagePreview; },
  VxeInput: function() { return VxeInput; },
  VxeLayoutAside: function() { return VxeLayoutAside; },
  VxeLayoutBody: function() { return VxeLayoutBody; },
  VxeLayoutContainer: function() { return VxeLayoutContainer; },
  VxeLayoutFooter: function() { return VxeLayoutFooter; },
  VxeLayoutHeader: function() { return VxeLayoutHeader; },
  VxeLink: function() { return VxeLink; },
  VxeList: function() { return VxeList; },
  VxeLoading: function() { return VxeLoading; },
  VxeMenu: function() { return VxeMenu; },
  VxeModal: function() { return VxeModal; },
  VxeNoticeBar: function() { return VxeNoticeBar; },
  VxeNumberInput: function() { return VxeNumberInput; },
  VxeOptgroup: function() { return VxeOptgroup; },
  VxeOption: function() { return VxeOption; },
  VxePager: function() { return VxePager; },
  VxePasswordInput: function() { return VxePasswordInput; },
  VxePrint: function() { return VxePrint; },
  VxePrintPageBreak: function() { return VxePrintPageBreak; },
  VxePulldown: function() { return VxePulldown; },
  VxeRadio: function() { return VxeRadio; },
  VxeRadioButton: function() { return VxeRadioButton; },
  VxeRadioGroup: function() { return VxeRadioGroup; },
  VxeRate: function() { return VxeRate; },
  VxeResult: function() { return VxeResult; },
  VxeRow: function() { return VxeRow; },
  VxeSelect: function() { return VxeSelect; },
  VxeSlider: function() { return VxeSlider; },
  VxeSplit: function() { return VxeSplit; },
  VxeSplitPane: function() { return VxeSplitPane; },
  VxeSteps: function() { return VxeSteps; },
  VxeSwitch: function() { return VxeSwitch; },
  VxeTabPane: function() { return VxeTabPane; },
  VxeTableSelect: function() { return VxeTableSelect; },
  VxeTabs: function() { return VxeTabs; },
  VxeTag: function() { return VxeTag; },
  VxeText: function() { return VxeText; },
  VxeTextEllipsis: function() { return VxeTextEllipsis; },
  VxeTextarea: function() { return VxeTextarea; },
  VxeTip: function() { return VxeTip; },
  VxeTooltip: function() { return VxeTooltip; },
  VxeTree: function() { return VxeTree; },
  VxeTreeSelect: function() { return VxeTreeSelect; },
  VxeUI: function() { return index_esm_VxeUI; },
  VxeUpload: function() { return VxeUpload; },
  VxeWatermark: function() { return VxeWatermark; },
  Watermark: function() { return Watermark; },
  WatermarkController: function() { return WatermarkController; },
  clipboard: function() { return clipboard; },
  commands: function() { return commands; },
  component: function() { return component; },
  config: function() { return config; },
  coreVersion: function() { return coreVersion; },
  createEvent: function() { return createEvent; },
  drawer: function() { return components_drawer; },
  formats: function() { return formats; },
  getComponent: function() { return getComponent; },
  getConfig: function() { return getConfig; },
  getI18n: function() { return getI18n; },
  getIcon: function() { return getIcon; },
  getLanguage: function() { return getLanguage; },
  getTheme: function() { return getTheme; },
  globalEvents: function() { return globalEvents; },
  globalResize: function() { return globalResize; },
  globalStore: function() { return globalStore; },
  handleCheckInfo: function() { return handleCheckInfo; },
  hasComponent: function() { return hasComponent; },
  hasLanguage: function() { return hasLanguage; },
  hooks: function() { return hooks; },
  install: function() { return install; },
  interceptor: function() { return interceptor; },
  loading: function() { return components_loading; },
  log: function() { return log; },
  menus: function() { return menus; },
  modal: function() { return components_modal; },
  permission: function() { return permission; },
  print: function() { return components_print; },
  readFile: function() { return readFile; },
  renderCustomIcon: function() { return renderCustomIcon; },
  renderEmptyElement: function() { return renderEmptyElement; },
  renderGlobalIcon: function() { return renderGlobalIcon; },
  renderer: function() { return renderer; },
  saveFile: function() { return saveFile; },
  setConfig: function() { return setConfig; },
  setI18n: function() { return setI18n; },
  setIcon: function() { return setIcon; },
  setLanguage: function() { return setLanguage; },
  setTheme: function() { return setTheme; },
  setup: function() { return setup; },
  use: function() { return use; },
  useFns: function() { return useFns; },
  usePermission: function() { return usePermission; },
  useSize: function() { return useSize; },
  validators: function() { return validators; },
  version: function() { return ui_version; },
  watermark: function() { return components_watermark; }
});

;// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
/* eslint-disable no-var */
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (false) { var getCurrentScript; }

  var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (src) {
    __webpack_require__.p = src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.push.js
var es_array_push = __webpack_require__(4114);
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/core.js
const coreVersion = "4.2.9";
const VxeCore = {
  coreVersion,
  uiVersion: '',
  tableVersion: '',
  designVersion: '',
  ganttVersion: ''
};
// EXTERNAL MODULE: external {"commonjs":"vue","commonjs2":"vue","root":"Vue"}
var external_commonjs_vue_commonjs2_vue_root_Vue_ = __webpack_require__(9274);
// EXTERNAL MODULE: external {"root":"XEUtils","commonjs":"xe-utils","commonjs2":"xe-utils","amd":"xe-utils"}
var external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_ = __webpack_require__(8871);
var external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default = /*#__PURE__*/__webpack_require__.n(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_);
;// CONCATENATED MODULE: ./node_modules/dom-zindex/es/index.esm.js
var winDom = null;
var bodyEl = null;
var storeEl = null;
var storeId = 'z-index-manage';
var styleEl = null;
var styleId = 'z-index-style';
var storeMainKey = 'm';
var storeSubKey = 's';
var storeData = {
  m: 1000,
  s: 1000
};
function getDocument() {
  if (!winDom) {
    if (typeof document !== 'undefined') {
      winDom = document;
    }
  }
  return winDom;
}
function getBody() {
  if (winDom && !bodyEl) {
    bodyEl = winDom.body || winDom.getElementsByTagName('body')[0];
  }
  return bodyEl;
}
function getDomMaxZIndex() {
  var max = 0;
  var dom = getDocument();
  if (dom) {
    var body = getBody();
    if (body) {
      var allElem = body.getElementsByTagName('*');
      for (var i = 0; i < allElem.length; i++) {
        var elem = allElem[i];
        if (elem && elem.style && elem.nodeType === 1) {
          var zIndex = elem.style.zIndex;
          if (zIndex && /^\d+$/.test(zIndex)) {
            max = Math.max(max, Number(zIndex));
          }
        }
      }
    }
  }
  return max;
}
function getStyle() {
  if (!styleEl) {
    var dom = getDocument();
    if (dom) {
      styleEl = dom.getElementById(styleId);
      if (!styleEl) {
        styleEl = dom.createElement('style');
        styleEl.id = styleId;
        dom.getElementsByTagName('head')[0].appendChild(styleEl);
      }
    }
  }
  return styleEl;
}
function updateVar() {
  var styEl = getStyle();
  if (styEl) {
    var prefixes = '--dom-';
    var propKey = '-z-index';
    styEl.innerHTML = ':root{' + prefixes + 'main' + propKey + ':' + getCurrent() + ';' + prefixes + 'sub' + propKey + ':' + getSubCurrent() + '}';
  }
}
function getStoreDom() {
  if (!storeEl) {
    var dom = getDocument();
    if (dom) {
      storeEl = dom.getElementById(storeId);
      if (!storeEl) {
        var body = getBody();
        if (body) {
          storeEl = dom.createElement('div');
          storeEl.id = storeId;
          storeEl.style.display = 'none';
          body.appendChild(storeEl);
          setCurrent(storeData.m);
          setSubCurrent(storeData.s);
        }
      }
    }
  }
  return storeEl;
}
function createSetHandle(key) {
  return function (value) {
    if (value) {
      value = Number(value);
      storeData[key] = value;
      var el = getStoreDom();
      if (el) {
        if (el.dataset) {
          el.dataset[key] = value + '';
        } else {
          el.setAttribute('data-' + key, value + '');
        }
      }
    }
    updateVar();
    return storeData[key];
  };
}
var setCurrent = createSetHandle(storeMainKey);
function createGetHandle(key, nextMethod) {
  return function getCurrent(currZindex) {
    var zIndex;
    var el = getStoreDom();
    if (el) {
      var domVal = el.dataset ? el.dataset[key] : el.getAttribute('data-' + key);
      if (domVal) {
        zIndex = Number(domVal);
      }
    }
    if (!zIndex) {
      zIndex = storeData[key];
    }
    if (currZindex) {
      if (Number(currZindex) < zIndex) {
        return nextMethod();
      }
      return currZindex;
    }
    return zIndex;
  };
}
var getCurrent = createGetHandle(storeMainKey, getNext);
function getNext() {
  return setCurrent(getCurrent() + 1);
}
var setSubCurrent = createSetHandle(storeSubKey);
var _getSubCurrent = createGetHandle(storeSubKey, getSubNext);
function getSubCurrent() {
  return getCurrent() + _getSubCurrent();
}
function getSubNext() {
  setSubCurrent(_getSubCurrent() + 1);
  return getSubCurrent();
}
/**
 * Web common z-index style management
 */
var DomZIndex = {
  setCurrent: setCurrent,
  getCurrent: getCurrent,
  getNext: getNext,
  setSubCurrent: setSubCurrent,
  getSubCurrent: getSubCurrent,
  getSubNext: getSubNext,
  getMax: getDomMaxZIndex
};
updateVar();
/* harmony default export */ var index_esm = (DomZIndex);
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/configStore.js
const globalConfigStore = {
  size: '',
  version: 1,
  zIndex: 999,
  resizeInterval: 500
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/themeStore.js
const themeConfigStore = {
  theme: ''
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/theme.js


function setTheme(name) {
  const theme = !name || name === 'default' ? 'light' : name;
  themeConfigStore.theme = theme;
  if (typeof document !== 'undefined') {
    const documentElement = document.documentElement;
    if (documentElement) {
      documentElement.setAttribute('data-vxe-ui-theme', theme);
    }
  }
  return VxeCore;
}
function getTheme() {
  return themeConfigStore.theme;
}
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/config.js





/**
* 全局参数设置
*/
function setConfig(options) {
  if (options) {
    if (options.zIndex) {
      index_esm.setCurrent(options.zIndex);
    }
    if (options.theme) {
      setTheme(options.theme);
    }
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge(globalConfigStore, options);
  }
  return VxeCore;
}
/**
* 获取全局参数
*/
function getConfig(key, defaultValue) {
  return arguments.length ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(globalConfigStore, key, defaultValue) : globalConfigStore;
}
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/dataStore.js
const globalStore = {};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/iconStore.js
const iconConfigStore = {};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/vm.js

function getSlotVNs(vns) {
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(vns)) {
    return vns;
  }
  return vns ? [vns] : [];
}
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/icon.js





function setIcon(options) {
  if (options) {
    Object.assign(iconConfigStore, options);
  }
  return VxeCore;
}
function getIcon(key) {
  return arguments.length ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(iconConfigStore, key) : iconConfigStore;
}
function renderGlobalIcon(name) {
  const icon = getIcon(name);
  return renderCustomIcon(icon, name);
}
function renderCustomIcon(icon, name) {
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(icon)) {
    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {}, getSlotVNs(icon({
      name
    })));
  }
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
    class: icon
  });
}
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/event.js


const GLOBAL_EVENT_KEYS = {
  F2: 'F2',
  ESCAPE: 'Escape',
  ENTER: 'Enter',
  TAB: 'Tab',
  DELETE: 'Delete',
  BACKSPACE: 'Backspace',
  SPACEBAR: ' ',
  CONTEXT_MENU: 'ContextMenu',
  ARROW_UP: 'ArrowUp',
  ARROW_DOWN: 'ArrowDown',
  ARROW_LEFT: 'ArrowLeft',
  ARROW_RIGHT: 'ArrowRight',
  PAGE_UP: 'PageUp',
  PAGE_DOWN: 'PageDown',
  Control: 'Control',
  R: 'R',
  P: 'P',
  Z: 'Z',
  X: 'X',
  C: 'C',
  V: 'V',
  M: 'M'
};
const browse = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().browse();
const convertEventKeys = {
  ' ': 'Spacebar',
  Apps: GLOBAL_EVENT_KEYS.CONTEXT_MENU,
  Del: GLOBAL_EVENT_KEYS.DELETE,
  Up: GLOBAL_EVENT_KEYS.ARROW_UP,
  Down: GLOBAL_EVENT_KEYS.ARROW_DOWN,
  Left: GLOBAL_EVENT_KEYS.ARROW_LEFT,
  Right: GLOBAL_EVENT_KEYS.ARROW_RIGHT
};
// 监听全局事件
const wheelName = browse.firefox ? 'DOMMouseScroll' : 'mousewheel';
const eventStore = [];
function triggerEvent(evnt) {
  const isWheel = evnt.type === wheelName;
  eventStore.forEach(({
    type,
    cb
  }) => {
    // 如果被取消冒泡，不再执行
    if (!evnt.cancelBubble) {
      if (type === evnt.type || isWheel && type === 'mousewheel') {
        cb(evnt);
      }
    }
  });
}
class VxeComponentEvent {
  constructor(evnt, params1, params2) {
    Object.defineProperty(this, "$event", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "type", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ''
    });
    Object.defineProperty(this, "key", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ''
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ''
    });
    this.$event = evnt;
    if (evnt) {
      if (evnt.type) {
        this.type = evnt.type;
      }
      if (evnt.key) {
        this.key = evnt.key;
      }
      if (evnt.code) {
        this.code = evnt.code;
      }
    }
    Object.assign(this, params1);
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(params2, (val, key) => {
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(val)) {
        let rest = null;
        let isRun = false;
        Object.defineProperty(this, key, {
          get() {
            if (!isRun) {
              isRun = true;
              rest = val();
            }
            return rest;
          }
        });
      } else {
        this[key] = val;
      }
    });
  }
  stopPropagation() {
    const evnt = this.$event;
    if (evnt) {
      evnt.stopPropagation();
    }
  }
  preventDefault() {
    const evnt = this.$event;
    if (evnt) {
      evnt.preventDefault();
    }
  }
}
const createEvent = (evnt, params1, params2) => {
  if (evnt instanceof VxeComponentEvent) {
    evnt = evnt.$event;
  }
  return new VxeComponentEvent(evnt, params1, params2);
};
const globalEvents = {
  on(comp, type, cb) {
    eventStore.push({
      comp,
      type,
      cb
    });
  },
  off(comp, type) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(eventStore, item => item.comp === comp && item.type === type);
  },
  hasKey(evnt, targetKey) {
    const {
      key
    } = evnt;
    targetKey = targetKey.toLowerCase();
    return key ? targetKey === key.toLowerCase() || !!(convertEventKeys[key] && convertEventKeys[key].toLowerCase() === targetKey) : false;
  }
};
if (browse.isDoc) {
  if (!browse.msie) {
    window.addEventListener('copy', triggerEvent, false);
    window.addEventListener('cut', triggerEvent, false);
    window.addEventListener('paste', triggerEvent, false);
  }
  document.addEventListener('keydown', triggerEvent, false);
  document.addEventListener('contextmenu', triggerEvent, false);
  window.addEventListener('mousedown', triggerEvent, false);
  window.addEventListener('blur', triggerEvent, false);
  window.addEventListener('resize', triggerEvent, false);
  window.addEventListener(wheelName, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().throttle(triggerEvent, 100, {
    leading: true,
    trailing: false
  }), {
    passive: true,
    capture: false
  });
}
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/resize.js



/**
 * 监听 resize 事件
 * 如果项目中已使用了 resize-observer-polyfill，那么只需要将方法定义全局，该组件就会自动使用
 */
let resizeTimeout;
/* eslint-disable no-use-before-define */
const resize_eventStore = [];
const defaultInterval = 500;
function eventHandle() {
  if (resize_eventStore.length) {
    resize_eventStore.forEach(item => {
      item.tarList.forEach(observer => {
        const {
          target,
          width,
          heighe
        } = observer;
        const clientWidth = target.clientWidth;
        const clientHeight = target.clientHeight;
        const rWidth = clientWidth && width !== clientWidth;
        const rHeight = clientHeight && heighe !== clientHeight;
        if (rWidth || rHeight) {
          observer.width = clientWidth;
          observer.heighe = clientHeight;
          setTimeout(item.callback);
        }
      });
    });
    /* eslint-disable @typescript-eslint/no-use-before-define */
    eventListener();
  }
}
function eventListener() {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(eventHandle, globalConfigStore.resizeInterval || defaultInterval);
}
class XEResizeObserver {
  constructor(callback) {
    Object.defineProperty(this, "tarList", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "callback", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.callback = callback;
  }
  observe(target) {
    if (target) {
      const {
        tarList
      } = this;
      if (!tarList.some(observer => observer.target === target)) {
        tarList.push({
          target,
          width: target.clientWidth,
          heighe: target.clientHeight
        });
      }
      if (!resize_eventStore.length) {
        eventListener();
      }
      if (!resize_eventStore.some(item => item === this)) {
        resize_eventStore.push(this);
      }
    }
  }
  unobserve(target) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(resize_eventStore, item => item.tarList.some(observer => observer.target === target));
  }
  disconnect() {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(resize_eventStore, item => item === this);
  }
}
const globalResize = {
  create(callback) {
    if (window.ResizeObserver) {
      return new window.ResizeObserver(callback);
    }
    return new XEResizeObserver(callback);
  }
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/i18nStore.js

const i18nConfigStore = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
  language: '',
  langMaps: {}
});
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/i18n.js




let checkInstall = false;
let cacheMaps = {};
function getI18n(key, args) {
  const {
    langMaps,
    language
  } = i18nConfigStore;
  const {
    i18n
  } = globalConfigStore;
  if (i18n) {
    return `${i18n(key, args) || ''}`;
  }
  if (!checkInstall) {
    if (!langMaps[language]) {
      console.error(`[vxe core] 语言包未安装。Language not installed. https://${VxeCore.uiVersion ? 'vxeui.com' : 'vxetable.cn'}/#/start/i18n`);
    }
    checkInstall = true;
  }
  if (!args && cacheMaps[key]) {
    return cacheMaps[key];
  }
  const i18nLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFormatString(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(langMaps[language], key, key), args);
  if (!args) {
    cacheMaps[key] = i18nLabel;
  }
  return i18nLabel;
}
function setLanguage(locale) {
  const {
    language
  } = i18nConfigStore;
  const targetlang = locale || 'zh-CN';
  if (language !== targetlang) {
    i18nConfigStore.language = targetlang;
    cacheMaps = {};
  }
  return VxeCore;
}
function setI18n(locale, data) {
  i18nConfigStore.langMaps[locale] = Object.assign({}, data);
  return VxeCore;
}
function hasLanguage(language) {
  const {
    langMaps
  } = i18nConfigStore;
  return !!langMaps[language];
}
function getLanguage() {
  const {
    language
  } = i18nConfigStore;
  return language;
}
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/log.js

function createLog(type, name) {
  return function (key, args) {
    const msg = `[vxe ${name || ''}] ${getI18n(key, args)}`;
    console[type](msg);
    return msg;
  };
}
const version = "4.2.9";
const log = {
  create: createLog,
  warn: createLog('warn', `v${version}`),
  err: createLog('error', `v${version}`)
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/renderer.js


/**
 * 内置的组件渲染
 */
const renderMap = {};
/**
 * 全局渲染器
 */
const renderer = {
  mixin(opts) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(opts, (options, name) => renderer.add(name, options));
    return renderer;
  },
  get(name) {
    return renderMap[name] || null;
  },
  add(name, options) {
    if (name && options) {
      const renders = renderMap[name];
      if (renders) {
        // 检测是否覆盖
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (val, key) => {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(renders[key]) && renders[key] !== val) {
            log.warn('vxe.error.coverProp', [`Renderer.${name}`, key]);
          }
        });
        Object.assign(renders, options);
      } else {
        renderMap[name] = options;
      }
    }
    return renderer;
  },
  forEach(callback) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(renderMap, callback);
    return renderer;
  },
  delete(name) {
    delete renderMap[name];
    return renderer;
  }
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/store.js


/**
 * 创建数据仓库
 */
class Store {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, options) {
    const conf = this.store[name];
    // 检测是否覆盖
    const confKeys = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(conf);
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (item, key) => {
      if (confKeys.includes(key)) {
        log.warn('vxe.error.coverProp', [name, key]);
      }
    });
    this.store[name] = conf ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge(conf, options) : options;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(this.store, callback);
  }
}
/* harmony default export */ var store = (Store);
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/validators.js

const validators = new store();
Object.assign(validators, {
  _name: 'Validators'
});
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/menus.js


class VXEMenusStore {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    // 兼容
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(render)) {
      log.warn('vxe.error.delProp', ['menus -> callback', 'menuMethod']);
      render = {
        menuMethod: render
      };
    }
    // 检测是否覆盖
    const confKeys = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(conf);
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(render, (item, key) => {
      if (confKeys.includes(key)) {
        log.warn('vxe.error.coverProp', [name, key]);
      }
    });
    this.store[name] = conf ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(this.store, callback);
  }
}
const menus = new VXEMenusStore();
Object.assign(menus, {
  _name: 'Menus'
});
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/formats.js


class VXEFormatsStore {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    // 兼容
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(render)) {
      log.warn('vxe.error.delProp', ['formats -> callback', 'cellFormatMethod']);
      render = {
        cellFormatMethod: render
      };
    }
    // 检测是否覆盖
    const confKeys = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(conf);
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(render, (item, key) => {
      if (confKeys.includes(key)) {
        log.warn('vxe.error.coverProp', [name, key]);
      }
    });
    this.store[name] = conf ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(this.store, callback);
  }
}
const formats = new VXEFormatsStore();
Object.assign(formats, {
  _name: 'Formats'
});
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/commands.js


class VXECommandsStore {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    // 兼容
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(render)) {
      log.warn('vxe.error.delProp', ['commands -> callback', 'commandMethod']);
      render = {
        commandMethod: render
      };
    }
    // 检测是否覆盖
    const confKeys = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(conf);
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(render, (item, key) => {
      if (confKeys.includes(key)) {
        log.warn('vxe.error.coverProp', [name, key]);
      }
    });
    this.store[name] = conf ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(this.store, callback);
  }
}
const commands = new VXECommandsStore();
Object.assign(commands, {
  _name: 'Commands'
});
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/interceptor.js



const storeMap = {};
const interceptor = {
  mixin(options) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(options, (render, type) => {
      interceptor.add(type, render);
    });
    return interceptor;
  },
  get(type) {
    return storeMap[type] || [];
  },
  add(type, render) {
    // 兼容
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(render)) {
      //   log.warn('vxe.error.delProp', ['interceptor -> callback', 'tableInterceptorMethod'])
      render = {
        tableInterceptorMethod: render
      };
    }
    const callback = render.tableInterceptorMethod;
    if (callback) {
      let eList = storeMap[type];
      if (!eList) {
        eList = storeMap[type] = [];
      }
      // 检测重复
      if (eList.indexOf(callback) > -1) {
        log.warn('vxe.error.coverProp', ['Interceptor', type]);
      }
      eList.push(callback);
    }
    return interceptor;
  },
  delete(type, render) {
    const eList = storeMap[type];
    if (eList) {
      // 兼容
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(render)) {
        render = {
          tableInterceptorMethod: render
        };
      }
      const callback = render ? render.tableInterceptorMethod : null;
      if (callback) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(eList, fn => fn === callback);
      } else {
        delete storeMap[type];
      }
    }
  }
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/clipboard.js

let copyElem;
const clipStore = {
  text: '',
  html: ''
};
function handleText(text) {
  if (!copyElem) {
    copyElem = document.createElement('textarea');
    copyElem.id = '$VxeCopy';
    const styles = copyElem.style;
    styles.width = '48px';
    styles.height = '24px';
    styles.position = 'fixed';
    styles.zIndex = '0';
    styles.left = '-500px';
    styles.top = '-500px';
    document.body.appendChild(copyElem);
  }
  copyElem.value = text;
}
const clipboard = {
  getStore() {
    return clipStore;
  },
  setStore(data) {
    Object.assign(clipStore, data || {});
  },
  /**
   * 复制内容到剪贴板
   *
   * @param {String} content Text 内容
   */
  copy(content) {
    let result = false;
    try {
      const text = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content);
      handleText(text);
      copyElem.select();
      copyElem.setSelectionRange(0, copyElem.value.length);
      result = document.execCommand('copy');
      copyElem.blur();
      clipStore.text = text;
      clipStore.html = '';
    } catch (e) {}
    return result;
  },
  getText() {
    return clipStore.text || '';
  }
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/permission.js


function handleCheckInfo(permissionCode, permissionMethod) {
  let checkVisible = true;
  let checkDisabled = false;
  const checkMethod = permissionMethod || globalConfigStore.permissionMethod;
  if (permissionCode && checkMethod) {
    checkVisible = false;
    checkDisabled = true;
    let vDone = false;
    let dDone = false;
    // 或 使用 | 隔开：任意一个为可视，则可视；任意一个禁用，则禁用
    const codeList = String(permissionCode).split('|');
    for (let i = 0; i < codeList.length; i++) {
      const code = codeList[i];
      let visible = true;
      let disabled = false;
      const rest = checkMethod({
        code
      });
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(rest)) {
        visible = rest;
      } else if (rest) {
        visible = !!rest.visible;
        disabled = !!rest.disabled;
      }
      if (!disabled && !dDone) {
        dDone = true;
        checkDisabled = disabled;
      }
      if (visible && !vDone) {
        vDone = true;
        checkVisible = visible;
      }
      if (vDone && dDone) {
        break;
      }
    }
  }
  const info = {
    code: permissionCode,
    visible: checkVisible,
    disabled: checkDisabled
  };
  return info;
}
const permission = {
  getCheckInfo(code) {
    return handleCheckInfo(code);
  },
  checkVisible(code) {
    const permissionInfo = handleCheckInfo(code);
    return permissionInfo.visible;
  },
  checkDisable(code) {
    const permissionInfo = handleCheckInfo(code);
    return permissionInfo.disabled;
  }
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/hooks.js

const hooks = new store();
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/src/useFns.js


function useSize(props) {
  // 组件尺寸上下文
  const xeSizeInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeSizeInfo', null);
  const computeSize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    return props.size || (xeSizeInfo ? xeSizeInfo.value : null);
  });
  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('xeSizeInfo', computeSize);
  return {
    computeSize
  };
}
function usePermission(props) {
  const computePermissionInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
    return handleCheckInfo(props.permissionCode, props.permissionMethod);
  });
  return {
    computePermissionInfo
  };
}
const useFns = {
  useSize,
  usePermission
};
;// CONCATENATED MODULE: ./node_modules/@vxe-ui/core/es/index.esm.js






















const installedPlugins = [];
function use(Plugin, options) {
  if (Plugin && Plugin.install) {
    if (installedPlugins.indexOf(Plugin) === -1) {
      Plugin.install(index_esm_VxeUI, options);
      installedPlugins.push(Plugin);
    }
  }
  return index_esm_VxeUI;
}
const components = {};
function getComponent(name) {
  return components[name] || null;
}
function hasComponent(name) {
  return !!components[name];
}
function component(comp) {
  if (comp && comp.name) {
    components[comp.name] = comp;
    components[external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().kebabCase(comp.name)] = comp;
  }
}
function renderEmptyElement() {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
}
const index_esm_VxeUI = Object.assign(VxeCore, {
  renderEmptyElement,
  setTheme: setTheme,
  getTheme: getTheme,
  setConfig: setConfig,
  getConfig: getConfig,
  setIcon: setIcon,
  getIcon: getIcon,
  renderGlobalIcon: renderGlobalIcon,
  renderCustomIcon: renderCustomIcon,
  setLanguage: setLanguage,
  hasLanguage: hasLanguage,
  getLanguage: getLanguage,
  setI18n: setI18n,
  getI18n: getI18n,
  globalEvents: globalEvents,
  GLOBAL_EVENT_KEYS: GLOBAL_EVENT_KEYS,
  createEvent: createEvent,
  globalResize: globalResize,
  renderer: renderer,
  validators: validators,
  menus: menus,
  formats: formats,
  commands: commands,
  interceptor: interceptor,
  clipboard: clipboard,
  log: log,
  permission: permission,
  globalStore: globalStore,
  hooks: hooks,
  component,
  getComponent,
  hasComponent,
  useFns: useFns,
  use
});
setTheme();



















/* harmony default export */ var es_index_esm = ((/* unused pure expression or super */ null && (index_esm_VxeUI)));
;// CONCATENATED MODULE: ./packages/ui/src/comp.ts

const defineVxeComponent = external_commonjs_vue_commonjs2_vue_root_Vue_.defineComponent;
;// CONCATENATED MODULE: ./packages/dynamics/index.ts



let dynamicContainerElem;
const dynamicStore = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
  modals: [],
  drawers: [],
  globalLoading: null,
  globalWatermark: null
});
/**
 * 动态组件
 */
const VxeDynamics = defineVxeComponent({
  setup() {
    const VxeUIModalComponent = index_esm_VxeUI.getComponent('vxe-modal');
    const VxeUIDrawerComponent = index_esm_VxeUI.getComponent('vxe-drawer');
    const VxeUILoadingComponent = index_esm_VxeUI.getComponent('vxe-loading');
    const VxeUIWatermarkComponent = index_esm_VxeUI.getComponent('vxe-watermark');
    return () => {
      const {
        modals,
        drawers,
        globalWatermark,
        globalLoading
      } = dynamicStore;
      return [modals.length ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 1,
        class: 'vxe-dynamics--modal'
      }, modals.map(item => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIModalComponent, item))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), drawers.length ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 2,
        class: 'vxe-dynamics--drawer'
      }, drawers.map(item => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIDrawerComponent, item))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), globalWatermark ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUIWatermarkComponent, globalWatermark) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), globalLoading ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeUILoadingComponent, globalLoading) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()];
    };
  }
});
const dynamicApp = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createApp)(VxeDynamics);
function checkDynamic() {
  if (!dynamicContainerElem) {
    dynamicContainerElem = document.createElement('div');
    dynamicContainerElem.className = 'vxe-dynamics';
    document.body.appendChild(dynamicContainerElem);
    dynamicApp.mount(dynamicContainerElem);
  }
}
;// CONCATENATED MODULE: ./packages/ui/src/log.ts

const log_version = `ui v${"4.8.18"}`;
const warnLog = log.create('warn', log_version);
const errLog = log.create('error', log_version);
;// CONCATENATED MODULE: ./packages/ui/index.ts



const ui_version = "4.8.18";
index_esm_VxeUI.uiVersion = ui_version;
index_esm_VxeUI.dynamicApp = dynamicApp;
function config(options) {
  warnLog('vxe.error.delFunc', ['config', 'setConfig']);
  return setConfig(options);
}
function setup(options) {
  warnLog('vxe.error.delFunc', ['setup', 'setConfig']);
  return setConfig(options);
}
index_esm_VxeUI.config = config;
index_esm_VxeUI.setup = setup;
setConfig({
  alert: {},
  anchor: {},
  anchorLink: {},
  avatar: {},
  badge: {},
  breadcrumb: {
    separator: '/'
  },
  breadcrumbItem: {},
  button: {
    trigger: 'hover',
    prefixTooltip: {
      enterable: true
    },
    suffixTooltip: {
      enterable: true
    }
  },
  buttonGroup: {},
  calendar: {
    minDate: new Date(1900, 0, 1),
    maxDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1
  },
  card: {
    border: true,
    padding: true
  },
  carousel: {
    height: 200,
    loop: true,
    interval: 5000
  },
  carouselItem: {},
  checkbox: {},
  checkboxButton: {},
  checkboxGroup: {},
  col: {},
  collapse: {
    padding: true,
    expandConfig: {
      showIcon: true
    }
  },
  collapsePane: {},
  countdown: {},
  colorPicker: {
    type: 'rgb',
    clearable: true,
    showAlpha: true,
    clickToCopy: true,
    showColorExtractor: true,
    showQuick: true
  },
  datePanel: {
    // parseFormat: 'yyyy-MM-dd HH:mm:ss.SSS',
    // labelFormat: '',
    // valueFormat: '',
    startDate: new Date(1900, 0, 1),
    endDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1
  },
  datePicker: {
    // size: null,
    // transfer: false,
    shortcutConfig: {
      // position: 'left',
      align: 'left',
      mode: 'text',
      autoClose: true
    },
    startDay: 1,
    selectDay: 1,
    autoClose: true,
    showClearButton: null,
    showConfirmButton: null
  },
  dateRangePicker: {
    // size: null,
    // transfer: false,
    shortcutConfig: {
      // position: 'left',
      align: 'left',
      mode: 'text',
      autoClose: true
    },
    startDay: 1,
    selectDay: 1,
    separator: ' ~ ',
    autoClose: true,
    showClearButton: null,
    showConfirmButton: null
  },
  drawer: {
    // size: null,
    position: 'right',
    showHeader: true,
    lockView: true,
    mask: true,
    showTitleOverflow: true,
    showClose: true,
    padding: true,
    cancelClosable: true,
    confirmClosable: true
  },
  empty: {},
  form: {
    // preventSubmit: false,
    // size: null,
    // colon: false,
    validConfig: {
      showMessage: true,
      autoPos: true,
      theme: 'beautify'
    },
    tooltipConfig: {
      enterable: true
    },
    titleAsterisk: true,
    titleOverflow: false,
    padding: true
  },
  formDesign: {
    height: 400,
    showHeader: true,
    showPc: true
  },
  formGather: {},
  formGroup: {},
  formItem: {},
  formView: {},
  icon: {},
  iconPicker: {
    icons: ['home', 'company', 'comment', 'setting', 'send', 'envelope', 'envelope-open', 'bell', 'search', 'print', 'pc', 'goods', 'chart-line', 'edit', 'delete', 'save', 'folder', 'microphone', 'flag', 'link', 'location', 'sunny', 'rmb', 'usd', 'user', 'add-user', 'add-users', 'star', 'unlock', 'time', 'text', 'feedback', 'calendar', 'association-form', 'cloud-download', 'cloud-upload', 'file', 'subtable', 'chart-bar-x', 'chart-bar-y', 'chart-line', 'chart-pie', 'chart-radar']
  },
  image: {
    showPreview: true,
    showPrintButton: true,
    maskClosable: true
  },
  imageGroup: {
    showPreview: true,
    showPrintButton: true
  },
  imagePreview: {
    showPrintButton: true
  },
  input: {
    // size: null,
    // transfer: false
    // parseFormat: 'yyyy-MM-dd HH:mm:ss.SSS',
    // labelFormat: '',
    // valueFormat: '',
    startDate: new Date(1900, 0, 1),
    endDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1,
    digits: 2,
    controls: true
  },
  layoutAside: {},
  layoutBody: {},
  layoutContainer: {},
  layoutFooter: {},
  layoutHeader: {},
  link: {
    underline: true
  },
  listDesign: {
    height: 400,
    showPc: true
  },
  listView: {},
  list: {
    // size: null,
    virtualYConfig: {
      enabled: true,
      gt: 100
      // oSize: 0
    }
  },
  loading: {
    showIcon: true,
    showText: true
  },
  menu: {},
  modal: {
    // size: null,
    top: 16,
    showHeader: true,
    minWidth: 340,
    minHeight: 140,
    lockView: true,
    mask: true,
    duration: 3000,
    marginSize: 0,
    dblclickZoom: true,
    showTitleOverflow: true,
    animat: true,
    showClose: true,
    padding: true,
    draggable: true,
    showConfirmButton: null,
    cancelClosable: true,
    confirmClosable: true,
    zoomConfig: {
      minimizeMaxSize: 10,
      minimizeVerticalOffset: {
        top: -24,
        left: 0
      },
      minimizeHorizontalOffset: {
        top: 0,
        left: 32
      }
    },
    // remember: false,
    // storage: false,
    storageKey: 'VXE_MODAL_POSITION'
  },
  noticeBar: {},
  numberInput: {
    // size: null,
    // transfer: false
    digits: 2,
    autoFill: true,
    controlConfig: {
      enabled: true,
      layout: 'right',
      showButton: true,
      isWheel: true,
      isArrow: true
    }
  },
  optgroup: {},
  option: {},
  pager: {
    pageSizePlacement: 'top'
    // size: null,
    // autoHidden: false,
    // perfect: true,
    // pageSize: 10,
    // pagerCount: 7,
    // pageSizes: [10, 15, 20, 50, 100],
    // layouts: ['PrevJump', 'PrevPage', 'Jump', 'PageCount', 'NextPage', 'NextJump', 'Sizes', 'Total']
  },
  print: {
    pageStyle: {}
  },
  passwordInput: {
    controls: true
  },
  printPageBreak: {},
  pulldown: {
    destroyOnClose: true
  },
  radio: {
    strict: true
  },
  radioButton: {
    strict: true
  },
  radioGroup: {
    strict: true
  },
  rate: {},
  result: {},
  row: {},
  select: {
    multiCharOverflow: 8,
    remoteConfig: {
      enabled: true,
      autoLoad: true
    },
    virtualYConfig: {
      enabled: true,
      gt: 50,
      oSize: 2
    }
  },
  split: {
    resize: true,
    itemConfig: {
      minWidth: 40,
      minHeight: 40
    }
  },
  splitPane: {},
  slider: {
    max: 100,
    min: 0
  },
  steps: {},
  switch: {},
  tabPane: {},
  tableSelect: {
    gridConfig: {
      showOverflow: true,
      showHeaderOverflow: true,
      showFooterOverflow: true,
      rowConfig: {
        isHover: true
      },
      virtualXConfig: {
        enabled: true,
        gt: 0
      },
      virtualYConfig: {
        enabled: true,
        gt: 0
      }
    }
  },
  tabs: {},
  tag: {},
  textEllipsis: {
    underline: true
  },
  text: {},
  textarea: {
    resize: 'none'
  },
  tip: {},
  tooltip: {
    // size: null,
    // enterable: false,
    trigger: 'hover',
    theme: 'dark',
    enterDelay: 500,
    leaveDelay: 300,
    isArrow: true
  },
  tree: {
    // autoResize: false,
    indent: 20,
    minHeight: 60,
    radioConfig: {
      strict: true
    },
    virtualYConfig: {
      enabled: true,
      gt: 50,
      oSize: 2
    }
  },
  treeSelect: {
    autoClose: true,
    virtualYConfig: {
      enabled: true,
      gt: 0,
      oSize: 2
    },
    treeConfig: {
      maxHeight: 300,
      radioConfig: {},
      checkboxConfig: {},
      filterConfig: {
        autoExpandAll: true
      }
    }
  },
  upload: {
    mode: 'all',
    imageTypes: ['jpg', 'jpeg', 'png', 'gif'],
    showList: true,
    showUploadButton: true,
    showButtonText: true,
    showRemoveButton: true,
    showButtonIcon: true,
    showPreview: true,
    dragToUpload: true,
    // imageConfig: {},
    showLimitSize: true,
    showLimitCount: true,
    autoSubmit: true,
    maxSimultaneousUploads: 5
  },
  watermark: {
    rotate: -30,
    gap: [100, 100]
  },
  table: {},
  colgroup: {},
  column: {},
  toolbar: {},
  grid: {},
  gantt: {}
});
const iconPrefix = 'vxe-icon-';
setIcon({
  // loading
  LOADING: iconPrefix + 'spinner roll vxe-loading--default-icon',
  // button
  BUTTON_DROPDOWN: iconPrefix + 'arrow-down',
  BUTTON_LOADING: iconPrefix + 'spinner roll',
  BUTTON_TOOLTIP_ICON: iconPrefix + 'question-circle-fill',
  // menu
  MENU_ITEM_EXPAND_OPEN: iconPrefix + 'arrow-down rotate180',
  MENU_ITEM_EXPAND_CLOSE: iconPrefix + 'arrow-down',
  // select
  SELECT_LOADED: iconPrefix + 'spinner roll',
  SELECT_OPEN: iconPrefix + 'caret-down rotate180',
  SELECT_CLOSE: iconPrefix + 'caret-down',
  SELECT_ADD_OPTION: iconPrefix + 'add',
  // icon-picker
  ICON_PICKER_OPEN: iconPrefix + 'caret-down rotate180',
  ICON_PICKER_CLOSE: iconPrefix + 'caret-down',
  // pager
  PAGER_HOME: iconPrefix + 'home-page',
  PAGER_END: iconPrefix + 'end-page',
  PAGER_JUMP_PREV: iconPrefix + 'arrow-double-left',
  PAGER_JUMP_NEXT: iconPrefix + 'arrow-double-right',
  PAGER_PREV_PAGE: iconPrefix + 'arrow-left',
  PAGER_NEXT_PAGE: iconPrefix + 'arrow-right',
  PAGER_JUMP_MORE: iconPrefix + 'ellipsis-h',
  // radio
  RADIO_CHECKED: iconPrefix + 'radio-checked-fill',
  RADIO_UNCHECKED: iconPrefix + 'radio-unchecked',
  RADIO_DISABLED_UNCHECKED: iconPrefix + 'radio-unchecked-fill',
  // checkbox
  CHECKBOX_INDETERMINATE: iconPrefix + 'checkbox-indeterminate-fill',
  CHECKBOX_CHECKED: iconPrefix + 'checkbox-checked-fill',
  CHECKBOX_UNCHECKED: iconPrefix + 'checkbox-unchecked',
  CHECKBOX_DISABLED_UNCHECKED: iconPrefix + 'checkbox-unchecked-fill',
  // input
  INPUT_CLEAR: iconPrefix + 'error-circle-fill',
  INPUT_SEARCH: iconPrefix + 'search',
  INPUT_PLUS_NUM: iconPrefix + 'caret-up',
  INPUT_MINUS_NUM: iconPrefix + 'caret-down',
  // number-picker
  NUMBER_INPUT_MINUS_NUM: iconPrefix + 'minus',
  NUMBER_INPUT_PLUS_NUM: iconPrefix + 'add',
  // date-picker
  DATE_PICKER_DATE: iconPrefix + 'calendar',
  // password-input
  PASSWORD_INPUT_SHOW_PWD: iconPrefix + 'eye-fill-close',
  PASSWORD_INPUT_HIDE_PWD: iconPrefix + 'eye-fill',
  // modal
  MODAL_ZOOM_MIN: iconPrefix + 'minus',
  MODAL_ZOOM_REVERT: iconPrefix + 'recover',
  MODAL_ZOOM_IN: iconPrefix + 'square',
  MODAL_ZOOM_OUT: iconPrefix + 'maximize',
  MODAL_CLOSE: iconPrefix + 'close',
  MODAL_INFO: iconPrefix + 'info-circle-fill',
  MODAL_SUCCESS: iconPrefix + 'success-circle-fill',
  MODAL_WARNING: iconPrefix + 'warning-circle-fill',
  MODAL_ERROR: iconPrefix + 'error-circle-fill',
  MODAL_QUESTION: iconPrefix + 'question-circle-fill',
  MODAL_LOADING: iconPrefix + 'spinner roll',
  // drawer
  DRAWER_CLOSE: iconPrefix + 'close',
  // form
  FORM_PREFIX: iconPrefix + 'question-circle-fill',
  FORM_SUFFIX: iconPrefix + 'question-circle-fill',
  FORM_FOLDING: iconPrefix + 'arrow-up rotate180',
  FORM_UNFOLDING: iconPrefix + 'arrow-up',
  // form-design
  FORM_DESIGN_STYLE_SETTING: iconPrefix + 'layout',
  FORM_DESIGN_PROPS_PC: iconPrefix + 'pc',
  FORM_DESIGN_PROPS_MOBILE: iconPrefix + 'mobile',
  FORM_DESIGN_PROPS_ADD: iconPrefix + 'add',
  FORM_DESIGN_PROPS_EDIT: iconPrefix + 'edit',
  FORM_DESIGN_WIDGET_ADD: iconPrefix + 'square-plus-fill',
  FORM_DESIGN_WIDGET_COPY: iconPrefix + 'copy',
  FORM_DESIGN_WIDGET_DELETE: iconPrefix + 'delete',
  FORM_DESIGN_WIDGET_SWAP_LR: iconPrefix + 'swap',
  FORM_DESIGN_WIDGET_OPTION_DELETE: iconPrefix + 'delete',
  FORM_DESIGN_WIDGET_OPTION_EXPAND_OPEN: iconPrefix + 'square-plus',
  FORM_DESIGN_WIDGET_OPTION_EXPAND_CLOSE: iconPrefix + 'square-minus',
  // list-design
  LIST_DESIGN_FIELD_SETTING: iconPrefix + 'custom-column',
  LIST_DESIGN_LIST_SETTING: iconPrefix + 'menu',
  LIST_DESIGN_LIST_SETTING_SEARCH_DELETE: iconPrefix + 'delete',
  LIST_DESIGN_LIST_SETTING_ACTIVE_DELETE: iconPrefix + 'delete',
  // upload
  UPLOAD_FILE_ERROR: iconPrefix + 'warning-circle-fill',
  UPLOAD_FILE_ADD: iconPrefix + 'upload',
  UPLOAD_FILE_REMOVE: iconPrefix + 'delete',
  UPLOAD_FILE_DOWNLOAD: iconPrefix + 'download',
  UPLOAD_IMAGE_UPLOAD: iconPrefix + 'upload',
  UPLOAD_IMAGE_RE_UPLOAD: iconPrefix + 'repeat',
  UPLOAD_IMAGE_ADD: iconPrefix + 'add',
  UPLOAD_IMAGE_REMOVE: iconPrefix + 'close',
  UPLOAD_LOADING: iconPrefix + 'spinner roll vxe-loading--default-icon',
  UPLOAD_FILE_TYPE_DEFAULT: iconPrefix + 'file',
  UPLOAD_FILE_TYPE_XLSX: iconPrefix + 'file-excel',
  UPLOAD_FILE_TYPE_XLS: iconPrefix + 'file-excel',
  UPLOAD_FILE_TYPE_PDF: iconPrefix + 'file-pdf',
  UPLOAD_FILE_TYPE_PNG: iconPrefix + 'file-image',
  UPLOAD_FILE_TYPE_GIF: iconPrefix + 'file-image',
  UPLOAD_FILE_TYPE_JPG: iconPrefix + 'file-image',
  UPLOAD_FILE_TYPE_JPEG: iconPrefix + 'file-image',
  UPLOAD_FILE_TYPE_MD: iconPrefix + 'file-markdown',
  UPLOAD_FILE_TYPE_PPD: iconPrefix + 'file-ppt',
  UPLOAD_FILE_TYPE_DOCX: iconPrefix + 'file-word',
  UPLOAD_FILE_TYPE_DOC: iconPrefix + 'file-word',
  UPLOAD_FILE_TYPE_ZIP: iconPrefix + 'file-zip',
  UPLOAD_FILE_TYPE_TXT: iconPrefix + 'file-txt',
  // image-preview
  IMAGE_PREVIEW_CLOSE: iconPrefix + 'close',
  IMAGE_PREVIEW_PREVIOUS: iconPrefix + 'arrow-left',
  IMAGE_PREVIEW_NEXT: iconPrefix + 'arrow-right',
  IMAGE_PREVIEW_PCT_FULL: iconPrefix + 'pct-full',
  IMAGE_PREVIEW_PCT_1_1: iconPrefix + 'pct-1-1',
  IMAGE_PREVIEW_ZOOM_OUT: iconPrefix + 'search-zoom-out',
  IMAGE_PREVIEW_ZOOM_IN: iconPrefix + 'search-zoom-in',
  IMAGE_PREVIEW_ROTATE_LEFT: iconPrefix + 'rotate-left',
  IMAGE_PREVIEW_ROTATE_RIGHT: iconPrefix + 'rotate-right',
  IMAGE_PREVIEW_PRINT: iconPrefix + 'print',
  IMAGE_PREVIEW_DOWNLOAD: iconPrefix + 'download',
  // alert
  ALERT_CLOSE: iconPrefix + 'close',
  ALERT_INFO: iconPrefix + 'info-circle-fill',
  ALERT_SUCCESS: iconPrefix + 'success-circle-fill',
  ALERT_WARNING: iconPrefix + 'warning-circle-fill',
  ALERT_ERROR: iconPrefix + 'error-circle-fill',
  // tree
  TREE_NODE_OPEN: iconPrefix + 'caret-right rotate90',
  TREE_NODE_CLOSE: iconPrefix + 'caret-right',
  TREE_NODE_LOADED: iconPrefix + 'spinner roll',
  // tree-select
  TREE_SELECT_LOADED: iconPrefix + 'spinner roll',
  TREE_SELECT_OPEN: iconPrefix + 'caret-down rotate180',
  TREE_SELECT_CLOSE: iconPrefix + 'caret-down',
  // table-select
  TABLE_SELECT_LOADED: iconPrefix + 'spinner roll',
  TABLE_SELECT_OPEN: iconPrefix + 'caret-down rotate180',
  TABLE_SELECT_CLOSE: iconPrefix + 'caret-down',
  // tabs
  TABS_TAB_BUTTON_TOP: iconPrefix + 'arrow-up',
  TABS_TAB_BUTTON_BOTTOM: iconPrefix + 'arrow-down',
  TABS_TAB_BUTTON_LEFT: iconPrefix + 'arrow-left',
  TABS_TAB_BUTTON_RIGHT: iconPrefix + 'arrow-right',
  TABS_TAB_CLOSE: iconPrefix + 'close',
  TABS_TAB_REFRESH: iconPrefix + 'refresh',
  TABS_TAB_REFRESH_LOADING: iconPrefix + 'refresh roll',
  // text
  TEXT_COPY: iconPrefix + 'copy',
  TEXT_LOADING: iconPrefix + 'spinner roll',
  // carousel
  CAROUSEL_HORIZONTAL_PREVIOUS: iconPrefix + 'arrow-left',
  CAROUSEL_HORIZONTAL_NEXT: iconPrefix + 'arrow-right',
  CAROUSEL_VERTICAL_PREVIOUS: iconPrefix + 'arrow-up',
  CAROUSEL_VERTICAL_NEXT: iconPrefix + 'arrow-down',
  // collapse
  COLLAPSE_OPEN: iconPrefix + 'arrow-right rotate90',
  COLLAPSE_CLOSE: iconPrefix + 'arrow-right',
  // empty
  EMPTY_DEFAULT: iconPrefix + 'empty',
  // result
  RESULT_INFO: iconPrefix + 'info-circle-fill',
  RESULT_SUCCESS: iconPrefix + 'success-circle-fill',
  RESULT_WARNING: iconPrefix + 'warning-circle-fill',
  RESULT_ERROR: iconPrefix + 'error-circle-fill',
  RESULT_QUESTION: iconPrefix + 'question-circle-fill',
  RESULT_LOADING: iconPrefix + 'spinner roll',
  // rate
  RATE_CHECKED: iconPrefix + 'star-fill',
  RATE_UNCHECKED: iconPrefix + 'star',
  // color-picker
  COLOR_PICKER_COLOR_COPY: iconPrefix + 'copy',
  COLOR_PICKER_EYE_DROPPER: iconPrefix + 'dropper',
  COLOR_PICKER_TPTY_OPEN: iconPrefix + 'arrow-down rotate180',
  COLOR_PICKER_TPTY_CLOSE: iconPrefix + 'arrow-down',
  // split
  SPLIT_TOP_ACTION: iconPrefix + 'arrow-up',
  SPLIT_BOTTOM_ACTION: iconPrefix + 'arrow-down',
  SPLIT_LEFT_ACTION: iconPrefix + 'arrow-left',
  SPLIT_RIGHT_ACTION: iconPrefix + 'arrow-right'
});

/* harmony default export */ var ui = ((/* unused pure expression or super */ null && (VxeUI)));
;// CONCATENATED MODULE: ./packages/language/zh-CN.ts
/* harmony default export */ var zh_CN = ({
  vxe: {
    base: {
      pleaseInput: '请输入',
      pleaseSelect: '请选择',
      comma: '，',
      fullStop: '。'
    },
    loading: {
      text: '加载中...'
    },
    error: {
      downErr: '下载失败',
      errLargeData: '当绑定的数据量过大时，应该请使用 {0}，否则可能会出现卡顿',
      groupFixed: '如果使用分组表头，冻结列必须按组设置',
      groupMouseRange: '分组表头与 "{0}" 不能同时使用，这可能会出现错误',
      groupTag: '分组列头应该使用 "{0}" 而不是 "{1}"，这可能会出现错误',
      scrollErrProp: '启用虚拟滚动后不支持该参数 "{0}"',
      errConflicts: '参数 "{0}" 与 "{1}" 有冲突',
      modelConflicts: '绑定的字段值 "{0}" 与 "{1}" 存在冲突，将会出现错误',
      notSupportProp: '当启用参数 "{0}" 时不支持 "{1}"，应该为 "{2}"，否则将会出现错误',
      reqSupportProp: '当使用 "{0}" 时，应该设置 "{1}"，否则可能会出现错误',
      notConflictProp: '当使用 "{0}" 时，应该设置 "{1}"，否则可能会存在功能冲突',
      unableInsert: '无法插入到指定位置，请检查参数是否正确',
      useErr: '安装 "{0}" 模块时发生错误，可能顺序不正确，依赖的模块需要在 Table 之前安装',
      barUnableLink: '工具栏无法关联表格',
      expandContent: '展开行的插槽应该是 "content"，请检查是否正确',
      reqComp: '缺少 "{0}" 组件，请检查是否正确安装。 https://vxeui.com/#/start/useGlobal',
      reqModule: '缺少 "{0}" 模块',
      reqProp: '缺少必要的 "{0}" 参数，这可能会导致出现错误',
      emptyProp: '参数 "{0}" 不允许为空',
      errProp: '不支持的参数 "{0}"，可能为 "{1}"',
      colRepet: 'column.{0}="{1}" 重复了，这可能会导致某些功能无法使用',
      notFunc: '方法 "{0}" 不存在',
      errFunc: '参数 "{0}" 不是一个方法',
      notValidators: '全局校验 "{0}" 不存在',
      notFormats: '全局格式化 "{0}" 不存在',
      notCommands: '全局指令 "{0}" 不存在',
      notSlot: '插槽 "{0}" 不存在',
      noTree: '树结构不支持 "{0}"',
      noGroup: '数据分组后不支持 "{0}"',
      notProp: '不支持的参数 "{0}"',
      checkProp: '当数据量过大时可能会导致复选框卡顿，建议设置参数 "{0}" 提升渲染速度',
      coverProp: '"{0}" 的参数 "{1}" 重复定义，这可能会出现错误',
      uniField: '字段名 "{0}" 重复定义，这可能会出现错误',
      repeatKey: '主键重复 {0}="{1}"，这可能会出现错误',
      delFunc: '方法 "{0}" 已废弃，请使用 "{1}"',
      delProp: '参数 "{0}" 已废弃，请使用 "{1}"',
      delEvent: '事件 "{0}" 已废弃，请使用 "{1}"',
      removeProp: '参数 "{0}" 已废弃，不建议使用，这可能会导致出现错误',
      errFormat: '全局的格式化内容应该使用 "VXETable.formats" 定义，挂载 "formatter={0}" 的方式已不建议使用',
      notType: '不支持的文件类型 "{0}"',
      notExp: '该浏览器不支持导入/导出功能',
      impFields: '导入失败，请检查字段名和数据格式是否正确',
      treeNotImp: '树表格不支持导入',
      treeCrossDrag: '只能拖拽第一层级',
      treeDragChild: '父级不能拖拽到自己的子级中',
      reqPlugin: '扩展插件未安装 "{1}" https://vxeui.com/other{0}/#/{1}/install',
      errMaxRow: '超过支持的最大数据量 {0} 行，这可能会导致出现错误',
      useNew: '不建议使用 {0}，请使用 {1}',
      errorVersion: '版本不匹配，当前版本 {0}，最低支持版本为 {1}'
    },
    table: {
      emptyText: '暂无数据',
      allTitle: '全选/取消',
      seqTitle: '序号',
      actionTitle: '操作',
      confirmFilter: '筛选',
      resetFilter: '重置',
      allFilter: '全部',
      sortAsc: '升序：最低到最高',
      sortDesc: '降序：最高到最低',
      filter: '对所选的列启用筛选',
      impSuccess: '成功导入 {0} 条记录',
      expLoading: '正在导出中',
      expSuccess: '导出成功',
      expError: '导出失败',
      expFilename: '导出_{0}',
      expOriginFilename: '导出_源_{0}',
      customTitle: '列设置',
      customAll: '全部',
      customConfirm: '确认',
      customClose: '关闭',
      customCancel: '取消',
      customRestore: '恢复默认',
      maxFixedCol: '最大冻结列的数量不能超过 {0} 个',
      maxGroupCol: '最大分组字段的数量不能超过 {0} 个',
      dragTip: '移动：{0}',
      resizeColTip: '宽：{0} 像素',
      resizeRowTip: '高：{0} 像素',
      rowGroupContentTotal: '{0}（{1}）'
    },
    grid: {
      selectOneRecord: '请至少选择一条记录！',
      deleteSelectRecord: '您确定要删除所选记录吗？',
      removeSelectRecord: '您确定要移除所选记录吗？',
      dataUnchanged: '数据未改动！',
      delSuccess: '成功删除所选记录！',
      saveSuccess: '保存成功！',
      operError: '发生错误，操作失败！'
    },
    select: {
      clear: '清除',
      allChecked: '全选',
      total: '{0} / {1}',
      search: '搜索',
      loadingText: '加载中',
      emptyText: '暂无数据',
      maxSize: '最大可选择的数量不能超过 {0} 个',
      overSizeErr: '已超出最大可选数量 {0} 个，超出部分将被忽略！',
      searchEmpty: '未匹配到数据！'
    },
    tree: {
      searchEmpty: '未匹配到数据！'
    },
    treeSelect: {
      clearChecked: '清除',
      allChecked: '全选',
      allExpand: '全部展开',
      clearExpand: '全部收起',
      total: '已选 {0}',
      search: '搜索',
      emptyText: '暂无数据'
    },
    pager: {
      goto: '前往',
      gotoTitle: '页数',
      pagesize: '{0}条/页',
      total: '共 {0} 条记录',
      pageClassifier: '页',
      homePage: '首页',
      homePageTitle: '首页',
      prevPage: '上一页',
      prevPageTitle: '上一页',
      nextPage: '下一页',
      nextPageTitle: '下一页',
      prevJump: '向上跳页',
      prevJumpTitle: '向上跳页',
      nextJump: '向下跳页',
      nextJumpTitle: '向下跳页',
      endPage: '末页',
      endPageTitle: '末页'
    },
    alert: {
      title: '系统提示'
    },
    button: {
      confirm: '确认',
      cancel: '取消',
      clear: '清除'
    },
    filter: {
      search: '搜索'
    },
    custom: {
      cstmTitle: '列设置',
      cstmRestore: '恢复默认',
      cstmCancel: '取消',
      cstmConfirm: '确定',
      cstmConfirmRestore: '请确认是否恢复成默认列配置？',
      cstmDragTarget: '移动：{0}',
      setting: {
        colSort: '排序',
        sortHelpTip: '点击并拖动图标可以调整顺序',
        colTitle: '列标题',
        colResizable: '列宽（像素）',
        colVisible: '是否显示',
        colFixed: '冻结列',
        colFixedMax: '冻结列（最多 {0} 列）',
        fixedLeft: '左侧',
        fixedUnset: '不设置',
        fixedRight: '右侧'
      }
    },
    import: {
      modes: {
        covering: '覆盖方式（直接覆盖表格数据）',
        insert: '底部追加（在表格的底部追加新数据）',
        insertTop: '顶部追加（在表格的顶部追加新数据）',
        insertBottom: '底部追加（在表格的底部追加新数据）'
      },
      impTitle: '导入数据',
      impFile: '文件名',
      impSelect: '选择文件',
      impType: '文件类型',
      impOpts: '参数设置',
      impMode: '导入模式',
      impConfirm: '导入',
      impCancel: '取消'
    },
    export: {
      types: {
        csv: 'CSV (逗号分隔)(*.csv)',
        html: '网页(*.html)',
        xml: 'XML 数据(*.xml)',
        txt: '文本文件(制表符分隔)(*.txt)',
        xls: 'Excel 97-2003 工作簿(*.xls)',
        xlsx: 'Excel 工作簿(*.xlsx)',
        pdf: 'PDF (*.pdf)'
      },
      modes: {
        empty: '空数据',
        current: '当前数据（当前页的数据）',
        selected: '选中数据（当前页选中的数据）',
        all: '全量数据（包括所有分页的数据）'
      },
      printTitle: '打印数据',
      expTitle: '导出数据',
      expName: '文件名',
      expNamePlaceholder: '请输入文件名',
      expSheetName: '标题',
      expSheetNamePlaceholder: '请输入标题',
      expType: '保存类型',
      expMode: '选择数据',
      expCurrentColumn: '全部字段',
      expColumn: '选择字段',
      expOpts: '参数设置',
      expOptHeader: '表头',
      expHeaderTitle: '是否需要表头',
      expOptFooter: '表尾',
      expFooterTitle: '是否需要表尾',
      expOptColgroup: '分组表头',
      expOptTitle: '列标题',
      expTitleTitle: '是否为列标题，否则显示为列的字段名',
      expColgroupTitle: '如果存在，则支持带有分组结构的表头',
      expOptMerge: '合并',
      expMergeTitle: '如果存在，则支持带有合并结构的单元格',
      expOptAllExpand: '展开树',
      expAllExpandTitle: '如果存在，则支持将带有层级结构的数据全部展开',
      expOptUseStyle: '样式',
      expUseStyleTitle: '如果存在，则支持带样式的单元格',
      expOptOriginal: '源数据',
      expOriginalTitle: '如果为源数据，则支持导入到表格中',
      expPrint: '打印',
      expConfirm: '导出',
      expCancel: '取消'
    },
    modal: {
      errTitle: '错误提示',
      zoomMin: '最小化',
      zoomIn: '最大化',
      zoomOut: '还原',
      close: '关闭',
      miniMaxSize: '最小化窗口的数量不能超过 {0} 个',
      footPropErr: 'show-footer 仅用于启用表尾，需配合 show-confirm-button | show-cancel-button | 插槽使用'
    },
    drawer: {
      close: '关闭'
    },
    form: {
      folding: '收起',
      unfolding: '展开'
    },
    toolbar: {
      import: '导入',
      export: '导出',
      print: '打印',
      refresh: '刷新',
      zoomIn: '全屏',
      zoomOut: '还原',
      custom: '列设置',
      customAll: '全部',
      customConfirm: '确认',
      customRestore: '重置',
      fixedLeft: '冻结在左侧',
      fixedRight: '冻结在右侧',
      cancelFixed: '取消冻结列'
    },
    datePicker: {
      yearTitle: '{0} 年'
    },
    dateRangePicker: {
      pleaseRange: '请选择开始日期与结束日期'
    },
    input: {
      date: {
        m1: '01 月',
        m2: '02 月',
        m3: '03 月',
        m4: '04 月',
        m5: '05 月',
        m6: '06 月',
        m7: '07 月',
        m8: '08 月',
        m9: '09 月',
        m10: '10 月',
        m11: '11 月',
        m12: '12 月',
        quarterLabel: '{0} 年',
        monthLabel: '{0} 年',
        dayLabel: '{0} 年 {1}',
        labelFormat: {
          date: 'yyyy-MM-dd',
          time: 'HH:mm:ss',
          datetime: 'yyyy-MM-dd HH:mm:ss',
          week: 'yyyy 年第 WW 周',
          month: 'yyyy-MM',
          quarter: 'yyyy 年第 q 季度',
          year: 'yyyy'
        },
        weeks: {
          w: '',
          w0: '周日',
          w1: '周一',
          w2: '周二',
          w3: '周三',
          w4: '周四',
          w5: '周五',
          w6: '周六'
        },
        months: {
          m0: '一月',
          m1: '二月',
          m2: '三月',
          m3: '四月',
          m4: '五月',
          m5: '六月',
          m6: '七月',
          m7: '八月',
          m8: '九月',
          m9: '十月',
          m10: '十一月',
          m11: '十二月'
        },
        quarters: {
          q1: '第一季度',
          q2: '第二季度',
          q3: '第三季度',
          q4: '第四季度'
        }
      }
    },
    numberInput: {
      currencySymbol: '¥'
    },
    imagePreview: {
      popupTitle: '预览',
      operBtn: {
        zoomOut: '缩小',
        zoomIn: '放大',
        pctFull: '等比例缩放',
        pct11: '显示原始尺寸',
        rotateLeft: '向左旋转',
        rotateRight: '向右旋转',
        print: '点击打印图片',
        download: '点击下载图片'
      }
    },
    upload: {
      fileBtnText: '点击或拖拽上传',
      imgBtnText: '点击或拖拽上传',
      dragPlaceholder: '请把文件拖放到这个区域即可上传',
      imgSizeHint: '单张{0}',
      imgCountHint: '最多{0}张',
      fileTypeHint: '支持 {0} 文件类型',
      fileSizeHint: '单个文件大小不超过{0}',
      fileCountHint: '最多可上传{0}个文件',
      uploadTypeErr: '文件类型不匹配！',
      overCountErr: '最多只能选择{0}个文件！',
      overCountExtraErr: '已超出最大数量{0}个，超出的{1}个文件将被忽略！',
      overSizeErr: '文件大小最大不能超过{0}！',
      manualUpload: '点击上传',
      reUpload: '重新上传',
      uploadProgress: '上传中 {0}%',
      uploadErr: '上传失败',
      uploadSuccess: '上传成功',
      moreBtnText: '更多（{0}）',
      viewItemTitle: '点击查看',
      morePopup: {
        readTitle: '查看列表',
        imageTitle: '上传图片',
        fileTitle: '上传文件'
      }
    },
    empty: {
      defText: '暂无数据'
    },
    colorPicker: {
      clear: '清除',
      confirm: '确认',
      copySuccess: '已复制到剪贴板：{0}',
      hex: '十六进制'
    },
    formDesign: {
      formName: '表单名称',
      defFormTitle: '未命名的表单',
      widgetPropTab: '控件属性',
      widgetFormTab: '表单属性',
      error: {
        wdFormUni: '该类型的控件在表单中只允许添加一个',
        wdSubUni: '该类型的控件在子表中只允许添加一个'
      },
      styleSetting: {
        btn: '样式设置',
        title: '表单的样式设置',
        layoutTitle: '控件布局',
        verticalLayout: '上下布局',
        horizontalLayout: '横向布局',
        styleTitle: '标题样式',
        boldTitle: '标题加粗',
        fontBold: '加粗',
        fontNormal: '常规',
        colonTitle: '显示冒号',
        colonVisible: '显示',
        colonHidden: '隐藏',
        alignTitle: '对齐方式',
        widthTitle: '标题宽度',
        alignLeft: '居左',
        alignRight: '居右',
        unitPx: '像素',
        unitPct: '百分比'
      },
      widget: {
        group: {
          base: '基础控件',
          layout: '布局控件',
          system: '系统控件',
          module: '模块控件',
          chart: '图表控件',
          advanced: '高级控件'
        },
        copyTitle: '副本_{0}',
        component: {
          input: '输入框',
          textarea: '文本域',
          select: '下拉选择',
          row: '一行多列',
          title: '标题',
          text: '文本',
          subtable: '子表',
          VxeSwitch: '是/否',
          VxeInput: '输入框',
          VxeNumberInput: '数字',
          VxeDatePicker: '日期',
          VxeTextarea: '文本域',
          VxeSelect: '下拉选择',
          VxeTreeSelect: '树形选择',
          VxeRadioGroup: '单选框',
          VxeCheckboxGroup: '复选框',
          VxeUploadFile: '文件',
          VxeUploadImage: '图片',
          VxeRate: '评分',
          VxeSlider: '滑块'
        }
      },
      widgetProp: {
        name: '控件名称',
        placeholder: '提示语',
        required: '必填校验',
        multiple: '允许多选',
        displaySetting: {
          name: '显示设置',
          pc: '电脑端',
          mobile: '手机端',
          visible: '显示',
          hidden: '隐藏'
        },
        dataSource: {
          name: '数据源',
          defValue: '选项{0}',
          addOption: '添加选项',
          batchEditOption: '批量编辑',
          batchEditTip: '每行对应一个选项，支持从表格、Excel、WPS 中直接复制粘贴。',
          batchEditSubTip: '每行对应一个选项，如果是分组，子项可以是空格或制表键开头，支持从表格、Excel、WPS 中直接复制粘贴。',
          buildOption: '生成选项'
        },
        rowProp: {
          colSize: '列数',
          col2: '两列',
          col3: '三列',
          col4: '四列',
          col6: '六列',
          layout: '布局'
        },
        textProp: {
          name: '内容',
          alignTitle: '对齐方式',
          alignLeft: '居左',
          alignCenter: '居中',
          alignRight: '居右',
          colorTitle: '字体颜色',
          sizeTitle: '字体大小',
          boldTitle: '字体加粗',
          fontNormal: '常规',
          fontBold: '加粗'
        },
        subtableProp: {
          seqTitle: '序号',
          showSeq: '显示序号',
          showCheckbox: '允许多选',
          errSubDrag: '子表不支持该控件，请使用其他控件',
          colPlace: '将控件拖拽进来'
        },
        uploadProp: {
          limitFileCount: '文件数量限制',
          limitFileSize: '文件大小限制',
          multiFile: '允许上传多个文件',
          limitImgCount: '图片数量限制',
          limitImgSize: '图片大小限制',
          multiImg: '允许上传多张图片'
        }
      }
    },
    listDesign: {
      fieldSettingTab: '字段设置',
      listSettingTab: '参数设置',
      searchTitle: '查询条件',
      listTitle: '列表字段',
      searchField: '查询字段',
      listField: '列表字段',
      activeBtn: {
        ActionButtonUpdate: '编辑',
        ActionButtonDelete: '删除'
      },
      search: {
        addBtn: '编辑',
        emptyText: '未配置查询条件',
        editPopupTitle: '编辑查询字段'
      },
      searchPopup: {
        colTitle: '标题',
        saveBtn: '保存'
      }
    },
    text: {
      copySuccess: '已复制到剪贴板',
      copyError: '当前环境不支持该操作'
    },
    countdown: {
      formats: {
        yyyy: '年',
        MM: '月',
        dd: '天',
        HH: '时',
        mm: '分',
        ss: '秒'
      }
    },
    plugins: {
      extendCellArea: {
        area: {
          mergeErr: '无法对合并单元格进行该操作',
          multiErr: '无法对多重选择区域进行该操作',
          selectErr: '无法操作指定区域的单元格',
          extendErr: '如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同',
          pasteMultiErr: '无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作',
          cpInvalidErr: '该操作无法进行，您选择的区域中存在被禁止的列（{0}）'
        },
        fnr: {
          title: '查找和替换',
          findLabel: '查找',
          replaceLabel: '替换',
          findTitle: '查找内容：',
          replaceTitle: '替换为：',
          tabs: {
            find: '查找',
            replace: '替换'
          },
          filter: {
            re: '正则表达式',
            whole: '全词匹配',
            sensitive: '区分大小写'
          },
          btns: {
            findNext: '查找下一个',
            findAll: '查找全部',
            replace: '替换',
            replaceAll: '替换全部',
            cancel: '取消'
          },
          header: {
            seq: '#',
            cell: '单元格',
            value: '值'
          },
          body: {
            row: '行：{0}',
            col: '列：{0}'
          },
          empty: '(空值)',
          reError: '无效的正则表达式',
          recordCount: '已找到 {0} 个单元格',
          notCell: '找不到匹配的单元格',
          replaceSuccess: '成功替换 {0} 个单元格'
        }
      },
      extendPivotTable: {
        aggregation: {
          grouping: '分组',
          values: '值',
          groupPlaceholder: '拖至此处进行分组',
          valuesPlaceholder: '拖至此处进行聚合',
          dragExistCol: '该列已存在',
          sortHelpTip: '点击并拖动图标可以调整顺序'
        },
        aggFuncs: {
          sum: '求和',
          count: '计数',
          avg: '平均值',
          min: '最小值',
          max: '最大值',
          first: '首个值',
          last: '末尾值'
        }
      },
      filterComplexInput: {
        menus: {
          fixedColumn: '冻结列',
          fixedGroup: '冻结分组',
          cancelFixed: '取消冻结',
          fixedLeft: '冻结左侧',
          fixedRight: '冻结右侧'
        },
        cases: {
          equal: '等于',
          gt: '大于',
          lt: '小于',
          begin: '开头是',
          endin: '结尾是',
          include: '包含',
          isSensitive: '区分大小写'
        }
      },
      filterCombination: {
        menus: {
          sort: '排序',
          clearSort: '清除排序',
          sortAsc: '升序',
          sortDesc: '降序',
          fixedColumn: '冻结列',
          fixedGroup: '冻结分组',
          cancelFixed: '取消冻结',
          fixedLeft: '冻结左侧',
          fixedRight: '冻结右侧',
          clearFilter: '清除筛选',
          textOption: '文本筛选',
          numberOption: '数值筛选'
        },
        popup: {
          title: '自定义筛选的方式',
          currColumnTitle: '当前列：',
          and: '与',
          or: '或',
          describeHtml: '可用 ? 代表单个字符<br/>用 * 代表任意多个字符'
        },
        cases: {
          equal: '等于',
          unequal: '不等于',
          gt: '大于',
          ge: '大于或等于',
          lt: '小于',
          le: '小于或等于',
          begin: '开头是',
          notbegin: '开头不是',
          endin: '结尾是',
          notendin: '结尾不是',
          include: '包含',
          exclude: '不包含',
          between: '介于',
          custom: '自定义筛选',
          insensitive: '不区分大小写',
          isSensitive: '区分大小写'
        },
        empty: '(空白)',
        notData: '无匹配项'
      }
    },
    pro: {
      area: {
        mergeErr: '无法对合并单元格进行该操作',
        multiErr: '无法对多重选择区域进行该操作',
        extendErr: '如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同',
        pasteMultiErr: '无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作'
      },
      fnr: {
        title: '查找和替换',
        findLabel: '查找',
        replaceLabel: '替换',
        findTitle: '查找内容：',
        replaceTitle: '替换为：',
        tabs: {
          find: '查找',
          replace: '替换'
        },
        filter: {
          re: '正则表达式',
          whole: '全词匹配',
          sensitive: '区分大小写'
        },
        btns: {
          findNext: '查找下一个',
          findAll: '查找全部',
          replace: '替换',
          replaceAll: '替换全部',
          cancel: '取消'
        },
        header: {
          seq: '#',
          cell: '单元格',
          value: '值'
        },
        empty: '(空值)',
        reError: '无效的正则表达式',
        recordCount: '已找到 {0} 个单元格',
        notCell: '找不到匹配的单元格',
        replaceSuccess: '成功替换 {0} 个单元格'
      }
    },
    renderer: {
      search: '搜索',
      cases: {
        equal: '等于',
        unequal: '不等于',
        gt: '大于',
        ge: '大于或等于',
        lt: '小于',
        le: '小于或等于',
        begin: '开头是',
        notbegin: '开头不是',
        endin: '结尾是',
        notendin: '结尾不是',
        include: '包含',
        exclude: '不包含',
        between: '介于',
        custom: '自定义筛选',
        insensitive: '不区分大小写',
        isSensitive: '区分大小写'
      },
      combination: {
        menus: {
          sort: '排序',
          clearSort: '清除排序',
          sortAsc: '升序',
          sortDesc: '降序',
          fixedColumn: '冻结列',
          fixedGroup: '冻结分组',
          cancelFixed: '取消冻结',
          fixedLeft: '冻结到左侧',
          fixedRight: '冻结到右侧',
          clearFilter: '清除筛选',
          textOption: '文本筛选',
          numberOption: '数值筛选'
        },
        popup: {
          title: '自定义筛选的方式',
          currColumnTitle: '当前列：',
          and: '与',
          or: '或',
          describeHtml: '可用 ? 代表单个字符<br/>用 * 代表任意多个字符'
        },
        empty: '(空白)',
        notData: '无匹配项'
      }
    }
  }
});
;// CONCATENATED MODULE: ./packages/ui/src/vn.ts

function getOnName(type) {
  return 'on' + type.substring(0, 1).toLocaleUpperCase() + type.substring(1);
}
function getModelEvent(name) {
  switch (name) {
    case 'input':
    case 'textarea':
      return 'input';
    case 'select':
      return 'change';
  }
  return 'update:modelValue';
}
function getChangeEvent(name) {
  switch (name) {
    case 'input':
    case 'textarea':
    case 'VxeInput':
    case 'VxeTextarea':
    case '$input': // 已废弃
    case '$textarea':
      // 已废弃
      return 'input';
  }
  return 'change';
}
function vn_getSlotVNs(vns) {
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(vns)) {
    return vns;
  }
  return vns ? [vns] : [];
}
;// CONCATENATED MODULE: ./packages/alert/src/alert.ts





/* harmony default export */ var src_alert = (defineVxeComponent({
  name: 'VxeAlert',
  props: {
    title: {
      type: [String, Number],
      default: () => getConfig().alert.title
    },
    content: [String, Number],
    status: String,
    showIcon: Boolean,
    showClose: Boolean,
    icon: {
      type: String,
      default: () => getConfig().alert.icon
    }
  },
  emits: ['close'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeAlert = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const alertMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $alert: $xeAlert
        }, params));
      }
    };
    const closeEvent = evnt => {
      alertMethods.dispatchEvent('close', {}, evnt);
    };
    const alertPrivateMethods = {};
    Object.assign($xeAlert, alertMethods, alertPrivateMethods);
    const renderVN = () => {
      const {
        status,
        content,
        icon,
        title,
        showIcon,
        showClose
      } = props;
      const defaultSlot = slots.default;
      const titleSlot = slots.title;
      const iconSlot = slots.icon;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-alert', {
          [`theme--${status}`]: status
        }]
      }, [iconSlot || showIcon && status || icon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-alert--icon'
      }, iconSlot ? vn_getSlotVNs(iconSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon || getIcon()[`ALERT_${status?.toUpperCase()}`]
      })]) : renderEmptyElement($xeAlert), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-alert--body'
      }, [titleSlot || title ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-alert--title'
      }, titleSlot ? vn_getSlotVNs(titleSlot({})) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(title)) : renderEmptyElement($xeAlert), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-alert--content'
      }, defaultSlot ? vn_getSlotVNs(defaultSlot({})) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content))]), showClose ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-alert--close-btn',
        onClick: closeEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().ALERT_CLOSE
      })]) : renderEmptyElement($xeAlert)]);
    };
    $xeAlert.renderVN = renderVN;
    return $xeAlert;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/alert/index.ts



const VxeAlert = Object.assign({}, src_alert, {
  install(app) {
    app.component(src_alert.name, src_alert);
  }
});
dynamicApp.use(VxeAlert);
index_esm_VxeUI.component(src_alert);
const Alert = VxeAlert;
/* harmony default export */ var packages_alert = (VxeAlert);
;// CONCATENATED MODULE: ./packages/ui/src/dom.ts

let tpImgEl;
function initTpImg() {
  if (!tpImgEl) {
    tpImgEl = new Image();
    tpImgEl.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
  }
  return tpImgEl;
}
function getTpImg() {
  if (!tpImgEl) {
    return initTpImg();
  }
  return tpImgEl;
}
const reClsMap = {};
function getClsRE(cls) {
  if (!reClsMap[cls]) {
    reClsMap[cls] = new RegExp(`(?:^|\\s)${cls}(?!\\S)`, 'g');
  }
  return reClsMap[cls];
}
function getNodeOffset(elem, container, rest) {
  if (elem) {
    const parentElem = elem.parentNode;
    rest.top += elem.offsetTop;
    rest.left += elem.offsetLeft;
    if (parentElem && parentElem !== document.documentElement && parentElem !== document.body) {
      rest.top -= parentElem.scrollTop;
      rest.left -= parentElem.scrollLeft;
    }
    if (container && (elem === container || elem.offsetParent === container) ? 0 : elem.offsetParent) {
      return getNodeOffset(elem.offsetParent, container, rest);
    }
  }
  return rest;
}
function isPx(val) {
  return val && /^\d+(px)?$/.test(val);
}
function isScale(val) {
  return val && /^\d+%$/.test(val);
}
function hasClass(elem, cls) {
  return !!(elem && elem.className && elem.className.match && elem.className.match(getClsRE(cls)));
}
function removeClass(elem, cls) {
  if (elem && hasClass(elem, cls)) {
    elem.className = elem.className.replace(getClsRE(cls), '');
  }
}
function addClass(elem, cls) {
  if (elem && !hasClass(elem, cls)) {
    removeClass(elem, cls);
    elem.className = `${elem.className} ${cls}`;
  }
}
function hasControlKey(evnt) {
  return evnt.ctrlKey || evnt.metaKey;
}
function toCssUnit(val, unit = 'px') {
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(val) || /^\d+$/.test(`${val}`)) {
    return `${val}${unit}`;
  }
  return `${val || ''}`;
}
function getDomNode() {
  const documentElement = document.documentElement;
  const bodyElem = document.body;
  return {
    scrollTop: documentElement.scrollTop || bodyElem.scrollTop,
    scrollLeft: documentElement.scrollLeft || bodyElem.scrollLeft,
    visibleHeight: documentElement.clientHeight || bodyElem.clientHeight,
    visibleWidth: documentElement.clientWidth || bodyElem.clientWidth
  };
}
/**
 * 检查触发源是否属于目标节点
 */
function getEventTargetNode(evnt, container, queryCls, queryMethod) {
  let targetElem;
  let target = evnt.target.shadowRoot && evnt.composed ? evnt.composedPath()[0] || evnt.target : evnt.target;
  while (target && target.nodeType && target !== document) {
    if (queryCls && hasClass(target, queryCls) && (!queryMethod || queryMethod(target))) {
      targetElem = target;
    } else if (target === container) {
      return {
        flag: queryCls ? !!targetElem : true,
        container,
        targetElem: targetElem
      };
    }
    target = target.parentNode;
  }
  return {
    flag: false
  };
}
/**
 * 获取元素相对于 document 的位置
 */
function getOffsetPos(elem, container) {
  return getNodeOffset(elem, container, {
    left: 0,
    top: 0
  });
}
function getAbsolutePos(elem) {
  const bounding = elem.getBoundingClientRect();
  const boundingTop = bounding.top;
  const boundingLeft = bounding.left;
  const {
    scrollTop,
    scrollLeft,
    visibleHeight,
    visibleWidth
  } = getDomNode();
  return {
    boundingTop,
    top: scrollTop + boundingTop,
    boundingLeft,
    left: scrollLeft + boundingLeft,
    visibleHeight,
    visibleWidth
  };
}
function getPaddingTopBottomSize(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const paddingTop = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.paddingTop);
    const paddingBottom = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(computedStyle.paddingBottom);
    return paddingTop + paddingBottom;
  }
  return 0;
}
function getPaddingLeftRightSize(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const paddingLeft = XEUtils.toNumber(computedStyle.paddingLeft);
    const paddingRight = XEUtils.toNumber(computedStyle.paddingRight);
    return paddingLeft + paddingRight;
  }
  return 0;
}
const scrollIntoViewIfNeeded = 'scrollIntoViewIfNeeded';
const scrollIntoView = 'scrollIntoView';
function scrollToView(elem) {
  if (elem) {
    if (elem[scrollIntoViewIfNeeded]) {
      elem[scrollIntoViewIfNeeded]();
    } else if (elem[scrollIntoView]) {
      elem[scrollIntoView]();
    }
  }
}
function dom_triggerEvent(targetElem, type) {
  if (targetElem) {
    targetElem.dispatchEvent(new Event(type));
  }
}
function isNodeElement(elem) {
  return elem && elem.nodeType === 1;
}
function updatePanelPlacement(targetElem, panelElem, options) {
  const {
    placement,
    teleportTo,
    marginSize
  } = Object.assign({
    teleportTo: false,
    marginSize: 32
  }, options);
  let panelPlacement = 'bottom';
  let top = '';
  let bottom = '';
  let left = '';
  const right = '';
  let minWidth = '';
  const stys = {};
  if (panelElem && targetElem) {
    const documentElement = document.documentElement;
    const bodyElem = document.body;
    const targetHeight = targetElem.offsetHeight;
    const panelHeight = panelElem.offsetHeight;
    const panelWidth = panelElem.offsetWidth;
    const panelRect = panelElem.getBoundingClientRect();
    const targetRect = targetElem.getBoundingClientRect();
    const visibleHeight = documentElement.clientHeight || bodyElem.clientHeight;
    const visibleWidth = documentElement.clientWidth || bodyElem.clientWidth;
    minWidth = targetElem.offsetWidth;
    if (teleportTo) {
      left = targetRect.left;
      top = targetRect.top + targetHeight;
      if (placement === 'top') {
        panelPlacement = 'top';
        top = targetRect.top - panelHeight;
      } else if (!placement) {
        // 如果下面不够放，则向上
        if (top + panelHeight + marginSize > visibleHeight) {
          panelPlacement = 'top';
          top = targetRect.top - panelHeight;
        }
        // 如果上面不够放，则向下（优先）
        if (top < marginSize) {
          panelPlacement = 'bottom';
          top = targetRect.top + targetHeight;
        }
      }
      // 如果溢出右边
      if (left + panelWidth + marginSize > visibleWidth) {
        left -= left + panelWidth + marginSize - visibleWidth;
      }
      // 如果溢出左边
      if (left < marginSize) {
        left = marginSize;
      }
    } else {
      if (placement === 'top') {
        panelPlacement = 'top';
        bottom = targetHeight;
      } else if (!placement) {
        // 如果下面不够放，则向上
        top = targetHeight;
        if (targetRect.top + targetRect.height + marginSize > visibleHeight) {
          // 如果上面不够放，则向下（优先）
          if (targetRect.top - targetHeight - panelHeight > marginSize) {
            panelPlacement = 'top';
            top = '';
            bottom = targetHeight;
          }
        }
      }
      // 是否超出右侧
      if (panelRect.left + panelRect.width + marginSize > visibleWidth) {
        left = -(panelRect.left + panelRect.width + marginSize - visibleWidth);
      }
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(top)) {
      stys.top = toCssUnit(top);
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(bottom)) {
      stys.bottom = toCssUnit(bottom);
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(left)) {
      stys.left = toCssUnit(left);
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(right)) {
      stys.right = toCssUnit(right);
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(minWidth)) {
      stys.minWidth = toCssUnit(minWidth);
    }
  }
  return {
    top: top || 0,
    bottom: bottom || 0,
    left: left || 0,
    right: right || 0,
    style: stys,
    placement: panelPlacement
  };
}
;// CONCATENATED MODULE: ./packages/anchor/src/util.ts

function assembleAnchorLink($xeAnchor, elem, linkConfig, $xeParentAnchorLink) {
  const staticLinks = $xeAnchor.reactData.staticLinks;
  const parentElem = elem.parentNode;
  const parentLinkConfig = $xeParentAnchorLink ? $xeParentAnchorLink.linkConfig : null;
  const parentLinks = parentLinkConfig ? parentLinkConfig.children : staticLinks;
  if (parentElem && parentLinks) {
    parentLinks.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, elem), 0, linkConfig);
    $xeAnchor.reactData.staticLinks = staticLinks.slice(0);
  }
}
function destroyAnchorLink($xeAnchor, linkConfig) {
  const staticLinks = $xeAnchor.reactData.staticLinks;
  const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(staticLinks, item => item.id === linkConfig.id, {
    children: 'children'
  });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  $xeAnchor.reactData.staticLinks = staticLinks.slice(0);
}
;// CONCATENATED MODULE: ./packages/anchor/src/anchor-link.ts





/* harmony default export */ var anchor_link = (defineVxeComponent({
  name: 'VxeAnchorLink',
  props: {
    content: [String, Number],
    title: [String, Number],
    href: String
  },
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const $xeAnchor = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeAnchor', null);
    const $xeParentAnchorLink = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeAnchorLink', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const linkConfig = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      id: xID,
      href: props.href,
      children: []
    });
    const refMaps = {
      refElem
    };
    const computeIsActive = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        href
      } = props;
      if ($xeAnchor) {
        return $xeAnchor.reactData.activeHref === href;
      }
      return null;
    });
    const computeMaps = {};
    const $xeAnchorLink = {
      xID,
      props,
      context,
      reactData,
      linkConfig,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const clickEvent = event => {
      const {
        href
      } = props;
      if ($xeAnchor) {
        $xeAnchor.handleClickLink(event, href);
      }
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.href, val => {
      linkConfig.href = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const elem = refElem.value;
      if ($xeAnchor && elem) {
        assembleAnchorLink($xeAnchor, elem, linkConfig, $xeParentAnchorLink);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      if ($xeAnchor) {
        destroyAnchorLink($xeAnchor, linkConfig);
      }
    });
    const renderVN = () => {
      const {
        href,
        content,
        title
      } = props;
      const defaultSlot = slots.default;
      const subSlot = slots.sub;
      const isActive = computeIsActive.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-anchor-link', {
          'is--active': isActive
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('a', {
        class: 'vxe-anchor-link--item',
        href,
        title,
        onClick: clickEvent
      }, defaultSlot ? defaultSlot({}) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content)), subSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-anchor-link--sub-items'
      }, subSlot({})) : renderEmptyElement($xeAnchorLink)]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeAnchorLink', $xeAnchorLink);
    $xeAnchorLink.renderVN = renderVN;
    return $xeAnchorLink;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/anchor/src/anchor.ts







/* harmony default export */ var src_anchor = (defineVxeComponent({
  name: 'VxeAnchor',
  props: {
    modelValue: String,
    options: Array,
    container: [String, Object, Function],
    showMarker: {
      type: Boolean,
      default: true
    }
  },
  emits: ['update:modelValue', 'change', 'click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMarkerElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      activeHref: null,
      staticLinks: [],
      containerElem: null
    });
    const refMaps = {
      refElem
    };
    const computeAllHrefList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const list = [];
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(reactData.staticLinks, item => {
        list.push(item.href || '');
      }, {
        children: 'children'
      });
      return list;
    });
    const computeMaps = {};
    const $xeAnchor = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const anchorMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $anchor: $xeAnchor
        }, params));
      }
    };
    const getContainerElem = () => {
      const {
        container
      } = props;
      if (container) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isElement(container)) {
          return container;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(container)) {
          return document.querySelector(container);
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(container)) {
          return container({
            $anchor: $xeAnchor
          });
        }
      }
      return null;
    };
    const emitEvent = value => {
      reactData.activeHref = value;
      emit('update:modelValue', value);
    };
    const handleContainerScrollEvent = () => {
      const allHrefList = computeAllHrefList.value;
      const {
        containerElem
      } = reactData;
      if (containerElem) {
        const wrapperElList = containerElem.querySelectorAll(allHrefList.map(href => `${href}`).join(','));
        for (let i = 0; i < wrapperElList.length; i++) {
          const wrapperEl = wrapperElList[i];
          const wrapperRect = wrapperEl.getBoundingClientRect();
          if (wrapperRect.top > 0) {
            const href = wrapperEl.id;
            reactData.activeHref = `#${href}`;
            break;
          }
        }
      }
    };
    const removeContainerElemScroll = () => {
      const {
        containerElem
      } = reactData;
      if (containerElem) {
        containerElem.removeEventListener('scroll', handleContainerScrollEvent);
      }
    };
    const updateContainerElem = () => {
      const containerElem = getContainerElem();
      reactData.containerElem = containerElem;
      if (containerElem) {
        containerElem.addEventListener('scroll', handleContainerScrollEvent, {
          passive: false
        });
      }
    };
    const updateMarkerPos = () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          activeHref
        } = reactData;
        const elem = refElem.value;
        const markerEl = refMarkerElem.value;
        if (elem && markerEl) {
          if (activeHref) {
            const linkEl = elem.querySelector(`[href="${activeHref}"]`);
            if (linkEl) {
              const {
                top
              } = getOffsetPos(linkEl, elem);
              markerEl.style.top = `${top}px`;
            }
          }
        }
      });
    };
    const anchorPrivateMethods = {
      handleClickLink(evnt, href) {
        evnt.preventDefault();
        const targetEl = document.getElementById(`${href}`.replace('#', ''));
        if (targetEl) {
          targetEl.scrollIntoView({
            behavior: 'smooth'
          });
        }
        emitEvent(href);
        anchorMethods.dispatchEvent('click', {
          href
        }, evnt);
      }
    };
    Object.assign($xeAnchor, anchorMethods, anchorPrivateMethods);
    const renderSubItems = options => {
      const itemVNs = [];
      if (options) {
        options.forEach(item => {
          const subItems = item.children;
          if (subItems && subItems.length) {
            itemVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(anchor_link, {
              content: item.content,
              title: item.title,
              href: item.href
            }, {
              sub: () => renderSubItems(subItems)
            }));
          } else {
            itemVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(anchor_link, {
              content: item.content,
              title: item.title,
              href: item.href
            }));
          }
        });
      }
      return itemVNs;
    };
    const renderVN = () => {
      const {
        options,
        showMarker
      } = props;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-anchor', {
          'is--marker': showMarker
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-anchor--list'
      }, defaultSlot ? defaultSlot({}) : renderSubItems(options)), showMarker ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refMarkerElem,
        class: 'vxe-anchor--marker'
      }) : renderEmptyElement($xeAnchor)]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.activeHref = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.activeHref, () => {
      updateMarkerPos();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.container, () => {
      removeContainerElemScroll();
      updateContainerElem();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        updateContainerElem();
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      removeContainerElemScroll();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeAnchor', $xeAnchor);
    $xeAnchor.renderVN = renderVN;
    return $xeAnchor;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/anchor/index.ts



const VxeAnchor = Object.assign({}, src_anchor, {
  install(app) {
    app.component(src_anchor.name, src_anchor);
  }
});
dynamicApp.use(VxeAnchor);
index_esm_VxeUI.component(src_anchor);
const Anchor = VxeAnchor;
/* harmony default export */ var packages_anchor = (VxeAnchor);
;// CONCATENATED MODULE: ./packages/anchor-link/index.ts



const VxeAnchorLink = Object.assign({}, anchor_link, {
  install(app) {
    app.component(anchor_link.name, anchor_link);
  }
});
dynamicApp.use(VxeAnchorLink);
index_esm_VxeUI.component(anchor_link);
const AnchorLink = VxeAnchorLink;
/* harmony default export */ var packages_anchor_link = (VxeAnchorLink);
;// CONCATENATED MODULE: ./packages/avatar/src/avatar.ts





/* harmony default export */ var avatar = (defineVxeComponent({
  name: 'VxeAvatar',
  props: {
    count: [String, Number],
    dot: Boolean,
    content: [String, Number],
    icon: String,
    src: String,
    width: [String, Number],
    height: [String, Number],
    circle: {
      type: Boolean,
      default: () => getConfig().avatar.circle
    },
    status: {
      type: String,
      default: () => getConfig().avatar.status
    },
    size: {
      type: String,
      default: () => getConfig().avatar.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeAvatarStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        width,
        height
      } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeCountNum = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        count
      } = props;
      return count ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(count) : 0;
    });
    const computeMaps = {};
    const $xeAvatar = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $avatar: $xeAvatar
      }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeAvatar, collapsePaneMethods, collapsePanePrivateMethods);
    const renderContent = () => {
      const {
        icon,
        content,
        src
      } = props;
      if (icon) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-avatar--icon'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: icon
        })]);
      }
      if (content) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-avatar--content'
        }, `${content}`);
      }
      if (src) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('img', {
          class: 'vxe-avatar--img',
          src
        });
      }
      return renderEmptyElement($xeAvatar);
    };
    const renderVN = () => {
      const {
        circle,
        dot,
        status
      } = props;
      const vSize = computeSize.value;
      const countNum = computeCountNum.value;
      const avatarStyle = computeAvatarStyle.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-avatar', {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          'is--circle': circle,
          'is--dot': dot
        }],
        style: avatarStyle
      }, [renderContent(), countNum ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-avatar--count'
      }, countNum > 99 ? '99+' : `${countNum}`) : renderEmptyElement($xeAvatar)]);
    };
    $xeAvatar.renderVN = renderVN;
    return $xeAvatar;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/avatar/index.ts



const VxeAvatar = Object.assign({}, avatar, {
  install(app) {
    app.component(avatar.name, avatar);
  }
});
dynamicApp.use(VxeAvatar);
index_esm_VxeUI.component(avatar);
const Avatar = VxeAvatar;
/* harmony default export */ var packages_avatar = (VxeAvatar);
;// CONCATENATED MODULE: ./packages/badge/src/badge.ts




/* harmony default export */ var badge = (defineVxeComponent({
  name: 'VxeBadge',
  props: {
    count: [String, Number],
    dot: Boolean,
    content: [String, Number],
    size: {
      type: String,
      default: () => getConfig().badge.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeCountNum = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        count
      } = props;
      return count ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(count) : 0;
    });
    const computeMaps = {};
    const $xeBadge = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $badge: $xeBadge
      }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeBadge, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const {
        dot,
        content
      } = props;
      const vSize = computeSize.value;
      const countNum = computeCountNum.value;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-badge', {
          [`size--${vSize}`]: vSize,
          'is--dot': dot
        }]
      }, [defaultSlot || content ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-badge--content'
      }, defaultSlot ? defaultSlot({}) : `${content || ''}`) : [], countNum ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-badge--count'
      }, countNum > 99 ? '99+' : `${countNum}`) : renderEmptyElement($xeBadge)]);
    };
    $xeBadge.renderVN = renderVN;
    return $xeBadge;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/badge/index.ts



const VxeBadge = Object.assign({}, badge, {
  install(app) {
    app.component(badge.name, badge);
  }
});
dynamicApp.use(VxeBadge);
index_esm_VxeUI.component(badge);
const Badge = VxeBadge;
/* harmony default export */ var packages_badge = (VxeBadge);
;// CONCATENATED MODULE: ./packages/breadcrumb/src/breadcrumb-item.ts




/* harmony default export */ var breadcrumb_item = (defineVxeComponent({
  name: 'VxeBreadcrumbItem',
  props: {
    title: String,
    routerLink: Object
  },
  emits: [],
  setup(props, context) {
    const {
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeBreadcrumb = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeBreadcrumb', null);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeSeparator = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if ($xeBreadcrumb) {
        return $xeBreadcrumb.props.separator;
      }
      return '';
    });
    const clickEvent = evnt => {
      if ($xeBreadcrumb) {
        const item = {
          title: props.title,
          routerLink: props.routerLink
        };
        $xeBreadcrumb.handleClickLink(evnt, item);
      }
    };
    const computeMaps = {};
    const $xeBreadcrumbItem = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const {
        title,
        routerLink
      } = props;
      const separator = computeSeparator.value;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        ref: refElem,
        class: 'vxe-breadcrumb-item',
        onClick: clickEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-breadcrumb-item--content'
      }, [routerLink ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('router-link'), {
        class: 'vxe-breadcrumb-item--content-link',
        title,
        to: routerLink
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-breadcrumb-item--content-text'
          }, defaultSlot ? defaultSlot({}) : `${title || ''}`);
        }
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-breadcrumb-item--content-text'
      }, defaultSlot ? defaultSlot({}) : `${title || ''}`)]), separator ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-breadcrumb-item--separator'
      }, `${separator}`) : renderEmptyElement($xeBreadcrumbItem)]);
    };
    $xeBreadcrumbItem.renderVN = renderVN;
    return $xeBreadcrumbItem;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/breadcrumb/src/breadcrumb.ts





/* harmony default export */ var breadcrumb = (defineVxeComponent({
  name: 'VxeBreadcrumb',
  props: {
    separator: {
      type: String,
      default: () => getConfig().breadcrumb.separator
    },
    options: Array
  },
  emits: ['click'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeBreadcrumb = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const breadcrumbMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $breadcrumb: $xeBreadcrumb
        }, params));
      }
    };
    const breadcrumbPrivateMethods = {
      handleClickLink(evnt, option) {
        breadcrumbMethods.dispatchEvent('click', {
          option
        }, evnt);
      }
    };
    Object.assign($xeBreadcrumb, breadcrumbMethods, breadcrumbPrivateMethods);
    const renderItems = () => {
      const {
        options
      } = props;
      if (options && options.length) {
        return options.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(breadcrumb_item, {
            title: item.title,
            routerLink: item.routerLink
          });
        });
      }
      return [];
    };
    const renderVN = () => {
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: 'vxe-breadcrumb'
      }, defaultSlot ? defaultSlot({}) : renderItems());
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeBreadcrumb', $xeBreadcrumb);
    $xeBreadcrumb.renderVN = renderVN;
    return $xeBreadcrumb;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/breadcrumb/index.ts



const VxeBreadcrumb = Object.assign({}, breadcrumb, {
  install(app) {
    app.component(breadcrumb.name, breadcrumb);
  }
});
dynamicApp.use(VxeBreadcrumb);
index_esm_VxeUI.component(breadcrumb);
const Breadcrumb = VxeBreadcrumb;
/* harmony default export */ var packages_breadcrumb = (VxeBreadcrumb);
;// CONCATENATED MODULE: ./packages/breadcrumb-item/index.ts



const VxeBreadcrumbItem = Object.assign({}, breadcrumb_item, {
  install(app) {
    app.component(breadcrumb_item.name, breadcrumb_item);
  }
});
dynamicApp.use(VxeBreadcrumbItem);
index_esm_VxeUI.component(breadcrumb_item);
const BreadcrumbItem = VxeBreadcrumbItem;
/* harmony default export */ var packages_breadcrumb_item = (VxeBreadcrumbItem);
;// CONCATENATED MODULE: ./packages/ui/src/utils.ts



function isEnableConf(conf) {
  return conf && conf.enabled !== false;
}
function nextZIndex() {
  return index_esm.getNext();
}
function getLastZIndex() {
  return index_esm.getCurrent();
}
function nextSubZIndex() {
  return index_esm.getSubNext();
}
function getSubLastZIndex() {
  return index_esm.getSubCurrent();
}
function getGlobalDefaultConfig(value, globalValue) {
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(value)) {
    return globalValue;
  }
  return value;
}
function getFuncText(content, args) {
  if (content) {
    const translate = getConfig().translate;
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(translate ? translate('' + content, args) : content);
  }
  return '';
}
/**
 * 判断值为：'' | null | undefined 时都属于空值
 */
function eqEmptyValue(cellValue) {
  return cellValue === null || cellValue === undefined || cellValue === '';
}
function handleBooleanDefaultValue(value) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(value) ? value : null;
}
;// CONCATENATED MODULE: ./packages/tooltip/src/tooltip.ts







/* harmony default export */ var tooltip = (defineVxeComponent({
  name: 'VxeTooltip',
  props: {
    modelValue: Boolean,
    size: {
      type: String,
      default: () => getConfig().tooltip.size || getConfig().size
    },
    selector: String,
    trigger: {
      type: String,
      default: () => getConfig().tooltip.trigger || 'hover'
    },
    theme: {
      type: String,
      default: () => getConfig().tooltip.theme || 'dark'
    },
    content: {
      type: [String, Number],
      default: null
    },
    useHTML: Boolean,
    zIndex: [String, Number],
    popupClassName: [String, Function],
    isArrow: {
      type: Boolean,
      default: () => getConfig().tooltip.isArrow
    },
    enterable: {
      type: Boolean,
      default: () => getConfig().tooltip.enterable
    },
    enterDelay: {
      type: Number,
      default: () => getConfig().tooltip.enterDelay
    },
    leaveDelay: {
      type: Number,
      default: () => getConfig().tooltip.leaveDelay
    }
  },
  emits: ['update:modelValue'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      target: null,
      isUpdate: false,
      visible: false,
      tipContent: '',
      tipActive: false,
      tipTarget: null,
      tipZindex: 0,
      tipStore: {
        style: {},
        placement: '',
        arrowStyle: {}
      }
    });
    const internalData = {};
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xeTooltip = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let tooltipMethods = {};
    const updateTipStyle = () => {
      const {
        tipTarget,
        tipStore
      } = reactData;
      if (tipTarget) {
        const {
          scrollTop,
          scrollLeft,
          visibleWidth
        } = getDomNode();
        const {
          top,
          left
        } = getAbsolutePos(tipTarget);
        const el = refElem.value;
        const marginSize = 6;
        const offsetHeight = el.offsetHeight;
        const offsetWidth = el.offsetWidth;
        let tipLeft = left;
        let tipTop = top - offsetHeight - marginSize;
        tipLeft = Math.max(marginSize, left + Math.floor((tipTarget.offsetWidth - offsetWidth) / 2));
        if (tipLeft + offsetWidth + marginSize > scrollLeft + visibleWidth) {
          tipLeft = scrollLeft + visibleWidth - offsetWidth - marginSize;
        }
        if (top - offsetHeight < scrollTop + marginSize) {
          tipStore.placement = 'bottom';
          tipTop = top + tipTarget.offsetHeight + marginSize;
        }
        tipStore.style.top = `${tipTop}px`;
        tipStore.style.left = `${tipLeft}px`;
        tipStore.arrowStyle.left = `${left - tipLeft + tipTarget.offsetWidth / 2}px`;
      }
    };
    const updateValue = value => {
      if (value !== reactData.visible) {
        reactData.visible = value;
        reactData.isUpdate = true;
        emit('update:modelValue', value);
      }
    };
    const updateZindex = () => {
      if (reactData.tipZindex < getLastZIndex()) {
        reactData.tipZindex = nextZIndex();
      }
    };
    const clickEvent = () => {
      if (reactData.visible) {
        tooltipMethods.close();
      } else {
        handleVisible(reactData.target || getSelectorEl(), props.content);
      }
    };
    const targetMouseenterEvent = () => {
      handleVisible(reactData.target || getSelectorEl(), props.content);
    };
    const targetMouseleaveEvent = () => {
      const {
        trigger,
        enterable,
        leaveDelay
      } = props;
      reactData.tipActive = false;
      if (enterable && trigger === 'hover') {
        setTimeout(() => {
          if (!reactData.tipActive) {
            tooltipMethods.close();
          }
        }, leaveDelay);
      } else {
        tooltipMethods.close();
      }
    };
    const wrapperMouseenterEvent = () => {
      reactData.tipActive = true;
    };
    const wrapperMouseleaveEvent = () => {
      const {
        trigger,
        enterable,
        leaveDelay
      } = props;
      reactData.tipActive = false;
      if (enterable && trigger === 'hover') {
        setTimeout(() => {
          if (!reactData.tipActive) {
            tooltipMethods.close();
          }
        }, leaveDelay);
      }
    };
    const showTip = () => {
      const {
        tipStore
      } = reactData;
      const el = refElem.value;
      if (el) {
        const parentNode = el.parentNode;
        if (!parentNode) {
          document.body.appendChild(el);
        }
      }
      updateValue(true);
      updateZindex();
      tipStore.placement = 'top';
      tipStore.style = {
        width: 'auto',
        left: 0,
        top: 0,
        zIndex: props.zIndex || reactData.tipZindex
      };
      tipStore.arrowStyle = {
        left: '50%'
      };
      return tooltipMethods.updatePlacement();
    };
    const handleDelayFn = () => {
      internalData.showDelayTip = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().debounce(() => {
        if (reactData.tipActive) {
          showTip();
        }
      }, props.enterDelay, {
        leading: false,
        trailing: true
      });
    };
    const handleVisible = (target, content) => {
      const contentSlot = slots.content;
      if (!contentSlot && (content === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(content))) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
      if (target) {
        const {
          showDelayTip
        } = internalData;
        const {
          trigger,
          enterDelay
        } = props;
        reactData.tipActive = true;
        reactData.tipTarget = target;
        reactData.tipContent = content;
        if (enterDelay && trigger === 'hover') {
          if (showDelayTip) {
            showDelayTip();
          }
        } else {
          return showTip();
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const getSelectorEl = () => {
      const {
        selector
      } = props;
      if (selector) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isElement(selector)) {
          return selector;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(selector)) {
          return document.querySelector(selector);
        }
      }
      return null;
    };
    tooltipMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $tooltip: $xeTooltip
        }, params));
      },
      open(target, content) {
        return handleVisible(target || reactData.target || getSelectorEl(), content);
      },
      close() {
        reactData.tipTarget = null;
        reactData.tipActive = false;
        Object.assign(reactData.tipStore, {
          style: {},
          placement: '',
          arrowStyle: null
        });
        updateValue(false);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      toVisible(target, content) {
        return handleVisible(target, content);
      },
      updatePlacement() {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
          const {
            tipTarget
          } = reactData;
          const el = refElem.value;
          if (tipTarget && el) {
            updateTipStyle();
            return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
              updateTipStyle();
            });
          }
        });
      },
      isActived() {
        return reactData.tipActive;
      },
      setActived(active) {
        reactData.tipActive = !!active;
      }
    };
    Object.assign($xeTooltip, tooltipMethods);
    const renderContent = () => {
      const {
        useHTML
      } = props;
      const {
        tipContent
      } = reactData;
      const contentSlot = slots.content;
      if (contentSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: 1,
          class: 'vxe-tooltip--content'
        }, vn_getSlotVNs(contentSlot({})));
      }
      if (useHTML) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: 2,
          class: 'vxe-tooltip--content',
          innerHTML: tipContent
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 3,
        class: 'vxe-tooltip--content'
      }, `${tipContent}`);
    };
    const renderVN = () => {
      const {
        popupClassName,
        theme,
        isArrow,
        enterable
      } = props;
      const {
        tipActive,
        visible,
        tipStore
      } = reactData;
      const defaultSlot = slots.default;
      const vSize = computeSize.value;
      let ons;
      if (enterable) {
        ons = {
          onMouseenter: wrapperMouseenterEvent,
          onMouseleave: wrapperMouseleaveEvent
        };
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-tooltip--wrapper', `theme--${theme}`, popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
          $tooltip: $xeTooltip
        }) : popupClassName : '', {
          [`size--${vSize}`]: vSize,
          [`placement--${tipStore.placement}`]: tipStore.placement,
          'is--enterable': enterable,
          'is--visible': visible,
          'is--arrow': isArrow,
          'is--active': tipActive
        }],
        style: tipStore.style,
        ...ons
      }, [renderContent(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tooltip--arrow',
        style: tipStore.arrowStyle
      }), ...(defaultSlot ? vn_getSlotVNs(defaultSlot({})) : [])]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.enterDelay, () => {
      handleDelayFn();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.content, val => {
      reactData.tipContent = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      if (!reactData.isUpdate) {
        if (val) {
          handleVisible(reactData.target || getSelectorEl(), props.content);
        } else {
          tooltipMethods.close();
        }
      }
      reactData.isUpdate = false;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          trigger,
          content
        } = props;
        const wrapperElem = refElem.value;
        if (wrapperElem) {
          const parentNode = wrapperElem.parentNode;
          if (parentNode) {
            reactData.tipContent = content;
            reactData.tipZindex = nextZIndex();
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(wrapperElem.children, (elem, index) => {
              if (index > 1) {
                parentNode.insertBefore(elem, wrapperElem);
                if (!reactData.target) {
                  reactData.target = elem;
                }
              }
            });
            parentNode.removeChild(wrapperElem);
            const {
              target
            } = reactData;
            if (target) {
              if (trigger === 'hover') {
                target.onmouseenter = targetMouseenterEvent;
                target.onmouseleave = targetMouseleaveEvent;
              } else if (trigger === 'click') {
                target.onclick = clickEvent;
              }
            }
            if (props.modelValue) {
              handleVisible(target || getSelectorEl(), content);
            }
          }
        }
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      const {
        target
      } = reactData;
      const wrapperElem = refElem.value;
      if (target) {
        target.onmouseenter = null;
        target.onmouseleave = null;
        target.onclick = null;
      }
      if (wrapperElem) {
        const parentNode = wrapperElem.parentNode;
        if (parentNode) {
          parentNode.removeChild(wrapperElem);
        }
      }
    });
    handleDelayFn();
    $xeTooltip.renderVN = renderVN;
    return $xeTooltip;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/button/src/button.ts










const VxeButtonComponent = defineVxeComponent({
  name: 'VxeButton',
  props: {
    /**
     * 按钮类型
     */
    type: String,
    mode: String,
    className: [String, Function],
    popupClassName: [String, Function],
    /**
     * 按钮尺寸
     */
    size: {
      type: String,
      default: () => getConfig().button.size || getConfig().size
    },
    /**
     * 用来标识这一项
     */
    name: [String, Number],
    routerLink: Object,
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    /**
     * 按钮内容
     */
    content: String,
    /**
     * 固定显示下拉面板的方向
     */
    placement: String,
    /**
     * 按钮状态
     */
    status: String,
    /**
     * 标题
     */
    title: String,
    /**
     * 按钮的前缀图标，属于 prefix-icon 的简写
     */
    icon: String,
    iconRender: Object,
    /**
     * 按钮的前缀图标
     */
    prefixIcon: String,
    prefixRender: Object,
    /**
     * 按钮的后缀图标
     */
    suffixIcon: String,
    suffixRender: Object,
    /**
     * 圆角边框
     */
    round: Boolean,
    /**
     * 圆角按钮
     */
    circle: Boolean,
    /**
     * 是否禁用
     */
    disabled: Boolean,
    /**
     * 是否加载中
     */
    loading: Boolean,
    trigger: {
      type: String,
      default: () => getConfig().button.trigger
    },
    align: String,
    prefixTooltip: Object,
    suffixTooltip: Object,
    options: Array,
    /**
     * 在下拉面板关闭时销毁内容
     */
    destroyOnClose: {
      type: Boolean,
      default: () => getConfig().button.destroyOnClose
    },
    /**
     * 是否将弹框容器插入于 body 内
     */
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: ['click', 'mouseenter', 'mouseleave', 'dropdown-click', 'dropdownClick'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const $xeButtonGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeButtonGroup', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const {
      computePermissionInfo
    } = usePermission(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: ''
    });
    const internalData = {
      showTime: undefined,
      tooltipTimeout: undefined
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refButton = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBtnPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xeButton = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let buttonMethods = {};
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().button.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeBtnDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      const permissionInfo = computePermissionInfo.value;
      return disabled || permissionInfo.disabled;
    });
    const computeIsFormBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      if (type) {
        return ['submit', 'reset', 'button'].indexOf(type) > -1;
      }
      return false;
    });
    const computeBtnMode = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        mode
      } = props;
      if (mode === 'text' || type === 'text' || $xeButtonGroup && $xeButtonGroup.props.mode === 'text') {
        return 'text';
      }
      return 'button';
    });
    const computeBtnStatus = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        status
      } = props;
      if (status) {
        return status;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.status;
      }
      return '';
    });
    const computeBtnAlign = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        align
      } = props;
      if (align) {
        return align;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.align;
      }
      return false;
    });
    const computeBtnRound = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        round
      } = props;
      if (round) {
        return round;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.round;
      }
      return false;
    });
    const computeBtnCircle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        circle
      } = props;
      if (circle) {
        return circle;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.circle;
      }
      return false;
    });
    const computeDownBtnList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        options
      } = props;
      if (options) {
        return options.filter(item => {
          const {
            permissionCode
          } = item;
          return !permissionCode || permission.checkVisible(permissionCode);
        });
      }
      return [];
    });
    const computePrefixTipOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().button.prefixTooltip, props.prefixTooltip);
    });
    const computeSuffixTipOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().button.suffixTooltip, props.suffixTooltip);
    });
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      const {
        placement
      } = props;
      const {
        panelIndex
      } = reactData;
      const targetElem = refButton.value;
      const panelElem = refBtnPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(handleStyle);
    };
    const clickEvent = evnt => {
      if ($xeButtonGroup) {
        $xeButtonGroup.handleClick({
          name: props.name
        }, evnt);
      }
      dispatchEvent('click', {
        $event: evnt
      }, evnt);
    };
    const downBtnClickEvent = (params, option) => {
      const {
        $event
      } = params;
      hidePanel();
      dispatchEvent('dropdown-click', {
        name: option.name,
        option
      }, $event);
    };
    const mousedownDropdownEvent = evnt => {
      const isLeftBtn = evnt.button === 0;
      if (isLeftBtn) {
        evnt.stopPropagation();
      }
    };
    const clickDropdownEvent = evnt => {
      const dropdownElem = evnt.currentTarget;
      const panelElem = refBtnPanel.value;
      const {
        flag,
        targetElem
      } = getEventTargetNode(evnt, dropdownElem, 'vxe-button');
      if (flag) {
        if (panelElem) {
          panelElem.dataset.active = 'N';
        }
        reactData.visiblePanel = false;
        setTimeout(() => {
          if (!panelElem || panelElem.dataset.active !== 'Y') {
            reactData.isAniVisible = false;
          }
        }, 350);
        dispatchEvent('dropdown-click', {
          name: targetElem.getAttribute('name'),
          option: null
        }, evnt);
      }
    };
    const mouseenterDropdownEvent = () => {
      const panelElem = refBtnPanel.value;
      if (panelElem) {
        panelElem.dataset.active = 'Y';
        reactData.isAniVisible = true;
        setTimeout(() => {
          if (panelElem.dataset.active === 'Y') {
            reactData.visiblePanel = true;
            updateZindex();
            updatePlacement();
            setTimeout(() => {
              if (reactData.visiblePanel) {
                updatePlacement();
              }
            }, 50);
          }
        }, 20);
      }
    };
    const mouseenterTargetEvent = evnt => {
      const {
        loading
      } = props;
      const btnDisabled = computeBtnDisabled.value;
      if (!(btnDisabled || loading)) {
        openPanel();
        mouseenterEvent(evnt);
      }
    };
    const mouseleaveTargetEvent = evnt => {
      hidePanel();
      mouseleaveEvent(evnt);
    };
    const mouseenterEvent = evnt => {
      dispatchEvent('mouseenter', {}, evnt);
    };
    const mouseleaveEvent = evnt => {
      dispatchEvent('mouseleave', {}, evnt);
    };
    const clickTargetEvent = evnt => {
      const {
        loading,
        trigger
      } = props;
      const btnDisabled = computeBtnDisabled.value;
      if (!(btnDisabled || loading)) {
        if (trigger === 'click') {
          if (reactData.visiblePanel) {
            hidePanel();
          } else {
            openPanel();
          }
        }
        clickEvent(evnt);
      }
    };
    const openPanel = () => {
      const {
        trigger
      } = props;
      const panelElem = refBtnPanel.value;
      if (panelElem) {
        panelElem.dataset.active = 'Y';
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        internalData.showTime = setTimeout(() => {
          if (panelElem.dataset.active === 'Y') {
            mouseenterDropdownEvent();
          } else {
            reactData.isAniVisible = false;
          }
        }, trigger === 'click' ? 50 : 250);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const hidePanel = () => {
      const panelElem = refBtnPanel.value;
      clearTimeout(internalData.showTime);
      if (panelElem) {
        panelElem.dataset.active = 'N';
        setTimeout(() => {
          if (panelElem.dataset.active !== 'Y') {
            reactData.visiblePanel = false;
            setTimeout(() => {
              if (panelElem.dataset.active !== 'Y') {
                reactData.isAniVisible = false;
              }
            }, 350);
          }
        }, 100);
      } else {
        reactData.isAniVisible = false;
        reactData.visiblePanel = false;
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const mouseleaveDropdownEvent = () => {
      hidePanel();
    };
    const renderTooltipIcon = (tipOpts, type) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tooltip, {
        useHTML: tipOpts.useHTML,
        content: tipOpts.content,
        enterable: tipOpts.enterable,
        theme: tipOpts.theme
      }, {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: `vxe-button--item vxe-button--tooltip-${type}-icon`
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
            class: tipOpts.icon || getIcon().BUTTON_TOOLTIP_ICON
          })]);
        }
      });
    };
    const renderContent = () => {
      const {
        content,
        suffixIcon,
        loading,
        prefixTooltip,
        suffixTooltip,
        suffixRender
      } = props;
      const prefixIcon = props.prefixIcon || props.icon;
      const prefixRender = props.prefixRender || props.iconRender;
      const prefixTipOpts = computePrefixTipOpts.value;
      const suffixTipOpts = computeSuffixTipOpts.value;
      const prefixIconSlot = slots.prefix || slots.icon;
      const suffixIconSlot = slots.suffix;
      const defaultSlot = slots.default;
      const contVNs = [];
      if (prefixTooltip) {
        contVNs.push(renderTooltipIcon(prefixTipOpts, 'prefix'));
      }
      if (loading) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-button--item vxe-button--loading-icon', getIcon().BUTTON_LOADING]
        }));
      } else if (prefixIconSlot) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-button--item vxe-button--custom-prefix-icon'
        }, prefixIconSlot({})));
      } else if (prefixRender) {
        const compConf = renderer.get(prefixRender.name);
        const pIconMethod = compConf ? compConf.renderButtonPrefix : null;
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-button--item vxe-button--custom-prefix-icon']
        }, pIconMethod ? vn_getSlotVNs(pIconMethod(prefixRender, {
          $button: $xeButton
        })) : []));
      } else if (prefixIcon) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-button--item vxe-button--prefix-icon', prefixIcon]
        }));
      }
      if (defaultSlot) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-button--item vxe-button--content'
        }, defaultSlot({})));
      } else if (content) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-button--item vxe-button--content'
        }, getFuncText(content)));
      }
      if (suffixIconSlot) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-button--item vxe-button--custom-suffix-icon'
        }, suffixIconSlot({})));
      } else if (suffixRender) {
        const compConf = renderer.get(suffixRender.name);
        const sIconMethod = compConf ? compConf.renderButtonSuffix : null;
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-button--item vxe-button--custom-suffix-icon']
        }, sIconMethod ? vn_getSlotVNs(sIconMethod(suffixRender, {
          $button: $xeButton
        })) : []));
      } else if (suffixIcon) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-button--item vxe-button--suffix-icon', suffixIcon]
        }));
      }
      if (suffixTooltip) {
        contVNs.push(renderTooltipIcon(suffixTipOpts, 'suffix'));
      }
      return contVNs;
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $button: $xeButton
      }, params));
    };
    buttonMethods = {
      dispatchEvent,
      openPanel,
      closePanel: hidePanel,
      focus() {
        const btnElem = refButton.value;
        if (btnElem) {
          btnElem.focus();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const btnElem = refButton.value;
        if (btnElem) {
          btnElem.blur();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    const handleGlobalMousewheelEvent = evnt => {
      const panelElem = refBtnPanel.value;
      if (reactData.visiblePanel && !getEventTargetNode(evnt, panelElem).flag) {
        hidePanel();
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const btnDisabled = computeBtnDisabled.value;
      const {
        visiblePanel
      } = reactData;
      if (!btnDisabled) {
        const el = refElem.value;
        const panelElem = refBtnPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hidePanel();
        }
      }
    };
    const handleGlobalResizeEvent = () => {
      const {
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    Object.assign($xeButton, buttonMethods);
    const renderVN = () => {
      const {
        className,
        popupClassName,
        trigger,
        title,
        routerLink,
        type,
        destroyOnClose,
        name,
        loading
      } = props;
      const {
        initialized,
        isAniVisible,
        visiblePanel
      } = reactData;
      const isFormBtn = computeIsFormBtn.value;
      const btnMode = computeBtnMode.value;
      const btnStatus = computeBtnStatus.value;
      const btnRound = computeBtnRound.value;
      const btnAlign = computeBtnAlign.value;
      const btnCircle = computeBtnCircle.value;
      const btnTransfer = computeBtnTransfer.value;
      const btnDisabled = computeBtnDisabled.value;
      const permissionInfo = computePermissionInfo.value;
      const downBtnList = computeDownBtnList.value;
      const vSize = computeSize.value;
      const dropdownsSlot = slots.dropdowns;
      if (!permissionInfo.visible) {
        return renderEmptyElement($xeButton);
      }
      if (dropdownsSlot || downBtnList.length) {
        const btnOns = {};
        const panelOns = {};
        if (trigger === 'hover') {
          // hover 触发
          btnOns.onMouseenter = mouseenterTargetEvent;
          btnOns.onMouseleave = mouseleaveTargetEvent;
          panelOns.onMouseenter = mouseenterDropdownEvent;
          panelOns.onMouseleave = mouseleaveDropdownEvent;
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-button--dropdown', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
            $button: $xeButton
          }) : className : '', {
            [`size--${vSize}`]: vSize,
            'is--active': visiblePanel
          }]
        }, [routerLink ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('router-link'), {
          ref: refButton,
          class: ['vxe-button', 'vxe-button--link', `type--${btnMode}`, btnAlign ? `align--${btnAlign}` : '', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
            $button: $xeButton
          }) : className : '', {
            [`size--${vSize}`]: vSize,
            [`theme--${btnStatus}`]: btnStatus,
            'is--round': btnRound,
            'is--circle': btnCircle,
            'is--disabled': btnDisabled || loading,
            'is--loading': loading
          }],
          title,
          name,
          type: isFormBtn ? type : 'button',
          disabled: btnDisabled || loading,
          to: routerLink,
          onClick: clickTargetEvent,
          ...btnOns
        }, {
          default() {
            return renderContent().concat([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
              class: `vxe-button--dropdown-arrow ${getIcon().BUTTON_DROPDOWN}`
            })]);
          }
        }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
          ref: refButton,
          class: ['vxe-button', `type--${btnMode}`, btnAlign ? `align--${btnAlign}` : '', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
            $button: $xeButton
          }) : className : '', {
            [`size--${vSize}`]: vSize,
            [`theme--${btnStatus}`]: btnStatus,
            'is--round': btnRound,
            'is--circle': btnCircle,
            'is--disabled': btnDisabled || loading,
            'is--loading': loading
          }],
          title,
          name,
          type: isFormBtn ? type : 'button',
          disabled: btnDisabled || loading,
          onClick: clickTargetEvent,
          ...btnOns
        }, renderContent().concat([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: `vxe-button--dropdown-arrow ${getIcon().BUTTON_DROPDOWN}`
        })])), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
          to: 'body',
          disabled: btnTransfer ? !initialized : true
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refBtnPanel,
          class: ['vxe-button--dropdown-panel', popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
            $button: $xeButton
          }) : popupClassName : '', {
            [`size--${vSize}`]: vSize,
            'is--transfer': btnTransfer,
            'ani--leave': isAniVisible,
            'ani--enter': visiblePanel
          }],
          placement: reactData.panelPlacement,
          style: reactData.panelStyle,
          ...panelOns
        }, initialized && (visiblePanel || isAniVisible) ? [dropdownsSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-button--dropdown-wrapper',
          onMousedown: mousedownDropdownEvent,
          onClick: clickDropdownEvent
        }, initialized && (destroyOnClose ? visiblePanel || isAniVisible : true) ? dropdownsSlot({}) : []) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-button--dropdown-wrapper'
        }, initialized && (destroyOnClose ? visiblePanel || isAniVisible : true) ? downBtnList.map((option, i) => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeButtonComponent, {
            key: i,
            type: option.type,
            mode: option.mode || btnMode,
            className: option.className,
            name: option.name,
            routerLink: option.routerLink,
            permissionCode: option.permissionCode,
            title: option.title,
            content: option.content,
            status: option.status,
            icon: option.icon,
            round: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(option.round) ? option.round : btnMode === 'text' ? false : btnRound,
            circle: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(option.circle) ? option.circle : btnMode === 'text' ? false : btnCircle,
            disabled: option.disabled,
            loading: option.loading,
            align: option.align,
            onClick(params) {
              downBtnClickEvent(params, option);
            }
          });
        }) : [])] : [])])]);
      }
      if (routerLink) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('router-link'), {
          ref: refButton,
          class: ['vxe-button', 'vxe-button--link', `type--${btnMode}`, btnAlign ? `align--${btnAlign}` : '', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
            $button: $xeButton
          }) : className : '', {
            [`size--${vSize}`]: vSize,
            [`theme--${btnStatus}`]: btnStatus,
            'is--round': btnRound,
            'is--circle': btnCircle,
            'is--disabled': btnDisabled || loading,
            'is--loading': loading
          }],
          title,
          name,
          type: isFormBtn ? type : 'button',
          disabled: btnDisabled || loading,
          to: routerLink,
          onClick: clickEvent,
          onMouseenter: mouseenterEvent,
          onMouseleave: mouseleaveEvent
        }, {
          default() {
            return renderContent();
          }
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        ref: refButton,
        class: ['vxe-button', `type--${btnMode}`, btnAlign ? `align--${btnAlign}` : '', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $button: $xeButton
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          [`theme--${btnStatus}`]: btnStatus,
          'is--round': btnRound,
          'is--circle': btnCircle,
          'is--disabled': btnDisabled || loading,
          'is--loading': loading
        }],
        title,
        name,
        type: isFormBtn ? type : 'button',
        disabled: btnDisabled || loading,
        onClick: clickEvent,
        onMouseenter: mouseenterEvent,
        onMouseleave: mouseleaveEvent
      }, renderContent());
    };
    $xeButton.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      if (props.type === 'text') {
        warnLog('vxe.error.delProp', ['type=text', 'mode=text']);
      }
      globalEvents.on($xeButton, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeButton, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeButton, 'resize', handleGlobalResizeEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeButton, 'mousewheel');
      globalEvents.off($xeButton, 'mousedown');
      globalEvents.off($xeButton, 'resize');
    });
    return $xeButton;
  },
  render() {
    return this.renderVN();
  }
});
/* harmony default export */ var src_button = (VxeButtonComponent);
;// CONCATENATED MODULE: ./packages/button/index.ts



const VxeButton = Object.assign({}, src_button, {
  install(app) {
    app.component(src_button.name, src_button);
  }
});
dynamicApp.use(VxeButton);
index_esm_VxeUI.component(src_button);
const Button = VxeButton;
/* harmony default export */ var packages_button = (VxeButton);
;// CONCATENATED MODULE: ./packages/button/src/button-group.ts





/* harmony default export */ var button_group = (defineVxeComponent({
  name: 'VxeButtonGroup',
  props: {
    options: Array,
    mode: String,
    status: String,
    round: Boolean,
    vertical: Boolean,
    circle: Boolean,
    align: String,
    className: [String, Function],
    disabled: Boolean,
    permissionCode: [String, Number],
    size: {
      type: String,
      default: () => getConfig().buttonGroup.size || getConfig().size
    }
  },
  emits: ['click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const computeMaps = {};
    const $xeButtonGroup = {
      xID,
      props,
      context,
      reactData,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const {
      computePermissionInfo
    } = usePermission(props);
    const buttonGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $buttonGroup: $xeButtonGroup
        }, params));
      }
    };
    const buttonGroupPrivateMethods = {
      handleClick(params, evnt) {
        const {
          options
        } = props;
        const {
          name
        } = params;
        const option = options ? options.find(item => item.name === name) : null;
        buttonGroupMethods.dispatchEvent('click', {
          ...params,
          option
        }, evnt);
      }
    };
    Object.assign($xeButtonGroup, buttonGroupMethods, buttonGroupPrivateMethods);
    const renderVN = () => {
      const {
        className,
        options,
        vertical
      } = props;
      const permissionInfo = computePermissionInfo.value;
      const defaultSlot = slots.default;
      if (!permissionInfo.visible) {
        return renderEmptyElement($xeButtonGroup);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-button-group', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $buttonGroup: $xeButtonGroup
        }) : className : '', {
          'is--vertical': vertical
        }]
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          key: index,
          ...item
        });
      }) : []);
    };
    $xeButtonGroup.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeButtonGroup', $xeButtonGroup);
    return $xeButtonGroup;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/button-group/index.ts



const VxeButtonGroup = Object.assign({}, button_group, {
  install(app) {
    app.component(button_group.name, button_group);
  }
});
dynamicApp.use(VxeButtonGroup);
index_esm_VxeUI.component(button_group);
const ButtonGroup = VxeButtonGroup;
/* harmony default export */ var packages_button_group = (VxeButtonGroup);
;// CONCATENATED MODULE: ./packages/date-panel/src/util.ts

function hasTimestampValueType(valueFormat) {
  return valueFormat === 'timestamp';
}
function hasDateValueType(valueFormat) {
  return valueFormat === 'date';
}
function handleValueFormat(type, valueFormat) {
  if (valueFormat) {
    if (!(hasDateValueType(valueFormat) || hasTimestampValueType(valueFormat))) {
      return valueFormat;
    }
  }
  if (type === 'time') {
    return 'HH:mm:ss';
  }
  if (type === 'datetime') {
    return 'yyyy-MM-dd HH:mm:ss';
  }
  return 'yyyy-MM-dd';
}
function toStringTimeDate(str) {
  const rest = new Date(2e3, 0, 1);
  if (str) {
    let h = 0;
    let m = 0;
    let s = 0;
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(str) || /^[0-9]{11,15}$/.test(`${str}`)) {
      str = new Date(Number(str));
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDate(str)) {
      h = str.getHours();
      m = str.getMinutes();
      s = str.getSeconds();
    } else {
      str = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(str);
      const parses = str.match(/^(\d{1,2})(:(\d{1,2}))?(:(\d{1,2}))?/);
      if (parses) {
        h = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(parses[1]);
        m = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(parses[3]);
        s = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(parses[5]);
      }
    }
    rest.setHours(h);
    rest.setMinutes(m);
    rest.setSeconds(s);
    return rest;
  }
  return rest;
}
function getDateQuarter(date) {
  const month = date.getMonth();
  if (month < 3) {
    return 1;
  } else if (month < 6) {
    return 2;
  } else if (month < 9) {
    return 3;
  }
  return 4;
}
const parseDateValue = (val, type, options) => {
  const {
    valueFormat
  } = options;
  if (val) {
    if (type === 'time') {
      return toStringTimeDate(val);
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(val) || /^[0-9]{10,15}$/.test(`${val}`)) {
      return new Date(Number(val));
    }
    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(val)) {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().last(val.split(',')), valueFormat);
    }
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(val, valueFormat);
  }
  return null;
};
const parseDateString = (val, type, options) => {
  const dValue = parseDateValue(val, type, options);
  return dValue ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(dValue, options.valueFormat) : '';
};
function parseDateObj(val, type, options) {
  const {
    labelFormat,
    firstDay
  } = options;
  let dValue = null;
  let dLabel = '';
  if (val) {
    dValue = parseDateValue(val, type, options);
  }
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(dValue)) {
    dLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(dValue, labelFormat, {
      firstDay
    });
    // 周选择器，由于年份和第几周是冲突的行为，所以需要特殊处理，判断是否跨年，例如
    // '2024-12-31' 'yyyy-MM-dd W' >> '2024-12-31 1'
    // '2025-01-01' 'yyyy-MM-dd W' >> '2025-01-01 1'
    if (labelFormat && type === 'week') {
      const weekNum = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getYearWeek(dValue, firstDay);
      const weekDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(dValue, 0, weekNum === 1 ? (6 + firstDay) % 7 : firstDay, firstDay);
      const weekFullYear = weekDate.getFullYear();
      if (weekFullYear !== dValue.getFullYear()) {
        const yyIndex = labelFormat.indexOf('yyyy');
        if (yyIndex > -1) {
          const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
          if (yyNum && !isNaN(yyNum)) {
            dLabel = dLabel.replace(`${yyNum}`, `${weekFullYear}`);
          }
        }
      }
    }
  } else {
    dValue = null;
  }
  return {
    label: dLabel,
    value: dValue
  };
}
function getDateByCode(code, val, type, options) {
  const {
    valueFormat,
    firstDay
  } = options;
  let dValue = null;
  const value = (code === 'prev' || code === 'next' ? new Date() : val ? parseDateValue(val, type, options) : null) || new Date();
  switch (code) {
    case 'prev':
    case 'next':
    case 'minus':
    case 'plus':
      {
        const offsetNum = code === 'plus' || code === 'next' ? 1 : -1;
        switch (type) {
          case 'date':
          case 'datetime':
            dValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(value, offsetNum);
            break;
          case 'week':
            dValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(value, offsetNum, firstDay, firstDay);
            break;
          case 'month':
            dValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(value, offsetNum);
            break;
          case 'quarter':
            dValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(value, offsetNum);
            break;
          case 'year':
            dValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(value, offsetNum);
            break;
        }
        break;
      }
    default:
      dValue = new Date();
      break;
  }
  return {
    value: dValue ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(dValue, valueFormat) : ''
  };
}
const rangeDateOffsetNumMaps = {
  last180: -180,
  last90: -90,
  last60: -60,
  last30: -30,
  last7: -7,
  last3: -3,
  last1: -1
};
function getRangeDateOffsetNum(code) {
  return rangeDateOffsetNumMaps[code] || 0;
}
function getRangeDateByCode(code, val, type, options) {
  const {
    valueFormat,
    firstDay
  } = options;
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(val)) {
    val = val.join('');
  }
  const value = (val ? parseDateValue(val, type, options) : null) || new Date();
  let sValue = null;
  const eValue = value;
  switch (code) {
    case 'last1':
    case 'last3':
    case 'last7':
    case 'last30':
    case 'last60':
    case 'last90':
    case 'last180':
      {
        const offsetNum = getRangeDateOffsetNum(code);
        switch (type) {
          case 'date':
          case 'datetime':
            sValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(value, offsetNum);
            break;
          case 'week':
            sValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(value, offsetNum, firstDay, firstDay);
            break;
          case 'month':
            sValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(value, offsetNum);
            break;
          case 'quarter':
            sValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(value, offsetNum);
            break;
          case 'year':
            sValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(value, offsetNum);
            break;
        }
        break;
      }
    default:
      sValue = new Date();
      break;
  }
  const startValue = sValue ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(sValue, valueFormat) : '';
  const endValue = eValue ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(eValue, valueFormat) : '';
  return {
    startValue,
    endValue
  };
}
;// CONCATENATED MODULE: ./packages/calendar/src/calendar.ts








/* harmony default export */ var calendar = (defineVxeComponent({
  name: 'VxeCalendar',
  props: {
    modelValue: [String, Number, Date],
    type: {
      type: String,
      default: 'date'
    },
    className: String,
    size: {
      type: String,
      default: () => getConfig().calendar.size || getConfig().size
    },
    multiple: Boolean,
    width: [String, Number],
    height: [String, Number],
    // date、week、month、quarter、year
    minDate: {
      type: [String, Number, Date],
      default: () => getConfig().calendar.minDate
    },
    maxDate: {
      type: [String, Number, Date],
      default: () => getConfig().calendar.maxDate
    },
    startDay: {
      type: [String, Number],
      default: () => getConfig().calendar.startDay
    },
    labelFormat: String,
    valueFormat: String,
    festivalMethod: {
      type: Function,
      default: () => getConfig().calendar.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().calendar.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().calendar.selectDay
    }
  },
  emits: ['update:modelValue', 'change', 'click', 'date-prev', 'date-today', 'date-next', 'view-change'],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      selectValue: props.modelValue,
      inputValue: props.modelValue,
      datePanelValue: null,
      datePanelLabel: '',
      datePanelType: 'day',
      selectMonth: null,
      currentDate: null
    });
    const internalData = {
      yearSize: 12,
      monthSize: 20,
      quarterSize: 8
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xeCalendar = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const computeCalendarStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        height,
        width
      } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return false;
    });
    const computeIsCalendarType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return ['date', 'week', 'month', 'quarter', 'year'].indexOf(props.type) > -1;
    });
    const computeDateStartTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.minDate ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(props.minDate) : null;
    });
    const computeDateEndTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.maxDate ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(props.maxDate) : null;
    });
    const computeSupportMultiples = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return ['date', 'week', 'month', 'quarter', 'year'].indexOf(props.type) > -1;
    });
    const computeDateListValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        multiple
      } = props;
      const {
        selectValue
      } = reactData;
      const isCalendarType = computeIsCalendarType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && selectValue && isCalendarType) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(selectValue).split(',').map(item => {
          const date = parseDate(item, dateValueFormat);
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(date)) {
            return date;
          }
          return null;
        });
      }
      return [];
    });
    const computeDateMultipleValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateLabelFormat)).join(', ');
    });
    const computeDateValueFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        valueFormat
      } = props;
      if (valueFormat) {
        return valueFormat;
      }
      return 'yyyy-MM-dd';
    });
    const computeDateValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectValue
      } = reactData;
      const isCalendarType = computeIsCalendarType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (selectValue && isCalendarType) {
        const date = parseDate(selectValue, dateValueFormat);
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateStartTime = computeDateStartTime.value;
      const {
        selectMonth
      } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateEndTime = computeDateEndTime.value;
      const {
        selectMonth
      } = reactData;
      if (selectMonth && dateEndTime) {
        return selectMonth >= dateEndTime;
      }
      return false;
    });
    const computeDateHMSTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateValue = computeDateValue.value;
      return dateValue ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1000 : 0;
    });
    const computeDateLabelFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        labelFormat
      } = props;
      const isCalendarType = computeIsCalendarType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (isCalendarType) {
        return labelFormat || dateValueFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return null;
    });
    const computeYearList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const {
        yearSize
      } = internalData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (let index = -4; index < yearSize + 4; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(startYearDate, index, 'first');
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelObj = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isCalendarType = computeIsCalendarType.value;
      let y = '';
      let m = '';
      if (isCalendarType) {
        const {
          datePanelType,
          selectMonth
        } = reactData;
        const yearList = computeYearList.value;
        let year = '';
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === 'quarter' || datePanelType === 'month') {
          y = `${year}`;
        } else if (datePanelType === 'year') {
          y = yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : '';
        } else {
          y = `${year}`;
          m = month ? getI18n(`vxe.input.date.m${month}`) : '-';
        }
      }
      return {
        y,
        m
      };
    });
    const computeFirstDayOfWeek = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        startDay
      } = props;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(startDay);
    });
    const computeWeekDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const weeks = [];
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index = 0; index < 6; index++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map(day => {
          return {
            value: day,
            label: getI18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        const dateHeaders = computeDateHeaders.value;
        return [{
          label: getI18n('vxe.input.date.weeks.w')
        }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const yearList = computeYearList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(yearList, 4);
    });
    const computeQuarterList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const {
        quarterSize
      } = internalData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter(currentDate);
        const firstYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, 'first');
        const selFullYear = firstYear.getFullYear();
        for (let index = -2; index < quarterSize - 2; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(firstYear, index);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const quarterList = computeQuarterList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(quarterList, 2);
    });
    const computeMonthList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const {
        monthSize
      } = internalData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, 'first').getFullYear();
        for (let index = -4; index < monthSize - 4; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const monthList = computeMonthList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(monthList, 4);
    });
    const computeDayList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index = 0; index < 42; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(startDayDate, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dayList = computeDayList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(dayList, 7);
    });
    const computeWeekDates = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map(list => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const parseDate = (value, format) => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(value, format);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit('update:modelValue', value);
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(props.modelValue) !== value) {
        dispatchEvent('change', {
          value
        }, evnt);
      }
    };
    const dateParseValue = value => {
      const {
        type
      } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let dValue = null;
      let dLabel = '';
      if (value) {
        dValue = parseDate(value, dateValueFormat);
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(dValue)) {
        dLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(dValue, dateLabelFormat, {
          firstDay: firstDayOfWeek
        });
        // 由于年份和第几周是冲突的行为，所以需要特殊处理，判断是否跨年
        if (dateLabelFormat && type === 'week') {
          const firstWeekDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(dValue, 0, firstDayOfWeek, firstDayOfWeek);
          if (firstWeekDate.getFullYear() < dValue.getFullYear()) {
            const yyIndex = dateLabelFormat.indexOf('yyyy');
            if (yyIndex > -1) {
              const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
              if (yyNum && !isNaN(yyNum)) {
                dLabel = dLabel.replace(`${yyNum}`, `${yyNum - 1}`);
              }
            }
          }
        }
      } else {
        dValue = null;
      }
      reactData.datePanelValue = dValue;
      reactData.datePanelLabel = dLabel;
    };
    /**
     * 值变化时处理
     */
    const changeValue = () => {
      const isCalendarType = computeIsCalendarType.value;
      const {
        inputValue
      } = reactData;
      if (isCalendarType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    /**
     * 检查初始值
     */
    const initValue = () => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        changeValue();
      }
    };
    const dateCheckMonth = date => {
      const month = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(date, 0, 'first');
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = date => {
      const {
        modelValue,
        multiple
      } = props;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === 'week') {
        const sWeek = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.selectDay);
        date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      }
      const inpVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat, {
        firstDay: firstDayOfWeek
      });
      dateCheckMonth(date);
      reactData.selectValue = date;
      if (multiple) {
        // 如果为多选
        const dateMultipleValue = computeDateMultipleValue.value;
        // 如果是日期类型
        if (dateMultipleValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(val, inpVal))) {
          handleChange(dateMultipleValue.filter(val => !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(val, inpVal)).join(','), {
            type: 'update'
          });
        } else {
          handleChange(dateMultipleValue.concat([inpVal]).join(','), {
            type: 'update'
          });
        }
      } else {
        // 如果为单选
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(modelValue, inpVal)) {
          handleChange(inpVal, {
            type: 'update'
          });
        }
      }
    };
    const dateMonthHandle = (date, offsetMonth) => {
      reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(date, offsetMonth, 'first');
    };
    const dateNowHandle = () => {
      const currentDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleYearTypeEvent = () => {
      reactData.datePanelType = 'year';
    };
    const dateToggleMonthTypeEvent = evnt => {
      let {
        datePanelType
      } = reactData;
      if (datePanelType === 'month' || datePanelType === 'quarter') {
        datePanelType = 'year';
      } else {
        datePanelType = 'month';
      }
      reactData.datePanelType = datePanelType;
      changeViewEvent(evnt);
    };
    const datePrevEvent = evnt => {
      const {
        type
      } = props;
      const {
        datePanelType,
        selectMonth
      } = reactData;
      const {
        yearSize
      } = internalData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        if (type === 'year') {
          reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
        } else if (type === 'month' || type === 'quarter') {
          if (datePanelType === 'year') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
          } else {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -1, 'first');
          }
        } else {
          if (datePanelType === 'year') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
          } else if (datePanelType === 'month') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -1, 'first');
          } else {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(selectMonth, -1, 'first');
          }
        }
        dispatchEvent('date-prev', {
          type
        }, evnt);
        changeViewEvent(evnt);
      }
    };
    const dateTodayMonthEvent = evnt => {
      dateNowHandle();
      if (!props.multiple) {
        dateChange(reactData.currentDate);
      }
      dispatchEvent('date-today', {
        type: props.type
      }, evnt);
      changeViewEvent(evnt);
    };
    const dateNextEvent = evnt => {
      const {
        type
      } = props;
      const {
        datePanelType,
        selectMonth
      } = reactData;
      const {
        yearSize
      } = internalData;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        if (type === 'year') {
          reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
        } else if (type === 'month' || type === 'quarter') {
          if (datePanelType === 'year') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
          } else {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 1, 'first');
          }
        } else {
          if (datePanelType === 'year') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
          } else if (datePanelType === 'month') {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 1, 'first');
          } else {
            reactData.selectMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(selectMonth, 1, 'first');
          }
        }
        dispatchEvent('date-next', {
          type
        }, evnt);
        changeViewEvent(evnt);
      }
    };
    const isDateDisabled = item => {
      const {
        disabledMethod
      } = props;
      const {
        datePanelType
      } = reactData;
      return disabledMethod && disabledMethod({
        type: datePanelType,
        viewType: datePanelType,
        date: item.date,
        $calendar: $xeCalendar
      });
    };
    const changeViewEvent = evnt => {
      const {
        datePanelType
      } = reactData;
      const yearDatas = computeYearDatas.value;
      const quarterDatas = computeQuarterDatas.value;
      const monthDatas = computeMonthDatas.value;
      const weekDates = computeWeekDates.value;
      const dayDatas = computeDayDatas.value;
      const viewDates = [];
      let dataList = [];
      switch (datePanelType) {
        case 'year':
          dataList = yearDatas;
          break;
        case 'quarter':
          dataList = quarterDatas;
          break;
        case 'month':
          dataList = monthDatas;
          break;
        case 'week':
          dataList = weekDates;
          break;
        case 'day':
          dataList = dayDatas;
          break;
      }
      dataList.forEach(rows => {
        rows.forEach(item => {
          viewDates.push(item.date);
        });
      });
      dispatchEvent('view-change', {
        viewType: datePanelType,
        viewDates
      }, evnt);
    };
    const dateSelectItem = date => {
      const {
        type
      } = props;
      const {
        datePanelType
      } = reactData;
      if (type === 'month') {
        if (datePanelType === 'year') {
          reactData.datePanelType = 'month';
          dateCheckMonth(date);
          changeViewEvent(null);
        } else {
          dateChange(date);
        }
      } else if (type === 'year') {
        dateChange(date);
      } else if (type === 'quarter') {
        if (datePanelType === 'year') {
          reactData.datePanelType = 'quarter';
          dateCheckMonth(date);
          changeViewEvent(null);
        } else {
          dateChange(date);
        }
      } else {
        if (datePanelType === 'month') {
          reactData.datePanelType = type === 'week' ? type : 'day';
          dateCheckMonth(date);
          changeViewEvent(null);
        } else if (datePanelType === 'year') {
          reactData.datePanelType = 'month';
          dateCheckMonth(date);
          changeViewEvent(null);
        } else {
          dateChange(date);
        }
      }
    };
    const dateSelectEvent = item => {
      if (!isDateDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = offsetDay => {
      if (!isDateDisabled({
        date: offsetDay
      })) {
        const dayList = computeDayList.value;
        if (!dayList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetDay, 'yyyyMMdd'))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = offsetYear => {
      if (!isDateDisabled({
        date: offsetYear
      })) {
        const yearList = computeYearList.value;
        if (!yearList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetYear, 'yyyy'))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = offsetQuarter => {
      if (!isDateDisabled({
        date: offsetQuarter
      })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetQuarter, 'yyyyq'))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = offsetMonth => {
      if (!isDateDisabled({
        date: offsetMonth
      })) {
        const monthList = computeMonthList.value;
        if (!monthList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetMonth, 'yyyyMM'))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = item => {
      if (!isDateDisabled(item)) {
        const {
          datePanelType
        } = reactData;
        if (datePanelType === 'month') {
          dateMoveMonth(item.date);
        } else if (datePanelType === 'quarter') {
          dateMoveQuarter(item.date);
        } else if (datePanelType === 'year') {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const dateConfirmEvent = () => {};
    const dateOpenPanel = () => {
      const {
        type
      } = props;
      const dateValue = computeDateValue.value;
      if (['year', 'quarter', 'month', 'week'].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = 'day';
      }
      reactData.currentDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        dateNowHandle();
      }
    };
    const renderDateLabel = (item, label) => {
      const {
        festivalMethod
      } = props;
      if (festivalMethod) {
        const {
          datePanelType
        } = reactData;
        const festivalRest = festivalMethod({
          type: datePanelType,
          viewType: datePanelType,
          date: item.date,
          $calendar: $xeCalendar
        });
        const festivalItem = festivalRest ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(festivalRest) ? {
          label: festivalRest
        } : festivalRest : {};
        const extraItem = festivalItem.extra ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(festivalItem.extra) ? {
          label: festivalItem.extra
        } : festivalItem.extra : null;
        const labels = [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-calendar--date-label', {
            'is-notice': festivalItem.notice
          }]
        }, extraItem && extraItem.label ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', `${label || ''}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-calendar--date-label--extra', extraItem.important ? 'is-important' : '', extraItem.className],
          style: extraItem.style
        }, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(extraItem.label))] : [`${label || ''}`])];
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          // 默认最多支持3个节日重叠
          const festivalLabels = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(festivalLabel).split(',');
          labels.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-calendar--date-festival', festivalItem.important ? 'is-important' : '', festivalItem.className],
            style: festivalItem.style
          }, [festivalLabels.length > 1 ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-calendar--date-festival--overlap', `overlap--${festivalLabels.length}`]
          }, festivalLabels.map(label => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', label.substring(0, 3)))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-calendar--date-festival--label'
          }, festivalLabels[0].substring(0, 3))]));
        }
        return labels;
      }
      return `${label || ''}`;
    };
    const renderDateDayTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyMMdd';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-calendar--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', dateHeaders.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', {
          class: 'vxe-calendar--view-th'
        }, item.label);
      })), ...dayDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: ['vxe-calendar--view-td', {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            }],
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, item.label));
        }));
      })])];
    };
    const renderDateWeekTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyMMdd';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-calendar--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', weekHeaders.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
          class: 'vxe-calendar--view-th'
        }, item.label);
      })), ...weekDates.map(rows => {
        const isSelected = multiple ? rows.some(item => dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat))) : rows.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat));
        const isHover = rows.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat));
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: ['vxe-calendar--view-td', {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': isSelected,
              'is--hover': isHover
            }],
            // event
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, item.label));
        }));
      })])];
    };
    const renderDateMonthTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyMM';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-calendar--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', monthDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: ['vxe-calendar--view-td', {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            }],
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, getI18n(`vxe.input.date.months.m${item.month}`)));
        }));
      }))])];
    };
    const renderDateQuarterTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyq';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-calendar--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', quarterDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: ['vxe-calendar--view-td', {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            }],
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, getI18n(`vxe.input.date.quarters.q${item.quarter}`)));
        }));
      }))])];
    };
    const renderDateYearTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyy';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-calendar--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', yearDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: ['vxe-calendar--view-td', {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            }],
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, item.year));
        }));
      }))])];
    };
    const renderDateTable = () => {
      const {
        datePanelType
      } = reactData;
      switch (datePanelType) {
        case 'week':
          return renderDateWeekTable();
        case 'month':
          return renderDateMonthTable();
        case 'quarter':
          return renderDateQuarterTable();
        case 'year':
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType
      } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelObj = computeSelectDatePanelObj.value;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-calendar--header'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-calendar--type-wrapper'
      }, [datePanelType === 'year' ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        class: 'vxe-calendar--date-picker-label',
        disabled: datePanelType === 'year',
        content: selectDatePanelObj.y
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-calendar--date-picker-btns'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        class: 'vxe-calendar--date-picker-btn',
        content: selectDatePanelObj.y,
        onClick: dateToggleYearTypeEvent
      }), selectDatePanelObj.m ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        class: 'vxe-calendar--date-picker-btn',
        content: selectDatePanelObj.m,
        onClick: dateToggleMonthTypeEvent
      }) : renderEmptyElement($xeCalendar)])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-calendar--btn-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        disabled: isDisabledPrevDateBtn,
        icon: 'vxe-icon-caret-left',
        onClick: datePrevEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        icon: 'vxe-icon-dot',
        onClick: dateTodayMonthEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        disabled: isDisabledNextDateBtn,
        icon: 'vxe-icon-caret-right',
        onClick: dateNextEvent
      }), multiple && computeSupportMultiples.value ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-calendar--btn vxe-calendar--confirm-btn'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: 'vxe-calendar--confirm',
        type: 'button',
        onClick: dateConfirmEvent
      }, getI18n('vxe.button.confirm'))]) : null])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-calendar--body'
      }, renderDateTable())];
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $input: $xeCalendar
      }, params));
    };
    const calendarMethods = {
      dispatchEvent
    };
    Object.assign($xeCalendar, calendarMethods);
    const renderVN = () => {
      const {
        className,
        type
      } = props;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const calendarStyle = computeCalendarStyle.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-calendar', `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          'is--disabled': isDisabled
        }],
        style: calendarStyle
      }, [renderDatePanel()]);
    };
    $xeCalendar.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.inputValue = val;
      changeValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.type, () => {
      // 切换类型是重置内置变量
      Object.assign(reactData, {
        selectValue: null,
        inputValue: null,
        datePanelValue: null,
        datePanelLabel: '',
        datePanelType: 'day',
        selectMonth: null,
        currentDate: null
      });
      initValue();
      dateOpenPanel();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeDateLabelFormat, () => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      dateOpenPanel();
    });
    initValue();
    return $xeCalendar;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/calendar/index.ts



const VxeCalendar = Object.assign({}, calendar, {
  install(app) {
    app.component(calendar.name, calendar);
  }
});
dynamicApp.use(VxeCalendar);
index_esm_VxeUI.component(calendar);
const Calendar = VxeCalendar;
/* harmony default export */ var packages_calendar = (VxeCalendar);
;// CONCATENATED MODULE: ./packages/loading/src/loading.ts





/* harmony default export */ var src_loading = (defineVxeComponent({
  name: 'VxeLoading',
  props: {
    modelValue: Boolean,
    icon: {
      type: String,
      default: () => getConfig().loading.icon
    },
    showIcon: {
      type: Boolean,
      default: () => getConfig().loading.showIcon
    },
    text: {
      type: String,
      default: () => getConfig().loading.text
    },
    showText: {
      type: Boolean,
      default: () => getConfig().loading.showText
    },
    status: String,
    size: {
      type: String,
      default: () => getConfig().loading.size || getConfig().size
    }
  },
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false
    });
    const computeMaps = {
      computeSize
    };
    const $xeLoading = {
      xID,
      props,
      context,
      reactData,
      getComputeMaps: () => computeMaps
    };
    const computeLoadingIcon = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.icon || getIcon().LOADING;
    });
    const computeLoadingText = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        text
      } = props;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(text) ? text : getI18n('vxe.loading.text');
    });
    const handleInit = () => {
      if (!reactData.initialized) {
        reactData.initialized = !!reactData.initialized;
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $loading: $xeLoading
      }, params));
    };
    const loadingMethods = {
      dispatchEvent
    };
    const loadingPrivateMethods = {};
    Object.assign($xeLoading, loadingMethods, loadingPrivateMethods);
    const renderVN = () => {
      const {
        modelValue,
        showIcon,
        status
      } = props;
      const {
        initialized
      } = reactData;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      const textSlot = slots.text;
      const iconSlot = slots.icon;
      const loadingIcon = computeLoadingIcon.value;
      const loadingText = computeLoadingText.value;
      if (!initialized && !modelValue) {
        return renderEmptyElement($xeLoading);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-loading', {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          'is--visible': modelValue
        }]
      }, defaultSlot ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-loading--wrapper'
      }, vn_getSlotVNs(defaultSlot({})))] : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-loading--chunk'
      }, [showIcon && (iconSlot || loadingIcon) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-loading--icon'
      }, iconSlot ? vn_getSlotVNs(iconSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: loadingIcon
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-loading--spinner'
      }), textSlot || loadingText ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-loading--text'
      }, textSlot ? vn_getSlotVNs(textSlot({})) : `${loadingText}`) : null])]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, () => {
      handleInit();
    });
    handleInit();
    $xeLoading.renderVN = renderVN;
    return $xeLoading;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/card/src/card.ts







/* harmony default export */ var card = (defineVxeComponent({
  name: 'VxeCard',
  props: {
    title: String,
    showTitleOverflow: {
      type: Boolean,
      default: () => getConfig().card.showTitleOverflow
    },
    width: [String, Number],
    height: [String, Number],
    border: {
      type: Boolean,
      default: () => getConfig().card.border
    },
    loading: Boolean,
    shadow: {
      type: Boolean,
      default: () => getConfig().card.shadow
    },
    padding: {
      type: Boolean,
      default: () => getConfig().card.padding
    }
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeCardStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        height,
        width
      } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeMaps = {};
    const $xeCard = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $card: $xeCard
      }, params));
    };
    const cardMethods = {
      dispatchEvent
    };
    const cardPrivateMethods = {};
    Object.assign($xeCard, cardMethods, cardPrivateMethods);
    const renderVN = () => {
      const {
        title,
        border,
        shadow,
        padding,
        loading,
        showTitleOverflow
      } = props;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const titleSlot = slots.title;
      const extraSlot = slots.extra;
      const footerSlot = slots.footer;
      const leftSlot = slots.left;
      const rightSlot = slots.right;
      const cardStyle = computeCardStyle.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-card', {
          'is--border': border,
          'is--shadow': shadow,
          'is--padding': padding
        }],
        style: cardStyle
      }, [title || titleSlot || headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-card--header'
      }, headerSlot ? vn_getSlotVNs(headerSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-card--header-title', {
          'is--ellipsis': showTitleOverflow
        }]
      }, titleSlot ? vn_getSlotVNs(titleSlot({})) : `${title || ''}`), extraSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-card--header-extra'
      }, vn_getSlotVNs(extraSlot({}))) : renderEmptyElement($xeCard)]) : renderEmptyElement($xeCard), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-card--body'
      }, [leftSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-card--body-left'
      }, vn_getSlotVNs(leftSlot({}))) : renderEmptyElement($xeCard), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-card--body-content'
      }, defaultSlot ? vn_getSlotVNs(defaultSlot({})) : []), rightSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-card--body-right'
      }, vn_getSlotVNs(rightSlot({}))) : renderEmptyElement($xeCard)]), footerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-card--footer'
      }, vn_getSlotVNs(footerSlot({}))) : renderEmptyElement($xeCard),
      /**
       * 加载中
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-card--loading',
        modelValue: loading
      })]);
    };
    $xeCard.renderVN = renderVN;
    return $xeCard;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/card/index.ts



const VxeCard = Object.assign({}, card, {
  install(app) {
    app.component(card.name, card);
  }
});
dynamicApp.use(VxeCard);
index_esm_VxeUI.component(card);
const Card = VxeCard;
/* harmony default export */ var packages_card = (VxeCard);
;// CONCATENATED MODULE: ./packages/carousel/src/carousel.ts







/* harmony default export */ var carousel = (defineVxeComponent({
  name: 'VxeCarousel',
  props: {
    modelValue: [String, Number],
    options: Array,
    loading: Boolean,
    height: {
      type: [Number, String],
      default: () => getConfig().carousel.height
    },
    width: {
      type: [Number, String],
      default: () => getConfig().carousel.width
    },
    autoPlay: {
      type: Boolean,
      default: () => getConfig().carousel.autoPlay
    },
    interval: {
      type: [Number, String],
      default: () => getConfig().carousel.interval
    },
    loop: {
      type: Boolean,
      default: () => getConfig().carousel.loop
    },
    vertical: {
      type: Boolean,
      default: () => getConfig().carousel.vertical
    },
    showIndicators: {
      type: Boolean,
      default: () => getConfig().carousel.showIndicators
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refWrapperElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      activeName: '',
      staticItems: [],
      itemWidth: 0,
      itemHeight: 0
    });
    const internalData = {
      apTimeout: undefined,
      stopFlag: false
    };
    const refMaps = {
      refElem
    };
    const computeListStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        vertical,
        options
      } = props;
      const {
        activeName,
        itemWidth,
        itemHeight,
        staticItems
      } = reactData;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      const activeIndex = Math.max(0, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(list, item => item.name === activeName));
      const stys = {};
      if (vertical) {
        stys.transform = `translateY(-${activeIndex * itemHeight}px)`;
      } else {
        stys.width = `${itemWidth * list.length}px`;
        stys.transform = `translateX(-${activeIndex * itemWidth}px)`;
      }
      return stys;
    });
    const computeMaps = {};
    const $xeCarousel = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const updateStyle = () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const wrapperElem = refWrapperElem.value;
        if (wrapperElem) {
          reactData.itemWidth = wrapperElem.clientWidth;
          reactData.itemHeight = wrapperElem.clientHeight;
        }
      });
    };
    const clickItemEvent = (evnt, item) => {
      const value = item.name;
      reactData.activeName = item.name;
      emit('update:modelValue', value);
      emit('change', {
        value
      }, evnt);
      updateStyle();
    };
    const initDefaultActive = list => {
      let activeName = null;
      if (list && list.length) {
        let validVal = false;
        activeName = props.modelValue;
        list.forEach(item => {
          if (activeName === item.name) {
            validVal = true;
          }
        });
        if (!validVal) {
          activeName = list[0].name;
          emit('update:modelValue', activeName);
        }
      }
      reactData.activeName = activeName;
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $carousel: $xeCarousel
      }, params));
    };
    const handlePrevNext = isNext => {
      const {
        options,
        loop
      } = props;
      const {
        activeName,
        staticItems
      } = reactData;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      const index = Math.max(0, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(list, item => item.name === activeName));
      if (index > -1) {
        let item = null;
        if (isNext) {
          if (index < list.length - 1) {
            item = list[index + 1];
          } else {
            if (loop) {
              item = list[0];
            }
          }
        } else {
          if (index > 0) {
            item = list[index - 1];
          } else {
            if (loop) {
              item = list[list.length - 1];
            }
          }
        }
        if (item) {
          const name = item.name;
          const value = name;
          reactData.activeName = name;
          emit('update:modelValue', value);
          return true;
        }
      }
      return false;
    };
    const carouselMethods = {
      dispatchEvent,
      prev() {
        if (handlePrevNext(false)) {
          handleAutoPlay();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      next() {
        if (handlePrevNext(true)) {
          handleAutoPlay();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    const prevEvent = evnt => {
      if (handlePrevNext(false)) {
        const value = reactData.activeName;
        emit('change', {
          value
        }, evnt);
      }
    };
    const nextEvent = evnt => {
      if (handlePrevNext(true)) {
        const value = reactData.activeName;
        emit('change', {
          value
        }, evnt);
      }
    };
    const stopAutoPlay = () => {
      const {
        apTimeout
      } = internalData;
      internalData.stopFlag = true;
      if (apTimeout) {
        clearTimeout(apTimeout);
        internalData.apTimeout = undefined;
      }
    };
    const handleAutoPlay = () => {
      const {
        autoPlay,
        interval
      } = props;
      const {
        stopFlag
      } = internalData;
      stopAutoPlay();
      if (autoPlay) {
        internalData.stopFlag = false;
        internalData.apTimeout = setTimeout(() => {
          if (!stopFlag) {
            handlePrevNext(true);
          }
        }, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(interval) || 300);
      }
    };
    const mouseenterEvent = () => {
      stopAutoPlay();
    };
    const mouseleaveEvent = () => {
      handleAutoPlay();
    };
    const carouselPrivateMethods = {};
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
          return vn_getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    Object.assign($xeCarousel, carouselMethods, carouselPrivateMethods);
    const renderItemWrapper = list => {
      const {
        height
      } = props;
      const {
        activeName
      } = reactData;
      const listStyle = computeListStyle.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-carousel--list',
        style: listStyle
      }, list.map(item => {
        const {
          name,
          url,
          slots
        } = item;
        const defaultSlot = slots ? slots.default : null;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: `${name}`,
          class: ['vxe-carousel--item-inner', {
            'is--active': activeName === name
          }],
          style: height ? {
            height: toCssUnit(height)
          } : null
        }, defaultSlot ? callSlot(defaultSlot, {}) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('img', {
          class: 'vxe-carousel--item-img',
          src: url
        })]);
      }));
    };
    const renderIndicators = list => {
      const {
        activeName
      } = reactData;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-carousel--indicators'
      }, list.map(item => {
        const {
          name
        } = item;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: `${name}`,
          class: ['vxe-carousel--indicators-item', {
            'is--active': activeName === name
          }],
          onClick(evnt) {
            clickItemEvent(evnt, item);
          }
        });
      }));
    };
    const renderVN = () => {
      const {
        loading,
        height,
        width,
        showIndicators,
        vertical,
        options
      } = props;
      const {
        staticItems
      } = reactData;
      const defaultSlot = slots.default;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-carousel', `is--${vertical ? 'vertical' : 'horizontal'}`],
        style: width ? {
          width: toCssUnit(width)
        } : null,
        onMouseenter: mouseenterEvent,
        onMouseleave: mouseleaveEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-carousel--slots'
      }, defaultSlot ? defaultSlot({}) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refWrapperElem,
        class: 'vxe-carousel--item-wrapper',
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, [renderItemWrapper(list)]), showIndicators ? renderIndicators(list) : renderEmptyElement($xeCarousel), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-carousel--btn-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-carousel--previous-btn',
        onClick: prevEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: vertical ? getIcon().CAROUSEL_VERTICAL_PREVIOUS : getIcon().CAROUSEL_HORIZONTAL_PREVIOUS
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-carousel--next-btn',
        onClick: nextEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: vertical ? getIcon().CAROUSEL_VERTICAL_NEXT : getIcon().CAROUSEL_HORIZONTAL_NEXT
      })])]),
      /**
       * 加载中
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-carousel--loading',
        modelValue: loading
      })]);
    };
    const optsFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options, () => {
      optsFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(optsFlag, () => {
      initDefaultActive(props.options);
    });
    const stFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticItems ? reactData.staticItems.length : -1, () => {
      stFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticItems, () => {
      stFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(stFlag, () => {
      initDefaultActive(reactData.staticItems);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.autoPlay, () => {
      handleAutoPlay();
    });
    initDefaultActive(reactData.staticItems.length ? reactData.staticItems : props.options);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      handleAutoPlay();
      updateStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      stopAutoPlay();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeCarousel', $xeCarousel);
    $xeCarousel.renderVN = renderVN;
    return $xeCarousel;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/carousel/index.ts



const VxeCarousel = Object.assign({}, carousel, {
  install(app) {
    app.component(carousel.name, carousel);
  }
});
dynamicApp.use(VxeCarousel);
index_esm_VxeUI.component(carousel);
const Carousel = VxeCarousel;
/* harmony default export */ var packages_carousel = (VxeCarousel);
;// CONCATENATED MODULE: ./packages/carousel/src/util.ts

function assembleCarouselItem($xeCarousel, elem, itemConfig) {
  const staticItems = $xeCarousel.reactData.staticItems;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticItems.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, elem), 0, itemConfig);
  }
  $xeCarousel.reactData.staticItems = staticItems.slice(0);
}
function destroyCarouselItem($xeCarousel, itemConfig) {
  const staticItems = $xeCarousel.reactData.staticItems;
  const index = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(staticItems, item => item.id === itemConfig.id);
  if (index > -1) {
    staticItems.splice(index, 1);
  }
  $xeCarousel.reactData.staticItems = staticItems.slice(0);
}
;// CONCATENATED MODULE: ./packages/carousel/src/carousel-item.ts





/* harmony default export */ var carousel_item = (defineVxeComponent({
  name: 'VxeCarouselItem',
  props: {
    name: [String, Number],
    className: String,
    url: String
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeCarousel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeCarousel', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const itemConfig = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      id: xID,
      name: props.name,
      url: props.url,
      className: props.className,
      slots
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeCarouselItem = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $carouselItem: $xeCarouselItem
      }, params));
    };
    const carouselItemMethods = {
      dispatchEvent
    };
    const carouselItemPrivateMethods = {};
    Object.assign($xeCarouselItem, carouselItemMethods, carouselItemPrivateMethods);
    const renderVN = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      });
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.name, val => {
      itemConfig.name = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.url, val => {
      itemConfig.url = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const elem = refElem.value;
      if ($xeCarousel && elem) {
        assembleCarouselItem($xeCarousel, elem, itemConfig);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      if ($xeCarousel) {
        destroyCarouselItem($xeCarousel, itemConfig);
      }
    });
    $xeCarouselItem.renderVN = renderVN;
    return $xeCarouselItem;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/carousel-item/index.ts



const VxeCarouselItem = Object.assign({}, carousel_item, {
  install(app) {
    app.component(carousel_item.name, carousel_item);
  }
});
dynamicApp.use(VxeCarouselItem);
index_esm_VxeUI.component(carousel_item);
const CarouselItem = VxeCarouselItem;
/* harmony default export */ var packages_carousel_item = (VxeCarouselItem);
;// CONCATENATED MODULE: ./packages/checkbox/src/checkbox.ts





/* harmony default export */ var src_checkbox = (defineVxeComponent({
  name: 'VxeCheckbox',
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number],
      default: null
    },
    indeterminate: Boolean,
    title: [String, Number],
    checkedValue: {
      type: [String, Number, Boolean],
      default: true
    },
    uncheckedValue: {
      type: [String, Number, Boolean],
      default: false
    },
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().checkbox.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const $xeCheckboxGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeCheckboxGroup', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const $xeCheckbox = {
      xID,
      props,
      context,
      reactData
    };
    let checkboxMethods = {};
    const {
      computeSize
    } = useSize(props);
    const computeIsChecked = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if ($xeCheckboxGroup) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes($xeCheckboxGroup.props.modelValue, props.label);
      }
      return props.modelValue === props.checkedValue;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      const isChecked = computeIsChecked.value;
      if (disabled === null) {
        if ($xeCheckboxGroup) {
          const {
            computeIsDisabled: computeIsGroupDisabled,
            computeIsMaximize: computeIsGroupMaximize
          } = $xeCheckboxGroup.getComputeMaps();
          const isGroupDisabled = computeIsGroupDisabled.value;
          const isGroupMaximize = computeIsGroupMaximize.value;
          return isGroupDisabled || isGroupMaximize && !isChecked;
        }
      }
      return disabled;
    });
    const changeEvent = evnt => {
      const {
        checkedValue,
        uncheckedValue
      } = props;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const checked = evnt.target.checked;
        const value = checked ? checkedValue : uncheckedValue;
        const params = {
          checked,
          value,
          label: props.label
        };
        if ($xeCheckboxGroup) {
          $xeCheckboxGroup.handleChecked(params, evnt);
        } else {
          emit('update:modelValue', value);
          checkboxMethods.dispatchEvent('change', params, evnt);
          // 自动更新校验状态
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
          }
        }
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $checkbox: $xeCheckbox
      }, params));
    };
    checkboxMethods = {
      dispatchEvent
    };
    Object.assign($xeCheckbox, checkboxMethods);
    const renderVN = () => {
      const {
        label
      } = props;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const isChecked = computeIsChecked.value;
      const indeterminate = !isChecked && props.indeterminate;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('label', {
        key: label,
        class: ['vxe-checkbox vxe-checkbox--default', {
          [`size--${vSize}`]: vSize,
          'is--indeterminate': indeterminate,
          'is--disabled': isDisabled,
          'is--checked': isChecked
        }],
        title: props.title
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        class: 'vxe-checkbox--input',
        type: 'checkbox',
        disabled: isDisabled,
        checked: isChecked,
        onChange: changeEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-checkbox--icon', indeterminate ? getIcon().CHECKBOX_INDETERMINATE : isChecked ? getIcon().CHECKBOX_CHECKED : isDisabled ? getIcon().CHECKBOX_DISABLED_UNCHECKED : getIcon().CHECKBOX_UNCHECKED]
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-checkbox--label'
      }, slots.default ? slots.default({}) : getFuncText(props.content))]);
    };
    $xeCheckbox.renderVN = renderVN;
    return $xeCheckbox;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/checkbox/index.ts



const VxeCheckbox = Object.assign(src_checkbox, {
  install(app) {
    app.component(src_checkbox.name, src_checkbox);
  }
});
dynamicApp.use(VxeCheckbox);
index_esm_VxeUI.component(src_checkbox);
const Checkbox = VxeCheckbox;
/* harmony default export */ var packages_checkbox = (VxeCheckbox);
;// CONCATENATED MODULE: ./packages/checkbox/src/button.ts





/* harmony default export */ var checkbox_src_button = (defineVxeComponent({
  name: 'VxeCheckboxButton',
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number, Boolean],
      default: null
    },
    title: [String, Number],
    checkedValue: {
      type: [String, Number, Boolean],
      default: true
    },
    uncheckedValue: {
      type: [String, Number, Boolean],
      default: false
    },
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().checkboxButton.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const $xeCheckboxGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeCheckboxGroup', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const {
      computeSize
    } = useSize(props);
    const $xeCheckboxButton = {
      xID,
      props,
      context,
      reactData
    };
    const computeIsChecked = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if ($xeCheckboxGroup) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes($xeCheckboxGroup.props.modelValue, props.label);
      }
      return props.modelValue === props.checkedValue;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      const isChecked = computeIsChecked.value;
      if (disabled === null) {
        if ($xeCheckboxGroup) {
          const {
            computeIsDisabled: computeIsGroupDisabled,
            computeIsMaximize: computeIsGroupMaximize
          } = $xeCheckboxGroup.getComputeMaps();
          const isGroupDisabled = computeIsGroupDisabled.value;
          const isGroupMaximize = computeIsGroupMaximize.value;
          return isGroupDisabled || isGroupMaximize && !isChecked;
        }
      }
      return disabled;
    });
    const changeEvent = evnt => {
      const {
        checkedValue,
        uncheckedValue
      } = props;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const checked = evnt.target.checked;
        const value = checked ? checkedValue : uncheckedValue;
        const params = {
          checked,
          value,
          label: props.label
        };
        if ($xeCheckboxGroup) {
          $xeCheckboxGroup.handleChecked(params, evnt);
        } else {
          emit('update:modelValue', value);
          $xeCheckboxButton.dispatchEvent('change', params, evnt);
          // 自动更新校验状态
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
          }
        }
      }
    };
    const checkboxButtonMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $checkboxButton: $xeCheckboxButton
        }, params));
      }
    };
    const checkboxButtonPrivateMethods = {};
    Object.assign($xeCheckboxButton, checkboxButtonMethods, checkboxButtonPrivateMethods);
    const renderVN = () => {
      const {
        label
      } = props;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const isChecked = computeIsChecked.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('label', {
        key: label,
        class: ['vxe-checkbox vxe-checkbox--button', {
          [`size--${vSize}`]: vSize,
          'is--disabled': isDisabled
        }],
        title: props.title
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        class: 'vxe-checkbox--input',
        type: 'checkbox',
        disabled: isDisabled,
        checked: isChecked,
        onChange: changeEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-checkbox--label'
      }, slots.default ? slots.default({}) : getFuncText(props.content))]);
    };
    $xeCheckboxButton.renderVN = renderVN;
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/checkbox-button/index.ts



const VxeCheckboxButton = Object.assign(checkbox_src_button, {
  install: function (app) {
    app.component(checkbox_src_button.name, checkbox_src_button);
  }
});
dynamicApp.use(VxeCheckboxButton);
index_esm_VxeUI.component(checkbox_src_button);
const CheckboxButton = VxeCheckboxButton;
/* harmony default export */ var checkbox_button = (VxeCheckboxButton);
;// CONCATENATED MODULE: ./packages/checkbox/src/group.ts






/* harmony default export */ var group = (defineVxeComponent({
  name: 'VxeCheckboxGroup',
  props: {
    modelValue: Array,
    options: Array,
    optionProps: Object,
    disabled: {
      type: Boolean,
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().checkboxGroup.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsMaximize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        max
      } = props;
      if (max) {
        return (modelValue ? modelValue.length : 0) >= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max);
      }
      return false;
    });
    const computePropsOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, props.optionProps);
    });
    const computeLabelField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || 'label';
    });
    const computeValueField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || 'value';
    });
    const computeDisabledField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.disabled || 'disabled';
    });
    const computeMaps = {
      computeIsMaximize,
      computeIsDisabled
    };
    const $xeCheckboxGroup = {
      xID,
      props,
      context,
      reactData,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $checkboxGroup: $xeCheckboxGroup
      }, params));
    };
    const checkboxGroupMethods = {
      dispatchEvent
    };
    const checkboxGroupPrivateMethods = {
      handleChecked(params, evnt) {
        const {
          checked,
          label
        } = params;
        const checklist = props.modelValue || [];
        const checkIndex = checklist.indexOf(label);
        if (checked) {
          if (checkIndex === -1) {
            checklist.push(label);
          }
        } else {
          checklist.splice(checkIndex, 1);
        }
        emit('update:modelValue', checklist);
        $xeCheckboxGroup.dispatchEvent('change', Object.assign({}, params, {
          checklist,
          value: checklist
        }), evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, checklist);
        }
      }
    };
    Object.assign($xeCheckboxGroup, checkboxGroupMethods, checkboxGroupPrivateMethods);
    const renderVN = () => {
      const {
        options
      } = props;
      const defaultSlot = slots.default;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const disabledField = computeDisabledField.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-checkbox-group'
      }, defaultSlot ? defaultSlot({}) : options ? options.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_checkbox, {
          key: item[valueField],
          label: item[valueField],
          content: item[labelField],
          disabled: item[disabledField]
        });
      }) : []);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeCheckboxGroup', $xeCheckboxGroup);
    $xeCheckboxGroup.renderVN = renderVN;
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/checkbox-group/index.ts



const VxeCheckboxGroup = Object.assign(group, {
  install(app) {
    app.component(group.name, group);
  }
});
dynamicApp.use(VxeCheckboxGroup);
index_esm_VxeUI.component(group);
const CheckboxGroup = VxeCheckboxGroup;
/* harmony default export */ var checkbox_group = (VxeCheckboxGroup);
;// CONCATENATED MODULE: ./packages/row/src/col.ts





/* harmony default export */ var col = (defineVxeComponent({
  name: 'VxeCol',
  props: {
    span: [Number, String],
    align: String,
    width: [Number, String],
    fill: Boolean,
    ellipsis: Boolean,
    size: {
      type: String,
      default: () => getConfig().col.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const $xeRow = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeRow', null);
    const computeRowGutter = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if ($xeRow) {
        return $xeRow.props.gutter;
      }
      return null;
    });
    const computeRowVertical = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if ($xeRow) {
        return $xeRow.props.vertical;
      }
      return null;
    });
    const computeColStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        width
      } = props;
      const rowGutter = computeRowGutter.value;
      const rowVertical = computeRowVertical.value;
      const style = {};
      if (rowGutter) {
        let [lrGutter, tbGutter] = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(rowGutter) ? rowGutter : [rowGutter];
        if (rowVertical) {
          tbGutter = lrGutter;
          lrGutter = '';
        }
        if (lrGutter) {
          const padding = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(lrGutter) ? toCssUnit(lrGutter / 2) : `calc(${toCssUnit(lrGutter)} / 2)`;
          style.paddingLeft = padding;
          style.paddingRight = padding;
        }
        if (tbGutter) {
          const padding = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(tbGutter) ? toCssUnit(tbGutter / 2) : `calc(${toCssUnit(tbGutter)} / 2)`;
          style.paddingTop = padding;
          style.paddingBottom = padding;
        }
      }
      if (width) {
        style.width = toCssUnit(width);
      }
      return style;
    });
    const computeMaps = {};
    const $xeCol = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $col: $xeCol
      }, params));
    };
    const colMethods = {
      dispatchEvent
    };
    const colPrivateMethods = {};
    Object.assign($xeCol, colMethods, colPrivateMethods);
    const renderVN = () => {
      const {
        span,
        fill,
        align,
        width,
        ellipsis
      } = props;
      const colStyle = computeColStyle.value;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-col', span ? `span${span}` : '', align ? `align--${align}` : '', {
          'is--span': !!span,
          'is--width': !!width,
          'is--fill': fill,
          'is--ellipsis': ellipsis
        }],
        style: colStyle
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-col--inner'
      }, defaultSlot ? defaultSlot({}) : [])]);
    };
    $xeCol.renderVN = renderVN;
    return $xeCol;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/col/index.ts



const VxeCol = Object.assign({}, col, {
  install(app) {
    app.component(col.name, col);
  }
});
dynamicApp.use(VxeCol);
index_esm_VxeUI.component(col);
const Col = VxeCol;
/* harmony default export */ var packages_col = (VxeCol);
;// CONCATENATED MODULE: ./packages/collapse/src/collapse.ts






/* harmony default export */ var collapse = (defineVxeComponent({
  name: 'VxeCollapse',
  props: {
    modelValue: Array,
    options: Array,
    padding: {
      type: Boolean,
      default: () => getConfig().collapse.padding
    },
    expandConfig: Object,
    size: {
      type: String,
      default: () => getConfig().collapse.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'load', 'change', 'toggle-expand'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      staticPanes: [],
      activeNames: [],
      initNames: [],
      cachePaneMaps: {}
    });
    const refMaps = {
      refElem
    };
    const computeItemOptions = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        options
      } = props;
      return (options || []).filter(item => handleFilterItem(item));
    });
    const computeItemStaticOptions = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        staticPanes
      } = reactData;
      return staticPanes.filter(item => handleFilterItem(item));
    });
    const computeExpandOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().collapse.expandConfig, props.expandConfig);
    });
    const computeMaps = {};
    const $xeCollapse = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const handleFilterItem = item => {
      const {
        permissionCode
      } = item;
      if (permissionCode) {
        if (!permission.checkVisible(permissionCode)) {
          return false;
        }
      }
      return true;
    };
    const addInitName = name => {
      const {
        initNames
      } = reactData;
      if (name && !initNames.includes(name)) {
        initNames.push(name);
        dispatchEvent('load', {
          name
        }, null);
        return true;
      }
      return false;
    };
    const initDefaultName = list => {
      const {
        activeNames
      } = reactData;
      const nameMaps = {};
      if (list && list.length) {
        list.forEach(item => {
          const {
            name,
            preload
          } = item || {};
          if (name) {
            const isActive = activeNames.includes(name);
            nameMaps[`${name}`] = {
              loading: false
            };
            if (isActive) {
              addInitName(name);
            }
            if (preload) {
              if (!isActive) {
                activeNames.push(name);
              }
            }
          }
        });
      }
      reactData.activeNames = activeNames ? activeNames.slice(0) : [];
      reactData.cachePaneMaps = nameMaps;
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $collapse: $xeCollapse
      }, params));
    };
    const collapseMethods = {
      dispatchEvent
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
          return vn_getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const handleClickEvent = (evnt, item) => {
      const {
        activeNames
      } = reactData;
      const {
        name
      } = item;
      if (name) {
        const aIndex = activeNames.indexOf(name);
        let expanded = false;
        if (aIndex === -1) {
          expanded = true;
          activeNames.push(name);
        } else {
          activeNames.splice(aIndex, 1);
        }
        addInitName(name);
        dispatchEvent('change', {
          value: activeNames,
          name
        }, evnt);
        dispatchEvent('toggle-expand', {
          value: activeNames,
          name,
          expanded
        }, evnt);
      }
    };
    const collapsePrivateMethods = {};
    Object.assign($xeCollapse, collapseMethods, collapsePrivateMethods);
    const renderList = itemList => {
      const {
        activeNames,
        initNames
      } = reactData;
      const expandOpts = computeExpandOpts.value;
      return itemList.map(item => {
        const {
          icon,
          name,
          title,
          slots
        } = item;
        const titleSlot = slots ? slots.title : null;
        const defaultSlot = slots ? slots.default : null;
        const isActive = name && activeNames.includes(name);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-collapse-item'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-collapse--item-header',
          onClick(evnt) {
            handleClickEvent(evnt, item);
          }
        }, [expandOpts.showIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-collapse--item-switch'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: isActive ? getIcon().COLLAPSE_OPEN : getIcon().COLLAPSE_CLOSE
        })]) : renderEmptyElement($xeCollapse), icon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-collapse--item-icon'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: icon
        })]) : renderEmptyElement($xeCollapse), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-collapse--item-name'
        }, titleSlot ? callSlot(titleSlot, {
          name,
          title
        }) : `${title}`)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-collapse--item-content', {
            'is--visible': isActive
          }]
        }, [name && initNames.includes(name) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-collapse--item-inner'
        }, [defaultSlot ? callSlot(defaultSlot, {
          name,
          title
        }) : '']) : renderEmptyElement($xeCollapse)])]);
      });
    };
    const renderVN = () => {
      const {
        padding
      } = props;
      const vSize = computeSize.value;
      const itemOptions = computeItemOptions.value;
      const itemStaticOptions = computeItemStaticOptions.value;
      const defaultSlot = slots.default;
      const itemList = defaultSlot ? itemStaticOptions : itemOptions;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-collapse', {
          [`size--${vSize}`]: vSize,
          'is--padding': padding
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-collapse-slots'
      }, defaultSlot ? defaultSlot({}) : []), renderList(itemList)]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.activeNames = val || [];
    });
    const optsFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options, () => {
      optsFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(optsFlag, () => {
      initDefaultName(props.options);
    });
    const stFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticPanes ? reactData.staticPanes.length : -1, () => {
      stFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticPanes, () => {
      stFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(stFlag, () => {
      initDefaultName(reactData.staticPanes);
    });
    reactData.activeNames = props.modelValue || [];
    initDefaultName(reactData.staticPanes.length ? reactData.staticPanes : props.options);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeCollapse', $xeCollapse);
    $xeCollapse.renderVN = renderVN;
    return $xeCollapse;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/collapse/index.ts



const VxeCollapse = Object.assign({}, collapse, {
  install(app) {
    app.component(collapse.name, collapse);
  }
});
dynamicApp.use(VxeCollapse);
index_esm_VxeUI.component(collapse);
const Collapse = VxeCollapse;
/* harmony default export */ var packages_collapse = (VxeCollapse);
;// CONCATENATED MODULE: ./packages/collapse/src/util.ts

function assembleCollapseItem($xeCollapse, elem, collapseConfig) {
  const staticPanes = $xeCollapse.reactData.staticPanes;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticPanes.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, elem), 0, collapseConfig);
    $xeCollapse.reactData.staticPanes = staticPanes.slice(0);
  }
}
function destroyCollapseItem($xeCollapse, collapseConfig) {
  const staticPanes = $xeCollapse.reactData.staticPanes;
  const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(staticPanes, item => item.id === collapseConfig.id, {
    children: 'children'
  });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  $xeCollapse.reactData.staticPanes = staticPanes.slice(0);
}
;// CONCATENATED MODULE: ./packages/collapse/src/collapse-pane.ts





/* harmony default export */ var collapse_pane = (defineVxeComponent({
  name: 'VxeCollapsePane',
  props: {
    title: [String, Number],
    name: [String, Number],
    icon: String,
    preload: Boolean,
    permissionCode: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeCollapse = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeCollapse', null);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const collapseConfig = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      id: xID,
      title: props.title,
      name: props.name,
      icon: props.icon,
      preload: props.preload,
      permissionCode: props.permissionCode,
      slots: slots
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeCollapsePane = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $collapsePane: $xeCollapsePane
      }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeCollapsePane, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      }, []);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.title, val => {
      collapseConfig.title = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.name, val => {
      collapseConfig.name = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.icon, val => {
      collapseConfig.icon = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.permissionCode, val => {
      collapseConfig.permissionCode = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const elem = refElem.value;
      if ($xeCollapse && elem) {
        assembleCollapseItem($xeCollapse, elem, collapseConfig);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      if ($xeCollapse) {
        destroyCollapseItem($xeCollapse, collapseConfig);
      }
    });
    $xeCollapsePane.renderVN = renderVN;
    return $xeCollapsePane;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/collapse-pane/index.ts



const VxeCollapsePane = Object.assign({}, collapse_pane, {
  install(app) {
    app.component(collapse_pane.name, collapse_pane);
  }
});
dynamicApp.use(VxeCollapsePane);
index_esm_VxeUI.component(collapse_pane);
const CollapsePane = VxeCollapsePane;
/* harmony default export */ var packages_collapse_pane = (VxeCollapsePane);
;// CONCATENATED MODULE: ./packages/color-picker/src/util.ts

const hexAlphaKeyMaps = {};
const hexAlphaNumMaps = {};
'FF,FC,FA,F7,F5,F2,F0,ED,EB,E8,E6,E3,E0,DE,DB,D9,D6,D4,D1,CF,CC,C9,C7,C4,C2,BF,BD,BA,B8,B5,B3,B0,AD,AB,A8,A6,A3,A1,9E,9C,99,96,94,91,8F,8C,8A,87,85,82,80,7D,7A,78,75,73,70,6E,6B,69,66,63,61,5E,5C,59,57,54,52,4F,4D,4A,47,45,42,40,3D,3B,38,36,33,30,2E,2B,29,26,24,21,1F,1C,1A,17,14,12,0F,0D,0A,08,05,03,00'.split(',').forEach((key, i) => {
  const num = (100 - i) / 100;
  hexAlphaKeyMaps[key] = num;
  hexAlphaNumMaps[num] = key;
});
const rgbRE = /^rgb(a?)\((\d{1,3})[,\s]+(\d{1,3})[,\s]+(\d{1,3})([,//\s]+([0-9.]{1,4})(%?))?\)$/;
function hasRgb(value) {
  return value && rgbRE.test(value);
}
const hexRE = /^(#?)([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;
function hasHex(value) {
  return value && hexRE.test(value);
}
function parseColor(value) {
  const rest = {
    value: '',
    type: '',
    hex: '',
    hexV: '',
    hexA: '',
    r: 0,
    g: 0,
    b: 0,
    a: 1
  };
  if (value) {
    const hexRest = value.match(hexRE);
    if (hexRest) {
      rest.value = value;
      rest.type = 'hex';
      rest.hex = value;
      rest.hexV = hexRest[2];
      rest.hexA = hexRest[3] || '';
      rest.a = (hexRest[3] ? hexAlphaKeyMaps[hexRest[3].toUpperCase()] : 1) || 1;
    }
    const rgbRest = value.match(rgbRE);
    if (rgbRest) {
      rest.value = value;
      rest.type = rgbRest[6] ? 'rgba' : 'rgb';
      rest.r = parseInt(rgbRest[2]);
      rest.g = parseInt(rgbRest[3]);
      rest.b = parseInt(rgbRest[4]);
      rest.a = rgbRest[7] ? parseInt(rgbRest[6]) / 100 : rgbRest[6] ? parseFloat(rgbRest[6]) : 1;
    }
  }
  return rest;
}
function updateColorAlpha(value, alpha = 1) {
  const colorRest = parseColor(value);
  const {
    type,
    hexV,
    r,
    g,
    b
  } = colorRest;
  if (type === 'rgb' || type === 'rgba') {
    return toRgb(r, g, b, alpha);
  }
  if (type === 'hex') {
    return `#${hexV}${alpha === 1 ? '' : hexAlphaNumMaps[alpha] || ''}`;
  }
  return '';
}
function toRgb(r, g, b, a) {
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(a)) {
    return `rgb(${r},${g},${b})`;
  }
  return `rgba(${r},${g},${b},${a})`;
}
function rgbToHex(rgbRest) {
  if (!rgbRest) {
    return '';
  }
  const {
    r,
    g,
    b,
    a = 1
  } = rgbRest;
  const hexR = r.toString(16).padStart(2, '0');
  const hexG = g.toString(16).padStart(2, '0');
  const hexB = b.toString(16).padStart(2, '0');
  const hexA = a === 1 ? '' : hexAlphaNumMaps[a] || '';
  // 返回十六进制颜色代码
  return `#${hexR}${hexG}${hexB}${hexA}`.toUpperCase();
}
function rgbToHsv(rgbRest) {
  if (!rgbRest) {
    return null;
  }
  const {
    r,
    g,
    b
  } = rgbRest;
  const rAbs = r / 255;
  const gAbs = g / 255;
  const bAbs = b / 255;
  let h = 0;
  let s = 0;
  const val = Math.max(rAbs, gAbs, bAbs);
  const num = val - Math.min(rAbs, gAbs, bAbs);
  const handleDiff = c => (val - c) / 6 / num + 1 / 2;
  if (num === 0) {
    h = s = 0;
  } else {
    s = num / val;
    const rr = handleDiff(rAbs);
    const gg = handleDiff(gAbs);
    const bb = handleDiff(bAbs);
    if (rAbs === val) {
      h = bb - gg;
    } else if (gAbs === val) {
      h = 1 / 3 + rr - bb;
    } else if (bAbs === val) {
      h = 2 / 3 + gg - rr;
    }
    if (h < 0) {
      h += 1;
    } else if (h > 1) {
      h -= 1;
    }
  }
  return {
    h: Math.round(h * 360),
    s: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().round(s, 2),
    v: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().round(val, 2)
  };
}
function hsvToRgb(h, s, v) {
  let r = 0;
  let g = 0;
  let b = 0;
  const i = Math.floor(h / 60);
  const f = h / 60 - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  switch (i) {
    case 0:
      r = v;
      g = t;
      b = p;
      break;
    case 1:
      r = q;
      g = v;
      b = p;
      break;
    case 2:
      r = p;
      g = v;
      b = t;
      break;
    case 3:
      r = p;
      g = q;
      b = v;
      break;
    case 4:
      r = t;
      g = p;
      b = v;
      break;
    case 5:
      r = v;
      g = p;
      b = q;
      break;
  }
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
}
function hexToHsv(str) {
  const rgbRest = hexToRgb(str);
  if (rgbRest) {
    return rgbToHsv(rgbRest);
  }
  return null;
}
function hexToRgb(str) {
  if (str) {
    const rests = str.match(/^(#?)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})?$/);
    if (rests) {
      return {
        r: parseInt(rests[2], 16),
        g: parseInt(rests[3], 16),
        b: parseInt(rests[4], 16),
        a: (rests[5] ? hexAlphaKeyMaps[rests[5].toUpperCase()] : 1) || 1
      };
    }
  }
  return null;
}
;// CONCATENATED MODULE: ./packages/number-input/src/util.ts

function handleNumber(val) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(val) ? val.replace(/[^0-9e.-]/g, '') : val;
}
function toFloatValueFixed(inputValue, digitsValue) {
  if (/^-/.test('' + inputValue)) {
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().ceil(inputValue, digitsValue), digitsValue);
  }
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFixed(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(inputValue, digitsValue), digitsValue);
}
;// CONCATENATED MODULE: ./packages/input/src/input.ts











/* harmony default export */ var input = (defineVxeComponent({
  name: 'VxeInput',
  props: {
    modelValue: [String, Number, Date],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    title: String,
    type: {
      type: String,
      default: 'text'
    },
    clearable: {
      type: Boolean,
      default: () => getConfig().input.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: {
      type: String,
      default: null
    },
    maxLength: {
      type: [String, Number],
      default: () => getConfig().input.maxLength
    },
    autoComplete: {
      type: String,
      default: 'off'
    },
    autoFocus: {
      type: Boolean,
      default: null
    },
    align: String,
    form: String,
    className: String,
    size: {
      type: String,
      default: () => getConfig().input.size || getConfig().size
    },
    multiple: Boolean,
    // text
    showWordCount: Boolean,
    countMethod: Function,
    // number、integer、float
    min: {
      type: [String, Number],
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    step: [String, Number],
    trim: {
      type: Boolean,
      default: () => getConfig().input.trim
    },
    exponential: {
      type: Boolean,
      default: () => getConfig().input.exponential
    },
    // number、integer、float、password
    controls: {
      type: Boolean,
      default: () => getConfig().input.controls
    },
    // float
    digits: {
      type: [String, Number],
      default: () => getConfig().input.digits
    },
    // date、week、month、quarter、year
    startDate: {
      type: [String, Number, Date],
      default: () => getConfig().input.startDate
    },
    endDate: {
      type: [String, Number, Date],
      default: () => getConfig().input.endDate
    },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    // 已废弃 startWeek，被 startDay 替换
    startWeek: Number,
    startDay: {
      type: [String, Number],
      default: () => getConfig().input.startDay
    },
    labelFormat: String,
    valueFormat: String,
    editable: {
      type: Boolean,
      default: true
    },
    festivalMethod: {
      type: Function,
      default: () => getConfig().input.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().input.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().input.selectDay
    },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    },
    // 已废弃
    maxlength: [String, Number],
    // 已废弃
    autocomplete: String
  },
  emits: ['update:modelValue', 'input', 'change', 'keydown', 'keyup', 'wheel', 'click', 'focus', 'blur', 'clear', 'search-click', 'toggle-visible', 'prev-number', 'next-number', 'prefix-click', 'suffix-click', 'date-prev', 'date-today', 'date-next'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeSelect = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeSelect', null);
    const $xeTreeSelect = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTreeSelect', null);
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      panelIndex: 0,
      showPwd: false,
      visiblePanel: false,
      isAniVisible: false,
      panelStyle: {},
      panelPlacement: '',
      isActivated: false,
      inputValue: props.modelValue,
      datetimePanelValue: null,
      datePanelValue: null,
      datePanelLabel: '',
      datePanelType: 'day',
      selectMonth: null,
      currentDate: null
    });
    const internalData = {
      yearSize: 12,
      monthSize: 20,
      quarterSize: 8,
      hpTimeout: undefined,
      dnTimeout: undefined
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTarget = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPanelWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTimeBody = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeInput = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let inputMethods = {};
    const parseDate = (value, format) => {
      const {
        type
      } = props;
      if (type === 'time') {
        return toStringTimeDate(value);
      }
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(value, format);
    };
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().input.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      if ($xeForm) {
        return $xeForm.props.readonly;
      }
      return false;
    });
    const computeIsReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeInpMaxLength = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        maxLength,
        maxlength
      } = props;
      const maxLen = maxLength || maxlength;
      const isNumType = computeIsNumType.value;
      // 数值最大长度限制 16 位，包含小数
      if (isNumType) {
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(maxLen)) {
          return 16;
        }
      }
      return maxLen;
    });
    const computeIsDateTimeType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      return type === 'time' || type === 'datetime';
    });
    const computeIsNumType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return ['number', 'integer', 'float'].indexOf(props.type) > -1;
    });
    const computeInputCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getSize(reactData.inputValue);
    });
    const computeIsCountError = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const inputCount = computeInputCount.value;
      const inpMaxLength = computeInpMaxLength.value;
      return inpMaxLength && inputCount > external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inpMaxLength);
    });
    const computeIsDatePickerType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDateTimeType = computeIsDateTimeType.value;
      return isDateTimeType || ['date', 'week', 'month', 'quarter', 'year'].indexOf(props.type) > -1;
    });
    const computeIsPawdType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.type === 'password';
    });
    const computeIsSearchType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.type === 'search';
    });
    const computeDigitsValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(props.digits) || 1;
    });
    const computeStepValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      const digitsValue = computeDigitsValue.value;
      const step = props.step;
      if (type === 'integer') {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(step) || 1;
      } else if (type === 'float') {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(step) || 1 / Math.pow(10, digitsValue);
      }
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(step) || 1;
    });
    const computeIsClearable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      return props.clearable && (isPawdType || isNumType || isDatePickerType || type === 'text' || type === 'search');
    });
    const computeDateStartTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.startDate ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(props.startDate) : null;
    });
    const computeDateEndTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.endDate ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(props.endDate) : null;
    });
    const computeSupportMultiples = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return ['date', 'week', 'month', 'quarter', 'year'].indexOf(props.type) > -1;
    });
    const computeDateListValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        multiple
      } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && modelValue && isDatePickerType) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(modelValue).split(',').map(item => {
          const date = parseDate(item, dateValueFormat);
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(date)) {
            return date;
          }
          return null;
        });
      }
      return [];
    });
    const computeDateMultipleValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateLabelFormat)).join(', ');
    });
    const computeDateValueFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        valueFormat
      } = props;
      if (valueFormat) {
        return valueFormat;
      }
      if (type === 'time') {
        return 'HH:mm:ss';
      }
      if (type === 'datetime') {
        return 'yyyy-MM-dd HH:mm:ss';
      }
      return 'yyyy-MM-dd';
    });
    const computeDateValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue
      } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (modelValue && isDatePickerType) {
        const date = parseDate(modelValue, dateValueFormat);
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateStartTime = computeDateStartTime.value;
      const {
        selectMonth
      } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateEndTime = computeDateEndTime.value;
      const {
        selectMonth
      } = reactData;
      if (selectMonth && dateEndTime) {
        return selectMonth >= dateEndTime;
      }
      return false;
    });
    const computeDateTimeLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        datetimePanelValue
      } = reactData;
      const hasTimeSecond = computeHasTimeSecond.value;
      if (datetimePanelValue) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(datetimePanelValue, hasTimeSecond ? 'HH:mm:ss' : 'HH:mm');
      }
      return '';
    });
    const computeDateHMSTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      return dateValue && isDateTimeType ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1000 : 0;
    });
    const computeDateLabelFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        labelFormat
      } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        return labelFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return '';
    });
    const computeYearList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const {
        yearSize
      } = internalData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (let index = -4; index < yearSize + 4; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(startYearDate, index, 'first');
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelObj = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      let y = '';
      let m = '';
      if (isDatePickerType) {
        const {
          datePanelType,
          selectMonth
        } = reactData;
        const yearList = computeYearList.value;
        let year = '';
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === 'quarter' || datePanelType === 'month') {
          y = getI18n('vxe.datePicker.yearTitle', [year]);
        } else if (datePanelType === 'year') {
          y = yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : '';
        } else {
          y = getI18n('vxe.datePicker.yearTitle', [year]);
          m = month ? getI18n(`vxe.input.date.m${month}`) : '-';
        }
      }
      return {
        y,
        m
      };
    });
    const computeFirstDayOfWeek = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        startDay,
        startWeek
      } = props;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(startDay) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(startDay) ? startDay : startWeek);
    });
    const computeWeekDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const weeks = [];
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index = 0; index < 6; index++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map(day => {
          return {
            value: day,
            label: getI18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const dateHeaders = computeDateHeaders.value;
        return [{
          label: getI18n('vxe.input.date.weeks.w')
        }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const yearList = computeYearList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(yearList, 4);
    });
    const computeQuarterList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const {
        quarterSize
      } = internalData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter(currentDate);
        const firstYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, 'first');
        const selFullYear = firstYear.getFullYear();
        for (let index = -2; index < quarterSize - 2; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(firstYear, index);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const quarterList = computeQuarterList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(quarterList, 2);
    });
    const computeMonthList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const {
        monthSize
      } = internalData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, 'first').getFullYear();
        for (let index = -4; index < monthSize - 4; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const monthList = computeMonthList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(monthList, 4);
    });
    const computeDayList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index = 0; index < 42; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(startDayDate, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dayList = computeDayList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(dayList, 7);
    });
    const computeWeekDates = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map(list => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const computeHourList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 24; index++) {
          list.push({
            value: index,
            label: ('' + index).padStart(2, '0')
          });
        }
      }
      return list;
    });
    const computeMinuteList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 60; index++) {
          list.push({
            value: index,
            label: ('' + index).padStart(2, '0')
          });
        }
      }
      return list;
    });
    const computeHasTimeMinute = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /mm/.test(dateValueFormat);
    });
    const computeHasTimeSecond = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /ss/.test(dateValueFormat);
    });
    const computeSecondList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const minuteList = computeMinuteList.value;
      return minuteList;
    });
    const computeInputReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        editable,
        multiple
      } = props;
      const isReadonly = computeIsReadonly.value;
      return isReadonly || multiple || !editable || type === 'week' || type === 'quarter';
    });
    const computeInputType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      const {
        showPwd
      } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      if (isDatePickerType || isNumType || isPawdType && showPwd || type === 'number') {
        return 'text';
      }
      return type;
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(placeholder)) {
        const globalPlaceholder = getConfig().input.placeholder;
        if (globalPlaceholder) {
          return getFuncText(globalPlaceholder);
        }
        return getI18n('vxe.base.pleaseInput');
      }
      return placeholder;
    });
    const computeInpImmediate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        immediate
      } = props;
      return immediate || !(type === 'text' || type === 'number' || type === 'integer' || type === 'float');
    });
    const computeNumValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      const {
        inputValue
      } = reactData;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        return type === 'integer' ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(handleNumber(inputValue)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(handleNumber(inputValue));
      }
      return 0;
    });
    const computeIsDisabledSubtractNumber = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        min
      } = props;
      const {
        inputValue
      } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      // 当有值时再进行判断
      if ((inputValue || inputValue === 0) && isNumType && min !== null) {
        return numValue <= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(min);
      }
      return false;
    });
    const computeIsDisabledAddNumber = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        max
      } = props;
      const {
        inputValue
      } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      // 当有值时再进行判断
      if ((inputValue || inputValue === 0) && isNumType && max !== null) {
        return numValue >= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max);
      }
      return false;
    });
    const getNumberValue = val => {
      const {
        type,
        exponential
      } = props;
      const inpMaxLength = computeInpMaxLength.value;
      const digitsValue = computeDigitsValue.value;
      const restVal = type === 'float' ? toFloatValueFixed(val, digitsValue) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(val);
      if (exponential && (val === restVal || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(val).toLowerCase() === external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(restVal).toExponential())) {
        return val;
      }
      return restVal.slice(0, inpMaxLength);
    };
    const emitModel = value => {
      emit('update:modelValue', value);
    };
    const triggerEvent = evnt => {
      const {
        inputValue
      } = reactData;
      inputMethods.dispatchEvent(evnt.type, {
        value: inputValue
      }, evnt);
    };
    const handleChange = (value, evnt) => {
      if (props.trim) {
        value = `${value || ''}`.trim();
      }
      reactData.inputValue = value;
      emitModel(value);
      inputMethods.dispatchEvent('input', {
        value
      }, evnt);
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(props.modelValue) !== value) {
        inputMethods.dispatchEvent('change', {
          value
        }, evnt);
        if (!$xeSelect && !$xeTreeSelect) {
          // 自动更新校验状态
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
          }
        }
      }
    };
    const emitInputEvent = (value, evnt) => {
      const isDatePickerType = computeIsDatePickerType.value;
      const inpImmediate = computeInpImmediate.value;
      reactData.inputValue = value;
      if (!isDatePickerType) {
        if (inpImmediate) {
          handleChange(value, evnt);
        } else {
          inputMethods.dispatchEvent('input', {
            value
          }, evnt);
        }
      }
    };
    const inputEvent = evnt => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const changeEvent = evnt => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent(evnt);
      }
    };
    const blurEvent = evnt => {
      const {
        inputValue
      } = reactData;
      const inpImmediate = computeInpImmediate.value;
      const value = inputValue;
      if (!inpImmediate) {
        handleChange(value, evnt);
      }
      afterCheckValue();
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
      }
      inputMethods.dispatchEvent('blur', {
        value
      }, evnt);
      if (!$xeSelect && !$xeTreeSelect) {
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const focusEvent = evnt => {
      const {
        inputValue
      } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      reactData.isActivated = true;
      if (isNumType) {
        reactData.inputValue = eqEmptyValue(inputValue) ? '' : `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inputValue)}`;
      } else if (isDatePickerType) {
        datePickerOpenEvent(evnt);
      }
      triggerEvent(evnt);
    };
    const clickPrefixEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          inputValue
        } = reactData;
        inputMethods.dispatchEvent('prefix-click', {
          value: inputValue
        }, evnt);
      }
    };
    const hidePanel = () => {
      return new Promise(resolve => {
        reactData.visiblePanel = false;
        internalData.hpTimeout = setTimeout(() => {
          reactData.isAniVisible = false;
          resolve();
        }, 350);
      });
    };
    const clearValueEvent = (evnt, value) => {
      const {
        type,
        autoFocus
      } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        hidePanel();
      }
      if (autoFocus || autoFocus === null) {
        if (isNumType || ['text', 'search', 'password'].indexOf(type) > -1) {
          focus();
        }
      }
      handleChange('', evnt);
      inputMethods.dispatchEvent('clear', {
        value
      }, evnt);
    };
    const clickSuffixEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          inputValue
        } = reactData;
        inputMethods.dispatchEvent('suffix-click', {
          value: inputValue
        }, evnt);
      }
    };
    const dateParseValue = value => {
      const {
        type
      } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let dValue = null;
      let dLabel = '';
      if (value) {
        dValue = parseDate(value, dateValueFormat);
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(dValue)) {
        dLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(dValue, dateLabelFormat, {
          firstDay: firstDayOfWeek
        });
        // 周选择器，由于年份和第几周是冲突的行为，所以需要特殊处理，判断是否跨年，例如
        // '2024-12-31' 'yyyy-MM-dd W' >> '2024-12-31 1'
        // '2025-01-01' 'yyyy-MM-dd W' >> '2025-01-01 1'
        if (dateLabelFormat && type === 'week') {
          const weekNum = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getYearWeek(dValue, firstDayOfWeek);
          const weekDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(dValue, 0, weekNum === 1 ? (6 + firstDayOfWeek) % 7 : firstDayOfWeek, firstDayOfWeek);
          const weekFullYear = weekDate.getFullYear();
          if (weekFullYear !== dValue.getFullYear()) {
            const yyIndex = dateLabelFormat.indexOf('yyyy');
            if (yyIndex > -1) {
              const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
              if (yyNum && !isNaN(yyNum)) {
                dLabel = dLabel.replace(`${yyNum}`, `${weekFullYear}`);
              }
            }
          }
        }
      } else {
        dValue = null;
      }
      reactData.datePanelValue = dValue;
      reactData.datePanelLabel = dLabel;
    };
    /**
     * 值变化时处理
     */
    const changeValue = () => {
      const isDatePickerType = computeIsDatePickerType.value;
      const {
        inputValue
      } = reactData;
      if (isDatePickerType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    /**
     * 检查初始值
     */
    const initValue = () => {
      const {
        type
      } = props;
      const {
        inputValue
      } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const digitsValue = computeDigitsValue.value;
      if (isDatePickerType) {
        changeValue();
      } else if (type === 'float') {
        if (inputValue) {
          const validValue = toFloatValueFixed(inputValue, digitsValue);
          if (inputValue !== validValue) {
            handleChange(validValue, {
              type: 'init'
            });
          }
        }
      }
    };
    const validMaxNum = num => {
      return props.max === null || props.max === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(num) <= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.max);
    };
    const validMinNum = num => {
      return props.min === null || props.min === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(num) >= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.min);
    };
    const dateRevert = () => {
      reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
    };
    const dateCheckMonth = date => {
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const weekNum = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getYearWeek(date, firstDayOfWeek);
      const weekStartDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(date, 0, firstDayOfWeek, firstDayOfWeek);
      const month = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(weekNum === 1 ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(weekStartDate, 6) : date, 0, 'first');
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = date => {
      const {
        modelValue,
        multiple
      } = props;
      const {
        datetimePanelValue
      } = reactData;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === 'week') {
        const sWeek = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.selectDay);
        date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      } else if (isDateTimeType) {
        date.setHours(datetimePanelValue.getHours());
        date.setMinutes(datetimePanelValue.getMinutes());
        date.setSeconds(datetimePanelValue.getSeconds());
      }
      const inpVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat, {
        firstDay: firstDayOfWeek
      });
      dateCheckMonth(date);
      if (multiple) {
        // 如果为多选
        const dateMultipleValue = computeDateMultipleValue.value;
        if (isDateTimeType) {
          // 如果是datetime特殊类型
          const dateListValue = [...computeDateListValue.value];
          const datetimeRest = [];
          const eqIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(dateListValue, val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(date, val, 'yyyyMMdd'));
          if (eqIndex === -1) {
            dateListValue.push(date);
          } else {
            dateListValue.splice(eqIndex, 1);
          }
          dateListValue.forEach(item => {
            if (item) {
              item.setHours(datetimePanelValue.getHours());
              item.setMinutes(datetimePanelValue.getMinutes());
              item.setSeconds(datetimePanelValue.getSeconds());
              datetimeRest.push(item);
            }
          });
          handleChange(datetimeRest.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat)).join(','), {
            type: 'update'
          });
        } else {
          // 如果是日期类型
          if (dateMultipleValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(val, inpVal))) {
            handleChange(dateMultipleValue.filter(val => !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(val, inpVal)).join(','), {
              type: 'update'
            });
          } else {
            handleChange(dateMultipleValue.concat([inpVal]).join(','), {
              type: 'update'
            });
          }
        }
      } else {
        // 如果为单选
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(modelValue, inpVal)) {
          handleChange(inpVal, {
            type: 'update'
          });
        }
      }
    };
    const afterCheckValue = () => {
      const {
        type,
        min,
        max,
        exponential
      } = props;
      const {
        inputValue,
        datetimePanelValue
      } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      const inputReadonly = computeInputReadonly.value;
      if (!inputReadonly) {
        if (isNumType) {
          if (inputValue) {
            const inpVal = `${handleNumber(inputValue)}`;
            if (inpVal) {
              let inpNumVal = type === 'integer' ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(inpVal) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inpVal);
              if (!validMinNum(inpNumVal)) {
                inpNumVal = min;
              } else if (!validMaxNum(inpNumVal)) {
                inpNumVal = max;
              }
              if (exponential) {
                const inpStringVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(inputValue).toLowerCase();
                if (inpStringVal === external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inpNumVal).toExponential()) {
                  inpNumVal = inpStringVal;
                }
              }
              handleChange(getNumberValue(inpNumVal), {
                type: 'check'
              });
            } else {
              // 输入错误字符，清空
              let inpValue = '';
              if (min || min === 0) {
                inpValue = `${min}`;
              }
              handleChange(inpValue, {
                type: 'check'
              });
            }
          }
        } else if (isDatePickerType) {
          if (inputValue) {
            let inpDateVal = parseDate(inputValue, dateLabelFormat);
            if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(inpDateVal)) {
              if (type === 'time') {
                inpDateVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(inpDateVal, dateLabelFormat);
                if (inputValue !== inpDateVal) {
                  handleChange(inpDateVal, {
                    type: 'check'
                  });
                }
                reactData.inputValue = inpDateVal;
              } else {
                let isChange = false;
                const firstDayOfWeek = computeFirstDayOfWeek.value;
                if (type === 'datetime') {
                  const dateValue = computeDateValue.value;
                  if (inputValue !== external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(dateValue, dateLabelFormat) || inputValue !== external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(inpDateVal, dateLabelFormat)) {
                    isChange = true;
                    datetimePanelValue.setHours(inpDateVal.getHours());
                    datetimePanelValue.setMinutes(inpDateVal.getMinutes());
                    datetimePanelValue.setSeconds(inpDateVal.getSeconds());
                  }
                } else {
                  isChange = true;
                }
                reactData.inputValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(inpDateVal, dateLabelFormat, {
                  firstDay: firstDayOfWeek
                });
                if (isChange) {
                  dateChange(inpDateVal);
                }
              }
            } else {
              dateRevert();
            }
          } else {
            handleChange('', {
              type: 'check'
            });
          }
        }
      }
    };
    // 密码
    const passwordToggleEvent = evnt => {
      const {
        showPwd
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!isDisabled && !isReadonly) {
        reactData.showPwd = !showPwd;
      }
      inputMethods.dispatchEvent('toggle-visible', {
        visible: reactData.showPwd
      }, evnt);
    };
    // 密码
    // 搜索
    const searchEvent = evnt => {
      inputMethods.dispatchEvent('search-click', {}, evnt);
    };
    // 搜索
    // 数值
    const numberChange = (isPlus, evnt) => {
      const {
        min,
        max,
        type
      } = props;
      const {
        inputValue
      } = reactData;
      const stepValue = computeStepValue.value;
      const numValue = type === 'integer' ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(handleNumber(inputValue)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(handleNumber(inputValue));
      const newValue = isPlus ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().add(numValue, stepValue) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().subtract(numValue, stepValue);
      let restNum;
      if (!validMinNum(newValue)) {
        restNum = min;
      } else if (!validMaxNum(newValue)) {
        restNum = max;
      } else {
        restNum = newValue;
      }
      emitInputEvent(getNumberValue(restNum), evnt);
    };
    const numberNextEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      numberStopDown();
      if (!isDisabled && !isReadonly && !isDisabledSubtractNumber) {
        numberChange(false, evnt);
      }
      inputMethods.dispatchEvent('next-number', {
        value: reactData.inputValue
      }, evnt);
    };
    const numberDownNextEvent = evnt => {
      internalData.dnTimeout = setTimeout(() => {
        numberNextEvent(evnt);
        numberDownNextEvent(evnt);
      }, 60);
    };
    const numberPrevEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      numberStopDown();
      if (!isDisabled && !isReadonly && !isDisabledAddNumber) {
        numberChange(true, evnt);
      }
      inputMethods.dispatchEvent('prev-number', {
        value: reactData.inputValue
      }, evnt);
    };
    const numberKeydownEvent = evnt => {
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      if (isUpArrow || isDwArrow) {
        evnt.preventDefault();
        if (isUpArrow) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
      }
    };
    const keydownEvent = evnt => {
      const {
        type,
        exponential,
        controls
      } = props;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        const isControlKey = hasControlKey(evnt);
        const isShiftKey = evnt.shiftKey;
        const isAltKey = evnt.altKey;
        const keyCode = evnt.keyCode;
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        if (!isControlKey && !isShiftKey && !isAltKey) {
          if (globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR) || type === 'integer' && keyCode === 110 || (!exponential || keyCode !== 69) && keyCode >= 65 && keyCode <= 90 || keyCode >= 186 && keyCode <= 188 || keyCode >= 191) {
            evnt.preventDefault();
          }
        }
        if (isEsc) {
          afterCheckValue();
        } else if (isUpArrow || isDwArrow) {
          if (controls) {
            numberKeydownEvent(evnt);
          }
        }
      }
      triggerEvent(evnt);
    };
    const keyupEvent = evnt => {
      triggerEvent(evnt);
    };
    // 数值
    const numberStopDown = () => {
      const {
        dnTimeout
      } = internalData;
      if (dnTimeout) {
        clearTimeout(dnTimeout);
        internalData.dnTimeout = undefined;
      }
    };
    const numberDownPrevEvent = evnt => {
      internalData.dnTimeout = setTimeout(() => {
        numberPrevEvent(evnt);
        numberDownPrevEvent(evnt);
      }, 60);
    };
    const numberMousedownEvent = evnt => {
      numberStopDown();
      if (evnt.button === 0) {
        const isPrevNumber = hasClass(evnt.currentTarget, 'is--prev');
        if (isPrevNumber) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
        internalData.dnTimeout = setTimeout(() => {
          if (isPrevNumber) {
            numberDownPrevEvent(evnt);
          } else {
            numberDownNextEvent(evnt);
          }
        }, 500);
      }
    };
    const wheelEvent = evnt => {
      const isNumType = computeIsNumType.value;
      if (isNumType && props.controls) {
        if (reactData.isActivated) {
          const delta = evnt.deltaY;
          if (delta > 0) {
            numberNextEvent(evnt);
          } else if (delta < 0) {
            numberPrevEvent(evnt);
          }
          evnt.preventDefault();
        }
      }
      triggerEvent(evnt);
    };
    // 日期
    const dateMonthHandle = (date, offsetMonth) => {
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const weekNum = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getYearWeek(date, firstDayOfWeek);
      const weekStartDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(date, 0, firstDayOfWeek, firstDayOfWeek);
      const month = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(weekNum === 1 ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(weekStartDate, 6) : date, offsetMonth, 'first');
      reactData.selectMonth = month;
    };
    const dateNowHandle = () => {
      const currentDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleYearTypeEvent = () => {
      reactData.datePanelType = 'year';
    };
    const dateToggleMonthTypeEvent = () => {
      let {
        datePanelType
      } = reactData;
      if (datePanelType === 'month' || datePanelType === 'quarter') {
        datePanelType = 'year';
      } else {
        datePanelType = 'month';
      }
      reactData.datePanelType = datePanelType;
    };
    const datePrevEvent = evnt => {
      const {
        type
      } = props;
      const {
        datePanelType,
        selectMonth,
        inputValue
      } = reactData;
      const {
        yearSize
      } = internalData;
      const value = inputValue;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        let viewDate;
        if (type === 'year') {
          viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
        } else if (type === 'month' || type === 'quarter') {
          if (datePanelType === 'year') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
          } else {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -1, 'first');
          }
        } else {
          if (datePanelType === 'year') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
          } else if (datePanelType === 'month') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -1, 'first');
          } else {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(selectMonth, -1, 'first');
          }
        }
        reactData.selectMonth = viewDate;
        inputMethods.dispatchEvent('date-prev', {
          viewType: datePanelType,
          viewDate,
          value,
          type
        }, evnt);
      }
    };
    const dateTodayMonthEvent = evnt => {
      dateNowHandle();
      if (!props.multiple) {
        dateChange(reactData.currentDate);
        hidePanel();
      }
      inputMethods.dispatchEvent('date-today', {
        type: props.type
      }, evnt);
    };
    const dateNextEvent = evnt => {
      const {
        type
      } = props;
      const {
        datePanelType,
        selectMonth,
        inputValue
      } = reactData;
      const {
        yearSize
      } = internalData;
      const value = inputValue;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        let viewDate;
        if (type === 'year') {
          viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
        } else if (type === 'month' || type === 'quarter') {
          if (datePanelType === 'year') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
          } else {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 1, 'first');
          }
        } else {
          if (datePanelType === 'year') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
          } else if (datePanelType === 'month') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 1, 'first');
          } else {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(selectMonth, 1, 'first');
          }
        }
        reactData.selectMonth = viewDate;
        inputMethods.dispatchEvent('date-next', {
          viewType: datePanelType,
          viewDate,
          value,
          type
        }, evnt);
      }
    };
    const isDateDisabled = item => {
      const {
        disabledMethod
      } = props;
      const {
        datePanelType
      } = reactData;
      const dateStartTime = computeDateStartTime.value;
      const dateEndTime = computeDateEndTime.value;
      const {
        date
      } = item;
      if (dateStartTime && dateStartTime.getTime() > date.getTime()) {
        return true;
      }
      if (dateEndTime && dateEndTime.getTime() < date.getTime()) {
        return true;
      }
      if (disabledMethod) {
        return disabledMethod({
          type: datePanelType,
          viewType: datePanelType,
          date,
          $input: $xeInput
        });
      }
      return false;
    };
    const dateSelectItem = date => {
      const {
        type,
        multiple
      } = props;
      const {
        datePanelType
      } = reactData;
      if (type === 'month') {
        if (datePanelType === 'year') {
          reactData.datePanelType = 'month';
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else if (type === 'year') {
        dateChange(date);
        if (!multiple) {
          hidePanel();
        }
      } else if (type === 'quarter') {
        if (datePanelType === 'year') {
          reactData.datePanelType = 'quarter';
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else {
        if (datePanelType === 'month') {
          reactData.datePanelType = type === 'week' ? type : 'day';
          dateCheckMonth(date);
        } else if (datePanelType === 'year') {
          reactData.datePanelType = 'month';
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (type === 'datetime') {
            // 日期带时间
          } else {
            if (!multiple) {
              hidePanel();
            }
          }
        }
      }
    };
    const dateSelectEvent = item => {
      if (!isDateDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = offsetDay => {
      if (!isDateDisabled({
        date: offsetDay
      })) {
        const dayList = computeDayList.value;
        if (!dayList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetDay, 'yyyyMMdd'))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = offsetYear => {
      if (!isDateDisabled({
        date: offsetYear
      })) {
        const yearList = computeYearList.value;
        if (!yearList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetYear, 'yyyy'))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = offsetQuarter => {
      if (!isDateDisabled({
        date: offsetQuarter
      })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetQuarter, 'yyyyq'))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = offsetMonth => {
      if (!isDateDisabled({
        date: offsetMonth
      })) {
        const monthList = computeMonthList.value;
        if (!monthList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetMonth, 'yyyyMM'))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = item => {
      if (!isDateDisabled(item)) {
        const {
          datePanelType
        } = reactData;
        if (datePanelType === 'month') {
          dateMoveMonth(item.date);
        } else if (datePanelType === 'quarter') {
          dateMoveQuarter(item.date);
        } else if (datePanelType === 'year') {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const updateTimePos = liElem => {
      if (liElem) {
        const height = liElem.offsetHeight;
        const ulElem = liElem.parentNode;
        ulElem.scrollTop = liElem.offsetTop - height * 4;
      }
    };
    const dateTimeChangeEvent = evnt => {
      reactData.datetimePanelValue = new Date(reactData.datetimePanelValue.getTime());
      updateTimePos(evnt.currentTarget);
    };
    const dateHourEvent = (evnt, item) => {
      reactData.datetimePanelValue.setHours(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateConfirmEvent = () => {
      const {
        multiple
      } = props;
      const {
        datetimePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        const dateValueFormat = computeDateValueFormat.value;
        if (multiple) {
          // 如果为多选
          const dateMultipleValue = computeDateMultipleValue.value;
          if (isDateTimeType) {
            // 如果是datetime特殊类型
            const dateListValue = [...computeDateListValue.value];
            const datetimeRest = [];
            dateListValue.forEach(item => {
              if (item) {
                item.setHours(datetimePanelValue.getHours());
                item.setMinutes(datetimePanelValue.getMinutes());
                item.setSeconds(datetimePanelValue.getSeconds());
                datetimeRest.push(item);
              }
            });
            handleChange(datetimeRest.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat)).join(','), {
              type: 'update'
            });
          } else {
            // 如果是日期类型
            handleChange(dateMultipleValue.join(','), {
              type: 'update'
            });
          }
        } else {
          dateChange(dateValue || reactData.currentDate);
        }
      }
      hidePanel();
    };
    const dateMinuteEvent = (evnt, item) => {
      reactData.datetimePanelValue.setMinutes(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateSecondEvent = (evnt, item) => {
      reactData.datetimePanelValue.setSeconds(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateOffsetEvent = evnt => {
      const {
        isActivated,
        datePanelValue,
        datePanelType
      } = reactData;
      if (isActivated) {
        evnt.preventDefault();
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        if (datePanelType === 'year') {
          let offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(datePanelValue || Date.now(), 0, 'first');
          if (isLeftArrow) {
            offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(offsetYear, -1);
          } else if (isUpArrow) {
            offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(offsetYear, -4);
          } else if (isRightArrow) {
            offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(offsetYear, 1);
          } else if (isDwArrow) {
            offsetYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(offsetYear, 4);
          }
          dateMoveYear(offsetYear);
        } else if (datePanelType === 'quarter') {
          let offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(datePanelValue || Date.now(), 0, 'first');
          if (isLeftArrow) {
            offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(offsetQuarter, -1);
          } else if (isUpArrow) {
            offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(offsetQuarter, -2);
          } else if (isRightArrow) {
            offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(offsetQuarter, 1);
          } else if (isDwArrow) {
            offsetQuarter = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(offsetQuarter, 2);
          }
          dateMoveQuarter(offsetQuarter);
        } else if (datePanelType === 'month') {
          let offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(datePanelValue || Date.now(), 0, 'first');
          if (isLeftArrow) {
            offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(offsetMonth, -1);
          } else if (isUpArrow) {
            offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(offsetMonth, -4);
          } else if (isRightArrow) {
            offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(offsetMonth, 1);
          } else if (isDwArrow) {
            offsetMonth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(offsetMonth, 4);
          }
          dateMoveMonth(offsetMonth);
        } else {
          let offsetDay = datePanelValue || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
          const firstDayOfWeek = computeFirstDayOfWeek.value;
          if (isLeftArrow) {
            offsetDay = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(offsetDay, -1);
          } else if (isUpArrow) {
            offsetDay = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(offsetDay, -1, firstDayOfWeek);
          } else if (isRightArrow) {
            offsetDay = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(offsetDay, 1);
          } else if (isDwArrow) {
            offsetDay = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(offsetDay, 1, firstDayOfWeek);
          }
          dateMoveDay(offsetDay);
        }
      }
    };
    const datePgOffsetEvent = evnt => {
      const {
        isActivated
      } = reactData;
      if (isActivated) {
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        evnt.preventDefault();
        if (isPgUp) {
          datePrevEvent(evnt);
        } else {
          dateNextEvent(evnt);
        }
      }
    };
    const dateOpenPanel = () => {
      const {
        type
      } = props;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValue = computeDateValue.value;
      if (['year', 'quarter', 'month', 'week'].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = 'day';
      }
      reactData.currentDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        dateNowHandle();
      }
      if (isDateTimeType) {
        reactData.datetimePanelValue = reactData.datePanelValue || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const timeBodyElem = refInputTimeBody.value;
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(timeBodyElem.querySelectorAll('li.is--selected'), elem => {
            updateTimePos(elem);
          });
        });
      }
    };
    // 日期
    // 弹出面板
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          placement
        } = props;
        const {
          panelIndex
        } = reactData;
        const targetElem = refInputTarget.value;
        const panelElem = refInputPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (targetElem && panelElem) {
          const targetHeight = targetElem.offsetHeight;
          const targetWidth = targetElem.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const {
            boundingTop,
            boundingLeft,
            visibleHeight,
            visibleWidth
          } = getAbsolutePos(targetElem);
          let panelPlacement = 'bottom';
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === 'top') {
              panelPlacement = 'top';
              top = boundingTop - panelHeight;
            } else if (!placement) {
              // 如果下面不够放，则向上
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = 'top';
                top = boundingTop - panelHeight;
              }
              // 如果上面不够放，则向下（优先）
              if (top < marginSize) {
                panelPlacement = 'bottom';
                top = boundingTop + targetHeight;
              }
            }
            // 如果溢出右边
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            // 如果溢出左边
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === 'top') {
              panelPlacement = 'top';
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              // 如果下面不够放，则向上
              panelStyle.top = `${targetHeight}px`;
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                // 如果上面不够放，则向下（优先）
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = 'top';
                  panelStyle.top = '';
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
      });
    };
    const showPanel = () => {
      const {
        visiblePanel
      } = reactData;
      const {
        hpTimeout
      } = internalData;
      const isDisabled = computeIsDisabled.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!isDisabled && !visiblePanel) {
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        if (hpTimeout) {
          clearTimeout(hpTimeout);
          internalData.hpTimeout = undefined;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (isDatePickerType) {
          dateOpenPanel();
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        return updatePlacement();
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const datePickerOpenEvent = evnt => {
      const isReadonly = computeIsReadonly.value;
      if (!isReadonly) {
        evnt.preventDefault();
        showPanel();
      }
    };
    const clickEvent = evnt => {
      triggerEvent(evnt);
    };
    // 弹出面板
    // 全局事件
    const handleGlobalMousedownEvent = evnt => {
      const {
        visiblePanel,
        isActivated
      } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const el = refElem.value;
      const panelWrapperElem = refPanelWrapper.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelWrapperElem).flag;
        if (!reactData.isActivated) {
          // 如果是日期类型
          if (isDatePickerType) {
            if (visiblePanel) {
              hidePanel();
              afterCheckValue();
            }
          } else {
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const {
        clearable
      } = props;
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        const isPgDn = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_DOWN);
        const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
        let isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        } else if (operArrow) {
          if (isDatePickerType) {
            if (isActivated) {
              if (visiblePanel) {
                dateOffsetEvent(evnt);
              } else if (isUpArrow || isDwArrow) {
                datePickerOpenEvent(evnt);
              }
            }
          }
        } else if (isEnter) {
          if (isDatePickerType) {
            if (visiblePanel) {
              if (reactData.datePanelValue) {
                dateSelectItem(reactData.datePanelValue);
              } else {
                hidePanel();
              }
            } else if (isActivated) {
              datePickerOpenEvent(evnt);
            }
          }
        } else if (isPgUp || isPgDn) {
          if (isDatePickerType) {
            if (isActivated) {
              datePgOffsetEvent(evnt);
            }
          }
        }
        if (isTab || isEsc) {
          if (visiblePanel) {
            hidePanel();
          }
        } else if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelWrapperElem = refPanelWrapper.value;
          if (getEventTargetNode(evnt, panelWrapperElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const {
        isActivated,
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        hidePanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        const inputElem = refInputTarget.value;
        afterCheckValue();
        if (inputElem) {
          inputElem.blur();
        }
      }
    };
    const renderDateLabel = (item, label) => {
      const {
        festivalMethod
      } = props;
      if (festivalMethod) {
        const {
          datePanelType
        } = reactData;
        const festivalRest = festivalMethod({
          type: datePanelType,
          viewType: datePanelType,
          date: item.date,
          $input: $xeInput
        });
        const festivalItem = festivalRest ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(festivalRest) ? {
          label: festivalRest
        } : festivalRest : {};
        const extraItem = festivalItem.extra ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(festivalItem.extra) ? {
          label: festivalItem.extra
        } : festivalItem.extra : null;
        const labels = [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-input--date-label', {
            'is-notice': festivalItem.notice
          }]
        }, extraItem && extraItem.label ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', `${label || ''}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-input--date-label--extra', extraItem.important ? 'is-important' : '', extraItem.className],
          style: extraItem.style
        }, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(extraItem.label))] : [`${label || ''}`])];
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          // 默认最多支持3个节日重叠
          const festivalLabels = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(festivalLabel).split(',');
          labels.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-input--date-festival', festivalItem.important ? 'is-important' : '', festivalItem.className],
            style: festivalItem.style
          }, [festivalLabels.length > 1 ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: ['vxe-input--date-festival--overlap', `overlap--${festivalLabels.length}`]
          }, festivalLabels.map(label => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', label.substring(0, 3)))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
            class: 'vxe-input--date-festival--label'
          }, festivalLabels[0].substring(0, 3))]));
        }
        return labels;
      }
      return [`${label || ''}`];
    };
    const renderDateDayTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyMMdd';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-input--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('thead', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', dateHeaders.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', item.label);
      }))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', dayDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, item.label));
        }));
      }))])];
    };
    const renderDateWeekTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyMMdd';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-input--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('thead', [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', weekHeaders.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('th', item.label);
      }))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', weekDates.map(rows => {
        const isSelected = multiple ? rows.some(item => dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat))) : rows.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat));
        const isHover = rows.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat));
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': isSelected,
              'is--hover': isHover
            },
            // event
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, item.label));
        }));
      }))])];
    };
    const renderDateMonthTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyMM';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-input--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', monthDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, getI18n(`vxe.input.date.months.m${item.month}`)));
        }));
      }))])];
    };
    const renderDateQuarterTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyyq';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-input--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', quarterDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, getI18n(`vxe.input.date.quarters.q${item.quarter}`)));
        }));
      }))])];
    };
    const renderDateYearTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = 'yyyy';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('table', {
        class: `vxe-input--date-${datePanelType}-view`,
        cellspacing: 0,
        cellpadding: 0,
        border: 0
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tbody', yearDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('tr', rows.map(item => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('td', {
            class: {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--disabled': isDateDisabled(item),
              'is--selected': multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat),
              'is--hover': external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item)
          }, renderDateLabel(item, item.year));
        }));
      }))])];
    };
    const renderDateTable = () => {
      const {
        datePanelType
      } = reactData;
      switch (datePanelType) {
        case 'week':
          return renderDateWeekTable();
        case 'month':
          return renderDateMonthTable();
        case 'quarter':
          return renderDateQuarterTable();
        case 'year':
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType
      } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelObj = computeSelectDatePanelObj.value;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--date-picker-header'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--date-picker-type-wrapper'
      }, [datePanelType === 'year' ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--date-picker-label'
      }, selectDatePanelObj.y) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--date-picker-btns'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--date-picker-btn',
        onClick: dateToggleYearTypeEvent
      }, selectDatePanelObj.y), selectDatePanelObj.m ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--date-picker-btn',
        onClick: dateToggleMonthTypeEvent
      }, selectDatePanelObj.m) : renderEmptyElement($xeInput)])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--date-picker-btn-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-input--date-picker-btn vxe-input--date-picker-prev-btn', {
          'is--disabled': isDisabledPrevDateBtn
        }],
        onClick: datePrevEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: 'vxe-icon-caret-left'
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--date-picker-btn vxe-input--date-picker-current-btn',
        onClick: dateTodayMonthEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: 'vxe-icon-dot'
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-input--date-picker-btn vxe-input--date-picker-next-btn', {
          'is--disabled': isDisabledNextDateBtn
        }],
        onClick: dateNextEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: 'vxe-icon-caret-right'
      })]), multiple && computeSupportMultiples.value ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--date-picker-btn vxe-input--date-picker-confirm-btn'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: 'vxe-input--date-picker-confirm',
        type: 'button',
        onClick: dateConfirmEvent
      }, getI18n('vxe.button.confirm'))]) : null])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--date-picker-body'
      }, renderDateTable())];
    };
    const renderTimePanel = () => {
      const {
        datetimePanelValue
      } = reactData;
      const dateTimeLabel = computeDateTimeLabel.value;
      const hourList = computeHourList.value;
      const hasTimeMinute = computeHasTimeMinute.value;
      const minuteList = computeMinuteList.value;
      const hasTimeSecond = computeHasTimeSecond.value;
      const secondList = computeSecondList.value;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--time-picker-header'
      }, [hasTimeMinute ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-input--time-picker-title'
      }, dateTimeLabel) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--time-picker-btn'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: 'vxe-input--time-picker-confirm',
        type: 'button',
        onClick: dateConfirmEvent
      }, getI18n('vxe.button.confirm'))])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refInputTimeBody,
        class: 'vxe-input--time-picker-body'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-input--time-picker-hour-list'
      }, hourList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: index,
          class: {
            'is--selected': datetimePanelValue && datetimePanelValue.getHours() === item.value
          },
          onClick: evnt => dateHourEvent(evnt, item)
        }, item.label);
      })), hasTimeMinute ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-input--time-picker-minute-list'
      }, minuteList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: index,
          class: {
            'is--selected': datetimePanelValue && datetimePanelValue.getMinutes() === item.value
          },
          onClick: evnt => dateMinuteEvent(evnt, item)
        }, item.label);
      })) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), hasTimeMinute && hasTimeSecond ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-input--time-picker-second-list'
      }, secondList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: index,
          class: {
            'is--selected': datetimePanelValue && datetimePanelValue.getSeconds() === item.value
          },
          onClick: evnt => dateSecondEvent(evnt, item)
        }, item.label);
      })) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()])];
    };
    const renderPanel = () => {
      const {
        type
      } = props;
      const {
        initialized,
        isAniVisible,
        visiblePanel,
        panelPlacement,
        panelStyle
      } = reactData;
      const vSize = computeSize.value;
      const btnTransfer = computeBtnTransfer.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const renders = [];
      if (isDatePickerType) {
        if (type === 'datetime') {
          renders.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: type,
            ref: refPanelWrapper,
            class: 'vxe-input--panel-layout-wrapper'
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-input--panel-left-wrapper'
          }, renderDatePanel()), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-input--panel-right-wrapper'
          }, renderTimePanel())]));
        } else if (type === 'time') {
          renders.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: type,
            ref: refPanelWrapper,
            class: 'vxe-input--panel-wrapper'
          }, renderTimePanel()));
        } else {
          renders.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: type || 'default',
            ref: refPanelWrapper,
            class: 'vxe-input--panel-wrapper'
          }, renderDatePanel()));
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
          to: 'body',
          disabled: btnTransfer ? !initialized : true
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refInputPanel,
          class: ['vxe-table--ignore-clear vxe-input--panel', `type--${type}`, {
            [`size--${vSize}`]: vSize,
            'is--transfer': btnTransfer,
            'ani--leave': isAniVisible,
            'ani--enter': visiblePanel
          }],
          placement: panelPlacement,
          style: panelStyle
        }, visiblePanel || isAniVisible ? renders : [])]);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const renderNumberIcon = () => {
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--control-icon'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--number-icon'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-input--number-btn is--prev', {
          'is--disabled': isDisabledAddNumber
        }],
        onMousedown: numberMousedownEvent,
        onMouseup: numberStopDown,
        onMouseleave: numberStopDown
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().INPUT_PLUS_NUM
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-input--number-btn is--next', {
          'is--disabled': isDisabledSubtractNumber
        }],
        onMousedown: numberMousedownEvent,
        onMouseup: numberStopDown,
        onMouseleave: numberStopDown
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().INPUT_MINUS_NUM
      })])])]);
    };
    const renderDatePickerIcon = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--control-icon',
        onClick: datePickerOpenEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-input--date-picker-icon', getIcon().DATE_PICKER_DATE]
      })]);
    };
    const renderSearchIcon = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--control-icon',
        onClick: searchEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-input--search-icon', getIcon().INPUT_SEARCH]
      })]);
    };
    const renderPasswordIcon = () => {
      const {
        showPwd
      } = reactData;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--control-icon',
        onClick: passwordToggleEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-input--password-icon', showPwd ? getIcon().PASSWORD_INPUT_SHOW_PWD : getIcon().PASSWORD_INPUT_HIDE_PWD]
      })]);
    };
    const renderPrefixIcon = () => {
      const {
        prefixIcon
      } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--prefix',
        onClick: clickPrefixEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--prefix-icon'
      }, prefixSlot ? vn_getSlotVNs(prefixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: prefixIcon
      })])]) : null;
    };
    const renderSuffixIcon = () => {
      const {
        suffixIcon
      } = props;
      const {
        inputValue
      } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      const isSearchType = computeIsSearchType.value;
      const isClearable = computeIsClearable.value;
      const isExtraBtn = isPawdType || isNumType || isDatePickerType || isSearchType;
      return isClearable || suffixSlot || suffixIcon || isExtraBtn ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-input--suffix', {
          'is--clear': isClearable && !isDisabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }]
      }, [isClearable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--clear-icon',
        onClick: clearValueEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().INPUT_CLEAR
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), isExtraBtn ? renderExtraSuffixIcon() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), suffixSlot || suffixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--suffix-icon',
        onClick: clickSuffixEvent
      }, suffixSlot ? vn_getSlotVNs(suffixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: suffixIcon
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]) : null;
    };
    const renderExtraSuffixIcon = () => {
      const {
        controls
      } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      const isSearchType = computeIsSearchType.value;
      if (isPawdType) {
        return renderPasswordIcon();
      }
      if (isNumType) {
        if (controls) {
          return renderNumberIcon();
        }
      }
      if (isDatePickerType) {
        return renderDatePickerIcon();
      }
      if (isSearchType) {
        return renderSearchIcon();
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $input: $xeInput
      }, params));
    };
    inputMethods = {
      dispatchEvent,
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      showPanel,
      hidePanel,
      updatePlacement
    };
    Object.assign($xeInput, inputMethods);
    const renderVN = () => {
      const {
        className,
        controls,
        type,
        title,
        align,
        showWordCount,
        countMethod,
        name,
        autoComplete,
        autocomplete
      } = props;
      const {
        inputValue,
        visiblePanel,
        isActivated
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-input--readonly', `type--${type}`, className]
        }, inputValue);
      }
      const isCountError = computeIsCountError.value;
      const inputCount = computeInputCount.value;
      const inputReadonly = computeInputReadonly.value;
      const inpMaxLength = computeInpMaxLength.value;
      const inputType = computeInputType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const isWordCount = showWordCount && ['text', 'search'].includes(type);
      const prefix = renderPrefixIcon();
      const suffix = renderSuffixIcon();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-input', `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          [`is--${align}`]: align,
          'is--controls': controls,
          'is--prefix': !!prefix,
          'is--suffix': !!suffix,
          'is--visible': visiblePanel,
          'is--count': isWordCount,
          'is--disabled': isDisabled,
          'is--active': isActivated,
          'show--clear': isClearable && !isDisabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }],
        spellcheck: false
      }, [prefix || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-input--wrapper',
        title: title || null
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        ref: refInputTarget,
        class: 'vxe-input--inner',
        value: inputValue,
        name,
        type: inputType,
        placeholder: inpPlaceholder,
        maxlength: inpMaxLength,
        readonly: inputReadonly,
        disabled: isDisabled,
        autocomplete: autoComplete || autocomplete,
        onKeydown: keydownEvent,
        onKeyup: keyupEvent,
        onWheel: wheelEvent,
        onClick: clickEvent,
        onInput: inputEvent,
        onChange: changeEvent,
        onFocus: focusEvent,
        onBlur: blurEvent
      })]), suffix || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(),
      // 下拉面板
      renderPanel(),
      // 字数统计
      isWordCount ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-input--count', {
          'is--error': isCountError
        }]
      }, countMethod ? `${countMethod({
        value: inputValue
      })}` : `${inputCount}${inpMaxLength ? `/${inpMaxLength}` : ''}`) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)()]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.inputValue = val;
      changeValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.type, () => {
      // 切换类型是重置内置变量
      Object.assign(reactData, {
        inputValue: props.modelValue,
        datetimePanelValue: null,
        datePanelValue: null,
        datePanelLabel: '',
        datePanelType: 'day',
        selectMonth: null,
        currentDate: null
      });
      initValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeDateLabelFormat, () => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const {
        type
      } = props;
      if (['date', 'time', 'datetime', 'week', 'month', 'quarter', 'year'].includes(type)) {
        warnLog('vxe.error.useNew', [`<vxe-input type="${type}" ... />`, `<vxe-date-picker type="${type}" ... />`]);
      } else if (['number', 'integer', 'float'].includes(type)) {
        warnLog('vxe.error.useNew', [`<vxe-input type="${type}" ... />`, `<vxe-number-input type="${type}" ... />`]);
      } else if (['password'].includes(type)) {
        warnLog('vxe.error.useNew', [`<vxe-input type="${type}" ... />`, `<vxe-password-input type="${type}" ... />`]);
      }
      globalEvents.on($xeInput, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeInput, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeInput, 'keydown', handleGlobalKeydownEvent);
      globalEvents.on($xeInput, 'blur', handleGlobalBlurEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      numberStopDown();
      afterCheckValue();
      globalEvents.off($xeInput, 'mousewheel');
      globalEvents.off($xeInput, 'mousedown');
      globalEvents.off($xeInput, 'keydown');
      globalEvents.off($xeInput, 'blur');
    });
    initValue();
    $xeInput.renderVN = renderVN;
    return $xeInput;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/number-input/src/number-input.ts








/* harmony default export */ var number_input = (defineVxeComponent({
  name: 'VxeNumberInput',
  props: {
    modelValue: [String, Number],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    type: {
      type: String,
      default: 'number'
    },
    clearable: {
      type: Boolean,
      default: () => getConfig().numberInput.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: {
      type: [String, Number],
      default: () => getConfig().numberInput.maxLength
    },
    autoComplete: {
      type: String,
      default: 'off'
    },
    align: String,
    form: String,
    className: String,
    size: {
      type: String,
      default: () => getConfig().numberInput.size || getConfig().size
    },
    // number、integer、float
    min: {
      type: [String, Number],
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    step: [String, Number],
    exponential: {
      type: Boolean,
      default: () => getConfig().numberInput.exponential
    },
    showCurrency: {
      type: Boolean,
      default: () => getConfig().numberInput.showCurrency
    },
    currencySymbol: {
      type: String,
      default: () => getConfig().numberInput.currencySymbol
    },
    controlConfig: Object,
    // float
    digits: {
      type: [String, Number],
      default: null
    },
    autoFill: {
      type: Boolean,
      default: () => getConfig().numberInput.autoFill
    },
    editable: {
      type: Boolean,
      default: true
    },
    plusIcon: String,
    minusIcon: String,
    prefixIcon: String,
    suffixIcon: String,
    // 已废弃
    controls: {
      type: Boolean,
      default: null
    },
    // 已废弃
    maxlength: [String, Number],
    // 已废弃
    autocomplete: String
  },
  emits: ['update:modelValue', 'input', 'change', 'keydown', 'keyup', 'wheel', 'click', 'focus', 'blur', 'clear', 'plus-number', 'minus-number', 'prefix-click', 'suffix-click',
  // 已废弃
  'prev-number', 'next-number'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      isFocus: false,
      isActivated: false,
      inputValue: props.modelValue
    });
    const internalData = {
      // dnTimeout: undefined,
      // ainTimeout: undefined,
      // isMouseDown: undefined,
      // isUM: undefined
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTarget = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeDigitsValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        digits
      } = props;
      let defDigits = digits;
      if (defDigits === null) {
        defDigits = getConfig().numberInput.digits;
        if (defDigits === null) {
          if (type === 'amount') {
            defDigits = 2;
          }
        }
      }
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(defDigits) || 1;
    });
    const computeControlOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().numberInput.controlConfig, props.controlConfig);
    });
    const computeDecimalsType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      return type === 'float' || type === 'amount';
    });
    const computeStepValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      const digitsValue = computeDigitsValue.value;
      const decimalsType = computeDecimalsType.value;
      const step = props.step;
      if (type === 'integer') {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(step) || 1;
      } else if (decimalsType) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(step) || 1 / Math.pow(10, digitsValue);
      }
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(step) || 1;
    });
    const computeIsClearable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.clearable;
    });
    const computeInputReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        editable
      } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || !editable;
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().numberInput.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n('vxe.base.pleaseInput');
    });
    const computeInpMaxLength = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        maxLength,
        maxlength
      } = props;
      // 数值最大长度限制 16 位，包含小数
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(maxLength || maxlength) || 16;
    });
    const computeInpImmediate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        immediate
      } = props;
      return immediate;
    });
    const computeNumValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      const {
        inputValue
      } = reactData;
      return type === 'integer' ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(handleNumber(inputValue)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(handleNumber(inputValue));
    });
    const computeNumLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        showCurrency,
        currencySymbol,
        autoFill
      } = props;
      const {
        inputValue
      } = reactData;
      const digitsValue = computeDigitsValue.value;
      if (type === 'amount') {
        const num = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inputValue);
        let amountLabel = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().commafy(num, {
          digits: digitsValue
        });
        if (!autoFill) {
          const [iStr, dStr] = amountLabel.split('.');
          if (dStr) {
            const dRest = dStr.replace(/0+$/, '');
            amountLabel = dRest ? [iStr, '.', dRest].join('') : iStr;
          }
        }
        if (showCurrency) {
          return `${currencySymbol || getI18n('vxe.numberInput.currencySymbol') || ''}${amountLabel}`;
        }
        return amountLabel;
      }
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toString(inputValue);
    });
    const computeIsDisabledSubtractNumber = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        min
      } = props;
      const {
        inputValue
      } = reactData;
      const numValue = computeNumValue.value;
      // 当有值时再进行判断
      if ((inputValue || inputValue === 0) && min !== null) {
        return numValue <= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(min);
      }
      return false;
    });
    const computeIsDisabledAddNumber = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        max
      } = props;
      const {
        inputValue
      } = reactData;
      const numValue = computeNumValue.value;
      // 当有值时再进行判断
      if ((inputValue || inputValue === 0) && max !== null) {
        return numValue >= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max);
      }
      return false;
    });
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const computeMaps = {
      computeControlOpts
    };
    const $xeNumberInput = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    let numberInputMethods = {};
    const handleNumberString = val => {
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(val)) {
        return '';
      }
      return `${val}`;
    };
    const getNumberValue = val => {
      const {
        exponential,
        autoFill
      } = props;
      const inpMaxLength = computeInpMaxLength.value;
      const digitsValue = computeDigitsValue.value;
      const decimalsType = computeDecimalsType.value;
      let restVal = '';
      if (decimalsType) {
        restVal = toFloatValueFixed(val, digitsValue);
        if (!autoFill) {
          restVal = handleNumberString(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(restVal));
        }
      } else {
        restVal = handleNumberString(val);
      }
      if (exponential && (val === restVal || handleNumberString(val).toLowerCase() === external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(restVal).toExponential())) {
        return val;
      }
      return restVal.slice(0, inpMaxLength);
    };
    const triggerEvent = evnt => {
      const {
        inputValue
      } = reactData;
      numberInputMethods.dispatchEvent(evnt.type, {
        value: inputValue
      }, evnt);
    };
    const handleChange = (val, inputValue, evnt) => {
      const value = eqEmptyValue(val) ? null : Number(val);
      const isChange = value !== props.modelValue;
      if (isChange) {
        internalData.isUM = true;
        emit('update:modelValue', value);
      }
      if (reactData.inputValue !== inputValue) {
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          reactData.inputValue = inputValue || '';
        });
      }
      numberInputMethods.dispatchEvent('input', {
        value
      }, evnt);
      if (isChange) {
        numberInputMethods.dispatchEvent('change', {
          value
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const emitInputEvent = (inputValue, evnt) => {
      const inpImmediate = computeInpImmediate.value;
      const value = eqEmptyValue(inputValue) ? null : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inputValue);
      reactData.inputValue = inputValue;
      if (inpImmediate) {
        handleChange(value, inputValue, evnt);
      } else {
        numberInputMethods.dispatchEvent('input', {
          value
        }, evnt);
      }
    };
    const inputEvent = evnt => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const changeEvent = evnt => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent(evnt);
      }
    };
    const focusEvent = evnt => {
      const inputReadonly = computeInputReadonly.value;
      if (!inputReadonly) {
        const {
          inputValue
        } = reactData;
        reactData.inputValue = eqEmptyValue(inputValue) ? '' : `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inputValue)}`;
        reactData.isFocus = true;
        reactData.isActivated = true;
        triggerEvent(evnt);
      }
    };
    const clickPrefixEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          inputValue
        } = reactData;
        numberInputMethods.dispatchEvent('prefix-click', {
          value: inputValue
        }, evnt);
      }
    };
    const clearValueEvent = (evnt, value) => {
      focus();
      handleChange(null, '', evnt);
      numberInputMethods.dispatchEvent('clear', {
        value
      }, evnt);
    };
    const clickSuffixEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          inputValue
        } = reactData;
        numberInputMethods.dispatchEvent('suffix-click', {
          value: inputValue
        }, evnt);
      }
    };
    const updateModel = val => {
      const {
        autoFill
      } = props;
      const {
        inputValue
      } = reactData;
      const digitsValue = computeDigitsValue.value;
      const decimalsType = computeDecimalsType.value;
      if (eqEmptyValue(val)) {
        reactData.inputValue = '';
      } else {
        let textValue = `${val}`;
        if (decimalsType) {
          textValue = toFloatValueFixed(val, digitsValue);
          if (!autoFill) {
            textValue = `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textValue)}`;
          }
        }
        if (textValue !== inputValue) {
          reactData.inputValue = textValue;
        }
      }
    };
    /**
     * 检查初始值
     */
    const initValue = () => {
      const {
        autoFill
      } = props;
      const {
        inputValue
      } = reactData;
      const digitsValue = computeDigitsValue.value;
      const decimalsType = computeDecimalsType.value;
      if (decimalsType) {
        if (inputValue) {
          let textValue = '';
          let validValue = null;
          if (inputValue) {
            textValue = toFloatValueFixed(inputValue, digitsValue);
            validValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textValue);
            if (!autoFill) {
              textValue = `${validValue}`;
            }
          }
          if (inputValue !== validValue) {
            handleChange(validValue, textValue, {
              type: 'init'
            });
          } else {
            reactData.inputValue = textValue;
          }
        }
      }
    };
    const validMaxNum = num => {
      return props.max === null || props.max === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(num) <= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.max);
    };
    const validMinNum = num => {
      return props.min === null || props.min === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(num) >= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.min);
    };
    const afterCheckValue = () => {
      const {
        type,
        min,
        max,
        exponential
      } = props;
      const {
        inputValue
      } = reactData;
      const inputReadonly = computeInputReadonly.value;
      if (!inputReadonly) {
        if (eqEmptyValue(inputValue)) {
          let inpNumVal = null;
          let inpValue = inputValue;
          if (min || min === 0) {
            inpNumVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(min);
            inpValue = `${inpNumVal}`;
          }
          handleChange(inpNumVal, `${inpValue || ''}`, {
            type: 'check'
          });
          return;
        }
        if (inputValue || min || max) {
          let inpNumVal = type === 'integer' ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(handleNumber(inputValue)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(handleNumber(inputValue));
          if (!validMinNum(inpNumVal)) {
            inpNumVal = min;
          } else if (!validMaxNum(inpNumVal)) {
            inpNumVal = max;
          }
          if (exponential) {
            const inpStringVal = handleNumberString(inputValue).toLowerCase();
            if (inpStringVal === external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inpNumVal).toExponential()) {
              inpNumVal = inpStringVal;
            }
          }
          const inpValue = getNumberValue(inpNumVal);
          handleChange(eqEmptyValue(inpValue) ? null : Number(inpValue), inpValue, {
            type: 'check'
          });
        }
      }
    };
    const blurEvent = evnt => {
      const {
        inputValue
      } = reactData;
      const inpImmediate = computeInpImmediate.value;
      const value = inputValue ? Number(inputValue) : null;
      if (!inpImmediate) {
        handleChange(value, handleNumberString(inputValue), evnt);
      }
      afterCheckValue();
      reactData.isFocus = false;
      reactData.isActivated = false;
      numberInputMethods.dispatchEvent('blur', {
        value
      }, evnt);
      // 自动更新校验状态
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    // 数值
    const numberChange = (isPlus, evnt) => {
      const {
        min,
        max,
        type
      } = props;
      const {
        inputValue
      } = reactData;
      const stepValue = computeStepValue.value;
      const numValue = type === 'integer' ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(handleNumber(inputValue)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(handleNumber(inputValue));
      const newValue = isPlus ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().add(numValue, stepValue) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().subtract(numValue, stepValue);
      let restNum;
      if (!validMinNum(newValue)) {
        restNum = min;
      } else if (!validMaxNum(newValue)) {
        restNum = max;
      } else {
        restNum = newValue;
      }
      emitInputEvent(getNumberValue(restNum), evnt);
    };
    const numberPlusEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      if (!isDisabled && !formReadonly && !isDisabledAddNumber) {
        numberChange(true, evnt);
      }
      reactData.isActivated = true;
      numberInputMethods.dispatchEvent('plus-number', {
        value: reactData.inputValue
      }, evnt);
      // 已废弃
      numberInputMethods.dispatchEvent('next-number', {
        value: reactData.inputValue
      }, evnt);
    };
    const numberMinusEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      if (!isDisabled && !formReadonly && !isDisabledSubtractNumber) {
        numberChange(false, evnt);
      }
      reactData.isActivated = true;
      numberInputMethods.dispatchEvent('minus-number', {
        value: reactData.inputValue
      }, evnt);
      // 已废弃
      numberInputMethods.dispatchEvent('prev-number', {
        value: reactData.inputValue
      }, evnt);
    };
    const numberKeydownEvent = evnt => {
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      if (isUpArrow || isDwArrow) {
        evnt.preventDefault();
        if (isUpArrow) {
          numberPlusEvent(evnt);
        } else {
          numberMinusEvent(evnt);
        }
      }
    };
    const keydownEvent = evnt => {
      const {
        type,
        exponential,
        controls
      } = props;
      const controlOpts = computeControlOpts.value;
      const {
        isArrow
      } = controlOpts;
      const inputReadonly = computeInputReadonly.value;
      const isControlKey = hasControlKey(evnt);
      const isShiftKey = evnt.shiftKey;
      const isAltKey = evnt.altKey;
      const keyCode = evnt.keyCode;
      const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      if (!isControlKey && !isShiftKey && !isAltKey) {
        if (globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR) || type === 'integer' && keyCode === 110 || (!exponential || keyCode !== 69) && keyCode >= 65 && keyCode <= 90 || keyCode >= 186 && keyCode <= 188 || keyCode >= 191) {
          evnt.preventDefault();
        }
      }
      if (isEsc) {
        afterCheckValue();
      } else if (isUpArrow || isDwArrow) {
        if (isEnableConf(controlOpts) && (controls === false ? controls : isArrow) && !inputReadonly) {
          numberKeydownEvent(evnt);
        }
      }
      triggerEvent(evnt);
    };
    const keyupEvent = evnt => {
      triggerEvent(evnt);
    };
    // 数值
    const stopDown = () => {
      const {
        dnTimeout
      } = internalData;
      if (dnTimeout) {
        clearTimeout(dnTimeout);
        internalData.dnTimeout = undefined;
      }
    };
    const stopAutoIncrement = () => {
      const {
        ainTimeout
      } = internalData;
      if (ainTimeout) {
        clearTimeout(ainTimeout);
        internalData.ainTimeout = undefined;
      }
    };
    const numberDownMinusEvent = evnt => {
      numberStopAll();
      internalData.ainTimeout = setTimeout(() => {
        numberMinusEvent(evnt);
        numberDownMinusEvent(evnt);
      }, 60);
    };
    const numberDownPlusEvent = evnt => {
      numberStopAll();
      internalData.ainTimeout = setTimeout(() => {
        numberPlusEvent(evnt);
        numberDownPlusEvent(evnt);
      }, 60);
    };
    const numberStopAll = () => {
      stopDown();
      stopAutoIncrement();
    };
    const numberClickEvent = evnt => {
      if (internalData.isMouseDown) {
        internalData.isMouseDown = false;
      } else {
        numberStopAll();
        const isAddNumber = hasClass(evnt.currentTarget, 'is--plus');
        if (isAddNumber) {
          numberPlusEvent(evnt);
        } else {
          numberMinusEvent(evnt);
        }
      }
    };
    const numberMousedownEvent = evnt => {
      numberStopAll();
      internalData.isMouseDown = true;
      if (evnt.button === 0) {
        const isAddNumber = hasClass(evnt.currentTarget, 'is--plus');
        if (isAddNumber) {
          numberPlusEvent(evnt);
        } else {
          numberMinusEvent(evnt);
        }
        internalData.dnTimeout = setTimeout(() => {
          if (isAddNumber) {
            numberDownPlusEvent(evnt);
          } else {
            numberDownMinusEvent(evnt);
          }
        }, 500);
      }
    };
    const wheelEvent = evnt => {
      const {
        controls
      } = props;
      const controlOpts = computeControlOpts.value;
      const {
        isWheel
      } = controlOpts;
      const inputReadonly = computeInputReadonly.value;
      if (isEnableConf(controlOpts) && (controls === false ? controls : isWheel) && !inputReadonly) {
        if (reactData.isActivated) {
          evnt.stopPropagation();
          evnt.preventDefault();
          const delta = evnt.deltaY;
          if (delta > 0) {
            // 向下
            numberMinusEvent(evnt);
          } else if (delta < 0) {
            // 向上
            numberPlusEvent(evnt);
          }
        }
      }
      triggerEvent(evnt);
    };
    const clickEvent = evnt => {
      triggerEvent(evnt);
    };
    // 全局事件
    const handleGlobalMousedownEvent = evnt => {
      const {
        isActivated
      } = reactData;
      const el = refElem.value;
      const panelElem = refInputPanel.value;
      const isDisabled = computeIsDisabled.value;
      const inputReadonly = computeInputReadonly.value;
      const inpImmediate = computeInpImmediate.value;
      if (!isDisabled && !inputReadonly && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (!reactData.isActivated) {
          if (!inpImmediate) {
            const {
              inputValue
            } = reactData;
            const value = inputValue ? Number(inputValue) : null;
            handleChange(value, handleNumberString(inputValue), evnt);
          }
          afterCheckValue();
        }
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const {
        clearable
      } = props;
      const isDisabled = computeIsDisabled.value;
      const inputReadonly = computeInputReadonly.value;
      if (!isDisabled && !inputReadonly) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        let isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        }
        if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const {
        isActivated
      } = reactData;
      if (isActivated) {
        afterCheckValue();
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $numberInput: $xeNumberInput
      }, params));
    };
    numberInputMethods = {
      dispatchEvent,
      focus() {
        const inputReadonly = computeInputReadonly.value;
        if (!inputReadonly) {
          const inputElem = refInputTarget.value;
          reactData.isActivated = true;
          inputElem.focus();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    Object.assign($xeNumberInput, numberInputMethods);
    const renderPrefixIcon = () => {
      const {
        prefixIcon
      } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-number-input--prefix',
        onClick: clickPrefixEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-number-input--prefix-icon'
      }, prefixSlot ? vn_getSlotVNs(prefixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: prefixIcon
      })])]) : renderEmptyElement($xeNumberInput);
    };
    const renderSuffixIcon = () => {
      const {
        suffixIcon
      } = props;
      const {
        inputValue
      } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isClearable = computeIsClearable.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-number-input--suffix', {
          'is--clear': isClearable && !isDisabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }]
      }, [isClearable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-number-input--clear-icon',
        onClick: clearValueEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().INPUT_CLEAR
      })]) : renderEmptyElement($xeNumberInput), suffixSlot || suffixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-number-input--suffix-icon',
        onClick: clickSuffixEvent
      }, suffixSlot ? vn_getSlotVNs(suffixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: suffixIcon
      })]) : renderEmptyElement($xeNumberInput)]);
    };
    const renderInput = () => {
      const {
        type,
        name,
        autocomplete,
        autoComplete
      } = props;
      const {
        inputValue,
        isFocus
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      const numLabel = computeNumLabel.value;
      const inputReadonly = computeInputReadonly.value;
      const inpMaxLength = computeInpMaxLength.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'ni',
        class: 'vxe-number-input--input-wrapper'
      }, [renderPrefixIcon(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-number-input--input-inner'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        ref: refInputTarget,
        class: 'vxe-number-input--input',
        value: !isFocus && type === 'amount' ? numLabel : inputValue,
        name,
        type: 'text',
        placeholder: inpPlaceholder,
        maxlength: inpMaxLength,
        readonly: inputReadonly,
        disabled: isDisabled,
        autocomplete: autoComplete || autocomplete,
        onKeydown: keydownEvent,
        onKeyup: keyupEvent,
        onWheel: wheelEvent,
        onClick: clickEvent,
        onInput: inputEvent,
        onChange: changeEvent,
        onFocus: focusEvent,
        onBlur: blurEvent
      })]), renderSuffixIcon()]);
    };
    const renderMinusBtn = () => {
      const {
        minusIcon
      } = props;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        key: 'prev',
        class: ['vxe-number-input--minus-btn is--minus', {
          'is--disabled': isDisabledSubtractNumber
        }],
        type: 'button',
        onClick: numberClickEvent,
        onMousedown: numberMousedownEvent,
        onMouseup: numberStopAll,
        onMouseleave: numberStopAll
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: minusIcon || getIcon().NUMBER_INPUT_MINUS_NUM
      })]);
    };
    const renderPlusBtn = () => {
      const {
        plusIcon
      } = props;
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        key: 'next',
        class: ['vxe-number-input--plus-btn is--plus', {
          'is--disabled': isDisabledAddNumber
        }],
        type: 'button',
        onClick: numberClickEvent,
        onMousedown: numberMousedownEvent,
        onMouseup: numberStopAll,
        onMouseleave: numberStopAll
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: plusIcon || getIcon().NUMBER_INPUT_PLUS_NUM
      })]);
    };
    const renderSideControl = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'cplr',
        class: 'vxe-number-input--side-control'
      }, [renderPlusBtn(), renderMinusBtn()]);
    };
    const renderVN = () => {
      const {
        className,
        controls,
        type,
        align,
        prefixIcon,
        suffixIcon
      } = props;
      const {
        inputValue,
        isActivated
      } = reactData;
      const vSize = computeSize.value;
      const controlOpts = computeControlOpts.value;
      const {
        layout,
        showButton
      } = controlOpts;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const numLabel = computeNumLabel.value;
      const prefixSlot = slots.prefix;
      const suffixSlot = slots.suffix;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-number-input--readonly', `type--${type}`, className]
        }, numLabel);
      }
      const inputReadonly = computeInputReadonly.value;
      const isClearable = computeIsClearable.value;
      const isControls = isEnableConf(controlOpts) && (controls === false ? controls : showButton);
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-number-input', `type--${type}`, `control-${layout === 'right' || layout === 'left' ? layout : 'default'}`, className, {
          [`size--${vSize}`]: vSize,
          [`is--${align}`]: align,
          'is--controls': isControls && !inputReadonly,
          'is--prefix': !!prefixSlot || prefixIcon,
          'is--suffix': !!suffixSlot || suffixIcon,
          'is--disabled': isDisabled,
          'is--active': isActivated,
          'show--clear': isClearable && !isDisabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }],
        spellcheck: false
      }, isControls ? layout === 'right' ? [renderInput(), renderSideControl()] : layout === 'left' ? [renderSideControl(), renderInput()] : [renderPlusBtn(), renderInput(), renderMinusBtn()] : [renderInput()]);
    };
    $xeNumberInput.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      if (!internalData.isUM) {
        updateModel(val);
      }
      internalData.isUM = false;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.type, () => {
      // 切换类型是重置内置变量
      Object.assign(reactData, {
        inputValue: props.modelValue
      });
      initValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      globalEvents.on($xeNumberInput, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeNumberInput, 'keydown', handleGlobalKeydownEvent);
      globalEvents.on($xeNumberInput, 'blur', handleGlobalBlurEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      reactData.isFocus = false;
      numberStopAll();
      afterCheckValue();
      globalEvents.off($xeNumberInput, 'mousedown');
      globalEvents.off($xeNumberInput, 'keydown');
      globalEvents.off($xeNumberInput, 'blur');
    });
    initValue();
    return $xeNumberInput;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/color-picker/src/color-picker.ts










/* harmony default export */ var color_picker = (defineVxeComponent({
  name: 'VxeColorPicker',
  props: {
    modelValue: String,
    placeholder: String,
    clearable: {
      type: Boolean,
      default: () => getConfig().colorPicker.clearable
    },
    type: {
      type: String,
      default: () => getConfig().colorPicker.type
    },
    size: {
      type: String,
      default: () => getConfig().colorPicker.size || getConfig().size
    },
    className: [String, Function],
    popupClassName: [String, Function],
    colors: {
      type: Array,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(getConfig().colorPicker.colors, true) || []
    },
    showAlpha: {
      type: Boolean,
      default: () => getConfig().colorPicker.showAlpha
    },
    showEyeDropper: {
      type: Boolean,
      default: () => getConfig().colorPicker.showEyeDropper
    },
    showColorExtractor: {
      type: Boolean,
      default: () => getConfig().colorPicker.showColorExtractor
    },
    showQuick: {
      type: Boolean,
      default: () => getConfig().colorPicker.showQuick
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    clickToCopy: {
      type: Boolean,
      default: () => getConfig().colorPicker.clickToCopy
    },
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: ['update:modelValue', 'change', 'clear', 'click'],
  setup(props, context) {
    const {
      emit
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const WinEyeDropper = typeof window !== 'undefined' ? window.EyeDropper : null;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTarget = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refOptionPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHueSliderElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHueSliderBtnElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refAlphaSliderElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refAlphaSliderBtnElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refColorPanelElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refColorActiveElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      selectTyle: 'hex',
      selectColor: `${props.modelValue || ''}`,
      showTypePopup: false,
      panelColor: '',
      hexValue: '',
      rValue: 0,
      gValue: 0,
      bValue: 0,
      aValue: 0,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const typeList = [{
      label: 'HEX',
      value: 'hex'
    }, {
      label: 'RGB',
      value: 'rgb'
    }];
    const internalData = {
      // hpTimeout: undefined
    };
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().colorPicker.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeColorList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        colors
      } = props;
      if (colors) {
        return colors.map(item => {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
            return {
              label: item,
              value: item
            };
          }
          return {
            label: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.label) ? item.value : item.label,
            value: item.value
          };
        });
      }
      return [];
    });
    const computeIsRgb = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectTyle
      } = reactData;
      return selectTyle === 'rgb';
    });
    const computeSelectTypeItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectTyle
      } = reactData;
      return typeList.find(item => item.value === selectTyle);
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeColorPicker = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const emitModel = value => {
      emit('update:modelValue', value);
    };
    const updateMode = () => {
      const {
        modelValue
      } = props;
      reactData.selectColor = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(modelValue);
      updateModelColor();
    };
    const updateType = () => {
      const {
        type
      } = props;
      let selectTyle = 'hex';
      if (type === 'rgb' || type === 'rgba') {
        selectTyle = 'rgb';
      }
      reactData.selectTyle = selectTyle;
      updateMode();
    };
    const updateModelColor = () => {
      const {
        selectColor,
        isAniVisible
      } = reactData;
      const isRgb = computeIsRgb.value;
      const hueSliderEl = refHueSliderElem.value;
      const alphaSliderEl = refAlphaSliderElem.value;
      const colorRest = parseColor(selectColor);
      reactData.hexValue = colorRest.hex;
      reactData.rValue = colorRest.r;
      reactData.gValue = colorRest.g;
      reactData.bValue = colorRest.b;
      reactData.aValue = colorRest.a;
      if (colorRest.value) {
        if (isRgb) {
          if (colorRest.type === 'hex') {
            const rgbRest = hexToRgb(colorRest.hex);
            if (rgbRest) {
              reactData.rValue = rgbRest.r;
              reactData.gValue = rgbRest.g;
              reactData.bValue = rgbRest.b;
              reactData.aValue = rgbRest.a;
            }
          }
        } else {
          if (colorRest.type !== 'hex') {
            reactData.hexValue = rgbToHex(colorRest);
          }
        }
      }
      if (isAniVisible) {
        const hsvRest = colorRest.type === 'hex' ? hexToHsv(colorRest.hex) : rgbToHsv(colorRest);
        const colorPanelEl = refColorPanelElem.value;
        if (hsvRest) {
          if (colorPanelEl) {
            const offsetTop = colorPanelEl.clientHeight * (1 - hsvRest.v);
            const offsetLeft = colorPanelEl.clientWidth * hsvRest.s;
            handlePanelColor(offsetLeft, offsetTop);
          }
          if (hueSliderEl) {
            handleHueColor(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().ceil((1 - hsvRest.h / 360) * hueSliderEl.clientWidth));
          }
        }
        if (alphaSliderEl) {
          handleAlphaColor(alphaSliderEl.clientWidth * colorRest.a);
        }
      }
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      const {
        placement
      } = props;
      const {
        panelIndex
      } = reactData;
      const targetElem = refElem.value;
      const panelElem = refOptionPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(handleStyle);
    };
    const showOptionPanel = () => {
      const {
        hpTimeout
      } = internalData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (hpTimeout) {
          clearTimeout(hpTimeout);
          internalData.hpTimeout = undefined;
        }
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        setTimeout(() => {
          updateModelColor();
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      internalData.hpTimeout = setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, value) => {
      reactData.selectColor = value;
      if (value !== props.modelValue) {
        emitModel(value);
        dispatchEvent('change', {
          value
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue);
      dispatchEvent('clear', {
        value: selectValue
      }, evnt);
    };
    const focusEvent = () => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
      }
    };
    const blurEvent = () => {
      reactData.isActivated = false;
    };
    const clearEvent = evnt => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const confirmEvent = evnt => {
      const {
        selectColor
      } = reactData;
      changeEvent(evnt, selectColor);
      hideOptionPanel();
    };
    const togglePanelEvent = evnt => {
      evnt.preventDefault();
      if (reactData.visiblePanel) {
        hideOptionPanel();
      } else {
        showOptionPanel();
      }
    };
    const clickEvent = evnt => {
      togglePanelEvent(evnt);
      dispatchEvent('click', {}, evnt);
    };
    const handlePanelClickEvent = () => {
      reactData.showTypePopup = false;
    };
    const toggleTypeVisibleEvent = evnt => {
      evnt.stopPropagation();
      reactData.showTypePopup = !reactData.showTypePopup;
    };
    const handleChangeType = type => {
      const {
        selectTyle
      } = reactData;
      if (type !== selectTyle) {
        reactData.selectTyle = type;
        updateModelColor();
      }
      reactData.showTypePopup = false;
    };
    const handleHueColor = offsetLeft => {
      const hueSliderEl = refHueSliderElem.value;
      const hueSliderBtnEl = refHueSliderBtnElem.value;
      if (hueSliderEl && hueSliderBtnEl) {
        if (offsetLeft < 0) {
          offsetLeft = 0;
        }
        const barWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(hueSliderEl.clientWidth);
        const itemNum = 255;
        const countNum = itemNum * 6;
        const offsetX = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().ceil(countNum / barWidth * offsetLeft);
        const offsetNum = offsetX % itemNum;
        let rNum = 0;
        let gNum = 0;
        let bNum = 0;
        switch (Math.ceil(offsetX / itemNum)) {
          case 1:
            rNum = itemNum;
            bNum = offsetNum;
            break;
          case 2:
            rNum = itemNum - offsetNum;
            bNum = itemNum;
            break;
          case 3:
            gNum = offsetNum;
            bNum = itemNum;
            break;
          case 4:
            gNum = itemNum;
            bNum = itemNum - offsetNum;
            break;
          case 5:
            rNum = offsetNum;
            gNum = itemNum;
            break;
          case 6:
            rNum = itemNum;
            gNum = itemNum - offsetNum;
            break;
        }
        reactData.panelColor = toRgb(rNum, gNum, bNum);
        hueSliderBtnEl.style.left = toCssUnit(offsetLeft);
      }
    };
    const handleHueBarEvent = evnt => {
      const hueSliderEl = refHueSliderElem.value;
      const hueSliderBtnEl = refHueSliderBtnElem.value;
      if (hueSliderEl && hueSliderBtnEl) {
        const hueSliderRect = hueSliderEl.getBoundingClientRect();
        const barWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(hueSliderEl.clientWidth);
        const offsetLeft = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().ceil(Math.min(barWidth - 1, Math.max(1, evnt.clientX - hueSliderRect.x)));
        handleHueColor(offsetLeft);
      }
    };
    const handleHueSliderMousedownEvent = evnt => {
      evnt.preventDefault();
      document.onmousemove = evnt => {
        evnt.preventDefault();
        handleHueBarEvent(evnt);
      };
      document.onmouseup = evnt => {
        document.onmousemove = null;
        document.onmouseup = null;
        handleHueBarEvent(evnt);
      };
    };
    const handleAlphaColor = offsetLeft => {
      const {
        selectColor
      } = reactData;
      const alphaSliderEl = refAlphaSliderElem.value;
      const alphaSliderBtnEl = refAlphaSliderBtnElem.value;
      if (alphaSliderEl && alphaSliderBtnEl) {
        const alphaSliderRect = alphaSliderEl.getBoundingClientRect();
        const barWidth = alphaSliderRect.width;
        if (offsetLeft < 0) {
          offsetLeft = 0;
        }
        if (offsetLeft > barWidth) {
          offsetLeft = barWidth;
        }
        const alpha = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().ceil(100 / barWidth * offsetLeft / 100, 2);
        reactData.aValue = alpha;
        alphaSliderBtnEl.style.left = toCssUnit(offsetLeft);
        reactData.selectColor = updateColorAlpha(selectColor, alpha);
      }
    };
    const handleAlphaBarEvent = evnt => {
      const alphaSliderEl = refAlphaSliderElem.value;
      const alphaSliderBtnEl = refAlphaSliderBtnElem.value;
      if (alphaSliderEl && alphaSliderBtnEl) {
        const alphaSliderRect = alphaSliderEl.getBoundingClientRect();
        const barWidth = alphaSliderRect.width;
        const offsetLeft = Math.min(barWidth, Math.max(0, evnt.clientX - alphaSliderRect.x));
        handleAlphaColor(offsetLeft);
        updateModelColor();
      }
    };
    const handleAlphaSliderMousedownEvent = evnt => {
      evnt.preventDefault();
      document.onmousemove = evnt => {
        evnt.preventDefault();
        handleAlphaBarEvent(evnt);
      };
      document.onmouseup = evnt => {
        document.onmousemove = null;
        document.onmouseup = null;
        handleAlphaBarEvent(evnt);
      };
    };
    const handleInputRgbEvent = () => {
      const {
        rValue,
        gValue,
        bValue,
        aValue
      } = reactData;
      reactData.selectColor = toRgb(rValue, gValue, bValue, aValue);
      updateModelColor();
    };
    const handleInputAlphaEvent = () => {
      const {
        aValue
      } = reactData;
      const alphaSliderEl = refAlphaSliderElem.value;
      const alphaSliderBtnEl = refAlphaSliderBtnElem.value;
      if (alphaSliderEl && alphaSliderBtnEl) {
        const alphaSliderRect = alphaSliderEl.getBoundingClientRect();
        const barWidth = alphaSliderRect.width;
        const offsetLeft = barWidth * aValue;
        handleAlphaColor(offsetLeft);
      }
    };
    const handleQuickEvent = (evnt, item) => {
      const value = item.value;
      reactData.selectColor = value;
      updateModelColor();
    };
    const handlePanelColor = (offsetLeft, offsetTop) => {
      const colorActiveEl = refColorActiveElem.value;
      if (colorActiveEl) {
        colorActiveEl.style.top = toCssUnit(offsetTop);
        colorActiveEl.style.left = toCssUnit(offsetLeft);
      }
    };
    const handleEyeDropperEvent = () => {
      if (WinEyeDropper) {
        try {
          const eyeDropper = new WinEyeDropper();
          eyeDropper.open().then(rest => {
            if (rest && rest.sRGBHex) {
              reactData.selectColor = rest.sRGBHex;
              updateModelColor();
            }
          }).catch(() => {});
        } catch (e) {}
      }
    };
    const handleSelectColorMousedownEvent = evnt => {
      const {
        showAlpha
      } = props;
      const {
        panelColor,
        aValue
      } = reactData;
      const colorPanelEl = refColorPanelElem.value;
      const colorActiveEl = refColorActiveElem.value;
      if (colorPanelEl && colorActiveEl) {
        const colorPanelRect = colorPanelEl.getBoundingClientRect();
        const offsetTop = evnt.clientY - colorPanelRect.y;
        const offsetLeft = evnt.clientX - colorPanelRect.x;
        const colorRest = parseColor(panelColor);
        if (colorRest) {
          const hsvRest = colorRest.type === 'hex' ? hexToHsv(colorRest.hex) : rgbToHsv(colorRest);
          if (hsvRest) {
            const ragRest = hsvToRgb(hsvRest.h, offsetLeft / colorPanelEl.clientWidth, 1 - offsetTop / colorPanelEl.clientHeight);
            reactData.selectColor = toRgb(ragRest.r, ragRest.g, ragRest.b, showAlpha ? aValue : null);
            handlePanelColor(offsetLeft, offsetTop);
            updateModelColor();
          }
        }
      }
    };
    const handleCopyColorEvent = () => {
      const {
        selectColor
      } = reactData;
      if (selectColor) {
        if (index_esm_VxeUI.clipboard.copy(selectColor)) {
          if (index_esm_VxeUI.modal) {
            index_esm_VxeUI.modal.message({
              content: getI18n('vxe.colorPicker.copySuccess', [selectColor]),
              status: 'success'
            });
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const {
        visiblePanel,
        isActivated
      } = reactData;
      if (visiblePanel) {
        hideOptionPanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        const targetElem = refInputTarget.value;
        if (targetElem) {
          targetElem.blur();
        }
      }
    };
    const handleGlobalResizeEvent = () => {
      const {
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $colorPicker: $xeColorPicker
      }, params));
    };
    const colorPickerMethods = {
      dispatchEvent
    };
    const colorPickerPrivateMethods = {};
    Object.assign($xeColorPicker, colorPickerMethods, colorPickerPrivateMethods);
    const renderColorWrapper = () => {
      const {
        showColorExtractor
      } = props;
      const {
        panelColor
      } = reactData;
      if (showColorExtractor) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refColorPanelElem,
          class: 'vxe-color-picker--color-wrapper',
          onMousedown: handleSelectColorMousedownEvent
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-color-picker--color-bg',
          style: {
            backgroundColor: panelColor
          }
        }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-color-picker--white-bg'
        }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-color-picker--black-bg'
        }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refColorActiveElem,
          class: 'vxe-color-picker--color-active'
        })]);
      }
      return renderEmptyElement($xeColorPicker);
    };
    const renderColorBar = () => {
      const {
        showAlpha,
        clickToCopy,
        showEyeDropper
      } = props;
      const {
        selectTyle,
        showTypePopup,
        hexValue,
        rValue,
        gValue,
        bValue,
        aValue,
        selectColor,
        panelColor
      } = reactData;
      const isRgb = computeIsRgb.value;
      const selectTypeItem = computeSelectTypeItem.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--bar-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--slider-wrapper'
      }, [showEyeDropper && WinEyeDropper ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--color-dropper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-color-picker--color-dropper-btn',
        onClick: handleEyeDropperEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().COLOR_PICKER_EYE_DROPPER
      })])]) : renderEmptyElement($xeColorPicker), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--slider-preview'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--preview-btn'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--preview-color',
        style: {
          backgroundColor: selectColor
        }
      }, clickToCopy ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-color-picker--preview-copy-btn',
        onClick: handleCopyColorEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().COLOR_PICKER_COLOR_COPY
      })])] : [])])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--slider-handle'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refHueSliderElem,
        class: 'vxe-color-picker--bar-hue-slider',
        onClick: handleHueBarEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refHueSliderBtnElem,
        class: 'vxe-color-picker--bar-hue-btn',
        onMousedown: handleHueSliderMousedownEvent
      })]), showAlpha ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refAlphaSliderElem,
        class: 'vxe-color-picker--bar-alpha-slider',
        onClick: handleAlphaBarEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--bar-alpha-bg',
        style: {
          background: `linear-gradient(to right, rgba(0, 0, 0, 0), ${panelColor})`
        }
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refAlphaSliderBtnElem,
        class: 'vxe-color-picker--bar-alpha-btn',
        onMousedown: handleAlphaSliderMousedownEvent
      })]) : renderEmptyElement($xeColorPicker)])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--custom-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--type-switch'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--type-label',
        onClick: toggleTypeVisibleEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', `${selectTypeItem ? selectTypeItem.label : selectTyle}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-color-picker--type-icon'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: showTypePopup ? getIcon().COLOR_PICKER_TPTY_OPEN : getIcon().COLOR_PICKER_TPTY_CLOSE
      })])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-color-picker--type-popup', {
          'is--visible': showTypePopup
        }]
      }, typeList.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-color-picker--type-item',
          onClick(evnt) {
            evnt.stopPropagation();
            handleChangeType(item.value);
          }
        }, item.label);
      }))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: `vxe-color-picker--${selectTyle}-wrapper`
      }, isRgb ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--input-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(number_input, {
        type: 'integer',
        size: 'mini',
        align: 'center',
        min: 0,
        max: 255,
        maxLength: 3,
        placeholder: '',
        modelValue: rValue,
        controlConfig: {
          showButton: false
        },
        'onUpdate:modelValue'(val) {
          reactData.rValue = val;
        },
        onChange: handleInputRgbEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(number_input, {
        type: 'integer',
        size: 'mini',
        align: 'center',
        min: 0,
        max: 255,
        maxLength: 3,
        placeholder: '',
        modelValue: gValue,
        controlConfig: {
          showButton: false
        },
        'onUpdate:modelValue'(val) {
          reactData.gValue = val;
        },
        onChange: handleInputRgbEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(number_input, {
        type: 'integer',
        size: 'mini',
        align: 'center',
        min: 0,
        max: 255,
        maxLength: 3,
        placeholder: '',
        modelValue: bValue,
        controlConfig: {
          showButton: false
        },
        'onUpdate:modelValue'(val) {
          reactData.bValue = val;
        },
        onChange: handleInputRgbEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(number_input, {
        type: 'number',
        size: 'mini',
        align: 'center',
        min: 0,
        max: 1,
        step: 0.01,
        maxLength: 4,
        placeholder: '',
        modelValue: aValue,
        controlConfig: {
          showButton: false
        },
        'onUpdate:modelValue'(val) {
          reactData.aValue = val;
        },
        onChange: handleInputAlphaEvent
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--input-title'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', 'R'), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', 'G'), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', 'B'), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', 'A')])] : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--input-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
        type: 'text',
        size: 'mini',
        align: 'center',
        maxLength: 9,
        placeholder: '',
        modelValue: hexValue,
        'onUpdate:modelValue'(val) {
          reactData.hexValue = val;
        },
        onChange() {
          const colorRest = parseColor(reactData.hexValue);
          if (colorRest) {
            if (colorRest.value) {
              reactData.selectColor = colorRest.value;
              updateModelColor();
            }
          }
        }
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--input-title'
      }, getI18n('vxe.colorPicker.hex'))])])]);
    };
    const renderQuickWrapper = () => {
      const {
        showQuick
      } = props;
      const colorList = computeColorList.value;
      if (showQuick && colorList.length) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-color-picker--quick-wrapper'
        }, colorList.map((item, i) => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: i,
            class: 'vxe-color-picker--quick-item',
            title: item.label || '',
            style: {
              backgroundColor: item.value
            },
            onClick(evnt) {
              handleQuickEvent(evnt, item);
            }
          });
        }));
      }
      return renderEmptyElement($xeColorPicker);
    };
    const renderVN = () => {
      const {
        className,
        popupClassName,
        clearable,
        modelValue
      } = props;
      const {
        initialized,
        isActivated,
        isAniVisible,
        visiblePanel
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-color-picker--readonly', className]
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-color-picker--readonly-color',
          style: {
            backgroundColor: modelValue
          }
        })]);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-color-picker', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $colorPicker: $xeColorPicker
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--selected': !!modelValue,
          'is--visible': visiblePanel,
          'is--disabled': isDisabled,
          'is--active': isActivated
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        ref: refInputTarget,
        class: 'vxe-color-picker--input',
        onFocus: focusEvent,
        onBlur: blurEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--inner',
        onClick: clickEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--inner-color',
        style: {
          backgroundColor: modelValue
        }
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: btnTransfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refOptionPanel,
        class: ['vxe-table--ignore-clear vxe-color-picker--panel', popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
          $colorPicker: $xeColorPicker
        }) : popupClassName : '', {
          [`size--${vSize}`]: vSize,
          'is--transfer': btnTransfer,
          'ani--leave': isAniVisible,
          'ani--enter': visiblePanel
        }],
        placement: reactData.panelPlacement,
        style: reactData.panelStyle
      }, [initialized && (visiblePanel || isAniVisible) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--panel-wrapper',
        onClick: handlePanelClickEvent
      }, [renderColorWrapper(), renderColorBar(), renderQuickWrapper(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-color-picker--footer-wrapper'
      }, [clearable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        content: getI18n('vxe.colorPicker.clear'),
        size: 'mini',
        onClick: clearEvent
      }) : renderEmptyElement($xeColorPicker), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        content: getI18n('vxe.colorPicker.confirm'),
        size: 'mini',
        status: 'primary',
        onClick: confirmEvent
      })])]) : renderEmptyElement($xeColorPicker)])])]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, () => {
      updateMode();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.type, () => {
      updateType();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      globalEvents.on($xeColorPicker, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeColorPicker, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeColorPicker, 'blur', handleGlobalBlurEvent);
      globalEvents.on($xeColorPicker, 'resize', handleGlobalResizeEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeColorPicker, 'mousewheel');
      globalEvents.off($xeColorPicker, 'mousedown');
      globalEvents.off($xeColorPicker, 'blur');
      globalEvents.off($xeColorPicker, 'resize');
    });
    updateType();
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeColorPicker', $xeColorPicker);
    $xeColorPicker.renderVN = renderVN;
    return $xeColorPicker;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/color-picker/index.ts



const VxeColorPicker = Object.assign({}, color_picker, {
  install(app) {
    app.component(color_picker.name, color_picker);
  }
});
dynamicApp.use(VxeColorPicker);
index_esm_VxeUI.component(color_picker);
const ColorPicker = VxeColorPicker;
/* harmony default export */ var packages_color_picker = (VxeColorPicker);
;// CONCATENATED MODULE: ./packages/text/src/text.ts





/* harmony default export */ var src_text = (defineVxeComponent({
  name: 'VxeText',
  props: {
    status: String,
    title: [String, Number],
    icon: String,
    loading: Boolean,
    content: [String, Number],
    clickToCopy: Boolean,
    size: {
      type: String,
      default: () => getConfig().text.size || getConfig().size
    }
  },
  emits: ['click'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refContentElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const clickIconEvent = () => {
      const {
        content,
        clickToCopy
      } = props;
      if (clickToCopy) {
        const contentEl = refContentElem.value;
        const copyVal = (contentEl ? contentEl.textContent : '') || content;
        if (copyVal) {
          if (index_esm_VxeUI.clipboard.copy(copyVal)) {
            if (index_esm_VxeUI.modal) {
              index_esm_VxeUI.modal.message({
                content: getI18n('vxe.text.copySuccess'),
                status: 'success'
              });
            }
          } else {
            if (index_esm_VxeUI.modal) {
              index_esm_VxeUI.modal.message({
                content: getI18n('vxe.text.copyError'),
                status: 'error'
              });
            }
          }
        }
      }
    };
    const $xeText = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $text: $xeText
      }, params));
    };
    const textMethods = {
      dispatchEvent
    };
    const clickEvent = evnt => {
      const {
        loading
      } = props;
      if (!loading) {
        dispatchEvent('click', {}, evnt);
      }
    };
    const textPrivateMethods = {};
    Object.assign($xeText, textMethods, textPrivateMethods);
    const renderContent = () => {
      const {
        loading,
        icon,
        content,
        clickToCopy
      } = props;
      const defaultSlot = slots.default;
      const iconSlot = slots.icon;
      return [loading ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-text--loading'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().TEXT_LOADING
      })]) : iconSlot || icon || clickToCopy ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-text--icon',
        onClick: clickIconEvent
      }, iconSlot ? vn_getSlotVNs(iconSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon || getIcon().TEXT_COPY
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)(), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        ref: refContentElem,
        class: 'vxe-text--content'
      }, defaultSlot ? defaultSlot({}) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content))];
    };
    const renderVN = () => {
      const {
        loading,
        status,
        title,
        clickToCopy
      } = props;
      const vSize = computeSize.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        ref: refElem,
        title,
        class: ['vxe-text', {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          'is--copy': clickToCopy,
          'is--loading': loading
        }],
        onClick: clickEvent
      }, renderContent());
    };
    $xeText.renderVN = renderVN;
    return $xeText;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/countdown/src/countdown.ts






/* harmony default export */ var countdown = (defineVxeComponent({
  name: 'VxeCountdown',
  props: {
    modelValue: [Number, String],
    format: String,
    prefixConfig: Object,
    suffixConfig: Object,
    size: {
      type: String,
      default: () => getConfig().countdown.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'start', 'end'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      currNum: 0,
      secondNum: 0
    });
    const internalData = {
      dnTimeout: undefined
    };
    const refMaps = {
      refElem
    };
    const computeTimeFormats = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        secondNum
      } = reactData;
      if (secondNum >= 31622400000) {
        return ['yyyy', 'MM', 'dd', 'HH', 'mm', 'ss'];
      }
      if (secondNum >= 2678400000) {
        return ['MM', 'dd', 'HH', 'mm', 'ss'];
      }
      if (secondNum >= 86400000) {
        return ['dd', 'HH', 'mm', 'ss'];
      }
      if (secondNum >= 3600000) {
        return ['HH', 'mm', 'ss'];
      }
      if (secondNum >= 60000) {
        return ['mm', 'ss'];
      }
      return ['ss'];
    });
    const computeDiffConf = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        currNum
      } = reactData;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getDateDiff(Date.now(), Date.now() + currNum);
    });
    const computeFormatLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        format
      } = props;
      const diffConf = computeDiffConf.value;
      let rest = '';
      if (format) {
        rest = `${format}`;
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(diffConf, (val, key) => {
          rest = rest.replace(new RegExp(key, 'g'), external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().padStart(val, key.length, '0'));
        });
        return rest;
      }
      return rest;
    });
    const computePrefixOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, props.prefixConfig, getConfig().countdown.prefixConfig);
    });
    const computeSuffixOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, props.suffixConfig, getConfig().countdown.suffixConfig);
    });
    const computeMaps = {
      computeSize
    };
    const $xeCountdown = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $carousel: $xeCountdown
      }, params));
    };
    const updateCount = () => {
      const secondNum = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.modelValue || 0);
      reactData.secondNum = secondNum;
      reactData.currNum = secondNum;
    };
    const handleTime = () => {
      const {
        currNum
      } = reactData;
      if (currNum > 1000) {
        reactData.currNum -= 1000;
        internalData.dnTimeout = setTimeout(() => {
          handleTime();
        }, 1000);
      } else {
        reactData.currNum = 0;
        handleStop();
      }
    };
    const countdownMethods = {
      dispatchEvent
    };
    const handleStart = () => {
      dispatchEvent('start', {}, null);
      handleTime();
    };
    const handleStop = () => {
      const {
        dnTimeout
      } = internalData;
      if (dnTimeout) {
        clearTimeout(dnTimeout);
        internalData.dnTimeout = undefined;
        dispatchEvent('end', {}, null);
      }
    };
    const countdownPrivateMethods = {};
    Object.assign($xeCountdown, countdownMethods, countdownPrivateMethods);
    const renderDefaultContentVNs = () => {
      const {
        format
      } = props;
      const timeFormats = computeTimeFormats.value;
      const diffConf = computeDiffConf.value;
      const formatLabel = computeFormatLabel.value;
      if (format) {
        return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: 'format',
          class: 'vxe-countdown--content-format'
        }, formatLabel)];
      }
      return timeFormats.map((key, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: index,
          class: 'vxe-countdown--content-item'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-countdown--content-num'
        }, `${diffConf[key] || 0}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-countdown--content-unit'
        }, getI18n(`vxe.countdown.formats.${key}`))]);
      });
    };
    const renderVN = () => {
      const {
        prefixConfig,
        suffixConfig
      } = props;
      const {
        currNum
      } = reactData;
      const vSize = computeSize.value;
      const diffConf = computeDiffConf.value;
      const prefixOpts = computePrefixOpts.value;
      const suffixOpts = computeSuffixOpts.value;
      const prefixSlot = slots.prefix;
      const suffixSlot = slots.suffix;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-countdown', diffConf.done ? 'is--progress' : 'is-end', {
          [`size--${vSize}`]: vSize
        }]
      }, [prefixSlot || prefixConfig ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-countdown--prefix'
      }, prefixSlot ? vn_getSlotVNs(prefixSlot({
        currentValue: currNum,
        diffConf
      })) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_text, {
        content: prefixOpts.content,
        icon: prefixOpts.icon,
        status: prefixOpts.status
      })]) : renderEmptyElement($xeCountdown), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-countdown--content'
      }, defaultSlot ? vn_getSlotVNs(defaultSlot({
        currentValue: currNum,
        diffConf
      })) : renderDefaultContentVNs()), suffixSlot || suffixConfig ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-countdown--suffix'
      }, suffixSlot ? vn_getSlotVNs(suffixSlot({
        currentValue: currNum,
        diffConf
      })) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_text, {
        content: suffixOpts.content,
        icon: suffixOpts.icon,
        status: suffixOpts.status
      })]) : renderEmptyElement($xeCountdown)]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, () => {
      updateCount();
      handleStop();
      handleStart();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      handleStop();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      handleStart();
    });
    updateCount();
    $xeCountdown.renderVN = renderVN;
    return $xeCountdown;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/countdown/index.ts



const VxeCountdown = Object.assign({}, countdown, {
  install(app) {
    app.component(countdown.name, countdown);
  }
});
dynamicApp.use(VxeCountdown);
index_esm_VxeUI.component(countdown);
const Countdown = VxeCountdown;
/* harmony default export */ var packages_countdown = (VxeCountdown);
;// CONCATENATED MODULE: ./packages/date-panel/src/date-panel.ts






/* harmony default export */ var date_panel = (defineVxeComponent({
  name: 'VxeDatePanel',
  props: {
    modelValue: [String, Number, Date],
    type: {
      type: String,
      default: 'date'
    },
    className: String,
    size: {
      type: String,
      default: () => getConfig().datePanel.size || getConfig().size
    },
    multiple: Boolean,
    limitCount: {
      type: [String, Number],
      default: () => getConfig().datePanel.limitCount
    },
    // date、week、month、quarter、year
    startDate: {
      type: [String, Number, Date],
      default: () => getConfig().datePanel.startDate
    },
    endDate: {
      type: [String, Number, Date],
      default: () => getConfig().datePanel.endDate
    },
    defaultDate: [String, Number, Date],
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    startDay: {
      type: [String, Number],
      default: () => getConfig().datePanel.startDay
    },
    labelFormat: String,
    valueFormat: String,
    timeFormat: String,
    festivalMethod: {
      type: Function,
      default: () => getConfig().datePanel.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().datePanel.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().datePanel.selectDay
    }
  },
  emits: ['update:modelValue', 'change', 'click', 'clear', 'date-prev', 'date-today', 'date-next', 'confirm'],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false,
      inputValue: '',
      datetimePanelValue: null,
      datePanelValue: null,
      datePanelLabel: '',
      datePanelType: 'day',
      selectMonth: null,
      currentDate: null
    });
    const internalData = {
      yearSize: 12,
      monthSize: 20,
      quarterSize: 8,
      hpTimeout: undefined
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPanelWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTimeBody = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xeDatePanel = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const computeIsDateTimeType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      return type === 'time' || type === 'datetime';
    });
    const computeIsDatePanelType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDateTimeType = computeIsDateTimeType.value;
      return isDateTimeType || ['date', 'week', 'month', 'quarter', 'year'].indexOf(props.type) > -1;
    });
    const computeDateStartTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.startDate ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(props.startDate) : null;
    });
    const computeDateEndTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.endDate ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(props.endDate) : null;
    });
    const computeDateListValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        multiple
      } = props;
      const isDatePanelType = computeIsDatePanelType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && modelValue && isDatePanelType) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(modelValue).split(',').map(item => {
          const date = parseDate(item, dateValueFormat);
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(date)) {
            return date;
          }
          return date;
        });
      }
      return [];
    });
    const computeDateMultipleValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateLabelFormat)).join(', ');
    });
    const computeLimitMaxCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.multiple ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.limitCount) : 0;
    });
    const computeOverCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        multiple
      } = props;
      const limitMaxCount = computeLimitMaxCount.value;
      const dateMultipleValue = computeDateMultipleValue.value;
      if (multiple && limitMaxCount) {
        return dateMultipleValue.length >= limitMaxCount;
      }
      return false;
    });
    const computeDateValueFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        valueFormat
      } = props;
      return handleValueFormat(type, valueFormat);
    });
    const computeDateValue = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue
      } = props;
      const isDatePanelType = computeIsDatePanelType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (modelValue && isDatePanelType) {
        const date = parseDate(modelValue, dateValueFormat);
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateStartTime = computeDateStartTime.value;
      const {
        selectMonth
      } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateEndTime = computeDateEndTime.value;
      const {
        selectMonth
      } = reactData;
      if (selectMonth && dateEndTime) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(selectMonth, 0, 'last') >= dateEndTime;
      }
      return false;
    });
    const computeDateTimeLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        datetimePanelValue
      } = reactData;
      const hasTimeSecond = computeHasTimeSecond.value;
      const hasTimeMinute = computeHasTimeMinute.value;
      if (datetimePanelValue) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(datetimePanelValue, hasTimeMinute && hasTimeSecond ? 'HH:mm:ss' : hasTimeMinute ? 'HH:mm' : 'HH');
      }
      return '';
    });
    const computeDateHMSTime = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      return dateValue && isDateTimeType ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1000 : 0;
    });
    const computeDateLabelFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        labelFormat
      } = props;
      const isDatePanelType = computeIsDatePanelType.value;
      if (isDatePanelType) {
        return labelFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return '';
    });
    const computeYearList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        yearSize
      } = internalData;
      const {
        selectMonth,
        currentDate
      } = reactData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (let index = -4; index < yearSize + 4; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(startYearDate, index, 'first');
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelObj = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDatePanelType = computeIsDatePanelType.value;
      let y = '';
      let m = '';
      if (isDatePanelType) {
        const {
          datePanelType,
          selectMonth
        } = reactData;
        const yearList = computeYearList.value;
        let year = '';
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === 'quarter' || datePanelType === 'month') {
          y = getI18n('vxe.datePicker.yearTitle', [year]);
        } else if (datePanelType === 'year') {
          y = yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : '';
        } else {
          y = getI18n('vxe.datePicker.yearTitle', [year]);
          m = month ? getI18n(`vxe.input.date.m${month}`) : '-';
        }
      }
      return {
        y,
        m
      };
    });
    const computeFirstDayOfWeek = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        startDay
      } = props;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(startDay);
    });
    const computeWeekDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const weeks = [];
      const isDatePanelType = computeIsDatePanelType.value;
      if (isDatePanelType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index = 0; index < 6; index++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDatePanelType = computeIsDatePanelType.value;
      if (isDatePanelType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map(day => {
          return {
            value: day,
            label: getI18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDatePanelType = computeIsDatePanelType.value;
      if (isDatePanelType) {
        const dateHeaders = computeDateHeaders.value;
        return [{
          label: getI18n('vxe.input.date.weeks.w')
        }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const yearList = computeYearList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(yearList, 4);
    });
    const computeQuarterList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        quarterSize
      } = internalData;
      const {
        selectMonth,
        currentDate
      } = reactData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter(currentDate);
        const firstYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, 'first');
        const selFullYear = firstYear.getFullYear();
        for (let index = -2; index < quarterSize - 2; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatQuarter(firstYear, index);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const quarterList = computeQuarterList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(quarterList, 2);
    });
    const computeMonthList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        monthSize
      } = internalData;
      const {
        selectMonth,
        currentDate
      } = reactData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, 'first').getFullYear();
        for (let index = -4; index < monthSize - 4; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 0, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const monthList = computeMonthList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(monthList, 4);
    });
    const computeDayList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectMonth,
        currentDate
      } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index = 0; index < 42; index++) {
          const date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(startDayDate, index);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dayList = computeDayList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(dayList, 7);
    });
    const computeWeekDates = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map(list => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const computeHourList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 24; index++) {
          list.push({
            value: index,
            label: ('' + index).padStart(2, '0')
          });
        }
      }
      return list;
    });
    const computeMinuteList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index = 0; index < 60; index++) {
          list.push({
            value: index,
            label: ('' + index).padStart(2, '0')
          });
        }
      }
      return list;
    });
    const computeHasTimeMinute = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        timeFormat
      } = props;
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(timeFormat || dateValueFormat) || /mm/.test(timeFormat || dateValueFormat);
    });
    const computeHasTimeSecond = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        timeFormat
      } = props;
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(timeFormat || dateValueFormat) || /ss/.test(timeFormat || dateValueFormat);
    });
    const computeSecondList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const minuteList = computeMinuteList.value;
      return minuteList;
    });
    const updateModelValue = modelValue => {
      const {
        type
      } = props;
      const dateValueFormat = computeDateValueFormat.value;
      reactData.inputValue = parseDateValue(modelValue, type, {
        valueFormat: dateValueFormat
      });
      dateOpenPanel();
    };
    const parseDate = (value, format) => {
      const {
        type,
        multiple
      } = props;
      if (type === 'time') {
        return toStringTimeDate(value);
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(value)) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(value[0], format);
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(value)) {
        return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(multiple ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().last(value.split(',')) : value, format);
      }
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(value, format);
    };
    const dateRevert = () => {
      reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
    };
    const afterCheckValue = inputLabel => {
      const {
        type
      } = props;
      const {
        inputValue,
        datetimePanelValue
      } = reactData;
      const dateLabelFormat = computeDateLabelFormat.value;
      if (inputLabel) {
        let inpDateVal = parseDate(inputLabel, dateLabelFormat);
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(inpDateVal)) {
          if (type === 'time') {
            inpDateVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(inpDateVal, dateLabelFormat);
            if (inputValue !== inpDateVal) {
              handleChange(inpDateVal, {
                type: 'check'
              });
            }
            reactData.inputValue = inpDateVal;
          } else {
            let isChange = false;
            const firstDayOfWeek = computeFirstDayOfWeek.value;
            if (type === 'datetime') {
              const dateValue = computeDateValue.value;
              if (inputLabel !== external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(dateValue, dateLabelFormat) || inputLabel !== external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(inpDateVal, dateLabelFormat)) {
                isChange = true;
                if (datetimePanelValue) {
                  datetimePanelValue.setHours(inpDateVal.getHours());
                  datetimePanelValue.setMinutes(inpDateVal.getMinutes());
                  datetimePanelValue.setSeconds(inpDateVal.getSeconds());
                }
              }
            } else {
              isChange = true;
            }
            reactData.inputValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(inpDateVal, dateLabelFormat, {
              firstDay: firstDayOfWeek
            });
            if (isChange) {
              dateChange(inpDateVal);
            }
          }
        } else {
          dateRevert();
        }
      } else {
        handleChange('', {
          type: 'check'
        });
      }
    };
    const handleChange = (value, evnt) => {
      const {
        type,
        modelValue,
        valueFormat
      } = props;
      const dateValueFormat = computeDateValueFormat.value;
      reactData.inputValue = value;
      if (hasTimestampValueType(valueFormat)) {
        const dateVal = parseDateValue(value, type, {
          valueFormat: dateValueFormat
        });
        const timeNum = dateVal ? dateVal.getTime() : null;
        emit('update:modelValue', timeNum);
        if (modelValue !== timeNum) {
          dispatchEvent('change', {
            value: timeNum
          }, evnt);
        }
      } else if (hasDateValueType(valueFormat)) {
        const dateVal = parseDateValue(value, type, {
          valueFormat: dateValueFormat
        });
        emit('update:modelValue', dateVal);
        if (modelValue && dateVal ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(modelValue).getTime() !== dateVal.getTime() : modelValue !== dateVal) {
          dispatchEvent('change', {
            value: dateVal
          }, evnt);
        }
      } else {
        emit('update:modelValue', value);
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(modelValue) !== value) {
          dispatchEvent('change', {
            value
          }, evnt);
        }
      }
    };
    const hidePanel = () => {
      return new Promise(resolve => {
        reactData.visiblePanel = false;
        internalData.hpTimeout = setTimeout(() => {
          reactData.isAniVisible = false;
          resolve();
        }, 350);
      });
    };
    const dateParseValue = val => {
      const {
        type
      } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const dateObj = parseDateObj(val, type, {
        valueFormat: dateValueFormat,
        labelFormat: dateLabelFormat,
        firstDay: firstDayOfWeek
      });
      reactData.datePanelValue = dateObj.value;
      reactData.datePanelLabel = dateObj.label;
    };
    /**
     * 值变化时处理
     */
    const changeValue = () => {
      const isDatePanelType = computeIsDatePanelType.value;
      const {
        inputValue
      } = reactData;
      if (isDatePanelType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    /**
     * 检查初始值
     */
    const initValue = () => {
      const {
        modelValue
      } = props;
      const isDatePanelType = computeIsDatePanelType.value;
      updateModelValue(modelValue);
      if (isDatePanelType) {
        changeValue();
      }
    };
    const dateCheckMonth = date => {
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const weekNum = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getYearWeek(date, firstDayOfWeek);
      const weekStartDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(date, 0, firstDayOfWeek, firstDayOfWeek);
      const month = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(weekNum === 1 ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(weekStartDate, 6) : date, 0, 'first');
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = (date, isReload) => {
      const {
        modelValue,
        multiple
      } = props;
      const {
        datetimePanelValue
      } = reactData;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === 'week') {
        const sWeek = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.selectDay);
        date = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      } else if (isDateTimeType) {
        if (datetimePanelValue) {
          date.setHours(datetimePanelValue.getHours());
          date.setMinutes(datetimePanelValue.getMinutes());
          date.setSeconds(datetimePanelValue.getSeconds());
        }
      }
      const inpVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat, {
        firstDay: firstDayOfWeek
      });
      dateCheckMonth(date);
      if (multiple) {
        const overCount = computeOverCount.value;
        // 如果为多选
        if (isDateTimeType) {
          // 如果是datetime特殊类型
          const dateListValue = isReload ? [] : [...computeDateListValue.value];
          const datetimeRest = [];
          const eqIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(dateListValue, val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(date, val, 'yyyyMMdd'));
          if (eqIndex === -1) {
            if (overCount) {
              // 如果超出最大多选数量
              return;
            }
            dateListValue.push(date);
          } else {
            dateListValue.splice(eqIndex, 1);
          }
          dateListValue.forEach(item => {
            if (item) {
              if (datetimePanelValue) {
                item.setHours(datetimePanelValue.getHours());
                item.setMinutes(datetimePanelValue.getMinutes());
                item.setSeconds(datetimePanelValue.getSeconds());
              }
              datetimeRest.push(item);
            }
          });
          handleChange(datetimeRest.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat)).join(','), {
            type: 'update'
          });
        } else {
          const dateMultipleValue = isReload ? [] : computeDateMultipleValue.value;
          // 如果是日期类型
          if (dateMultipleValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(val, inpVal))) {
            handleChange(dateMultipleValue.filter(val => !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(val, inpVal)).join(','), {
              type: 'update'
            });
          } else {
            if (overCount) {
              // 如果超出最大多选数量
              return;
            }
            handleChange(dateMultipleValue.concat([inpVal]).join(','), {
              type: 'update'
            });
          }
        }
      } else {
        // 如果为单选
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEqual(modelValue, inpVal)) {
          handleChange(inpVal, {
            type: 'update'
          });
        }
      }
    };
    // 日期
    const dateMonthHandle = (date, offsetMonth) => {
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const weekNum = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getYearWeek(date, firstDayOfWeek);
      const weekStartDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(date, 0, firstDayOfWeek, firstDayOfWeek);
      const month = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(weekNum === 1 ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(weekStartDate, 6) : date, offsetMonth, 'first');
      reactData.selectMonth = month;
    };
    const dateNowHandle = () => {
      const {
        type
      } = props;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let currentDate = new Date();
      switch (type) {
        case 'week':
          currentDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatWeek(currentDate, 0, firstDayOfWeek);
          break;
        case 'datetime':
          currentDate = new Date();
          reactData.datetimePanelValue = new Date();
          break;
        default:
          currentDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
          break;
      }
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleYearTypeEvent = () => {
      reactData.datePanelType = 'year';
    };
    const dateToggleMonthTypeEvent = () => {
      let {
        datePanelType
      } = reactData;
      if (datePanelType === 'month' || datePanelType === 'quarter') {
        datePanelType = 'year';
      } else {
        datePanelType = 'month';
      }
      reactData.datePanelType = datePanelType;
    };
    const datePrevEvent = evnt => {
      const {
        type
      } = props;
      const {
        datePanelType,
        selectMonth,
        inputValue
      } = reactData;
      const {
        yearSize
      } = internalData;
      const value = inputValue;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        let viewDate;
        if (type === 'year') {
          viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
        } else if (type === 'month' || type === 'quarter') {
          if (datePanelType === 'year') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
          } else {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -1, 'first');
          }
        } else {
          if (datePanelType === 'year') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -yearSize, 'first');
          } else if (datePanelType === 'month') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, -1, 'first');
          } else {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(selectMonth, -1, 'first');
          }
        }
        reactData.selectMonth = viewDate;
        dispatchEvent('date-prev', {
          viewType: datePanelType,
          viewDate,
          value,
          type
        }, evnt);
      }
    };
    const dateTodayMonthEvent = evnt => {
      dateNowHandle();
      dateChange(reactData.currentDate, true);
      if (!props.multiple) {
        hidePanel();
      }
      dispatchEvent('date-today', {
        type: props.type
      }, evnt);
    };
    const dateNextEvent = evnt => {
      const {
        type
      } = props;
      const {
        datePanelType,
        selectMonth,
        inputValue
      } = reactData;
      const {
        yearSize
      } = internalData;
      const value = inputValue;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        let viewDate;
        if (type === 'year') {
          viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
        } else if (type === 'month' || type === 'quarter') {
          if (datePanelType === 'year') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
          } else {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 1, 'first');
          }
        } else {
          if (datePanelType === 'year') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, yearSize, 'first');
          } else if (datePanelType === 'month') {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatYear(selectMonth, 1, 'first');
          } else {
            viewDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatMonth(selectMonth, 1, 'first');
          }
        }
        reactData.selectMonth = viewDate;
        dispatchEvent('date-next', {
          viewType: datePanelType,
          value,
          type
        }, evnt);
      }
    };
    const isRangeDisabled = item => {
      const dateStartTime = computeDateStartTime.value;
      const dateEndTime = computeDateEndTime.value;
      const {
        date
      } = item;
      if (dateStartTime && dateStartTime.getTime() > date.getTime()) {
        return true;
      }
      if (dateEndTime && dateEndTime.getTime() < date.getTime()) {
        return true;
      }
      return false;
    };
    const isDateDisabled = item => {
      const {
        disabledMethod
      } = props;
      const {
        datePanelType
      } = reactData;
      const {
        date
      } = item;
      if (disabledMethod) {
        return disabledMethod({
          type: datePanelType,
          viewType: datePanelType,
          date,
          $datePanel: $xeDatePanel
        });
      }
      return false;
    };
    const hasAllDisabled = item => {
      return isRangeDisabled(item) || isDateDisabled(item);
    };
    const dateSelectItem = date => {
      const {
        type,
        multiple
      } = props;
      const {
        datePanelType
      } = reactData;
      if (type === 'month') {
        if (datePanelType === 'year') {
          reactData.datePanelType = 'month';
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else if (type === 'year') {
        dateChange(date);
        if (!multiple) {
          hidePanel();
        }
      } else if (type === 'quarter') {
        if (datePanelType === 'year') {
          reactData.datePanelType = 'quarter';
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else {
        if (datePanelType === 'month') {
          reactData.datePanelType = type === 'week' ? type : 'day';
          dateCheckMonth(date);
        } else if (datePanelType === 'year') {
          reactData.datePanelType = 'month';
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (type === 'datetime') {
            // 日期带时间
          } else {
            if (!multiple) {
              hidePanel();
            }
          }
        }
      }
    };
    const dateSelectEvent = item => {
      if (!hasAllDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = offsetDay => {
      if (!hasAllDisabled({
        date: offsetDay
      })) {
        const dayList = computeDayList.value;
        if (!dayList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetDay, 'yyyyMMdd'))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = offsetYear => {
      if (!hasAllDisabled({
        date: offsetYear
      })) {
        const yearList = computeYearList.value;
        if (!yearList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetYear, 'yyyy'))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = offsetQuarter => {
      if (!hasAllDisabled({
        date: offsetQuarter
      })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetQuarter, 'yyyyq'))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = offsetMonth => {
      if (!hasAllDisabled({
        date: offsetMonth
      })) {
        const monthList = computeMonthList.value;
        if (!monthList.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(item.date, offsetMonth, 'yyyyMM'))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = item => {
      if (!hasAllDisabled(item)) {
        const {
          datePanelType
        } = reactData;
        if (datePanelType === 'month') {
          dateMoveMonth(item.date);
        } else if (datePanelType === 'quarter') {
          dateMoveQuarter(item.date);
        } else if (datePanelType === 'year') {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const dateMouseleaveEvent = () => {
      reactData.datePanelValue = null;
    };
    const updateTimePos = liElem => {
      if (liElem) {
        const height = liElem.offsetHeight;
        const ulElem = liElem.parentNode;
        ulElem.scrollTop = liElem.offsetTop - height * 4;
      }
    };
    const dateTimeChangeEvent = evnt => {
      const {
        datetimePanelValue
      } = reactData;
      reactData.datetimePanelValue = datetimePanelValue ? new Date(datetimePanelValue.getTime()) : new Date();
      updateTimePos(evnt.currentTarget);
    };
    const dateHourEvent = (evnt, item) => {
      const {
        datetimePanelValue
      } = reactData;
      if (datetimePanelValue) {
        datetimePanelValue.setHours(item.value);
      }
      dateTimeChangeEvent(evnt);
    };
    const dateConfirmEvent = evnt => {
      const {
        multiple
      } = props;
      const {
        datetimePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        const dateValueFormat = computeDateValueFormat.value;
        if (multiple) {
          // 如果为多选
          const dateMultipleValue = computeDateMultipleValue.value;
          if (isDateTimeType) {
            // 如果是datetime特殊类型
            const dateListValue = [...computeDateListValue.value];
            const datetimeRest = [];
            dateListValue.forEach(item => {
              if (item) {
                if (datetimePanelValue) {
                  item.setHours(datetimePanelValue.getHours());
                  item.setMinutes(datetimePanelValue.getMinutes());
                  item.setSeconds(datetimePanelValue.getSeconds());
                }
                datetimeRest.push(item);
              }
            });
            handleChange(datetimeRest.map(date => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toDateString(date, dateValueFormat)).join(','), {
              type: 'update'
            });
          } else {
            // 如果是日期类型
            handleChange(dateMultipleValue.join(','), {
              type: 'update'
            });
          }
        } else {
          dateChange(dateValue || reactData.currentDate);
        }
      }
      hidePanel();
      dispatchEvent('confirm', {}, evnt);
    };
    const dateMinuteEvent = (evnt, item) => {
      const {
        datetimePanelValue
      } = reactData;
      if (datetimePanelValue) {
        datetimePanelValue.setMinutes(item.value);
      }
      dateTimeChangeEvent(evnt);
    };
    const dateSecondEvent = (evnt, item) => {
      const {
        datetimePanelValue
      } = reactData;
      if (datetimePanelValue) {
        datetimePanelValue.setSeconds(item.value);
      }
      dateTimeChangeEvent(evnt);
    };
    const dateOpenPanel = () => {
      const {
        type,
        defaultDate
      } = props;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValueFormat = computeDateValueFormat.value;
      const dateValue = computeDateValue.value;
      if (['year', 'quarter', 'month', 'week'].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = 'day';
      }
      reactData.currentDate = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        if (defaultDate) {
          const defDate = parseDate(defaultDate, dateValueFormat);
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isValidDate(defDate)) {
            dateMonthHandle(defDate, 0);
          } else {
            dateNowHandle();
          }
        } else {
          dateNowHandle();
        }
      }
      if (isDateTimeType) {
        reactData.datetimePanelValue = reactData.datePanelValue || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getWhatDay(Date.now(), 0, 'first');
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const timeBodyElem = refInputTimeBody.value;
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(timeBodyElem.querySelectorAll('li.is--selected'), elem => {
            updateTimePos(elem);
          });
        });
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $datePanel: $xeDatePanel
      }, params));
    };
    const datePanelMethods = {
      dispatchEvent,
      getModelValue() {
        return reactData.inputValue;
      },
      setPanelDate(date) {
        if (date) {
          dateCheckMonth(date);
        }
      },
      getPanelDate() {
        return reactData.selectMonth;
      },
      checkValue(inputLabel) {
        afterCheckValue(inputLabel);
      },
      confirmByEvent(evnt) {
        dateConfirmEvent(evnt);
      }
    };
    Object.assign($xeDatePanel, datePanelMethods);
    const renderDateLabel = (item, label) => {
      const {
        festivalMethod
      } = props;
      const labelVNs = [];
      if (festivalMethod) {
        const {
          datePanelType
        } = reactData;
        const festivalRest = festivalMethod({
          type: datePanelType,
          viewType: datePanelType,
          date: item.date,
          $datePanel: $xeDatePanel
        });
        const festivalItem = festivalRest ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(festivalRest) ? {
          label: festivalRest
        } : festivalRest : {};
        const extraItem = festivalItem.extra ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(festivalItem.extra) ? {
          label: festivalItem.extra
        } : festivalItem.extra : null;
        labelVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-date-panel--label', {
            'is-notice': festivalItem.notice
          }]
        }, extraItem && extraItem.label ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', `${label}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-date-panel--label--extra', extraItem.important ? 'is-important' : '', extraItem.className],
          style: extraItem.style
        }, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(extraItem.label))] : `${label}`));
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          // 默认最多支持3个节日重叠
          const festivalLabels = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(festivalLabel).split(',');
          labelVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-date-panel--festival', festivalItem.important ? 'is-important' : '', festivalItem.className],
            style: festivalItem.style
          }, [festivalLabels.length > 1 ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-date-panel--festival--overlap', `overlap--${festivalLabels.length}`]
          }, festivalLabels.map(label => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', label.substring(0, 3)))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-date-panel--festival--label'
          }, festivalLabels[0].substring(0, 3))]));
        }
      }
      return labelVNs;
    };
    const renderDateDayTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const overCount = computeOverCount.value;
      const matchFormat = 'yyyyMMdd';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-date-panel--view-wrapper', `type--${datePanelType}`]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--view-header'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--view-row'
      }, dateHeaders.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--view-item',
          style: {
            width: `${100 / dateHeaders.length}%`
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--view-item-inner'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--view-item-label'
        }, item.label)])]);
      }))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--view-body'
      }, dayDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--view-row',
          style: {
            height: `${100 / dayDatas.length}%`
          }
        }, rows.map(item => {
          const isSelected = multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat);
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-date-panel--view-item', {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--range-disabled': isRangeDisabled(item),
              'is--disabled': isDateDisabled(item),
              'is--selected': isSelected,
              'is--over': overCount && !isSelected,
              'is--hover': !overCount && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            }],
            style: {
              width: `${100 / rows.length}%`
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item),
            onMouseleave: dateMouseleaveEvent
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-date-panel--view-item-inner'
          }, renderDateLabel(item, item.label))]);
        }));
      }))])];
    };
    const renderDateWeekTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const overCount = computeOverCount.value;
      const matchFormat = 'yyyyMMdd';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-date-panel--view-wrapper', `type--${datePanelType}`]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--view-header'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--view-row'
      }, weekHeaders.map((item, rIndex) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--view-item',
          style: {
            width: `${rIndex ? 13 : 9}%`
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--view-item-inner'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--view-item-label'
        }, item.label)])]);
      }))]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--view-body'
      }, weekDates.map(rows => {
        const isSelected = multiple ? rows.some(item => dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat))) : rows.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat));
        const isHover = rows.some(item => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat));
        const isNowWeek = rows.some(item => item.isNow);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--view-row',
          style: {
            height: `${100 / weekDates.length}%`
          }
        }, rows.map((item, rIndex) => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-date-panel--view-item', {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': rIndex ? item.isNow : isNowWeek,
              'is--next': item.isNext,
              'is--range-disabled': isRangeDisabled(item),
              'is--disabled': isDateDisabled(item),
              'is--selected': isSelected,
              'is--over': overCount && !isSelected,
              'is--hover': !overCount && isHover
            }],
            style: {
              width: `${rIndex ? 13 : 9}%`
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item),
            onMouseleave: dateMouseleaveEvent
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-date-panel--view-item-inner'
          }, renderDateLabel(item, item.label))]);
        }));
      }))])];
    };
    const renderDateMonthTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const overCount = computeOverCount.value;
      const matchFormat = 'yyyyMM';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-date-panel--view-wrapper', `type--${datePanelType}`]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--view-body'
      }, monthDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--view-row',
          style: {
            height: `${100 / monthDatas.length}%`
          }
        }, rows.map(item => {
          const isSelected = multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat);
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-date-panel--view-item', {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--range-disabled': isRangeDisabled(item),
              'is--disabled': isDateDisabled(item),
              'is--selected': isSelected,
              'is--over': overCount && !isSelected,
              'is--hover': !overCount && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            }],
            style: {
              width: `${100 / rows.length}%`
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item),
            onMouseleave: dateMouseleaveEvent
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-date-panel--view-item-inner'
          }, renderDateLabel(item, getI18n(`vxe.input.date.months.m${item.month}`)))]);
        }));
      }))])];
    };
    const renderDateQuarterTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const overCount = computeOverCount.value;
      const matchFormat = 'yyyyq';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-date-panel--view-wrapper', `type--${datePanelType}`]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--view-body'
      }, quarterDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--view-row',
          style: {
            height: `${100 / quarterDatas.length}%`
          }
        }, rows.map(item => {
          const isSelected = multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat);
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-date-panel--view-item', {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--range-disabled': isRangeDisabled(item),
              'is--disabled': isDateDisabled(item),
              'is--selected': isSelected,
              'is--over': overCount && !isSelected,
              'is--hover': !overCount && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            }],
            style: {
              width: `${100 / rows.length}%`
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item),
            onMouseleave: dateMouseleaveEvent
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-date-panel--view-item-inner'
          }, renderDateLabel(item, getI18n(`vxe.input.date.quarters.q${item.quarter}`)))]);
        }));
      }))])];
    };
    const renderDateYearTable = () => {
      const {
        multiple
      } = props;
      const {
        datePanelType,
        datePanelValue
      } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const overCount = computeOverCount.value;
      const matchFormat = 'yyyy';
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-date-panel--view-wrapper', `type--${datePanelType}`]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--view-body'
      }, yearDatas.map(rows => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--view-row',
          style: {
            height: `${100 / yearDatas.length}%`
          }
        }, rows.map(item => {
          const isSelected = multiple ? dateListValue.some(val => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(val, item.date, matchFormat)) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(dateValue, item.date, matchFormat);
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: ['vxe-date-panel--view-item', {
              'is--prev': item.isPrev,
              'is--current': item.isCurrent,
              'is--now': item.isNow,
              'is--next': item.isNext,
              'is--range-disabled': isRangeDisabled(item),
              'is--disabled': isDateDisabled(item),
              'is--selected': isSelected,
              'is--over': overCount && !isSelected,
              'is--hover': !overCount && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isDateSame(datePanelValue, item.date, matchFormat)
            }],
            style: {
              width: `${100 / rows.length}%`
            },
            onClick: () => dateSelectEvent(item),
            onMouseenter: () => dateMouseenterEvent(item),
            onMouseleave: dateMouseleaveEvent
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-date-panel--view-item-inner'
          }, renderDateLabel(item, item.year))]);
        }));
      }))])];
    };
    const renderDateTable = () => {
      const {
        datePanelType
      } = reactData;
      switch (datePanelType) {
        case 'week':
          return renderDateWeekTable();
        case 'month':
          return renderDateMonthTable();
        case 'quarter':
          return renderDateQuarterTable();
        case 'year':
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const {
        datePanelType
      } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelObj = computeSelectDatePanelObj.value;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--picker-header'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--picker-type-wrapper'
      }, [datePanelType === 'year' ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-date-panel--picker-label'
      }, selectDatePanelObj.y) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-date-panel--picker-btns'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-date-panel--picker-btn',
        onClick: dateToggleYearTypeEvent
      }, selectDatePanelObj.y), selectDatePanelObj.m ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-date-panel--picker-btn',
        onClick: dateToggleMonthTypeEvent
      }, selectDatePanelObj.m) : renderEmptyElement($xeDatePanel)])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--picker-btn-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-date-panel--picker-btn vxe-date-panel--picker-prev-btn', {
          'is--disabled': isDisabledPrevDateBtn
        }],
        onClick: datePrevEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: 'vxe-icon-caret-left'
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-date-panel--picker-btn vxe-date-panel--picker-current-btn',
        onClick: dateTodayMonthEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: 'vxe-icon-dot'
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-date-panel--picker-btn vxe-date-panel--picker-next-btn', {
          'is--disabled': isDisabledNextDateBtn
        }],
        onClick: dateNextEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: 'vxe-icon-caret-right'
      })])])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--picker-body'
      }, renderDateTable())];
    };
    const renderTimePanel = () => {
      const {
        type
      } = props;
      const {
        datetimePanelValue
      } = reactData;
      const dateTimeLabel = computeDateTimeLabel.value;
      const hourList = computeHourList.value;
      const hasTimeMinute = computeHasTimeMinute.value;
      const minuteList = computeMinuteList.value;
      const hasTimeSecond = computeHasTimeSecond.value;
      const secondList = computeSecondList.value;
      return [type === 'time' ? renderEmptyElement($xeDatePanel) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--time-header'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-panel--time-title'
      }, dateTimeLabel)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refInputTimeBody,
        class: 'vxe-date-panel--time-body'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-date-panel--time-hour-list'
      }, hourList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: index,
          class: {
            'is--selected': datetimePanelValue && datetimePanelValue.getHours() === item.value
          },
          onClick: evnt => dateHourEvent(evnt, item)
        }, item.label);
      })), hasTimeMinute ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-date-panel--time-minute-list'
      }, minuteList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: index,
          class: {
            'is--selected': datetimePanelValue && datetimePanelValue.getMinutes() === item.value
          },
          onClick: evnt => dateMinuteEvent(evnt, item)
        }, item.label);
      })) : renderEmptyElement($xeDatePanel), hasTimeMinute && hasTimeSecond ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('ul', {
        class: 'vxe-date-panel--time-second-list'
      }, secondList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('li', {
          key: index,
          class: {
            'is--selected': datetimePanelValue && datetimePanelValue.getSeconds() === item.value
          },
          onClick: evnt => dateSecondEvent(evnt, item)
        }, item.label);
      })) : renderEmptyElement($xeDatePanel)])];
    };
    const renderPickerPanel = () => {
      const {
        type
      } = props;
      if (type === 'datetime') {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: type,
          ref: refPanelWrapper,
          class: 'vxe-date-panel--time-layout-wrapper'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--time-left-wrapper'
        }, renderDatePanel()), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-date-panel--time-right-wrapper'
        }, renderTimePanel())]);
      } else if (type === 'time') {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: type,
          ref: refPanelWrapper,
          class: 'vxe-date-panel--wrapper'
        }, renderTimePanel());
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: type || 'default',
        ref: refPanelWrapper,
        class: 'vxe-date-panel--wrapper'
      }, renderDatePanel());
    };
    const renderVN = () => {
      const {
        type
      } = props;
      const vSize = computeSize.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-date-panel', `type--${type}`, {
          [`size--${vSize}`]: vSize
        }]
      }, [renderPickerPanel()]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      updateModelValue(val);
      changeValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.type, () => {
      // 切换类型是重置内置变量
      Object.assign(reactData, {
        inputValue: '',
        datetimePanelValue: null,
        datePanelValue: null,
        datePanelLabel: '',
        datePanelType: 'day',
        selectMonth: null,
        currentDate: null
      });
      initValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeDateLabelFormat, () => {
      const isDatePanelType = computeIsDatePanelType.value;
      if (isDatePanelType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    initValue();
    dateOpenPanel();
    $xeDatePanel.renderVN = renderVN;
    return $xeDatePanel;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/date-panel/index.ts



const VxeDatePanel = Object.assign({}, date_panel, {
  install(app) {
    app.component(date_panel.name, date_panel);
  }
});
dynamicApp.use(VxeDatePanel);
index_esm_VxeUI.component(date_panel);
const DatePanel = VxeDatePanel;
/* harmony default export */ var packages_date_panel = (VxeDatePanel);
;// CONCATENATED MODULE: ./packages/date-picker/src/date-picker.ts












/* harmony default export */ var date_picker = (defineVxeComponent({
  name: 'VxeDatePicker',
  props: {
    modelValue: [String, Number, Date],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    type: {
      type: String,
      default: 'date'
    },
    clearable: {
      type: Boolean,
      default: () => getConfig().datePicker.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    autoComplete: {
      type: String,
      default: 'off'
    },
    form: String,
    className: String,
    size: {
      type: String,
      default: () => getConfig().datePicker.size || getConfig().size
    },
    multiple: Boolean,
    limitCount: {
      type: [String, Number],
      default: () => getConfig().datePicker.limitCount
    },
    // date、week、month、quarter、year
    startDate: {
      type: [String, Number, Date],
      default: () => getConfig().datePicker.startDate
    },
    endDate: {
      type: [String, Number, Date],
      default: () => getConfig().datePicker.endDate
    },
    defaultDate: [String, Number, Date],
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    startDay: {
      type: [String, Number],
      default: () => getConfig().datePicker.startDay
    },
    labelFormat: String,
    valueFormat: String,
    timeFormat: String,
    editable: {
      type: Boolean,
      default: true
    },
    festivalMethod: {
      type: Function,
      default: () => getConfig().datePicker.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().datePicker.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().datePicker.selectDay
    },
    showClearButton: {
      type: Boolean,
      default: () => getConfig().datePicker.showClearButton
    },
    showConfirmButton: {
      type: Boolean,
      default: () => getConfig().datePicker.showConfirmButton
    },
    autoClose: {
      type: Boolean,
      default: () => getConfig().datePicker.autoClose
    },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    },
    shortcutConfig: Object,
    // 已废弃 startWeek，被 startDay 替换
    startWeek: Number
  },
  emits: ['update:modelValue', 'input', 'change', 'keydown', 'keyup', 'click', 'focus', 'blur', 'clear', 'prefix-click', 'suffix-click', 'date-prev', 'date-today', 'date-next', 'shortcut-click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      panelIndex: 0,
      visiblePanel: false,
      isAniVisible: false,
      panelStyle: {},
      panelPlacement: '',
      isActivated: false,
      inputValue: '',
      inputLabel: ''
    });
    const internalData = {
      hpTimeout: undefined
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTarget = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPanelWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refDatePanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeDatePicker = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().datePicker.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsDateTimeType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      return type === 'time' || type === 'datetime';
    });
    const computeIsDatePickerType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const isDateTimeType = computeIsDateTimeType.value;
      return isDateTimeType || ['date', 'week', 'month', 'quarter', 'year'].indexOf(props.type) > -1;
    });
    const computeIsClearable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.clearable;
    });
    const computeInputReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        editable,
        multiple
      } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || multiple || !editable || type === 'week' || type === 'quarter';
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().datePicker.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n('vxe.base.pleaseSelect');
    });
    const computeInpImmediate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        immediate
      } = props;
      return immediate;
    });
    const computeShortcutOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().datePicker.shortcutConfig, props.shortcutConfig);
    });
    const computeShortcutList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const shortcutOpts = computeShortcutOpts.value;
      const {
        options
      } = shortcutOpts;
      if (options) {
        return options.map((option, index) => {
          return Object.assign({
            name: `${option.name || option.code || index}`
          }, option);
        });
      }
      return [];
    });
    const computeDateLabelFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        labelFormat
      } = props;
      return labelFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
    });
    const computeDateValueFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        valueFormat
      } = props;
      return handleValueFormat(type, valueFormat);
    });
    const computeFirstDayOfWeek = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        startDay
      } = props;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(startDay);
    });
    const computePanelLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        multiple
      } = props;
      const {
        inputValue
      } = reactData;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const vals = inputValue ? multiple ? inputValue.split(',') : [inputValue] : [];
      return vals.map(val => {
        const dateObj = parseDateObj(val, type, {
          valueFormat: dateValueFormat,
          labelFormat: dateLabelFormat,
          firstDay: firstDayOfWeek
        });
        return dateObj.label;
      }).join(', ');
    });
    const updateModelValue = () => {
      const {
        modelValue
      } = props;
      let val = '';
      if (modelValue) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(modelValue) && /^[0-9]{11,15}$/.test(`${modelValue}`)) {
          val = new Date(modelValue);
        } else {
          val = modelValue;
        }
      }
      reactData.inputValue = val;
    };
    const triggerEvent = evnt => {
      const {
        inputValue
      } = reactData;
      dispatchEvent(evnt.type, {
        value: inputValue
      }, evnt);
    };
    const handleChange = (value, evnt) => {
      const {
        type,
        modelValue,
        valueFormat
      } = props;
      const dateValueFormat = computeDateValueFormat.value;
      reactData.inputValue = value;
      if (hasTimestampValueType(valueFormat)) {
        const dateVal = parseDateValue(value, type, {
          valueFormat: dateValueFormat
        });
        const timeNum = dateVal ? dateVal.getTime() : null;
        emit('update:modelValue', timeNum);
        if (modelValue !== timeNum) {
          dispatchEvent('change', {
            value: timeNum
          }, evnt);
          // 自动更新校验状态
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, timeNum);
          }
        }
      } else if (hasDateValueType(valueFormat)) {
        const dateVal = parseDateValue(value, type, {
          valueFormat: dateValueFormat
        });
        emit('update:modelValue', dateVal);
        if (modelValue && dateVal ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(modelValue).getTime() !== dateVal.getTime() : modelValue !== dateVal) {
          dispatchEvent('change', {
            value: dateVal
          }, evnt);
          // 自动更新校验状态
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, dateVal);
          }
        }
      } else {
        emit('update:modelValue', value);
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(modelValue) !== value) {
          dispatchEvent('change', {
            value
          }, evnt);
          // 自动更新校验状态
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
          }
        }
      }
    };
    const inputEvent = evnt => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      reactData.inputLabel = value;
      dispatchEvent('input', {
        value
      }, evnt);
    };
    const changeEvent = evnt => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent(evnt);
      }
    };
    const focusEvent = evnt => {
      reactData.isActivated = true;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        datePickerOpenEvent(evnt);
      }
      triggerEvent(evnt);
    };
    const clickPrefixEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          inputValue
        } = reactData;
        dispatchEvent('prefix-click', {
          value: inputValue
        }, evnt);
      }
    };
    const hidePanel = () => {
      return new Promise(resolve => {
        reactData.visiblePanel = false;
        internalData.hpTimeout = setTimeout(() => {
          reactData.isAniVisible = false;
          resolve();
        }, 350);
      });
    };
    const clearValueEvent = (evnt, value) => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        hidePanel();
      }
      handleChange('', evnt);
      dispatchEvent('clear', {
        value
      }, evnt);
    };
    const clickSuffixEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          inputValue
        } = reactData;
        dispatchEvent('suffix-click', {
          value: inputValue
        }, evnt);
      }
    };
    const blurEvent = evnt => {
      const $datePanel = refDatePanel.value;
      const {
        inputValue
      } = reactData;
      const inpImmediate = computeInpImmediate.value;
      const value = inputValue;
      if (!inpImmediate) {
        handleChange(value, evnt);
      }
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
        // 未打开面板时才校验
        if ($datePanel) {
          $datePanel.checkValue(reactData.inputLabel);
        }
      }
      dispatchEvent('blur', {
        value
      }, evnt);
      // 自动更新校验状态
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const keydownEvent = evnt => {
      triggerEvent(evnt);
    };
    const keyupEvent = evnt => {
      triggerEvent(evnt);
    };
    const confirmEvent = evnt => {
      const $datePanel = refDatePanel.value;
      if ($datePanel) {
        $datePanel.confirmByEvent(evnt);
      }
      hidePanel();
    };
    const panelChangeEvent = params => {
      const {
        multiple,
        autoClose
      } = props;
      const {
        value,
        $event
      } = params;
      const isDateTimeType = computeIsDateTimeType.value;
      handleChange(value, $event);
      if (!multiple && !isDateTimeType) {
        if (autoClose) {
          hidePanel();
        }
      }
    };
    // 全局事件
    const handleGlobalMousedownEvent = evnt => {
      const $datePanel = refDatePanel.value;
      const {
        visiblePanel,
        isActivated
      } = reactData;
      const el = refElem.value;
      const panelWrapperElem = refPanelWrapper.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelWrapperElem).flag;
        if (!reactData.isActivated) {
          if (visiblePanel) {
            hidePanel();
            if ($datePanel) {
              $datePanel.checkValue(reactData.inputLabel);
            }
          }
        }
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hidePanel();
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelWrapperElem = refPanelWrapper.value;
          if (getEventTargetNode(evnt, panelWrapperElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const $datePanel = refDatePanel.value;
      const {
        isActivated,
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        hidePanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        if ($datePanel) {
          $datePanel.checkValue(reactData.inputLabel);
        }
        const targetElem = refInputTarget.value;
        if (targetElem) {
          targetElem.blur();
        }
      }
    };
    const handleGlobalResizeEvent = () => {
      const {
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    // 弹出面板
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      const {
        placement
      } = props;
      const {
        panelIndex
      } = reactData;
      const targetElem = refInputTarget.value;
      const panelElem = refInputPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(handleStyle);
    };
    const showPanel = () => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && !visiblePanel) {
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        if (internalData.hpTimeout) {
          clearTimeout(internalData.hpTimeout);
          internalData.hpTimeout = undefined;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        return updatePlacement();
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const datePickerOpenEvent = evnt => {
      const formReadonly = computeFormReadonly.value;
      if (!formReadonly) {
        evnt.preventDefault();
        showPanel();
      }
    };
    const clickEvent = evnt => {
      triggerEvent(evnt);
    };
    const handleShortcutEvent = ({
      option,
      $event
    }) => {
      const {
        type
      } = props;
      const {
        inputValue
      } = reactData;
      const shortcutOpts = computeShortcutOpts.value;
      const {
        autoClose
      } = shortcutOpts;
      const {
        code,
        clickMethod
      } = option;
      let value = inputValue;
      const shortcutParams = {
        $datePicker: $xeDatePicker,
        option,
        value,
        code
      };
      if (!clickMethod && code) {
        const gCommandOpts = commands.get(code);
        const dpCommandMethod = gCommandOpts ? gCommandOpts.datePickerCommandMethod : null;
        if (dpCommandMethod) {
          dpCommandMethod(shortcutParams);
        } else {
          const dateValueFormat = computeDateValueFormat.value;
          const firstDayOfWeek = computeFirstDayOfWeek.value;
          switch (code) {
            case 'now':
            case 'prev':
            case 'next':
            case 'minus':
            case 'plus':
              {
                const restObj = getDateByCode(code, value, type, {
                  valueFormat: dateValueFormat,
                  firstDay: firstDayOfWeek
                });
                value = restObj.value;
                shortcutParams.value = value;
                handleChange(value, $event);
                break;
              }
            default:
              errLog('vxe.error.notCommands', [code]);
              break;
          }
        }
      } else {
        const optClickMethod = clickMethod || shortcutOpts.clickMethod;
        if (optClickMethod) {
          optClickMethod(shortcutParams);
        }
      }
      if (autoClose) {
        hidePanel();
      }
      dispatchEvent('shortcut-click', shortcutParams, $event);
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $datePicker: $xeDatePicker
      }, params));
    };
    const datePickerMethods = {
      dispatchEvent,
      setModelValue(value) {
        reactData.inputValue = value;
        emit('update:modelValue', value);
      },
      setModelValueByEvent(evnt, value) {
        handleChange(value || '', evnt);
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      showPanel,
      hidePanel,
      updatePlacement
    };
    Object.assign($xeDatePicker, datePickerMethods);
    const renderShortcutBtn = (pos, isVertical) => {
      const shortcutOpts = computeShortcutOpts.value;
      const {
        position,
        align,
        mode
      } = shortcutOpts;
      const shortcutList = computeShortcutList.value;
      if (isEnableConf(shortcutOpts) && shortcutList.length && (position || 'left') === pos) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: `vxe-date-picker--layout-${pos}-wrapper`
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(button_group, {
          options: shortcutList,
          mode,
          align,
          vertical: isVertical,
          onClick: handleShortcutEvent
        })]);
      }
      return renderEmptyElement($xeDatePicker);
    };
    const renderPanel = () => {
      const {
        type,
        multiple,
        showClearButton,
        showConfirmButton
      } = props;
      const {
        initialized,
        isAniVisible,
        visiblePanel,
        panelPlacement,
        panelStyle,
        inputValue
      } = reactData;
      const vSize = computeSize.value;
      const btnTransfer = computeBtnTransfer.value;
      const shortcutOpts = computeShortcutOpts.value;
      const isClearable = computeIsClearable.value;
      const isDateTimeType = computeIsDateTimeType.value;
      const shortcutList = computeShortcutList.value;
      const {
        position
      } = shortcutOpts;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const leftSlot = slots.left;
      const rightSlot = slots.right;
      const hasShortcutBtn = shortcutList.length > 0;
      const showConfirmBtn = showConfirmButton === null ? isDateTimeType || multiple : showConfirmButton;
      const showClearBtn = showClearButton === null ? isClearable && showConfirmBtn && type !== 'time' : showClearButton;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: btnTransfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refInputPanel,
        class: ['vxe-table--ignore-clear vxe-date-picker--panel', `type--${type}`, {
          [`size--${vSize}`]: vSize,
          'is--transfer': btnTransfer,
          'ani--leave': isAniVisible,
          'ani--enter': visiblePanel,
          'show--top': !!(topSlot || headerSlot || hasShortcutBtn && (position === 'top' || position === 'header')),
          'show--bottom': !!(bottomSlot || footerSlot || hasShortcutBtn && (position === 'bottom' || position === 'footer')),
          'show--left': !!(leftSlot || hasShortcutBtn && position === 'left'),
          'show--right': !!(rightSlot || hasShortcutBtn && position === 'right')
        }],
        placement: panelPlacement,
        style: panelStyle
      }, initialized && (visiblePanel || isAniVisible) ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refPanelWrapper,
        class: ['vxe-date-picker--layout-all-wrapper', `type--${type}`, {
          [`size--${vSize}`]: vSize
        }]
      }, [topSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--layout-top-wrapper'
      }, topSlot({})) : renderShortcutBtn('top'), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--layout-body-layout-wrapper'
      }, [leftSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--layout-left-wrapper'
      }, leftSlot({})) : renderShortcutBtn('left', true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--layout-body-content-wrapper'
      }, [headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--layout-header-wrapper'
      }, headerSlot({})) : renderShortcutBtn('header'), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--layout-body-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(date_panel, {
        ref: refDatePanel,
        modelValue: reactData.inputValue,
        type: props.type,
        className: props.className,
        multiple: props.multiple,
        limitCount: props.limitCount,
        startDate: props.startDate,
        endDate: props.endDate,
        defaultDate: props.defaultDate,
        minDate: props.minDate,
        maxDate: props.maxDate,
        startDay: props.startDay,
        labelFormat: props.labelFormat,
        valueFormat: props.valueFormat,
        timeFormat: props.timeFormat,
        festivalMethod: props.festivalMethod,
        disabledMethod: props.disabledMethod,
        selectDay: props.selectDay,
        onChange: panelChangeEvent
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--layout-footer-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--layout-footer-custom'
      }, footerSlot ? footerSlot({}) : [renderShortcutBtn('footer')]), showClearBtn || showConfirmBtn ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--layout-footer-btns'
      }, [showClearBtn ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        size: 'mini',
        disabled: inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue),
        content: getI18n('vxe.button.clear'),
        onClick: clearValueEvent
      }) : renderEmptyElement($xeDatePicker), showConfirmBtn ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        size: 'mini',
        status: 'primary',
        content: getI18n('vxe.button.confirm'),
        onClick: confirmEvent
      }) : renderEmptyElement($xeDatePicker)]) : renderEmptyElement($xeDatePicker)])]), rightSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--layout-right-wrapper'
      }, rightSlot({})) : renderShortcutBtn('right', true)]), bottomSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--layout-bottom-wrapper'
      }, bottomSlot({})) : renderShortcutBtn('bottom')])] : [])]);
    };
    const renderPrefixIcon = () => {
      const {
        prefixIcon
      } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--prefix',
        onClick: clickPrefixEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--prefix-icon'
      }, prefixSlot ? vn_getSlotVNs(prefixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: prefixIcon
      })])]) : null;
    };
    const renderSuffixIcon = () => {
      const {
        suffixIcon
      } = props;
      const {
        inputValue
      } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isClearable = computeIsClearable.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-date-picker--suffix', {
          'is--clear': isClearable && !isDisabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }]
      }, [isClearable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--clear-icon',
        onClick: clearValueEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().INPUT_CLEAR
      })]) : renderEmptyElement($xeDatePicker), renderExtraSuffixIcon(), suffixSlot || suffixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--suffix-icon',
        onClick: clickSuffixEvent
      }, suffixSlot ? vn_getSlotVNs(suffixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: suffixIcon
      })]) : renderEmptyElement($xeDatePicker)]);
    };
    const renderExtraSuffixIcon = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--control-icon',
        onClick: datePickerOpenEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-date-picker--date-picker-icon', getIcon().DATE_PICKER_DATE]
      })]);
    };
    const renderVN = () => {
      const {
        className,
        type,
        name,
        autoComplete
      } = props;
      const {
        inputValue,
        inputLabel,
        visiblePanel,
        isActivated
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const panelLabel = computePanelLabel.value;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-date-picker--readonly', `type--${type}`, className]
        }, panelLabel);
      }
      const inputReadonly = computeInputReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon();
      const suffix = renderSuffixIcon();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-date-picker', `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          'is--prefix': !!prefix,
          'is--suffix': !!suffix,
          'is--visible': visiblePanel,
          'is--disabled': isDisabled,
          'is--active': isActivated,
          'show--clear': isClearable && !isDisabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }],
        spellcheck: false
      }, [prefix || renderEmptyElement($xeDatePicker), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-picker--wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        ref: refInputTarget,
        class: 'vxe-date-picker--inner',
        value: inputLabel,
        name,
        type: 'text',
        placeholder: inpPlaceholder,
        readonly: inputReadonly,
        disabled: isDisabled,
        autocomplete: autoComplete,
        onKeydown: keydownEvent,
        onKeyup: keyupEvent,
        onClick: clickEvent,
        onInput: inputEvent,
        onChange: changeEvent,
        onFocus: focusEvent,
        onBlur: blurEvent
      })]), suffix || renderEmptyElement($xeDatePicker),
      // 下拉面板
      renderPanel()]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computePanelLabel, val => {
      reactData.inputLabel = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, () => {
      updateModelValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      globalEvents.on($xeDatePicker, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeDatePicker, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeDatePicker, 'keydown', handleGlobalKeydownEvent);
      globalEvents.on($xeDatePicker, 'blur', handleGlobalBlurEvent);
      globalEvents.on($xeDatePicker, 'resize', handleGlobalResizeEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeDatePicker, 'mousewheel');
      globalEvents.off($xeDatePicker, 'mousedown');
      globalEvents.off($xeDatePicker, 'blur');
      globalEvents.off($xeDatePicker, 'resize');
    });
    updateModelValue();
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeDatePicker', $xeDatePicker);
    $xeDatePicker.renderVN = renderVN;
    return $xeDatePicker;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/date-picker/index.ts



const VxeDatePicker = Object.assign({}, date_picker, {
  install(app) {
    app.component(date_picker.name, date_picker);
  }
});
dynamicApp.use(VxeDatePicker);
index_esm_VxeUI.component(date_picker);
const DatePicker = VxeDatePicker;
/* harmony default export */ var packages_date_picker = (VxeDatePicker);
;// CONCATENATED MODULE: ./packages/date-range-picker/src/date-range-picker.ts












/* harmony default export */ var date_range_picker = (defineVxeComponent({
  name: 'VxeDateRangePicker',
  props: {
    modelValue: [String, Number, Date, Array],
    startValue: [String, Number, Date],
    endValue: [String, Number, Date],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    type: {
      type: String,
      default: 'date'
    },
    clearable: {
      type: Boolean,
      default: () => getConfig().dateRangePicker.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    autoComplete: {
      type: String,
      default: 'off'
    },
    form: String,
    className: String,
    size: {
      type: String,
      default: () => getConfig().dateRangePicker.size || getConfig().size
    },
    // startDate: {
    //   type: [String, Number, Date] as PropType<VxeDateRangePickerPropTypes.StartDate>,
    //   default: () => getConfig().dateRangePicker.startDate
    // },
    // endDate: {
    //   type: [String, Number, Date] as PropType<VxeDateRangePickerPropTypes.EndDate>,
    //   default: () => getConfig().dateRangePicker.endDate
    // },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    defaultDate: [String, Number, Date],
    startDay: {
      type: [String, Number],
      default: () => getConfig().dateRangePicker.startDay
    },
    labelFormat: String,
    valueFormat: String,
    timeFormat: String,
    editable: {
      type: Boolean,
      default: true
    },
    festivalMethod: {
      type: Function,
      default: () => getConfig().dateRangePicker.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().dateRangePicker.disabledMethod
    },
    separator: {
      type: [String, Number],
      default: () => getConfig().dateRangePicker.separator
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().dateRangePicker.selectDay
    },
    showClearButton: {
      type: Boolean,
      default: () => getConfig().dateRangePicker.showClearButton
    },
    showConfirmButton: {
      type: Boolean,
      default: () => getConfig().dateRangePicker.showConfirmButton
    },
    autoClose: {
      type: Boolean,
      default: () => getConfig().dateRangePicker.autoClose
    },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    },
    shortcutConfig: Object
  },
  emits: ['update:modelValue', 'update:startValue', 'update:endValue', 'input', 'change', 'keydown', 'keyup', 'click', 'focus', 'blur', 'clear', 'prefix-click', 'suffix-click', 'date-prev', 'date-today', 'date-next', 'shortcut-click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      panelIndex: 0,
      visiblePanel: false,
      isAniVisible: false,
      panelStyle: {},
      panelPlacement: '',
      isActivated: false,
      startValue: '',
      endValue: ''
    });
    const internalData = {
      // selectStatus: false
      // hpTimeout: undefined
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTarget = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPanelWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refStartDatePanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refEndDatePanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeDateRangePicker = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let dateRangePickerMethods = {};
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().dateRangePicker.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeMVal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        startValue,
        endValue
      } = props;
      return `${startValue || ''}${endValue || ''}`;
    });
    const computeIsDateTimeType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      return type === 'time' || type === 'datetime';
    });
    const computeIsDatePickerType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return ['date', 'week', 'month', 'quarter', 'year'].indexOf(props.type) > -1;
    });
    const computeIsClearable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.clearable;
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().dateRangePicker.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n('vxe.dateRangePicker.pleaseRange');
    });
    const computeInpImmediate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        immediate
      } = props;
      return immediate;
    });
    const computeShortcutOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().dateRangePicker.shortcutConfig, props.shortcutConfig);
    });
    const computeShortcutList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const shortcutOpts = computeShortcutOpts.value;
      const {
        options
      } = shortcutOpts;
      if (options) {
        return options.map((option, index) => {
          return Object.assign({
            name: `${option.name || option.code || index}`
          }, option);
        });
      }
      return [];
    });
    const computeDateLabelFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        labelFormat
      } = props;
      return labelFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
    });
    const computeDateValueFormat = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type,
        valueFormat
      } = props;
      return handleValueFormat(type, valueFormat);
    });
    const computeFirstDayOfWeek = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        startDay
      } = props;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(startDay);
    });
    const computePanelLabelObj = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        startValue,
        endValue
      } = reactData;
      const vals = startValue || endValue ? [startValue || '', endValue || ''] : [];
      return formatRangeLabel(vals);
    });
    const computeInputLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const panelLabelObj = computePanelLabelObj.value;
      return panelLabelObj.label;
    });
    const formatRangeLabel = vals => {
      const {
        type,
        separator
      } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      const startRest = vals[0] ? parseDateObj(vals[0], type, {
        valueFormat: dateValueFormat,
        labelFormat: dateLabelFormat,
        firstDay: firstDayOfWeek
      }) : null;
      const endRest = vals[1] ? parseDateObj(vals[1], type, {
        valueFormat: dateValueFormat,
        labelFormat: dateLabelFormat,
        firstDay: firstDayOfWeek
      }) : null;
      const startLabel = startRest ? startRest.label : '';
      const endLabel = endRest ? endRest.label : '';
      return {
        label: (startLabel || endLabel ? [startLabel, endLabel] : []).join(`${separator || ' ~ '}`),
        startLabel,
        endLabel
      };
    };
    const getRangeValue = (sValue, eValue) => {
      const {
        modelValue
      } = props;
      const isArr = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue);
      if (sValue || eValue) {
        const rest = [sValue || '', eValue || ''];
        if (isArr) {
          return rest;
        }
        return rest.join(',');
      }
      return isArr ? [] : '';
    };
    const paraeUpdateModel = () => {
      const {
        type,
        modelValue
      } = props;
      const dateValueFormat = computeDateValueFormat.value;
      let sValue = '';
      let eValue = '';
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue)) {
        const date1 = parseDateString(modelValue[0], type, {
          valueFormat: dateValueFormat
        });
        const date2 = parseDateString(modelValue[1], type, {
          valueFormat: dateValueFormat
        });
        if (date1 || date2) {
          sValue = date1 || '';
          eValue = date2 || '';
        }
      } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(modelValue)) {
        const strArr = modelValue.split(',');
        if (strArr[0] || strArr[1]) {
          sValue = strArr[0] || '';
          eValue = strArr[1] || '';
        }
      }
      return {
        sValue,
        eValue
      };
    };
    const parseUpdateData = () => {
      const {
        type,
        startValue,
        endValue
      } = props;
      const dateValueFormat = computeDateValueFormat.value;
      let sValue = '';
      let eValue = '';
      sValue = parseDateString(startValue, type, {
        valueFormat: dateValueFormat
      });
      eValue = parseDateString(endValue, type, {
        valueFormat: dateValueFormat
      });
      return {
        sValue,
        eValue
      };
    };
    const updateModelValue = isModel => {
      const {
        modelValue,
        startValue,
        endValue
      } = props;
      let restObj = {
        sValue: '',
        eValue: ''
      };
      if (isModel) {
        if (modelValue) {
          restObj = paraeUpdateModel();
        } else {
          restObj = parseUpdateData();
        }
      } else {
        if (startValue || endValue) {
          restObj = parseUpdateData();
        } else {
          restObj = paraeUpdateModel();
        }
      }
      reactData.startValue = restObj.sValue;
      reactData.endValue = restObj.eValue;
    };
    const triggerEvent = evnt => {
      const {
        startValue,
        endValue
      } = reactData;
      const value = getRangeValue(startValue, endValue);
      dispatchEvent(evnt.type, {
        value,
        startValue,
        endValue
      }, evnt);
    };
    const handleChange = (sValue, eValue, evnt) => {
      const {
        modelValue
      } = props;
      reactData.startValue = sValue;
      reactData.endValue = eValue;
      const value = getRangeValue(sValue, eValue);
      emit('update:modelValue', value);
      emit('update:startValue', sValue || '');
      emit('update:endValue', eValue || '');
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(modelValue) !== value) {
        dispatchEvent('change', {
          value
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const changeEvent = evnt => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent(evnt);
      }
    };
    const focusEvent = evnt => {
      reactData.isActivated = true;
      dateRangePickerOpenEvent(evnt);
      triggerEvent(evnt);
    };
    const clickPrefixEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          startValue,
          endValue
        } = reactData;
        const value = getRangeValue(startValue, endValue);
        dispatchEvent('prefix-click', {
          value,
          startValue,
          endValue
        }, evnt);
      }
    };
    const hidePanel = () => {
      return new Promise(resolve => {
        reactData.visiblePanel = false;
        internalData.hpTimeout = setTimeout(() => {
          reactData.isAniVisible = false;
          resolve();
        }, 350);
      });
    };
    const clearValueEvent = (evnt, value) => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        hidePanel();
      }
      handleChange('', '', evnt);
      dispatchEvent('clear', {
        value
      }, evnt);
    };
    const checkValue = () => {
      const $startDatePanel = refStartDatePanel.value;
      const $endDatePanel = refEndDatePanel.value;
      if ($startDatePanel && $endDatePanel) {
        const startValue = $startDatePanel.getModelValue();
        const endValue = $endDatePanel.getModelValue();
        if (!startValue || !endValue) {
          handleChange('', '', {
            type: 'check'
          });
        }
      }
    };
    const handleSelectClose = () => {
      const {
        autoClose
      } = props;
      const {
        startValue,
        endValue
      } = reactData;
      const {
        selectStatus
      } = internalData;
      const isDatePickerType = computeIsDatePickerType.value;
      if (autoClose) {
        if (selectStatus && isDatePickerType) {
          if (startValue && endValue) {
            hidePanel();
          }
        }
      } else {
        if (startValue && endValue) {
          internalData.selectStatus = false;
        }
      }
    };
    const clickSuffixEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const {
          startValue,
          endValue
        } = reactData;
        const value = getRangeValue(startValue, endValue);
        dispatchEvent('suffix-click', {
          value,
          startValue,
          endValue
        }, evnt);
      }
    };
    const blurEvent = evnt => {
      const {
        startValue,
        endValue
      } = reactData;
      const inpImmediate = computeInpImmediate.value;
      const value = '';
      if (!inpImmediate) {
        handleChange(startValue, endValue, evnt);
      }
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
      }
      dispatchEvent('blur', {
        value,
        startValue,
        endValue
      }, evnt);
      // 自动更新校验状态
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const keydownEvent = evnt => {
      triggerEvent(evnt);
    };
    const keyupEvent = evnt => {
      triggerEvent(evnt);
    };
    const confirmEvent = evnt => {
      const $startDatePanel = refStartDatePanel.value;
      const $endDatePanel = refEndDatePanel.value;
      if ($startDatePanel && $endDatePanel) {
        const startValue = $startDatePanel.getModelValue();
        const endValue = $endDatePanel.getModelValue();
        if (startValue && !endValue || !startValue && endValue) {
          handleChange('', '', evnt);
        } else {
          $startDatePanel.confirmByEvent(evnt);
          $endDatePanel.confirmByEvent(evnt);
        }
      }
      hidePanel();
    };
    const startPanelChangeEvent = params => {
      const {
        selectStatus
      } = internalData;
      const {
        value,
        $event
      } = params;
      const endValue = selectStatus ? reactData.endValue : '';
      handleChange(value, endValue, $event);
      handleSelectClose();
      if (!selectStatus) {
        internalData.selectStatus = true;
      }
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const $startDatePanel = refStartDatePanel.value;
        const $endDatePanel = refEndDatePanel.value;
        if ($startDatePanel && $endDatePanel) {
          const startValue = $startDatePanel.getModelValue();
          if (!endValue && startValue) {
            $endDatePanel.setPanelDate(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(startValue));
          }
        }
      });
    };
    const endPanelChangeEvent = params => {
      const {
        selectStatus
      } = internalData;
      const {
        value,
        $event
      } = params;
      const startValue = selectStatus ? reactData.startValue : '';
      handleChange(startValue, value, $event);
      handleSelectClose();
      if (!selectStatus) {
        internalData.selectStatus = true;
      }
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const $startDatePanel = refStartDatePanel.value;
        const $endDatePanel = refEndDatePanel.value;
        if ($startDatePanel && $endDatePanel) {
          const endValue = $endDatePanel.getModelValue();
          if (!startValue && endValue) {
            $startDatePanel.setPanelDate(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringDate(endValue));
          }
        }
      });
    };
    // 全局事件
    const handleGlobalMousedownEvent = evnt => {
      const {
        visiblePanel,
        isActivated
      } = reactData;
      const el = refElem.value;
      const panelWrapperElem = refPanelWrapper.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && isActivated) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelWrapperElem).flag;
        if (!reactData.isActivated) {
          if (visiblePanel) {
            checkValue();
            hidePanel();
          }
        }
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hidePanel();
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelWrapperElem = refPanelWrapper.value;
          if (getEventTargetNode(evnt, panelWrapperElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const {
        visiblePanel,
        isActivated
      } = reactData;
      if (visiblePanel) {
        hidePanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        const targetElem = refInputTarget.value;
        if (targetElem) {
          targetElem.blur();
        }
      }
    };
    const handleGlobalResizeEvent = () => {
      const {
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    // 弹出面板
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      const {
        placement
      } = props;
      const {
        panelIndex
      } = reactData;
      const targetElem = refInputTarget.value;
      const panelElem = refInputPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(handleStyle);
    };
    const showPanel = () => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && !visiblePanel) {
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        if (internalData.hpTimeout) {
          clearTimeout(internalData.hpTimeout);
          internalData.hpTimeout = undefined;
        }
        internalData.selectStatus = false;
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        return updatePlacement();
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const dateRangePickerOpenEvent = evnt => {
      const formReadonly = computeFormReadonly.value;
      if (!formReadonly) {
        evnt.preventDefault();
        showPanel();
      }
    };
    const clickEvent = evnt => {
      triggerEvent(evnt);
    };
    const handleShortcutEvent = ({
      option,
      $event
    }) => {
      const {
        type
      } = props;
      const shortcutOpts = computeShortcutOpts.value;
      const {
        autoClose
      } = shortcutOpts;
      const {
        code,
        clickMethod
      } = option;
      let startValue = reactData.startValue;
      let endValue = reactData.endValue;
      let value = getRangeValue(startValue, endValue);
      const shortcutParams = {
        $dateRangePicker: $xeDateRangePicker,
        option: option,
        value,
        startValue,
        endValue,
        code
      };
      if (!clickMethod && code) {
        const gCommandOpts = commands.get(code);
        const drpCommandMethod = gCommandOpts ? gCommandOpts.dateRangePickerCommandMethod : null;
        if (drpCommandMethod) {
          drpCommandMethod(shortcutParams);
        } else {
          const dateValueFormat = computeDateValueFormat.value;
          const firstDayOfWeek = computeFirstDayOfWeek.value;
          switch (code) {
            case 'last1':
            case 'last3':
            case 'last7':
            case 'last30':
            case 'last60':
            case 'last90':
            case 'last180':
              {
                const restObj = getRangeDateByCode(code, value, type, {
                  valueFormat: dateValueFormat,
                  firstDay: firstDayOfWeek
                });
                startValue = restObj.startValue;
                endValue = restObj.endValue;
                value = getRangeValue(startValue, endValue);
                shortcutParams.value = value;
                shortcutParams.startValue = startValue;
                shortcutParams.endValue = endValue;
                handleChange(startValue, endValue, $event);
                break;
              }
            default:
              errLog('vxe.error.notCommands', [code]);
              break;
          }
        }
      } else {
        const optClickMethod = clickMethod || shortcutOpts.clickMethod;
        if (optClickMethod) {
          optClickMethod(shortcutParams);
        }
      }
      if (autoClose) {
        hidePanel();
      }
      dispatchEvent('shortcut-click', shortcutParams, $event);
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $dateRangePicker: $xeDateRangePicker
      }, params));
    };
    dateRangePickerMethods = {
      dispatchEvent,
      setModelValue(startValue, endValue) {
        reactData.startValue = startValue || '';
        reactData.endValue = endValue || '';
        const value = getRangeValue(startValue, endValue);
        emit('update:modelValue', value);
      },
      setModelValueByEvent(evnt, startValue, endValue) {
        handleChange(startValue || '', endValue || '', evnt);
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      showPanel,
      hidePanel,
      updatePlacement
    };
    Object.assign($xeDateRangePicker, dateRangePickerMethods);
    const renderShortcutBtn = (pos, isVertical) => {
      const shortcutOpts = computeShortcutOpts.value;
      const {
        position,
        align,
        mode
      } = shortcutOpts;
      const shortcutList = computeShortcutList.value;
      if (isEnableConf(shortcutOpts) && shortcutList.length && (position || 'left') === pos) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: `vxe-date-range-picker--layout-${pos}-wrapper`
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(button_group, {
          options: shortcutList,
          mode,
          align,
          vertical: isVertical,
          onClick: handleShortcutEvent
        })]);
      }
      return renderEmptyElement($xeDateRangePicker);
    };
    const renderPanel = () => {
      const {
        type,
        separator,
        autoClose,
        showConfirmButton,
        showClearButton
      } = props;
      const {
        initialized,
        isAniVisible,
        visiblePanel,
        panelPlacement,
        panelStyle,
        startValue,
        endValue
      } = reactData;
      const vSize = computeSize.value;
      const btnTransfer = computeBtnTransfer.value;
      const shortcutOpts = computeShortcutOpts.value;
      const isClearable = computeIsClearable.value;
      const panelLabelObj = computePanelLabelObj.value;
      const shortcutList = computeShortcutList.value;
      const isDateTimeType = computeIsDateTimeType.value;
      const {
        startLabel,
        endLabel
      } = panelLabelObj;
      const {
        position
      } = shortcutOpts;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const leftSlot = slots.left;
      const rightSlot = slots.right;
      const hasShortcutBtn = shortcutList.length > 0;
      const showConfirmBtn = showConfirmButton === null ? isDateTimeType || !autoClose : showConfirmButton;
      const showClearBtn = showClearButton === null ? isClearable : showClearButton;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: btnTransfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refInputPanel,
        class: ['vxe-table--ignore-clear vxe-date-range-picker--panel', `type--${type}`, {
          [`size--${vSize}`]: vSize,
          'is--transfer': btnTransfer,
          'ani--leave': isAniVisible,
          'ani--enter': visiblePanel,
          'show--top': !!(topSlot || headerSlot || hasShortcutBtn && (position === 'top' || position === 'header')),
          'show--bottom': !!(bottomSlot || footerSlot || hasShortcutBtn && (position === 'bottom' || position === 'footer')),
          'show--left': !!(leftSlot || hasShortcutBtn && position === 'left'),
          'show--right': !!(rightSlot || hasShortcutBtn && position === 'right')
        }],
        placement: panelPlacement,
        style: panelStyle
      }, initialized && (visiblePanel || isAniVisible) ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refPanelWrapper,
        class: ['vxe-date-range-picker--layout-all-wrapper', `type--${type}`, {
          [`size--${vSize}`]: vSize
        }]
      }, [topSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-top-wrapper'
      }, topSlot({})) : renderShortcutBtn('top'), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-body-layout-wrapper'
      }, [leftSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-left-wrapper'
      }, leftSlot({})) : renderShortcutBtn('left', true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-body-content-wrapper'
      }, [headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-header-wrapper'
      }, headerSlot({})) : renderShortcutBtn('header'), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-body-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(date_panel, {
        ref: refStartDatePanel,
        modelValue: startValue,
        type: props.type,
        className: props.className,
        minDate: props.minDate,
        maxDate: props.maxDate,
        endDate: endValue,
        startDay: props.startDay,
        labelFormat: props.labelFormat,
        valueFormat: props.valueFormat,
        timeFormat: props.timeFormat,
        festivalMethod: props.festivalMethod,
        disabledMethod: props.disabledMethod,
        selectDay: props.selectDay,
        onChange: startPanelChangeEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(date_panel, {
        ref: refEndDatePanel,
        modelValue: endValue,
        type: props.type,
        className: props.className,
        minDate: props.minDate,
        maxDate: props.maxDate,
        startDate: startValue,
        startDay: props.startDay,
        labelFormat: props.labelFormat,
        valueFormat: props.valueFormat,
        timeFormat: props.timeFormat,
        festivalMethod: props.festivalMethod,
        disabledMethod: props.disabledMethod,
        selectDay: props.selectDay,
        onChange: endPanelChangeEvent
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-footer-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-footer-label'
      }, startLabel || endLabel ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', startLabel), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', `${separator || ''}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', endLabel)] : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-footer-custom'
      }, footerSlot ? footerSlot({}) : [renderShortcutBtn('footer')]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-footer-btns'
      }, [showClearBtn ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        size: 'mini',
        disabled: !(startValue || endValue),
        content: getI18n('vxe.button.clear'),
        onClick: clearValueEvent
      }) : renderEmptyElement($xeDateRangePicker), showConfirmBtn ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        size: 'mini',
        status: 'primary',
        content: getI18n('vxe.button.confirm'),
        onClick: confirmEvent
      }) : renderEmptyElement($xeDateRangePicker)])])]), rightSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-right-wrapper'
      }, rightSlot({})) : renderShortcutBtn('right', true)]), bottomSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--layout-bottom-wrapper'
      }, bottomSlot({})) : renderShortcutBtn('bottom')])] : [])]);
    };
    const renderPrefixIcon = () => {
      const {
        prefixIcon
      } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--prefix',
        onClick: clickPrefixEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--prefix-icon'
      }, prefixSlot ? vn_getSlotVNs(prefixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: prefixIcon
      })])]) : null;
    };
    const renderSuffixIcon = () => {
      const {
        suffixIcon
      } = props;
      const {
        startValue,
        endValue
      } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isClearable = computeIsClearable.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-date-range-picker--suffix', {
          'is--clear': isClearable && !isDisabled && (startValue || endValue)
        }]
      }, [isClearable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--clear-icon',
        onClick: clearValueEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().INPUT_CLEAR
      })]) : renderEmptyElement($xeDateRangePicker), renderExtraSuffixIcon(), suffixSlot || suffixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--suffix-icon',
        onClick: clickSuffixEvent
      }, suffixSlot ? vn_getSlotVNs(suffixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: suffixIcon
      })]) : renderEmptyElement($xeDateRangePicker)]);
    };
    const renderExtraSuffixIcon = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--control-icon',
        onClick: dateRangePickerOpenEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-date-range-picker--date-picker-icon', getIcon().DATE_PICKER_DATE]
      })]);
    };
    const renderVN = () => {
      const {
        className,
        type,
        name,
        autoComplete
      } = props;
      const {
        startValue,
        endValue,
        visiblePanel,
        isActivated
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const inputLabel = computeInputLabel.value;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-date-range-picker--readonly', `type--${type}`, className]
        }, inputLabel);
      }
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon();
      const suffix = renderSuffixIcon();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-date-range-picker', `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          'is--prefix': !!prefix,
          'is--suffix': !!suffix,
          'is--visible': visiblePanel,
          'is--disabled': isDisabled,
          'is--active': isActivated,
          'show--clear': isClearable && !isDisabled && (startValue || endValue)
        }],
        spellcheck: false
      }, [prefix || renderEmptyElement($xeDateRangePicker), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-date-range-picker--wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        ref: refInputTarget,
        class: 'vxe-date-range-picker--inner',
        value: inputLabel,
        name,
        type: 'text',
        placeholder: inpPlaceholder,
        readonly: true,
        disabled: isDisabled,
        autocomplete: autoComplete,
        onKeydown: keydownEvent,
        onKeyup: keyupEvent,
        onClick: clickEvent,
        onChange: changeEvent,
        onFocus: focusEvent,
        onBlur: blurEvent
      })]), suffix || renderEmptyElement($xeDateRangePicker),
      // 下拉面板
      renderPanel()]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, () => {
      updateModelValue(true);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeMVal, () => {
      updateModelValue(false);
    });
    updateModelValue(true);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      globalEvents.on($xeDateRangePicker, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeDateRangePicker, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeDateRangePicker, 'keydown', handleGlobalKeydownEvent);
      globalEvents.on($xeDateRangePicker, 'blur', handleGlobalBlurEvent);
      globalEvents.on($xeDateRangePicker, 'resize', handleGlobalResizeEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onDeactivated)(() => {
      checkValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeDateRangePicker, 'mousewheel');
      globalEvents.off($xeDateRangePicker, 'mousedown');
      globalEvents.off($xeDateRangePicker, 'blur');
      globalEvents.off($xeDateRangePicker, 'resize');
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      checkValue();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeDateRangePicker', $xeDateRangePicker);
    $xeDateRangePicker.renderVN = renderVN;
    return $xeDateRangePicker;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/date-range-picker/index.ts



const VxeDateRangePicker = Object.assign({}, date_range_picker, {
  install(app) {
    app.component(date_range_picker.name, date_range_picker);
  }
});
dynamicApp.use(VxeDateRangePicker);
index_esm_VxeUI.component(date_range_picker);
const DateRangePicker = VxeDateRangePicker;
/* harmony default export */ var packages_date_range_picker = (VxeDateRangePicker);
;// CONCATENATED MODULE: ./packages/loading/index.ts



const VxeLoading = Object.assign({}, src_loading, {
  install(app) {
    app.component(src_loading.name, src_loading);
  }
});
const LoadingController = {
  open(options) {
    const opts = Object.assign({}, options);
    dynamicStore.globalLoading = {
      modelValue: true,
      text: opts.text,
      icon: opts.icon
    };
    checkDynamic();
  },
  close() {
    dynamicStore.globalLoading = null;
  }
};
dynamicApp.use(VxeLoading);
index_esm_VxeUI.component(src_loading);
index_esm_VxeUI.loading = LoadingController;
const Loading = VxeLoading;
/* harmony default export */ var loading = (VxeLoading);
;// CONCATENATED MODULE: ./packages/drawer/src/drawer.ts










const allActiveDrawers = [];
/* harmony default export */ var drawer = (defineVxeComponent({
  name: 'VxeDrawer',
  props: {
    modelValue: Boolean,
    id: String,
    title: String,
    loading: {
      type: Boolean,
      default: null
    },
    className: String,
    position: {
      type: [String, Object],
      default: () => getConfig().drawer.position
    },
    lockView: {
      type: Boolean,
      default: () => getConfig().drawer.lockView
    },
    lockScroll: Boolean,
    mask: {
      type: Boolean,
      default: () => getConfig().drawer.mask
    },
    maskClosable: {
      type: Boolean,
      default: () => getConfig().drawer.maskClosable
    },
    escClosable: {
      type: Boolean,
      default: () => getConfig().drawer.escClosable
    },
    cancelClosable: {
      type: Boolean,
      default: () => getConfig().drawer.cancelClosable
    },
    confirmClosable: {
      type: Boolean,
      default: () => getConfig().drawer.confirmClosable
    },
    showHeader: {
      type: Boolean,
      default: () => getConfig().drawer.showHeader
    },
    showFooter: {
      type: Boolean,
      default: () => getConfig().drawer.showFooter
    },
    showClose: {
      type: Boolean,
      default: () => getConfig().drawer.showClose
    },
    content: [Number, String],
    showCancelButton: {
      type: Boolean,
      default: null
    },
    cancelButtonText: {
      type: String,
      default: () => getConfig().drawer.cancelButtonText
    },
    showConfirmButton: {
      type: Boolean,
      default: () => getConfig().drawer.showConfirmButton
    },
    confirmButtonText: {
      type: String,
      default: () => getConfig().drawer.confirmButtonText
    },
    destroyOnClose: {
      type: Boolean,
      default: () => getConfig().drawer.destroyOnClose
    },
    showTitleOverflow: {
      type: Boolean,
      default: () => getConfig().drawer.showTitleOverflow
    },
    width: [Number, String],
    height: [Number, String],
    resize: {
      type: Boolean,
      default: () => getConfig().drawer.resize
    },
    zIndex: Number,
    transfer: {
      type: Boolean,
      default: () => getConfig().drawer.transfer
    },
    padding: {
      type: Boolean,
      default: () => getConfig().drawer.padding
    },
    size: {
      type: String,
      default: () => getConfig().drawer.size || getConfig().size
    },
    beforeHideMethod: {
      type: Function,
      default: () => getConfig().drawer.beforeHideMethod
    },
    slots: Object
  },
  emits: ['update:modelValue', 'show', 'hide', 'before-hide', 'close', 'confirm', 'cancel', 'resize'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeParentDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refDrawerBox = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refConfirmBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refCancelBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      visible: false,
      contentVisible: false,
      drawerZIndex: 0,
      resizeFlag: 1
    });
    const refMaps = {
      refElem
    };
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().modal.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeParentDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeDragType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      switch (props.position) {
        case 'top':
          return 'sb';
        case 'bottom':
          return 'st';
        case 'left':
          return 'wr';
      }
      return 'wl';
    });
    const computeMaps = {};
    const $xeDrawer = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getBox = () => {
      const boxElem = refDrawerBox.value;
      return boxElem;
    };
    const recalculate = () => {
      const {
        width,
        height
      } = props;
      const boxElem = getBox();
      if (boxElem) {
        boxElem.style.width = toCssUnit(width);
        boxElem.style.height = toCssUnit(height);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const updateZindex = () => {
      const {
        zIndex
      } = props;
      const {
        drawerZIndex
      } = reactData;
      if (zIndex) {
        reactData.drawerZIndex = zIndex;
      } else if (drawerZIndex < getLastZIndex()) {
        reactData.drawerZIndex = nextZIndex();
      }
    };
    const closeDrawer = type => {
      const {
        beforeHideMethod
      } = props;
      const {
        visible
      } = reactData;
      const params = {
        type
      };
      if (visible) {
        Promise.resolve(beforeHideMethod ? beforeHideMethod(params) : null).then(rest => {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isError(rest)) {
            reactData.contentVisible = false;
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(allActiveDrawers, item => item === $xeDrawer);
            dispatchEvent('before-hide', params, null);
            setTimeout(() => {
              reactData.visible = false;
              emit('update:modelValue', false);
              dispatchEvent('hide', params, null);
            }, 200);
          }
        }).catch(e => e);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const closeEvent = evnt => {
      const type = 'close';
      dispatchEvent(type, {
        type
      }, evnt);
      closeDrawer(type);
    };
    const confirmEvent = evnt => {
      const {
        confirmClosable
      } = props;
      const type = 'confirm';
      dispatchEvent(type, {
        type
      }, evnt);
      if (confirmClosable) {
        closeDrawer(type);
      }
    };
    const cancelEvent = evnt => {
      const {
        cancelClosable
      } = props;
      const type = 'cancel';
      dispatchEvent(type, {
        type
      }, evnt);
      if (cancelClosable) {
        closeDrawer(type);
      }
    };
    const openDrawer = () => {
      const {
        showFooter
      } = props;
      const {
        initialized,
        visible
      } = reactData;
      if (!initialized) {
        reactData.initialized = true;
      }
      if (!visible) {
        reactData.visible = true;
        reactData.contentVisible = false;
        updateZindex();
        allActiveDrawers.push($xeDrawer);
        setTimeout(() => {
          recalculate();
          reactData.contentVisible = true;
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            if (showFooter) {
              const confirmBtn = refConfirmBtn.value;
              const cancelBtn = refCancelBtn.value;
              const operBtn = confirmBtn || cancelBtn;
              if (operBtn) {
                operBtn.focus();
              }
            }
            const type = '';
            const params = {
              type
            };
            emit('update:modelValue', true);
            dispatchEvent('show', params, null);
          });
        }, 10);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $drawer: $xeDrawer
      }, params));
    };
    const drawerMethods = {
      dispatchEvent,
      open: openDrawer,
      close() {
        return closeDrawer('close');
      },
      getBox
    };
    const selfClickEvent = evnt => {
      const el = refElem.value;
      if (props.maskClosable && evnt.target === el) {
        const type = 'mask';
        closeDrawer(type);
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
      if (isEsc) {
        const lastDrawer = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().max(allActiveDrawers, item => item.reactData.drawerZIndex);
        // 多个时，只关掉最上层的窗口
        if (lastDrawer) {
          setTimeout(() => {
            if (lastDrawer === $xeDrawer && lastDrawer.props.escClosable) {
              const type = 'exit';
              dispatchEvent('close', {
                type
              }, evnt);
              closeDrawer(type);
            }
          }, 10);
        }
      }
    };
    const boxMousedownEvent = () => {
      const {
        drawerZIndex
      } = reactData;
      if (allActiveDrawers.some(comp => comp.reactData.visible && comp.reactData.drawerZIndex > drawerZIndex)) {
        updateZindex();
      }
    };
    const dragEvent = evnt => {
      evnt.preventDefault();
      const {
        visibleHeight,
        visibleWidth
      } = getDomNode();
      const marginSize = 0;
      const targetElem = evnt.target;
      const type = targetElem.getAttribute('type');
      const minWidth = 0;
      const minHeight = 0;
      const maxWidth = visibleWidth;
      const maxHeight = visibleHeight;
      const boxElem = getBox();
      const clientWidth = boxElem.clientWidth;
      const clientHeight = boxElem.clientHeight;
      const disX = evnt.clientX;
      const disY = evnt.clientY;
      const offsetTop = boxElem.offsetTop;
      const offsetLeft = boxElem.offsetLeft;
      const params = {
        type: 'resize'
      };
      document.onmousemove = evnt => {
        evnt.preventDefault();
        let dragLeft;
        let dragTop;
        let width;
        let height;
        switch (type) {
          case 'wl':
            dragLeft = disX - evnt.clientX;
            width = dragLeft + clientWidth;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            break;
          case 'st':
            dragTop = disY - evnt.clientY;
            height = clientHeight + dragTop;
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case 'wr':
            dragLeft = evnt.clientX - disX;
            width = dragLeft + clientWidth;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            break;
          case 'sb':
            dragTop = evnt.clientY - disY;
            height = dragTop + clientHeight;
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
        }
        boxElem.className = boxElem.className.replace(/\s?is--drag/, '') + ' is--drag';
        dispatchEvent('resize', params, evnt);
        reactData.resizeFlag++;
      };
      document.onmouseup = () => {
        document.onmousemove = null;
        document.onmouseup = null;
        reactData.resizeFlag++;
        setTimeout(() => {
          boxElem.className = boxElem.className.replace(/\s?is--drag/, '');
        }, 50);
      };
    };
    const formDesignPrivateMethods = {};
    Object.assign($xeDrawer, drawerMethods, formDesignPrivateMethods);
    const renderTitles = () => {
      const {
        slots: propSlots = {},
        showClose,
        title
      } = props;
      const titleSlot = slots.title || propSlots.title;
      const cornerSlot = slots.corner || propSlots.corner;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--header-title'
      }, titleSlot ? vn_getSlotVNs(titleSlot({
        $drawer: $xeDrawer
      })) : title ? getFuncText(title) : getI18n('vxe.alert.title')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--header-right'
      }, [cornerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--corner-wrapper'
      }, vn_getSlotVNs(cornerSlot({
        $drawer: $xeDrawer
      }))) : renderEmptyElement($xeDrawer), showClose ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-drawer--close-btn', 'trigger--btn'],
        title: getI18n('vxe.drawer.close'),
        onClick: closeEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().DRAWER_CLOSE
      })]) : renderEmptyElement($xeDrawer)])];
    };
    const renderHeader = () => {
      const {
        slots: propSlots = {},
        showTitleOverflow
      } = props;
      const headerSlot = slots.header || propSlots.header;
      if (props.showHeader) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-drawer--header', {
            'is--ellipsis': showTitleOverflow
          }]
        }, headerSlot ? vn_getSlotVNs(headerSlot({
          $drawer: $xeDrawer
        })) : renderTitles());
      }
      return renderEmptyElement($xeDrawer);
    };
    const renderBody = () => {
      const {
        slots: propSlots = {},
        content
      } = props;
      const defaultSlot = slots.default || propSlots.default;
      const leftSlot = slots.left || propSlots.left;
      const rightSlot = slots.right || propSlots.right;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--body'
      }, [leftSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--body-left'
      }, vn_getSlotVNs(leftSlot({
        $drawer: $xeDrawer
      }))) : renderEmptyElement($xeDrawer), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--body-default'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--content'
      }, defaultSlot ? vn_getSlotVNs(defaultSlot({
        $drawer: $xeDrawer
      })) : getFuncText(content))]), rightSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--body-right'
      }, vn_getSlotVNs(rightSlot({
        $drawer: $xeDrawer
      }))) : renderEmptyElement($xeDrawer), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(loading, {
        class: 'vxe-drawer--loading',
        modelValue: props.loading
      })]);
    };
    const renderDefaultFooter = () => {
      const {
        slots: propSlots = {},
        showCancelButton,
        showConfirmButton,
        loading
      } = props;
      const lfSlot = slots.leftfoot || propSlots.leftfoot;
      const rfSlot = slots.rightfoot || propSlots.rightfoot;
      const btnVNs = [];
      if (showCancelButton) {
        btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          key: 1,
          ref: refCancelBtn,
          content: props.cancelButtonText || getI18n('vxe.button.cancel'),
          onClick: cancelEvent
        }));
      }
      if (showConfirmButton) {
        btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          key: 2,
          ref: refConfirmBtn,
          loading: loading,
          status: 'primary',
          content: props.confirmButtonText || getI18n('vxe.button.confirm'),
          onClick: confirmEvent
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--footer-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--footer-left'
      }, lfSlot ? vn_getSlotVNs(lfSlot({
        $drawer: $xeDrawer
      })) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--footer-right'
      }, rfSlot ? vn_getSlotVNs(rfSlot({
        $drawer: $xeDrawer
      })) : btnVNs)]);
    };
    const renderFooter = () => {
      const {
        slots: propSlots = {}
      } = props;
      const footerSlot = slots.footer || propSlots.footer;
      if (props.showFooter) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-drawer--footer'
        }, footerSlot ? vn_getSlotVNs(footerSlot({
          $drawer: $xeDrawer
        })) : [renderDefaultFooter()]);
      }
      return renderEmptyElement($xeDrawer);
    };
    const renderVN = () => {
      const {
        slots: propSlots = {},
        className,
        position,
        loading,
        lockScroll,
        padding,
        lockView,
        mask,
        resize,
        destroyOnClose
      } = props;
      const {
        initialized,
        contentVisible,
        visible
      } = reactData;
      const asideSlot = slots.aside || propSlots.aside;
      const vSize = computeSize.value;
      const dragType = computeDragType.value;
      const btnTransfer = computeBtnTransfer.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: btnTransfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-drawer--wrapper', `pos--${position}`, className || '', {
          [`size--${vSize}`]: vSize,
          'is--padding': padding,
          'lock--scroll': lockScroll,
          'lock--view': lockView,
          'is--resize': resize,
          'is--mask': mask,
          'is--visible': contentVisible,
          'is--active': visible,
          'is--loading': loading
        }],
        style: {
          zIndex: reactData.drawerZIndex
        },
        onClick: selfClickEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refDrawerBox,
        class: 'vxe-drawer--box',
        onMousedown: boxMousedownEvent
      }, [asideSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--aside'
      }, vn_getSlotVNs(asideSlot({
        $drawer: $xeDrawer
      }))) : renderEmptyElement($xeDrawer), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-drawer--container'
      }, !reactData.initialized || destroyOnClose && !reactData.visible ? [] : [renderHeader(), renderBody(), renderFooter(), resize ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-drawer--resize'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: `${dragType}-resize`,
        type: dragType,
        onMousedown: dragEvent
      })]) : renderEmptyElement($xeDrawer)])])])]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.width, recalculate);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.height, recalculate);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, value => {
      if (value) {
        openDrawer();
      } else {
        closeDrawer('model');
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        if (props.modelValue) {
          openDrawer();
        }
        recalculate();
      });
      if (props.escClosable) {
        globalEvents.on($xeDrawer, 'keydown', handleGlobalKeydownEvent);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeDrawer, 'keydown');
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeDrawer', $xeDrawer);
    $xeDrawer.renderVN = renderVN;
    return $xeDrawer;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/drawer/index.ts





function handleDrawer(options) {
  // 使用动态组件渲染动态弹框
  checkDynamic();
  return new Promise(resolve => {
    if (options && options.id && allActiveDrawers.some(comp => comp.props.id === options.id)) {
      resolve('exist');
    } else {
      const _onHide = options.onHide;
      const drawerOpts = Object.assign(options, {
        key: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId(),
        modelValue: true,
        onHide(params) {
          const drawerList = dynamicStore.drawers;
          if (_onHide) {
            _onHide(params);
          }
          dynamicStore.drawers = drawerList.filter(item => item.key !== drawerOpts.key);
          resolve(params.type);
        }
      });
      dynamicStore.drawers.push(drawerOpts);
    }
  });
}
function getDrawer(id) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(allActiveDrawers, $drawer => $drawer.props.id === id);
}
/**
 * 全局关闭动态的活动窗口（只能用于关闭动态的创建的活动窗口）
 * 如果传 id 则关闭指定的窗口
 * 如果不传则关闭所有窗口
 */
function closeDrawer(id) {
  const drawers = id ? [getDrawer(id)] : allActiveDrawers;
  const restPromises = [];
  drawers.forEach($drawer => {
    if ($drawer) {
      restPromises.push($drawer.close());
    }
  });
  return Promise.all(restPromises);
}
function openDrawer(options) {
  return handleDrawer(Object.assign({}, options));
}
const DrawerController = {
  get: getDrawer,
  close: closeDrawer,
  open: openDrawer
};
const VxeDrawer = Object.assign(drawer, {
  install: function (app) {
    app.component(drawer.name, drawer);
  }
});
index_esm_VxeUI.drawer = DrawerController;
dynamicApp.use(VxeDrawer);
index_esm_VxeUI.component(drawer);
const Drawer = VxeDrawer;
/* harmony default export */ var packages_drawer = (VxeDrawer);
;// CONCATENATED MODULE: ./packages/empty/src/empty.ts




/* harmony default export */ var empty = (defineVxeComponent({
  name: 'VxeEmpty',
  props: {
    imageUrl: String,
    imageStyle: Object,
    icon: String,
    status: String,
    content: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeEmpty = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $empty: $xeEmpty
      }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeEmpty, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const {
        imageUrl,
        imageStyle,
        icon,
        status,
        content
      } = props;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-empty', {
          [`theme--${status}`]: status
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-empty--inner'
      }, [imageUrl ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-empty--img-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('img', {
        src: imageUrl,
        style: imageStyle
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-empty--icon-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon || getIcon().EMPTY_DEFAULT
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-empty--content-wrapper'
      }, `${content || getI18n('vxe.empty.defText')}`)])]);
    };
    $xeEmpty.renderVN = renderVN;
    return $xeEmpty;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/empty/index.ts



const VxeEmpty = Object.assign({}, empty, {
  install(app) {
    app.component(empty.name, empty);
  }
});
dynamicApp.use(VxeEmpty);
index_esm_VxeUI.component(empty);
const Empty = VxeEmpty;
/* harmony default export */ var packages_empty = (VxeEmpty);
;// CONCATENATED MODULE: ./packages/form/src/itemInfo.ts



class ItemInfo {
  constructor($xeForm, item) {
    const {
      field,
      itemRender,
      formatter
    } = item;
    if (formatter) {
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(formatter)) {
        const gFormatOpts = formats.get(formatter);
        if (!gFormatOpts || !gFormatOpts.formItemFormatMethod) {
          errLog('vxe.error.notFormats', [formatter]);
        }
      } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(formatter)) {
        const gFormatOpts = formats.get(formatter[0]);
        if (!gFormatOpts || !gFormatOpts.formItemFormatMethod) {
          errLog('vxe.error.notFormats', [formatter[0]]);
        }
      }
    }
    if (field && itemRender) {
      if (itemRender.startField && `${itemRender.startField}`.indexOf(field) >= 0) {
        errLog('vxe.error.modelConflicts', [`field=${field}`, `item-render.startField=${itemRender.startField}`]);
      }
      if (itemRender.endField && `${itemRender.endField}`.indexOf(field) >= 0) {
        errLog('vxe.error.modelConflicts', [`field=${field}`, `item-render.endField=${itemRender.endField}`]);
      }
    }
    Object.assign(this, {
      id: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('item_'),
      title: item.title,
      field: field,
      span: item.span,
      align: item.align,
      verticalAlign: item.verticalAlign,
      titleBackground: item.titleBackground,
      titleBold: item.titleBold,
      titleAlign: item.titleAlign,
      titleWidth: item.titleWidth,
      titleColon: item.titleColon,
      vertical: item.vertical,
      padding: item.padding,
      titleAsterisk: item.titleAsterisk,
      titlePrefix: item.titlePrefix,
      titleSuffix: item.titleSuffix,
      titleOverflow: item.titleOverflow,
      showTitle: item.showTitle,
      resetValue: item.resetValue,
      visibleMethod: item.visibleMethod,
      visible: item.visible,
      showContent: item.showContent,
      folding: item.folding,
      collapseNode: item.collapseNode,
      className: item.className,
      contentClassName: item.contentClassName,
      contentStyle: item.contentStyle,
      titleClassName: item.titleClassName,
      titleStyle: item.titleStyle,
      itemRender: itemRender,
      rules: item.rules,
      formatter,
      // 自定义参数
      params: item.params,
      // 渲染属性
      showError: false,
      errRule: null,
      slots: item.slots,
      children: []
    });
  }
  update(name, value) {
    this[name] = value;
  }
}
;// CONCATENATED MODULE: ./packages/form/src/util.ts






function isFormItem(item) {
  return item instanceof ItemInfo;
}
function createItem($xeForm, _vm) {
  return isFormItem(_vm) ? _vm : new ItemInfo($xeForm, _vm);
}
function handleFieldOrItem($xeForm, fieldOrItem) {
  if (fieldOrItem) {
    return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(fieldOrItem) ? $xeForm.getItemByField(fieldOrItem) : fieldOrItem;
  }
  return null;
}
function isHiddenItem($xeForm, formItem) {
  const {
    reactData
  } = $xeForm;
  const {
    collapseAll
  } = reactData;
  const {
    folding,
    visible
  } = formItem;
  return visible === false || folding && collapseAll;
}
function isActiveItem($xeForm, formItem) {
  const $xeGrid = $xeForm.xeGrid;
  let {
    visibleMethod,
    itemRender,
    visible,
    field
  } = formItem;
  if (visible === false) {
    return visible;
  }
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const fiVisibleMethod = compConf ? compConf.formItemVisibleMethod || compConf.itemVisibleMethod : null;
  if (!visibleMethod && fiVisibleMethod) {
    visibleMethod = fiVisibleMethod;
  }
  if (!visibleMethod) {
    return true;
  }
  const formProps = $xeForm.props;
  const {
    data
  } = formProps;
  return visibleMethod({
    data,
    field,
    property: field,
    item: formItem,
    $form: $xeForm,
    $grid: $xeGrid
  });
}
function watchItem(props, formItem) {
  Object.keys(props).forEach(name => {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props[name], value => {
      formItem.update(name, value);
    });
  });
}
function assembleItem($xeForm, el, formItem, formGroup) {
  const {
    reactData
  } = $xeForm;
  const formProps = $xeForm.props;
  const {
    customLayout
  } = formProps;
  const {
    staticItems
  } = reactData;
  if (customLayout) {
    if (!staticItems.some(item => item.id === formItem.id)) {
      staticItems.push(formItem);
    }
  } else {
    if (el) {
      const parentElem = el.parentNode;
      const parentItem = formGroup ? formGroup.formItem : null;
      const parentItems = parentItem ? parentItem.children : staticItems;
      if (parentElem) {
        parentItems.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, el), 0, formItem);
        reactData.staticItems = staticItems.slice(0);
      }
    }
  }
}
function destroyItem($xeForm, formItem) {
  const {
    reactData
  } = $xeForm;
  const {
    staticItems
  } = reactData;
  const index = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(staticItems, item => item.id === formItem.id);
  if (index > -1) {
    staticItems.splice(index, 1);
  }
  reactData.staticItems = staticItems.slice(0);
}
;// CONCATENATED MODULE: ./packages/icon/src/icon.ts




/* harmony default export */ var icon = (defineVxeComponent({
  name: 'VxeIcon',
  props: {
    name: String,
    className: String,
    roll: Boolean,
    status: String,
    size: {
      type: String,
      default: () => getConfig().icon.size || getConfig().size
    }
  },
  emits: ['click'],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const $xeIcon = {
      xID,
      props,
      context
    };
    const clickEvent = evnt => {
      emit('click', createEvent(evnt, {}));
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $icon: $xeIcon
      }, params));
    };
    const iconMethods = {
      dispatchEvent
    };
    const iconPrivateMethods = {};
    Object.assign($xeIcon, iconMethods, iconPrivateMethods);
    const renderVN = () => {
      const {
        name,
        roll,
        status,
        className
      } = props;
      const vSize = computeSize.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-icon', `vxe-icon-${name}`, `${className || ''}`, {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          roll: roll
        }],
        onClick: clickEvent
      });
    };
    $xeIcon.renderVN = renderVN;
    return $xeIcon;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form/src/render.ts










function renderPrefixIcon(titlePrefix) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: 'vxe-form--item-title-tip-prefix'
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(icon, {
    class: titlePrefix.icon || getIcon().FORM_PREFIX,
    status: titlePrefix.iconStatus
  })]);
}
function renderSuffixIcon(titleSuffix) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    class: 'vxe-form--item-title-tip-suffix'
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(icon, {
    class: titleSuffix.icon || getIcon().FORM_SUFFIX,
    status: titleSuffix.iconStatus
  })]);
}
const getItemClass = ($xeForm, item, isGroup) => {
  const formProps = $xeForm.props;
  const formReactData = $xeForm.reactData;
  const $xeGrid = $xeForm.xeGrid;
  const {
    data,
    rules,
    readonly,
    disabled,
    span: allSpan,
    titleBackground: allTitleBackground,
    titleBold: allTitleBold,
    titleColon: allTitleColon,
    titleAsterisk: allTitleAsterisk,
    vertical: allVertical,
    padding: allPadding
  } = formProps;
  const {
    collapseAll
  } = formReactData;
  const {
    folding,
    field,
    itemRender,
    showError,
    className,
    vertical,
    padding,
    children,
    showContent
  } = item;
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const itemClassName = compConf ? compConf.formItemClassName || compConf.itemClassName : '';
  const span = item.span || allSpan;
  const itemPadding = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(padding) ? allPadding : padding;
  const itemVertical = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(vertical) ? allVertical : vertical;
  const titleBackground = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleBackground) ? allTitleBackground : item.titleBackground;
  const titleBold = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleBold) ? allTitleBold : item.titleBold;
  const titleColon = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleColon) ? allTitleColon : item.titleColon;
  const titleAsterisk = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleAsterisk) ? allTitleAsterisk : item.titleAsterisk;
  const params = {
    data,
    disabled,
    readonly,
    field,
    property: field,
    item,
    $form: $xeForm,
    $grid: $xeGrid
  };
  const hasGroup = children && children.length > 0;
  let isRequired = false;
  let isValid = false;
  if (!readonly && rules) {
    const itemRules = rules[field];
    if (itemRules && itemRules.length) {
      isValid = true;
      isRequired = itemRules.some(rule => rule.required);
    }
  }
  return [isGroup || hasGroup ? 'vxe-form--group' : '', 'vxe-form--item', item.id, span ? `vxe-form--item-col_${span} is--span` : '', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className(params) : className : '', itemClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemClassName) ? itemClassName(params) : itemClassName : '', {
    'is--colon': titleColon,
    'is--tbg': titleBackground,
    'is--bold': titleBold,
    'is--padding': itemPadding,
    'is--vertical': itemVertical,
    'is--asterisk': titleAsterisk,
    'hide--content': showContent === false,
    'is--valid': isValid,
    'is--required': isRequired,
    'is--hidden': folding && collapseAll,
    'is--active': isActiveItem($xeForm, item),
    'is--error': showError
  }];
};
const getItemContentClass = ($xeForm, item, isGroup) => {
  const formProps = $xeForm.props;
  const $xeGrid = $xeForm.xeGrid;
  const {
    data,
    readonly,
    disabled,
    align: allAlign,
    verticalAlign: allVerticalAlign
  } = formProps;
  const {
    field,
    itemRender,
    contentClassName,
    children
  } = item;
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const itemContentClassName = compConf ? compConf.formItemContentClassName || compConf.itemContentClassName : '';
  const align = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.align) ? allAlign : item.align;
  const verticalAlign = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.verticalAlign) ? allVerticalAlign : item.verticalAlign;
  const params = {
    data,
    disabled,
    readonly,
    field,
    property: field,
    item,
    $form: $xeForm,
    $grid: $xeGrid
  };
  const hasGroup = children && children.length > 0;
  return [isGroup || hasGroup ? 'vxe-form--group-content vxe-form--item-row' : '', 'vxe-form--item-content', align ? `align--${align}` : '', verticalAlign ? `vertical-align--${verticalAlign}` : '', itemContentClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemContentClassName) ? itemContentClassName(params) : itemContentClassName : '', contentClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(contentClassName) ? contentClassName(params) : contentClassName : ''];
};
function renderTitle($xeForm, item, isGroup) {
  const formProps = $xeForm.props;
  const $xeGrid = $xeForm.xeGrid;
  const {
    data,
    readonly,
    disabled,
    titleAlign: allTitleAlign,
    titleWidth: allTitleWidth,
    titleOverflow: allTitleOverflow,
    vertical: allVertical
  } = formProps;
  const {
    slots,
    title,
    field,
    itemRender,
    titleOverflow,
    vertical,
    showTitle,
    titleClassName,
    titleStyle,
    titlePrefix,
    titleSuffix,
    children,
    showContent
  } = item;
  const {
    computeTooltipOpts
  } = $xeForm.getComputeMaps();
  const tooltipOpts = computeTooltipOpts.value;
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const itemTitleClassName = compConf ? compConf.formItemTitleClassName || compConf.itemTitleClassName : '';
  const itemTitleStyle = compConf ? compConf.formItemTitleStyle || compConf.itemTitleStyle : null;
  const itemVertical = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(vertical) ? allVertical : vertical;
  const titleAlign = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleAlign) ? allTitleAlign : item.titleAlign;
  const titleWidth = itemVertical ? null : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(item.titleWidth) ? allTitleWidth : item.titleWidth;
  const itemOverflow = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(titleOverflow) ? allTitleOverflow : titleOverflow;
  const ovEllipsis = itemOverflow === 'ellipsis';
  const ovTitle = itemOverflow === 'title';
  const ovTooltip = itemOverflow === true || itemOverflow === 'tooltip';
  const hasEllipsis = ovTitle || ovTooltip || ovEllipsis;
  const params = {
    data,
    disabled,
    readonly,
    field,
    property: field,
    item,
    $form: $xeForm,
    $grid: $xeGrid
  };
  const titleSlot = slots ? slots.title : null;
  const prefixSlot = slots ? slots.prefix : null;
  const suffixSlot = slots ? slots.suffix || slots.extra : null;
  const isTitle = showTitle !== false && (title || titleSlot);
  const hasGroup = children && children.length > 0;
  const titVNs = [];
  if (prefixSlot) {
    titVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      key: 'pt',
      class: 'vxe-form--item-title-prefix'
    }, $xeForm.callSlot(prefixSlot, params)));
  }
  if (titlePrefix) {
    titVNs.push(titlePrefix.content || titlePrefix.message ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tooltip, {
      key: 'pm',
      ...tooltipOpts,
      ...titlePrefix,
      content: getFuncText(titlePrefix.content || titlePrefix.message)
    }, {
      default: () => renderPrefixIcon(titlePrefix)
    }) : renderPrefixIcon(titlePrefix));
  }
  const rftTitle = compConf ? compConf.renderFormItemTitle || compConf.renderItemTitle : null;
  titVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
    key: 'pl',
    class: 'vxe-form--item-title-label'
  }, titleSlot ? $xeForm.callSlot(titleSlot, params) : rftTitle ? vn_getSlotVNs(rftTitle(itemRender, params)) : getFuncText(item.title)));
  const fixVNs = [];
  if (titleSuffix) {
    fixVNs.push(titleSuffix.content || titleSuffix.message ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tooltip, {
      key: 'sm',
      ...tooltipOpts,
      ...titleSuffix,
      content: getFuncText(titleSuffix.content || titleSuffix.message)
    }, {
      default: () => renderSuffixIcon(titleSuffix)
    }) : renderSuffixIcon(titleSuffix));
  }
  if (suffixSlot) {
    fixVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      key: 'st',
      class: 'vxe-form--item-title-suffix'
    }, $xeForm.callSlot(suffixSlot, params)));
  }
  const ons = ovTooltip ? {
    onMouseenter(evnt) {
      $xeForm.triggerTitleTipEvent(evnt, params);
    },
    onMouseleave: $xeForm.handleTitleTipLeaveEvent
  } : {};
  const itStyle = Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemTitleStyle) ? itemTitleStyle(params) : itemTitleStyle, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(titleStyle) ? titleStyle(params) : titleStyle);
  if (titleWidth && titleWidth !== 'auto' && showContent !== false) {
    itStyle.width = toCssUnit(titleWidth);
  }
  return isTitle ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
    class: [isGroup || hasGroup ? 'vxe-form--group-title' : '', 'vxe-form--item-title', titleAlign ? `align--${titleAlign}` : '', hasEllipsis ? 'is--ellipsis' : '', itemTitleClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemTitleClassName) ? itemTitleClassName(params) : itemTitleClassName : '', titleClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(titleClassName) ? titleClassName(params) : titleClassName : ''],
    style: itStyle,
    itemid: item.id,
    title: ovTitle ? getFuncText(title) : null,
    ...ons
  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
    class: 'vxe-form--item-title-content'
  }, titVNs), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
    class: 'vxe-form--item-title-postfix'
  }, fixVNs)]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
}
const renderItemContent = ($xeForm, item) => {
  const formProps = $xeForm.props;
  const formReactData = $xeForm.reactData;
  const formInternalData = $xeForm.internalData;
  const $xeGrid = $xeForm.xeGrid;
  const {
    computeCollapseOpts,
    computeValidOpts
  } = $xeForm.getComputeMaps();
  const {
    itemFormatCache
  } = formInternalData;
  const {
    data,
    readonly,
    disabled
  } = formProps;
  const {
    collapseAll
  } = formReactData;
  const {
    slots,
    field,
    itemRender,
    collapseNode,
    errRule,
    formatter
  } = item;
  const defaultSlot = slots ? slots.default : null;
  const validSlot = slots ? slots.valid : null;
  const collapseOpts = computeCollapseOpts.value;
  const validOpts = computeValidOpts.value;
  const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  const params = {
    data,
    disabled,
    readonly,
    field,
    property: field,
    item,
    itemValue,
    $form: $xeForm,
    $grid: $xeGrid
  };
  let contentVNs = [];
  const rftContent = compConf ? compConf.renderFormItemContent || compConf.renderItemContent : null;
  if (defaultSlot) {
    contentVNs = $xeForm.callSlot(defaultSlot, params);
  } else if (rftContent) {
    contentVNs = vn_getSlotVNs(rftContent(itemRender, params));
  } else if (field) {
    let itemLabel = itemValue;
    if (formatter) {
      let formatData;
      if (field) {
        const itemRest = itemFormatCache[field];
        if (itemRest) {
          formatData = itemRest.formatData;
          if (formatData) {
            if (formatData.value === itemValue) {
              return formatData.label;
            }
          } else {
            formatData = itemRest.formatData = {};
          }
        } else {
          itemFormatCache[field] = {
            field
          };
        }
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(formatter)) {
        const gFormatOpts = formats.get(formatter);
        const fiFormatMethod = gFormatOpts ? gFormatOpts.formItemFormatMethod : null;
        itemLabel = fiFormatMethod ? fiFormatMethod(params) : '';
      } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(formatter)) {
        const gFormatOpts = formats.get(formatter[0]);
        const fiFormatMethod = gFormatOpts ? gFormatOpts.formItemFormatMethod : null;
        itemLabel = fiFormatMethod ? fiFormatMethod(params, ...formatter.slice(1)) : '';
      } else {
        itemLabel = formatter(params);
      }
      if (formatData) {
        formatData.value = itemValue;
        formatData.label = itemLabel;
      }
    }
    contentVNs = [eqEmptyValue(itemLabel) ? '' : `${itemLabel}`];
  }
  if (collapseNode) {
    contentVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
      class: 'vxe-form--item-trigger-node',
      onClick: $xeForm.toggleCollapseEvent
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-form--item-trigger-text'
    }, collapseAll ? collapseOpts.unfoldButtonText || getI18n('vxe.form.unfolding') : collapseOpts.foldButtonText || getI18n('vxe.form.folding')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
      class: ['vxe-form--item-trigger-icon', collapseAll ? collapseOpts.foldIcon || getIcon().FORM_FOLDING : collapseOpts.unfoldIcon || getIcon().FORM_UNFOLDING]
    })]));
  }
  if (errRule && validOpts.showMessage) {
    const validParams = {
      ...params,
      rule: errRule
    };
    contentVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
      class: 'vxe-form-item--valid-error-tip',
      style: errRule.maxWidth ? {
        width: toCssUnit(errRule.maxWidth)
      } : null
    }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
      class: `vxe-form-item--valid-error-wrapper vxe-form-item--valid-error-theme-${validOpts.theme || 'normal'}`
    }, [validSlot ? $xeForm.callSlot(validSlot, validParams) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
      class: 'vxe-form--item--valid-error-msg'
    }, errRule.content || errRule.message)]])]));
  }
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
    class: 'vxe-form--item-inner'
  }, contentVNs);
};
;// CONCATENATED MODULE: ./packages/form/src/form-config-item.ts






const VxeFormConfigItem = defineVxeComponent({
  name: 'VxeFormConfigItem',
  props: {
    itemConfig: Object
  },
  setup(props) {
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', {});
    const xeformiteminfo = {
      itemConfig: props.itemConfig
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('xeFormItemInfo', xeformiteminfo);
    const renderItem = ($xeForm, item) => {
      const formProps = $xeForm.props;
      const $xeGrid = $xeForm.xeGrid;
      const {
        data,
        readonly,
        disabled
      } = formProps;
      const {
        visible,
        field,
        itemRender,
        contentStyle,
        children,
        showContent
      } = item;
      const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
      const itemStyle = compConf ? compConf.formItemStyle || compConf.itemStyle : null;
      const itemContentStyle = compConf ? compConf.formItemContentStyle || compConf.itemContentStyle : null;
      const params = {
        data,
        disabled,
        readonly,
        field,
        property: field,
        item,
        $form: $xeForm,
        $grid: $xeGrid
      };
      const hasGroup = children && children.length > 0;
      if (visible === false) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: item.id,
        itemid: item.id,
        class: getItemClass($xeForm, item),
        style: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [renderTitle($xeForm, item), showContent === false ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: getItemContentClass($xeForm, item),
        style: Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(contentStyle) ? contentStyle(params) : contentStyle)
      }, hasGroup ? children.map(childItem => renderItem($xeForm, childItem)) : [renderItemContent($xeForm, item)])]);
    };
    const renderVN = () => {
      return renderItem($xeForm, props.itemConfig);
    };
    const $xeFormconfigitem = {
      renderVN
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormGroup', null);
    return $xeFormconfigitem;
  },
  render() {
    return this.renderVN();
  }
});
/* harmony default export */ var form_config_item = (VxeFormConfigItem);
;// CONCATENATED MODULE: ./packages/form/render/index.ts





const componentDefaultModelProp = 'modelValue';
/**
 * 已废弃
 * @deprecated
 */
function getOldComponentName(name) {
  return `vxe-${name.replace('$', '')}`;
}
function getDefaultComponent({
  name
}) {
  return getComponent(name) || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)(name);
}
/**
 * 已废弃
 * @deprecated
 */
function getOldComponent({
  name
}) {
  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)(getOldComponentName(name));
}
function getNativeAttrs(renderOpts) {
  let {
    name,
    attrs
  } = renderOpts;
  if (name === 'input') {
    attrs = Object.assign({
      type: 'text'
    }, attrs);
  }
  return attrs;
}
function getComponentFormItemProps(renderOpts, params, value, defaultProps) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign({}, defaultProps, renderOpts.props, {
    [componentDefaultModelProp]: value
  });
}
/**
 * 原生事件处理
 * @param renderOpts
 * @param params
 * @param modelFunc
 * @param changeFunc
 */
function getNativeElementOns(renderOpts, params, modelFunc, changeFunc) {
  const {
    events
  } = renderOpts;
  const modelEvent = getModelEvent(renderOpts.name);
  const changeEvent = getChangeEvent(renderOpts.name);
  const isSameEvent = changeEvent === modelEvent;
  const ons = {};
  if (events) {
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(events, (func, key) => {
      ons[getOnName(key)] = function (...args) {
        func(params, ...args);
      };
    });
  }
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function (targetEvnt) {
      modelFunc(targetEvnt);
      if (isSameEvent && changeFunc) {
        changeFunc(targetEvnt);
      }
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (!isSameEvent && changeFunc) {
    ons[getOnName(changeEvent)] = function (...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
/**
 * 组件事件处理
 * @param renderOpts
 * @param params
 * @param modelFunc
 * @param changeFunc
 */
function getComponentOns(renderOpts, params, eFns, eventOns) {
  const {
    events
  } = renderOpts;
  const {
    model: modelFunc,
    change: changeFunc
  } = eFns || {};
  const modelEvent = getModelEvent(renderOpts.name);
  const changeEvent = getChangeEvent(renderOpts.name);
  const ons = {};
  external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().objectEach(events, (func, key) => {
    ons[getOnName(key)] = function (...args) {
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(func)) {
        errLog('vxe.error.errFunc', [func]);
      }
      func(params, ...args);
    };
  });
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function (targetEvnt) {
      modelFunc(targetEvnt);
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (changeFunc) {
    ons[getOnName(changeEvent)] = function (...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return eventOns ? Object.assign(ons, eventOns) : ons;
}
function getItemOns(renderOpts, params) {
  const {
    $form,
    data,
    field
  } = params;
  return getComponentOns(renderOpts, params, {
    model(value) {
      // 处理 model 值双向绑定
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(data, field, value);
    },
    change(params) {
      // 处理 change 事件相关逻辑
      $form.updateStatus(params);
    }
  });
}
function getNativeItemOns(renderOpts, params) {
  const {
    $form,
    data,
    field
  } = params;
  return getNativeElementOns(renderOpts, params, evnt => {
    // 处理 model 值双向绑定
    const itemValue = evnt.target.value;
    external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(data, field, itemValue);
  }, () => {
    // 处理 change 事件相关逻辑
    $form.updateStatus(params);
  });
}
function renderNativeOptgroup(renderOpts, params, renderOptionsMethods) {
  const {
    optionGroups,
    optionGroupProps = {}
  } = renderOpts;
  const groupOptions = optionGroupProps.options || 'options';
  const groupLabel = optionGroupProps.label || 'label';
  if (optionGroups) {
    return optionGroups.map((group, gIndex) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('optgroup', {
        key: gIndex,
        label: group[groupLabel]
      }, renderOptionsMethods(group[groupOptions], renderOpts, params));
    });
  }
  return [];
}
/**
 * 渲染表单-项
 * 用于渲染原生的标签
 */
function nativeItemRender(renderOpts, params) {
  const {
    data,
    field
  } = params;
  const {
    name
  } = renderOpts;
  const attrs = getNativeAttrs(renderOpts);
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(name, {
    class: `vxe-default-${name}`,
    ...attrs,
    value: attrs && name === 'input' && (attrs.type === 'submit' || attrs.type === 'reset') ? null : itemValue,
    ...getNativeItemOns(renderOpts, params)
  })];
}
function defaultItemRender(renderOpts, params) {
  const {
    data,
    field
  } = params;
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    ...getComponentFormItemProps(renderOpts, params, itemValue),
    ...getItemOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldItemRender(renderOpts, params) {
  const {
    data,
    field
  } = params;
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getOldComponent(renderOpts), {
    ...getComponentFormItemProps(renderOpts, params, itemValue),
    ...getItemOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldButtonItemRender(renderOpts, params) {
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('vxe-button'), {
    ...getComponentFormItemProps(renderOpts, params, null),
    ...getComponentOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldButtonsItemRender(renderOpts, params) {
  return renderOpts.children.map(childRenderOpts => oldButtonItemRender(childRenderOpts, params)[0]);
}
/**
 * 渲染原生的 select 标签
 */
function renderNativeFormOptions(options, renderOpts, params) {
  const {
    data,
    field
  } = params;
  const {
    optionProps = {}
  } = renderOpts;
  const labelProp = optionProps.label || 'label';
  const valueProp = optionProps.value || 'value';
  const disabledProp = optionProps.disabled || 'disabled';
  const cellValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  if (options) {
    return options.map((item, oIndex) => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('option', {
        key: oIndex,
        value: item[valueProp],
        disabled: item[disabledProp],
        /* eslint-disable eqeqeq */
        selected: item[valueProp] == cellValue
      }, item[labelProp]);
    });
  }
  return [];
}
/**
 * 渲染表单-项
 */
function defaultFormItemRender(renderOpts, params) {
  const {
    data,
    field
  } = params;
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    ...getComponentFormItemProps(renderOpts, params, itemValue),
    ...getItemOns(renderOpts, params)
  })];
}
function formItemRadioAndCheckboxRender(renderOpts, params) {
  const {
    options,
    optionProps
  } = renderOpts;
  const {
    data,
    field
  } = params;
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
    options,
    optionProps,
    ...getComponentFormItemProps(renderOpts, params, itemValue),
    ...getItemOns(renderOpts, params)
  })];
}
/**
 * 已废弃
 * @deprecated
 */
function oldFormItemRadioAndCheckboxRender(renderOpts, params) {
  const {
    name,
    options,
    optionProps = {}
  } = renderOpts;
  const {
    data,
    field
  } = params;
  const labelProp = optionProps.label || 'label';
  const valueProp = optionProps.value || 'value';
  const disabledProp = optionProps.disabled || 'disabled';
  const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
  const compName = getOldComponentName(name);
  // 如果是分组
  if (options) {
    return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)(`${compName}-group`), {
      ...getComponentFormItemProps(renderOpts, params, itemValue),
      ...getItemOns(renderOpts, params)
    }, {
      default: () => {
        return options.map((item, index) => {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)(compName), {
            key: index,
            label: item[valueProp],
            content: item[labelProp],
            disabled: item[disabledProp]
          });
        });
      }
    })];
  }
  return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)(compName), {
    ...getComponentFormItemProps(renderOpts, params, itemValue),
    ...getItemOns(renderOpts, params)
  })];
}
/**
 * 表单 - 渲染器
 */
renderer.mixin({
  input: {
    formItemAutoFocus: 'input',
    renderFormItemContent: nativeItemRender
  },
  textarea: {
    formItemAutoFocus: 'textarea',
    renderFormItemContent: nativeItemRender
  },
  select: {
    formItemAutoFocus: 'input',
    renderFormItemContent(renderOpts, params) {
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('select', {
        class: 'vxe-default-select',
        ...getNativeAttrs(renderOpts),
        ...getNativeItemOns(renderOpts, params)
      }, renderOpts.optionGroups ? renderNativeOptgroup(renderOpts, params, renderNativeFormOptions) : renderNativeFormOptions(renderOpts.options, renderOpts, params))];
    }
  },
  VxeInput: {
    formItemAutoFocus: 'input',
    renderFormItemContent: defaultItemRender
  },
  VxeNumberInput: {
    formItemAutoFocus: 'input',
    renderFormItemContent: defaultItemRender
  },
  VxePasswordInput: {
    formItemAutoFocus: 'input',
    renderFormItemContent: defaultItemRender
  },
  VxeTextarea: {
    formItemAutoFocus: 'textarea',
    renderFormItemContent: defaultItemRender
  },
  VxeDatePicker: {
    formItemAutoFocus: 'input',
    renderFormItemContent: defaultItemRender
  },
  VxeDateRangePicker: {
    formItemAutoFocus: 'input',
    renderFormItemContent(renderOpts, params) {
      const {
        startField,
        endField
      } = renderOpts;
      const {
        $form,
        data,
        field
      } = params;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      const seProps = {};
      const seOs = {};
      if (startField && endField) {
        seProps.startValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, startField);
        seProps.endValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, endField);
        seOs['onUpdate:startValue'] = value => {
          if (startField) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(data, startField, value);
          }
        };
        seOs['onUpdate:endValue'] = value => {
          if (endField) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(data, endField, value);
          }
        };
      }
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...getComponentFormItemProps(renderOpts, params, itemValue, seProps),
        ...getComponentOns(renderOpts, params, {
          model(value) {
            // 处理 model 值双向绑定
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(data, field, value);
          },
          change() {
            // 处理 change 事件相关逻辑
            $form.updateStatus(params);
          }
        }, seOs)
      })];
    }
  },
  VxeButton: {
    renderFormItemContent: defaultFormItemRender
  },
  VxeButtonGroup: {
    renderFormItemContent(renderOpts, params) {
      const {
        options
      } = renderOpts;
      const {
        data,
        field
      } = params;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        options,
        ...getComponentFormItemProps(renderOpts, params, itemValue),
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  VxeSelect: {
    formItemAutoFocus: 'input',
    renderFormItemContent(renderOpts, params) {
      const {
        data,
        field
      } = params;
      const {
        options,
        optionProps,
        optionGroups,
        optionGroupProps
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...getComponentFormItemProps(renderOpts, params, itemValue, {
          options,
          optionProps,
          optionGroups,
          optionGroupProps
        }),
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  VxeTreeSelect: {
    formItemAutoFocus: 'input',
    renderFormItemContent(renderOpts, params) {
      const {
        data,
        field
      } = params;
      const {
        options,
        optionProps
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...getComponentFormItemProps(renderOpts, params, itemValue, {
          options,
          optionProps
        }),
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  VxeTableSelect: {
    formItemAutoFocus: 'input',
    renderFormItemContent(renderOpts, params) {
      const {
        data,
        field
      } = params;
      const {
        options,
        optionProps
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...getComponentFormItemProps(renderOpts, params, itemValue, {
          options,
          optionProps
        }),
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  VxeColorPicker: {
    formItemAutoFocus: 'input',
    renderFormItemContent(renderOpts, params) {
      const {
        data,
        field
      } = params;
      const {
        options
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...getComponentFormItemProps(renderOpts, params, itemValue, {
          colors: options
        }),
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  VxeIconPicker: {
    formItemAutoFocus: 'input',
    renderFormItemContent(renderOpts, params) {
      const {
        data,
        field
      } = params;
      const {
        options
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...getComponentFormItemProps(renderOpts, params, itemValue, {
          icons: options
        }),
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  VxeRadio: {
    renderFormItemContent: defaultFormItemRender
  },
  VxeRadioGroup: {
    renderFormItemContent: formItemRadioAndCheckboxRender
  },
  VxeCheckbox: {
    renderFormItemContent: defaultFormItemRender
  },
  VxeCheckboxGroup: {
    renderFormItemContent: formItemRadioAndCheckboxRender
  },
  VxeSwitch: {
    renderFormItemContent: defaultItemRender
  },
  VxeRate: {
    renderFormItemContent: defaultItemRender
  },
  VxeSlider: {
    renderFormItemContent: defaultItemRender
  },
  VxeImage: {
    renderFormItemContent(renderOpts, params) {
      const {
        data,
        field
      } = params;
      const {
        props
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...props,
        src: itemValue,
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  VxeImageGroup: {
    renderFormItemContent(renderOpts, params) {
      const {
        data,
        field
      } = params;
      const {
        props
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getDefaultComponent(renderOpts), {
        ...props,
        urlList: itemValue,
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  VxeUpload: {
    renderFormItemContent: defaultItemRender
  },
  // 以下已废弃
  $input: {
    formItemAutoFocus: 'input',
    renderFormItemContent: oldItemRender
  },
  $textarea: {
    formItemAutoFocus: 'textarea',
    renderFormItemContent: oldItemRender
  },
  $button: {
    renderFormItemContent: oldButtonItemRender
  },
  $buttons: {
    renderFormItemContent: oldButtonsItemRender
  },
  $select: {
    formItemAutoFocus: 'input',
    renderFormItemContent(renderOpts, params) {
      const {
        data,
        field
      } = params;
      const {
        options,
        optionProps,
        optionGroups,
        optionGroupProps
      } = renderOpts;
      const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(getOldComponent(renderOpts), {
        ...getComponentFormItemProps(renderOpts, params, itemValue, {
          options,
          optionProps,
          optionGroups,
          optionGroupProps
        }),
        ...getItemOns(renderOpts, params)
      })];
    }
  },
  $radio: {
    renderFormItemContent: oldFormItemRadioAndCheckboxRender
  },
  $checkbox: {
    renderFormItemContent: oldFormItemRadioAndCheckboxRender
  },
  $switch: {
    renderFormItemContent: oldItemRender
  }
  // 以上已废弃
});
;// CONCATENATED MODULE: ./packages/form/src/form.ts














class Rule {
  constructor(rule) {
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.min,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }
  get content() {
    return getFuncText(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
}
// 如果存在 pattern，判断正则
function validREValue(pattern, val) {
  if (pattern && !(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
    return false;
  }
  return true;
}
// 如果存在 max，判断最大值
function validMaxValue(max, num) {
  if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(max) && num > external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max)) {
    return false;
  }
  return true;
}
// 如果存在 min，判断最小值
function validMinValue(min, num) {
  if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(min) && num < external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(min)) {
    return false;
  }
  return true;
}
function validRuleValue(rule, val, required) {
  const {
    type,
    min,
    max,
    pattern
  } = rule;
  const isArrType = type === 'array';
  const isNumType = type === 'number';
  const isStrType = type === 'string';
  const strVal = `${val}`;
  if (!validREValue(pattern, strVal)) {
    return false;
  }
  if (isArrType) {
    if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(val)) {
      return false;
    }
    if (required) {
      if (!val.length) {
        return false;
      }
    }
    if (!validMinValue(min, val.length)) {
      return false;
    }
    if (!validMaxValue(max, val.length)) {
      return false;
    }
  } else if (isNumType) {
    const numVal = Number(val);
    if (isNaN(numVal)) {
      return false;
    }
    if (!validMinValue(min, numVal)) {
      return false;
    }
    if (!validMaxValue(max, numVal)) {
      return false;
    }
  } else {
    if (isStrType) {
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(val)) {
        return false;
      }
    }
    if (required) {
      if (!strVal) {
        return false;
      }
    }
    if (!validMinValue(min, strVal.length)) {
      return false;
    }
    if (!validMaxValue(max, strVal.length)) {
      return false;
    }
  }
  return true;
}
function checkRuleStatus(rule, val) {
  const {
    required
  } = rule;
  const isEmptyVal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(val) ? !val.length : eqEmptyValue(val);
  if (required) {
    if (isEmptyVal) {
      return false;
    }
    if (!validRuleValue(rule, val, required)) {
      return false;
    }
  } else {
    if (!isEmptyVal) {
      if (!validRuleValue(rule, val, required)) {
        return false;
      }
    }
  }
  return true;
}
function createInternalData() {
  return {
    meTimeout: undefined,
    stTimeout: undefined,
    tooltipStore: {
      item: null,
      visible: false
    },
    itemFormatCache: {}
  };
}
/* harmony default export */ var src_form = (defineVxeComponent({
  name: 'VxeForm',
  props: {
    collapseStatus: {
      type: Boolean,
      default: true
    },
    loading: Boolean,
    data: Object,
    size: {
      type: String,
      default: () => getConfig().form.size || getConfig().size
    },
    span: {
      type: [String, Number],
      default: () => getConfig().form.span
    },
    align: {
      type: String,
      default: () => getConfig().form.align
    },
    verticalAlign: {
      type: String,
      default: () => getConfig().form.verticalAlign
    },
    border: {
      type: Boolean,
      default: () => getConfig().form.border
    },
    titleBackground: {
      type: Boolean,
      default: () => getConfig().form.titleBackground
    },
    titleBold: {
      type: Boolean,
      default: () => getConfig().form.titleBold
    },
    titleAlign: {
      type: String,
      default: () => getConfig().form.titleAlign
    },
    titleWidth: {
      type: [String, Number],
      default: () => getConfig().form.titleWidth
    },
    titleColon: {
      type: Boolean,
      default: () => getConfig().form.titleColon
    },
    titleAsterisk: {
      type: Boolean,
      default: () => getConfig().form.titleAsterisk
    },
    titleOverflow: {
      type: [Boolean, String],
      default: () => getConfig().form.titleOverflow
    },
    vertical: {
      type: Boolean,
      default: () => getConfig().form.vertical
    },
    padding: {
      type: Boolean,
      default: () => getConfig().form.padding
    },
    className: [String, Function],
    readonly: Boolean,
    disabled: Boolean,
    items: Array,
    rules: Object,
    preventSubmit: {
      type: Boolean,
      default: () => getConfig().form.preventSubmit
    },
    validConfig: Object,
    tooltipConfig: Object,
    collapseConfig: Object,
    customLayout: {
      type: Boolean,
      default: () => getConfig().form.customLayout
    },
    params: Object
  },
  emits: ['update:collapseStatus', 'collapse', 'toggle-collapse', 'submit', 'submit-invalid', 'reset'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeGrid = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeGrid', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      collapseAll: props.collapseStatus,
      staticItems: [],
      formItems: [],
      itemWidth: 0
    });
    const internalData = createInternalData();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTooltip = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    let formMethods = {};
    const computeValidOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().form.validConfig, props.validConfig);
    });
    const computeTooltipOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().tooltip, getConfig().form.tooltipConfig, props.tooltipConfig);
    });
    const computeCollapseOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().form.collapseConfig, props.collapseConfig);
    });
    const computeAutoItemWidthList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        titleWidth: allTitleWidth,
        vertical: allVertical
      } = props;
      const {
        formItems
      } = reactData;
      const itemList = [];
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(formItems, item => {
        const {
          titleWidth,
          vertical
        } = item;
        if (titleWidth === 'auto') {
          itemList.push(item);
        } else {
          const itemVertical = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(vertical) ? allVertical : vertical;
          const itemTitleWidth = itemVertical ? null : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(titleWidth) ? allTitleWidth : titleWidth;
          if (itemTitleWidth === 'auto' && (!item.children || !item.children.length)) {
            itemList.push(item);
          }
        }
      }, {
        children: 'children'
      });
      return itemList;
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize,
      computeValidOpts,
      computeTooltipOpts,
      computeCollapseOpts,
      computeAutoItemWidthList
    };
    const $xeForm = {
      xID,
      props,
      context,
      reactData,
      internalData,
      xeGrid: $xeGrid,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
          return vn_getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const loadItem = list => {
      if (list.length) {
        list.forEach(item => {
          if (item.slots) {
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(item.slots, func => {
              if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(func)) {
                if (!slots[func]) {
                  errLog('vxe.error.notSlot', [func]);
                }
              }
            });
          }
        });
      }
      reactData.staticItems = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().mapTree(list, item => createItem($xeForm, item), {
        children: 'children'
      });
      internalData.itemFormatCache = {};
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        return recalculate();
      });
    };
    const getItems = () => {
      const itemList = [];
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(reactData.formItems, item => {
        itemList.push(item);
      }, {
        children: 'children'
      });
      return itemList;
    };
    const getItemByField = field => {
      const rest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(reactData.formItems, item => item.field === field, {
        children: 'children'
      });
      return rest ? rest.item : null;
    };
    const getCollapseStatus = () => {
      return reactData.collapseAll;
    };
    const toggleCollapse = () => {
      const status = !getCollapseStatus();
      reactData.collapseAll = status;
      emit('update:collapseStatus', status);
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const toggleCollapseEvent = evnt => {
      toggleCollapse();
      const status = getCollapseStatus();
      formMethods.dispatchEvent('toggle-collapse', {
        status,
        collapse: status,
        data: props.data
      }, evnt);
      formMethods.dispatchEvent('collapse', {
        status,
        collapse: status,
        data: props.data
      }, evnt);
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        recalculate();
        if ($xeGrid) {
          $xeGrid.recalculate();
        }
      });
    };
    const clearValidate = fieldOrItem => {
      if (fieldOrItem) {
        let fields = fieldOrItem;
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrItem)) {
          fields = [fieldOrItem];
        }
        fields.forEach(field => {
          if (field) {
            const item = handleFieldOrItem($xeForm, field);
            if (item) {
              item.showError = false;
            }
          }
        });
      } else {
        getItems().forEach(item => {
          item.showError = false;
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const getResetValue = (item, data, itemValue) => {
      const {
        field,
        resetValue
      } = item;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(resetValue)) {
        return resetValue({
          field,
          item,
          data,
          $form: $xeForm,
          $grid: $xeGrid
        });
      } else if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(resetValue)) {
        // 默认
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(itemValue)) {
          return [];
        }
      }
      return resetValue;
    };
    const reset = () => {
      const {
        data
      } = props;
      const itemList = getItems();
      if (data) {
        itemList.forEach(item => {
          const {
            field,
            itemRender
          } = item;
          if (isEnableConf(itemRender)) {
            const {
              name,
              startField,
              endField
            } = itemRender;
            const compConf = renderer.get(name);
            const fiResetMethod = compConf ? compConf.formItemResetMethod || compConf.itemResetMethod : null;
            if (compConf && fiResetMethod) {
              fiResetMethod({
                data,
                field,
                property: field,
                item,
                $form: $xeForm,
                $grid: $xeGrid
              });
            } else if (field) {
              const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, field);
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(data, field, getResetValue(item, data, itemValue));
            }
            if (startField && endField) {
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(data, startField, getResetValue(item, data, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, startField)));
              external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(data, endField, getResetValue(item, data, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, endField)));
            }
          }
        });
      }
      internalData.itemFormatCache = {};
      clearValidate();
      return recalculate();
    };
    const resetEvent = evnt => {
      evnt.preventDefault();
      reset();
      formMethods.dispatchEvent('reset', {
        data: props.data
      }, evnt);
    };
    const handleFocus = fields => {
      const el = refElem.value;
      if (el) {
        for (let i = 0; i < fields.length; i++) {
          const field = fields[i];
          const item = getItemByField(field);
          if (item && isEnableConf(item.itemRender)) {
            const {
              itemRender
            } = item;
            const compConf = renderer.get(itemRender.name);
            // 定位到第一个
            if (!i) {
              scrollToView(el.querySelector(`.${item.id}`));
            }
            let inputElem = null;
            const autoFocus = itemRender.autoFocus || itemRender.autofocus || (compConf ? compConf.formItemAutoFocus : null);
            // 如果指定了聚焦 class
            if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(autoFocus)) {
              inputElem = autoFocus({
                $form: $xeForm,
                $grid: $xeGrid,
                item,
                data: props.data,
                field
              });
            } else {
              if (autoFocus === true) {
                // 自动匹配模式，会自动匹配第一个可输入元素
                inputElem = el.querySelector(`.${item.id} input,textarea`);
              } else if (autoFocus) {
                inputElem = el.querySelector(`.${item.id} ${autoFocus}`);
              }
            }
            if (inputElem) {
              inputElem.focus();
              break;
            }
          }
        }
      }
    };
    /**
     * 校验数据
     * 按表格行、列顺序依次校验（同步或异步）
     * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列
     * 如果校验失败则，触发回调或者 Promise<(ErrMap 校验不通过列的信息)>
     * 如果是传回调方式这返回一个 (ErrMap 校验不通过列的信息)
     *
     * rule 配置：
     *  required=Boolean 是否必填
     *  min=Number 最小长度
     *  max=Number 最大长度
     *  validator=Function({ itemValue, rule, rules, data, property }) 自定义校验，接收一个 Promise
     *  trigger=change 触发方式
     */
    const validItemRules = (validType, fields, val) => {
      const {
        data,
        rules: formRules
      } = props;
      const errorMaps = {};
      if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fields)) {
        fields = [fields];
      }
      return Promise.all(fields.map(property => {
        const errorRules = [];
        const syncVailds = [];
        if (property && formRules) {
          const rules = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(formRules, property);
          if (rules) {
            const itemValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isUndefined(val) ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(data, property) : val;
            rules.forEach(rule => {
              const {
                trigger,
                validator
              } = rule;
              if (validType === 'all' || !trigger || validType === trigger) {
                if (validator) {
                  const validParams = {
                    itemValue,
                    rule,
                    rules,
                    data,
                    field: property,
                    property,
                    $form: $xeForm
                  };
                  let customValid;
                  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(validator)) {
                    const gvItem = validators.get(validator);
                    if (gvItem) {
                      const validatorMethod = gvItem.formItemValidatorMethod || gvItem.itemValidatorMethod;
                      if (validatorMethod) {
                        customValid = validatorMethod(validParams);
                      } else {
                        warnLog('vxe.error.notValidators', [validator]);
                      }
                    } else {
                      errLog('vxe.error.notValidators', [validator]);
                    }
                  } else {
                    customValid = validator(validParams);
                  }
                  if (customValid) {
                    if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isError(customValid)) {
                      errorRules.push(new Rule({
                        type: 'custom',
                        trigger,
                        content: customValid.message,
                        rule: new Rule(rule)
                      }));
                    } else if (customValid.catch) {
                      // 如果为异步校验（注：异步校验是并发无序的）
                      syncVailds.push(customValid.catch(e => {
                        errorRules.push(new Rule({
                          type: 'custom',
                          trigger,
                          content: e ? e.message : rule.content || rule.message,
                          rule: new Rule(rule)
                        }));
                      }));
                    }
                  }
                } else {
                  if (!checkRuleStatus(rule, itemValue)) {
                    errorRules.push(new Rule(rule));
                  }
                }
              }
            });
          }
        }
        return Promise.all(syncVailds).then(() => {
          if (errorRules.length) {
            errorMaps[property] = errorRules.map(rule => {
              return {
                $form: $xeForm,
                rule,
                data,
                field: property,
                property
              };
            });
          }
        });
      })).then(() => {
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isEmpty(errorMaps)) {
          return Promise.reject(errorMaps);
        }
      });
    };
    const beginValidate = (itemList, type, callback) => {
      const {
        data,
        rules: formRules
      } = props;
      const validOpts = computeValidOpts.value;
      const validRest = {};
      const validFields = [];
      const itemValids = [];
      clearTimeout(internalData.meTimeout);
      if (data && formRules) {
        itemList.forEach(item => {
          const {
            field
          } = item;
          if (field && !isHiddenItem($xeForm, item) && isActiveItem($xeForm, item)) {
            itemValids.push(validItemRules(type || 'all', field).then(() => {
              item.errRule = null;
            }).catch(errorMaps => {
              const rest = errorMaps[field];
              if (!validRest[field]) {
                validRest[field] = [];
              }
              validRest[field].push(rest);
              validFields.push(field);
              item.errRule = rest[0].rule;
              return Promise.reject(rest);
            }));
          }
        });
        return Promise.all(itemValids).then(() => {
          if (callback) {
            callback();
          }
        }).catch(() => {
          return new Promise(resolve => {
            internalData.meTimeout = setTimeout(() => {
              itemList.forEach(item => {
                if (item.errRule) {
                  item.showError = true;
                }
              });
            }, 20);
            if (validOpts.autoPos !== false) {
              (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
                handleFocus(validFields);
              });
            }
            if (callback) {
              callback(validRest);
              resolve();
            } else {
              resolve(validRest);
            }
          });
        });
      }
      if (callback) {
        callback();
      }
      return Promise.resolve();
    };
    const validate = callback => {
      const {
        readonly
      } = props;
      clearValidate();
      if (readonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
      return beginValidate(getItems(), '', callback).then(params => {
        recalculate();
        return params;
      });
    };
    const validateField = (fieldOrItem, callback) => {
      const {
        readonly
      } = props;
      if (readonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
      let fields = [];
      if (fieldOrItem) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(fieldOrItem)) {
          fields = fieldOrItem;
        } else {
          fields = [fieldOrItem];
        }
      }
      return beginValidate(fields.map(field => handleFieldOrItem($xeForm, field)), '', callback).then(params => {
        recalculate();
        return params;
      });
    };
    const submitEvent = evnt => {
      const {
        readonly
      } = props;
      evnt.preventDefault();
      if (!props.preventSubmit) {
        clearValidate();
        if (readonly) {
          formMethods.dispatchEvent('submit', {
            data: props.data
          }, evnt);
          recalculate();
          return;
        }
        beginValidate(getItems()).then(errMap => {
          if (errMap) {
            formMethods.dispatchEvent('submit-invalid', {
              data: props.data,
              errMap
            }, evnt);
          } else {
            formMethods.dispatchEvent('submit', {
              data: props.data
            }, evnt);
          }
          recalculate();
        });
      }
    };
    const closeTooltip = () => {
      const {
        tooltipStore
      } = internalData;
      const $tooltip = refTooltip.value;
      if (tooltipStore.visible) {
        Object.assign(tooltipStore, {
          item: null,
          visible: false
        });
        if ($tooltip) {
          $tooltip.close();
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const triggerTitleTipEvent = (evnt, params) => {
      const {
        item
      } = params;
      const {
        tooltipStore
      } = internalData;
      const $tooltip = refTooltip.value;
      const overflowElem = evnt.currentTarget.children[0];
      const content = (overflowElem.textContent || '').trim();
      const isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;
      clearTimeout(internalData.stTimeout);
      if (tooltipStore.item !== item) {
        closeTooltip();
      }
      if (content && isCellOverflow) {
        Object.assign(tooltipStore, {
          item,
          visible: true
        });
        if ($tooltip) {
          $tooltip.open(overflowElem, content);
        }
      }
    };
    const handleTitleTipLeaveEvent = () => {
      const tooltipOpts = computeTooltipOpts.value;
      let $tooltip = refTooltip.value;
      if ($tooltip) {
        $tooltip.setActived(false);
      }
      if (tooltipOpts.enterable) {
        internalData.stTimeout = setTimeout(() => {
          $tooltip = refTooltip.value;
          if ($tooltip && !$tooltip.isActived()) {
            closeTooltip();
          }
        }, tooltipOpts.leaveDelay);
      } else {
        closeTooltip();
      }
    };
    const triggerItemEvent = (evnt, field, itemValue) => {
      if (field) {
        return validItemRules(evnt ? ['blur'].includes(evnt.type) ? 'blur' : 'change' : 'all', field, itemValue).then(() => {
          clearValidate(field);
        }).catch(errorMaps => {
          const rest = errorMaps[field];
          const item = getItemByField(field);
          if (rest && item) {
            item.showError = true;
            item.errRule = rest[0].rule;
          }
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    /**
     * 更新项状态
     * 如果组件值 v-model 发生 change 时，调用改函数用于更新某一项编辑状态
     * 如果单元格配置了校验规则，则会进行校验
     */
    const updateStatus = (scope, itemValue) => {
      const {
        field
      } = scope;
      return triggerItemEvent(new Event('change'), field, itemValue);
    };
    const recalculate = () => {
      const autoItemWidthList = computeAutoItemWidthList.value;
      const el = refElem.value;
      if (el && autoItemWidthList.length) {
        const itemElList = el.querySelectorAll(autoItemWidthList.map(item => `.vxe-form--item-title[itemid="${item.id}"]`).join(','));
        let maxItemWidth = 0;
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(itemElList, itemEl => {
          itemEl.style.width = '';
          maxItemWidth = Math.max(maxItemWidth, Math.ceil(itemEl.clientWidth + 2));
        });
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(itemElList, itemEl => {
          itemEl.style.width = `${maxItemWidth}px`;
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const handleGlobalResizeEvent = () => {
      recalculate();
    };
    formMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $form: $xeForm,
          $grid: $xeGrid
        }, params));
      },
      reset,
      validate,
      validateField,
      clearValidate,
      updateStatus,
      toggleCollapse,
      getItems,
      getItemByField,
      closeTooltip,
      recalculate
    };
    const formPrivateMethods = {
      callSlot,
      triggerItemEvent,
      toggleCollapseEvent,
      triggerTitleTipEvent,
      handleTitleTipLeaveEvent
    };
    Object.assign($xeForm, formMethods, formPrivateMethods);
    const renderVN = () => {
      const {
        loading,
        border,
        className,
        data,
        customLayout
      } = props;
      const {
        formItems
      } = reactData;
      const vSize = computeSize.value;
      const tooltipOpts = computeTooltipOpts.value;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('form', {
        ref: refElem,
        class: ['vxe-form', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          items: formItems,
          data,
          $form: $xeForm
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--border': border,
          'custom--layout': customLayout,
          'is--loading': loading
        }],
        onSubmit: submitEvent,
        onReset: resetEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form--wrapper vxe-form--item-row'
      }, customLayout ? defaultSlot ? defaultSlot({}) : [] : formItems.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(form_config_item, {
          key: index,
          itemConfig: item
        });
      })), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-form-slots',
        ref: 'hideItem'
      }, customLayout ? [] : defaultSlot ? defaultSlot({}) : []),
      /**
       * 加载中
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-form--loading',
        modelValue: loading
      }),
      /**
       * 工具提示
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tooltip, {
        ref: refTooltip,
        ...tooltipOpts
      })]);
    };
    const staticItemFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticItems.length, () => {
      staticItemFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticItems, () => {
      staticItemFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(staticItemFlag, () => {
      reactData.formItems = reactData.staticItems;
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        recalculate();
      });
    });
    const itemFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.items ? props.items.length : -1, () => {
      itemFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.items, () => {
      itemFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(itemFlag, () => {
      loadItem(props.items || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.collapseStatus, value => {
      reactData.collapseAll = !!value;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.readonly, () => {
      clearValidate();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.disabled, () => {
      clearValidate();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        if (props.customLayout && props.items) {
          errLog('vxe.error.errConflicts', ['custom-layout', 'items']);
        }
      });
      globalEvents.on($xeForm, 'resize', handleGlobalResizeEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeForm, 'resize');
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign(internalData, createInternalData());
    });
    if (props.items) {
      loadItem(props.items);
    }
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('xeFormItemInfo', null);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeForm', $xeForm);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormGroup', null);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormItem', null);
    $xeForm.renderVN = renderVN;
    return $xeForm;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form/index.ts



const VxeForm = Object.assign(src_form, {
  install(app) {
    app.component(src_form.name, src_form);
  }
});
dynamicApp.use(VxeForm);
index_esm_VxeUI.component(src_form);
const Form = VxeForm;
/* harmony default export */ var packages_form = (VxeForm);
;// CONCATENATED MODULE: ./packages/form/src/form-item.ts







const formItemProps = {
  title: String,
  field: String,
  span: {
    type: [String, Number],
    default: null
  },
  align: {
    type: String,
    default: null
  },
  verticalAlign: {
    type: String,
    default: null
  },
  titleBackground: {
    type: Boolean,
    default: null
  },
  titleBold: {
    type: Boolean,
    default: null
  },
  titleAlign: {
    type: String,
    default: null
  },
  titleWidth: {
    type: [String, Number],
    default: null
  },
  titleColon: {
    type: Boolean,
    default: null
  },
  titleAsterisk: {
    type: Boolean,
    default: null
  },
  showTitle: {
    type: Boolean,
    default: true
  },
  vertical: {
    type: Boolean,
    default: null
  },
  padding: {
    type: Boolean,
    default: null
  },
  formatter: [String, Function],
  className: [String, Function],
  contentClassName: [String, Function],
  contentStyle: [Object, Function],
  titleClassName: [String, Function],
  titleStyle: [Object, Function],
  titleOverflow: {
    type: [Boolean, String],
    default: null
  },
  titlePrefix: Object,
  titleSuffix: Object,
  resetValue: {
    default: null
  },
  visibleMethod: Function,
  visible: {
    type: Boolean,
    default: null
  },
  showContent: {
    type: Boolean,
    default: null
  },
  folding: Boolean,
  collapseNode: Boolean,
  itemRender: Object,
  rules: Array,
  params: Object
};
/* harmony default export */ var form_item = (defineVxeComponent({
  name: 'VxeFormItem',
  props: formItemProps,
  setup(props, {
    slots
  }) {
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', {});
    const $xeFormGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormGroup', null);
    const formItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(createItem($xeForm, props));
    formItem.slots = slots;
    const formItemInfo = {
      itemConfig: formItem
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('xeFormItemInfo', formItemInfo);
    const renderItem = ($xeForm, item) => {
      const formProps = $xeForm.props;
      const $xeGrid = $xeForm.xeGrid;
      const {
        data,
        readonly,
        disabled
      } = formProps;
      const {
        visible,
        field,
        itemRender,
        contentStyle,
        showContent
      } = item;
      const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
      const itemStyle = compConf ? compConf.formItemStyle || compConf.itemStyle : null;
      const itemContentStyle = compConf ? compConf.formItemContentStyle || compConf.itemContentStyle : null;
      const params = {
        data,
        disabled,
        readonly,
        field,
        property: field,
        item,
        $form: $xeForm,
        $grid: $xeGrid
      };
      if (visible === false) {
        return renderEmptyElement($xeFormitem);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        key: item.id,
        itemid: item.id,
        class: getItemClass($xeForm, item),
        style: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [renderTitle($xeForm, item), showContent === false ? renderEmptyElement($xeFormitem) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: getItemContentClass($xeForm, item),
        style: Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(contentStyle) ? contentStyle(params) : contentStyle)
      }, [renderItemContent($xeForm, item)])]);
    };
    const renderVN = () => {
      const customLayout = $xeForm ? $xeForm.props.customLayout : false;
      const item = formItem;
      return customLayout ? renderItem($xeForm, item) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      });
    };
    const $xeFormitem = {
      xID,
      formItem,
      renderVN
    };
    watchItem(props, formItem);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const elem = refElem.value;
      assembleItem($xeForm, elem, formItem, $xeFormGroup);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      destroyItem($xeForm, formItem);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormItem', $xeFormitem);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormGroup', null);
    return $xeFormitem;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form/src/form-group.ts








/* harmony default export */ var form_group = (defineVxeComponent({
  name: 'VxeFormGroup',
  props: formItemProps,
  setup(props, context) {
    const {
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', {});
    const $xeParentFormGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeFormGroup', null);
    const formItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(createItem($xeForm, props));
    formItem.slots = slots;
    formItem.children = [];
    const formItemInfo = {
      itemConfig: formItem
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('xeFormItemInfo', formItemInfo);
    const renderVN = () => {
      const formProps = $xeForm.props;
      const $xeGrid = $xeForm.xeGrid;
      const item = formItem;
      const {
        data,
        readonly,
        disabled
      } = formProps;
      const {
        visible,
        field,
        itemRender,
        contentStyle
      } = item;
      const compConf = isEnableConf(itemRender) ? renderer.get(itemRender.name) : null;
      const itemStyle = compConf ? compConf.formItemStyle || compConf.itemStyle : null;
      const itemContentStyle = compConf ? compConf.formItemContentStyle || compConf.itemContentStyle : null;
      const defaultSlot = slots ? slots.default : null;
      const params = {
        data,
        disabled,
        readonly,
        field,
        property: field,
        item,
        $form: $xeForm,
        $grid: $xeGrid
      };
      if (visible === false) {
        return renderEmptyElement($xeFormGroup);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        key: item.id,
        itemid: item.id,
        class: getItemClass($xeForm, item, true),
        style: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [renderTitle($xeForm, item, true), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: getItemContentClass($xeForm, item, true),
        style: Object.assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(contentStyle) ? contentStyle(params) : contentStyle)
      }, defaultSlot ? defaultSlot({}) : [])]);
    };
    const $xeFormGroup = {
      xID,
      formItem,
      renderVN
    };
    watchItem(props, formItem);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const elem = refElem.value;
      assembleItem($xeForm, elem, formItem, $xeParentFormGroup);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      destroyItem($xeForm, formItem);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormGroup', $xeFormGroup);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeFormItem', null);
    return $xeFormGroup;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/form-gather/index.ts



const VxeFormGatherComponent = Object.assign({}, form_group, {
  name: 'VxeFormGather'
});
/**
 * 已废弃，被 VxeFormGather 替换
 * @deprecated
 */
const VxeFormGather = Object.assign(VxeFormGatherComponent, {
  install(app) {
    app.component(VxeFormGatherComponent.name, VxeFormGatherComponent);
  }
});
dynamicApp.use(VxeFormGather);
index_esm_VxeUI.component(VxeFormGatherComponent);
/**
 * 已废弃，被 FormGroup 替换
 * @deprecated
 */
const FormGather = VxeFormGather;
/* harmony default export */ var form_gather = (VxeFormGather);
;// CONCATENATED MODULE: ./packages/form-group/index.ts



const VxeFormGroup = Object.assign(form_group, {
  install(app) {
    app.component(form_group.name, form_group);
  }
});
dynamicApp.use(VxeFormGroup);
index_esm_VxeUI.component(form_group);
const FormGroup = VxeFormGroup;
/* harmony default export */ var packages_form_group = (VxeFormGroup);
;// CONCATENATED MODULE: ./packages/form-item/index.ts



const VxeFormItem = Object.assign(form_item, {
  install(app) {
    app.component(form_item.name, form_item);
  }
});
dynamicApp.use(VxeFormItem);
index_esm_VxeUI.component(form_item);
const FormItem = VxeFormItem;
/* harmony default export */ var packages_form_item = (VxeFormItem);
;// CONCATENATED MODULE: ./packages/icon/index.ts



const VxeIcon = Object.assign({}, icon, {
  install(app) {
    app.component(icon.name, icon);
  }
});
dynamicApp.use(VxeIcon);
index_esm_VxeUI.component(icon);
const Icon = VxeIcon;
/* harmony default export */ var packages_icon = (VxeIcon);
;// CONCATENATED MODULE: ./packages/icon-picker/src/icon-picker.ts







/* harmony default export */ var icon_picker = (defineVxeComponent({
  name: 'VxeIconPicker',
  props: {
    modelValue: String,
    placeholder: String,
    clearable: Boolean,
    size: {
      type: String,
      default: () => getConfig().iconPicker.size || getConfig().size
    },
    className: [String, Function],
    popupClassName: [String, Function],
    showIconTitle: {
      type: Boolean,
      default: () => getConfig().iconPicker.showIconTitle
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    icons: Array,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: ['update:modelValue', 'change', 'clear', 'click'],
  setup(props, context) {
    const {
      emit
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      selectIcon: `${props.modelValue || ''}`,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = {
      // hpTimeout: undefined
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInput = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refOptionPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xeIconPicker = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let iconPickerMethods = {};
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().iconPicker.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().select.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n('vxe.base.pleaseSelect');
    });
    const computeIconList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      let {
        icons
      } = props;
      if (!icons || !icons.length) {
        icons = getConfig().iconPicker.icons || [];
      }
      return icons.map(item => {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
          return {
            title: item,
            icon: `vxe-icon-${`${item || ''}`.replace(/^vxe-icon-/, '')}`
          };
        }
        return {
          title: `${item.title || ''}`,
          icon: item.icon || '',
          iconRender: item.iconRender
        };
      });
    });
    const computeIconGroupList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const iconList = computeIconList.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().chunk(iconList, 4);
    });
    const computeSelectIconItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        selectIcon
      } = reactData;
      const iconList = computeIconList.value;
      return selectIcon ? iconList.find(item => item.icon === selectIcon) : null;
    });
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          placement
        } = props;
        const {
          panelIndex
        } = reactData;
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (panelElem && el) {
          const targetHeight = el.offsetHeight;
          const targetWidth = el.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const {
            boundingTop,
            boundingLeft,
            visibleHeight,
            visibleWidth
          } = getAbsolutePos(el);
          let panelPlacement = 'bottom';
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === 'top') {
              panelPlacement = 'top';
              top = boundingTop - panelHeight;
            } else if (!placement) {
              // 如果下面不够放，则向上
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = 'top';
                top = boundingTop - panelHeight;
              }
              // 如果上面不够放，则向下（优先）
              if (top < marginSize) {
                panelPlacement = 'bottom';
                top = boundingTop + targetHeight;
              }
            }
            // 如果溢出右边
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            // 如果溢出左边
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === 'top') {
              panelPlacement = 'top';
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              // 如果下面不够放，则向上
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                // 如果上面不够放，则向下（优先）
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = 'top';
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
        }
      });
    };
    const showOptionPanel = () => {
      const {
        hpTimeout
      } = internalData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (hpTimeout) {
          clearTimeout(hpTimeout);
          internalData.hpTimeout = undefined;
        }
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      internalData.hpTimeout = setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      reactData.selectIcon = selectValue;
      if (selectValue !== props.modelValue) {
        emit('update:modelValue', selectValue);
        dispatchEvent('change', {
          value: selectValue
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const focusEvent = () => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
      }
    };
    const blurEvent = () => {
      reactData.isActivated = false;
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue);
      dispatchEvent('clear', {
        value: selectValue
      }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const togglePanelEvent = evnt => {
      evnt.preventDefault();
      if (reactData.visiblePanel) {
        hideOptionPanel();
      } else {
        showOptionPanel();
      }
    };
    const clickEvent = evnt => {
      togglePanelEvent(evnt);
      dispatchEvent('click', {}, evnt);
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const {
        clearable
      } = props;
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isSpacebar = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hideOptionPanel();
          } else if (isEnter) {
            evnt.preventDefault();
            evnt.stopPropagation();
            // changeOptionEvent(evnt, currentValue, currentOption)
          } else if (isUpArrow || isDwArrow) {
            evnt.preventDefault();
            // let { firstOption, offsetOption } = findOffsetOption(currentValue, isUpArrow)
            // if (!offsetOption && !findVisibleOption(currentValue)) {
            //   offsetOption = firstOption
            // }
            // setCurrentOption(offsetOption)
            // scrollToOption(offsetOption, isDwArrow)
          } else if (isSpacebar) {
            evnt.preventDefault();
          }
        } else if ((isUpArrow || isDwArrow || isEnter || isSpacebar) && reactData.isActivated) {
          evnt.preventDefault();
          showOptionPanel();
        }
        if (reactData.isActivated) {
          if (isDel && clearable) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const {
        visiblePanel,
        isActivated
      } = reactData;
      if (visiblePanel) {
        hideOptionPanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        const $input = refInput.value;
        if ($input) {
          $input.blur();
        }
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $iconPicker: $xeIconPicker
      }, params));
    };
    iconPickerMethods = {
      dispatchEvent,
      isPanelVisible() {
        return reactData.visiblePanel;
      },
      togglePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      hidePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      showPanel() {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      focus() {
        const $input = refInput.value;
        reactData.isActivated = true;
        if ($input) {
          $input.blur();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const $input = refInput.value;
        if ($input) {
          $input.blur();
        }
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    const handleClickIconEvent = (evnt, item) => {
      const value = item.icon;
      changeEvent(evnt, value);
      hideOptionPanel();
    };
    Object.assign($xeIconPicker, iconPickerMethods);
    const renderIconWrapper = () => {
      const {
        showIconTitle
      } = props;
      const iconGroupList = computeIconGroupList.value;
      const isDisabled = computeIsDisabled.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-ico-picker--list-wrapper'
      }, iconGroupList.map(list => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-ico-picker--list'
        }, list.map(item => {
          const {
            iconRender
          } = item;
          const compConf = iconRender ? renderer.get(iconRender.name) : null;
          const oIconMethod = compConf ? compConf.renderIconPickerOptionIcon : null;
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-ico-picker--item',
            onClick(evnt) {
              if (!isDisabled) {
                handleClickIconEvent(evnt, item);
              }
            }
          }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-ico-picker--item-icon'
          }, oIconMethod && iconRender ? vn_getSlotVNs(oIconMethod(iconRender, {
            $iconPicker: $xeIconPicker,
            option: item
          })) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
            class: item.icon || ''
          })]), showIconTitle ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            class: 'vxe-ico-picker--item-title'
          }, `${item.title || ''}`) : renderEmptyElement($xeIconPicker)]);
        }));
      }));
    };
    const renderIconView = () => {
      const {
        selectIcon
      } = reactData;
      const selectIconItem = computeSelectIconItem.value;
      if (selectIconItem) {
        const {
          iconRender
        } = selectIconItem;
        const compConf = iconRender ? renderer.get(iconRender.name) : null;
        const oIconMethod = compConf ? compConf.renderIconPickerOptionIcon : null;
        if (oIconMethod && iconRender) {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
            key: 'inc',
            class: 'vxe-ico-picker--icon'
          }, vn_getSlotVNs(oIconMethod(iconRender, {
            $iconPicker: $xeIconPicker,
            option: selectIconItem
          })));
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'ind',
        class: 'vxe-ico-picker--icon'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: selectIcon
      })]);
    };
    const renderVN = () => {
      const {
        className,
        popupClassName,
        clearable
      } = props;
      const {
        initialized,
        isActivated,
        isAniVisible,
        visiblePanel,
        selectIcon
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-ico-picker--readonly', className]
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: selectIcon
        })]);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-ico-picker', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $iconPicker: $xeIconPicker
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'show--clear': clearable && !isDisabled && !!selectIcon,
          'is--visible': visiblePanel,
          'is--disabled': isDisabled,
          'is--active': isActivated
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-ico-picker--inner',
        onClick: clickEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        ref: refInput,
        class: 'vxe-ico-picker--input',
        onFocus: focusEvent,
        onBlur: blurEvent
      }), selectIcon ? renderIconView() : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-ico-picker--placeholder'
      }, inpPlaceholder), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-ico-picker--suffix'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-ico-picker--clear-icon',
        onClick: clearEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().INPUT_CLEAR
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-ico-picker--suffix-icon'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: visiblePanel ? getIcon().ICON_PICKER_OPEN : getIcon().ICON_PICKER_CLOSE
      })])])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: btnTransfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refOptionPanel,
        class: ['vxe-table--ignore-clear vxe-ico-picker--panel', popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
          $iconPicker: $xeIconPicker
        }) : popupClassName : '', {
          [`size--${vSize}`]: vSize,
          'is--transfer': btnTransfer,
          'ani--leave': isAniVisible,
          'ani--enter': visiblePanel
        }],
        placement: reactData.panelPlacement,
        style: reactData.panelStyle
      }, [initialized && (visiblePanel || isAniVisible) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-ico-picker--panel-wrapper'
      }, [renderIconWrapper()]) : renderEmptyElement($xeIconPicker)])])]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.selectIcon = `${val || ''}`;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      globalEvents.on($xeIconPicker, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeIconPicker, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeIconPicker, 'keydown', handleGlobalKeydownEvent);
      globalEvents.on($xeIconPicker, 'blur', handleGlobalBlurEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeIconPicker, 'mousewheel');
      globalEvents.off($xeIconPicker, 'mousedown');
      globalEvents.off($xeIconPicker, 'keydown');
      globalEvents.off($xeIconPicker, 'blur');
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeIconPicker', $xeIconPicker);
    $xeIconPicker.renderVN = renderVN;
    return $xeIconPicker;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/icon-picker/index.ts



const VxeIconPicker = Object.assign(icon_picker, {
  install: function (app) {
    app.component(icon_picker.name, icon_picker);
  }
});
dynamicApp.use(VxeIconPicker);
index_esm_VxeUI.component(icon_picker);
const IconPicker = VxeIconPicker;
/* harmony default export */ var packages_icon_picker = (VxeIconPicker);
;// CONCATENATED MODULE: ./packages/image/src/preview.ts






/* harmony default export */ var preview = (defineVxeComponent({
  name: 'VxeImagePreview',
  props: {
    modelValue: Number,
    urlList: Array,
    urlField: {
      type: String,
      default: () => getConfig().imagePreview.urlField
    },
    maskClosable: {
      type: Boolean,
      default: () => getConfig().imagePreview.maskClosable
    },
    marginSize: {
      type: String,
      default: () => getConfig().imagePreview.marginSize
    },
    showPrintButton: {
      type: Boolean,
      default: () => getConfig().imagePreview.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().imagePreview.showDownloadButton
    },
    toolbarConfig: Object,
    beforeDownloadMethod: Function,
    downloadMethod: Function
  },
  emits: ['update:modelValue', 'change', 'download', 'download-fail', 'rotate', 'close'],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      activeIndex: props.modelValue || 0,
      offsetPct11: false,
      offsetScale: 0,
      offsetRotate: 0,
      offsetLeft: 0,
      offsetTop: 0
    });
    const computeUrlProp = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.urlField || 'url';
    });
    const computeMarginSize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.marginSize || 0) || 16;
    });
    const computeToolbarOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().imagePreview.toolbarConfig, props.toolbarConfig);
    });
    const computeRotateText = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        offsetRotate
      } = reactData;
      if (offsetRotate) {
        return `${offsetRotate}°`;
      }
      return '0°';
    });
    const computeScaleText = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        offsetScale
      } = reactData;
      if (offsetScale) {
        return `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().ceil((1 + offsetScale) * 100)}%`;
      }
      return '100%';
    });
    const computeImgList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        urlList
      } = props;
      const urlProp = computeUrlProp.value;
      if (urlList && urlList.length) {
        return urlList.map(item => {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
            return item;
          }
          if (item[urlProp]) {
            return item[urlProp];
          }
          return '';
        });
      }
      return [];
    });
    const computeImgTransform = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      let {
        offsetScale,
        offsetRotate,
        offsetLeft,
        offsetTop
      } = reactData;
      const stys = [];
      let targetScale = 1;
      if (offsetScale) {
        targetScale = 1 + offsetScale;
        stys.push(`scale(${targetScale})`);
      }
      if (offsetRotate) {
        stys.push(`rotate(${offsetRotate}deg)`);
      }
      if (offsetLeft || offsetTop) {
        // 缩放与位移
        offsetLeft /= targetScale;
        offsetTop /= targetScale;
        let targetOffsetLeft = offsetLeft;
        let targetOffsetTop = offsetTop;
        if (offsetRotate) {
          // 转向与位移
          switch (offsetRotate % 360) {
            case 90:
            case -270:
              targetOffsetLeft = offsetTop;
              targetOffsetTop = -offsetLeft;
              break;
            case 180:
            case -180:
              targetOffsetLeft = -offsetLeft;
              targetOffsetTop = -offsetTop;
              break;
            case 270:
            case -90:
              targetOffsetLeft = -offsetTop;
              targetOffsetTop = offsetLeft;
              break;
          }
        }
        stys.push(`translate(${targetOffsetLeft}px, ${targetOffsetTop}px)`);
      }
      return stys.length ? stys.join(' ') : '';
    });
    const computeMaps = {
      computeImgList
    };
    const $xeImagePreview = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $imagePreview: $xeImagePreview
      }, params));
    };
    const imagePreviewMethods = {
      dispatchEvent
    };
    const emitModel = value => {
      reactData.activeIndex = value;
      emit('update:modelValue', value);
    };
    const handleCloseEvent = evnt => {
      dispatchEvent('close', {}, evnt);
    };
    const imagePreviewPrivateMethods = {};
    const resetStyle = () => {
      const elem = refElem.value;
      removeClass(elem, 'is--move');
      Object.assign(reactData, {
        offsetPct11: false,
        offsetScale: 0,
        offsetRotate: 0,
        offsetLeft: 0,
        offsetTop: 0
      });
    };
    const getOffsetZoomStep = () => {
      const {
        offsetScale
      } = reactData;
      let stepNum = 0.02;
      if (offsetScale >= -0.6) {
        stepNum = 0.04;
        if (offsetScale >= -0.4) {
          stepNum = 0.07;
          if (offsetScale >= 0) {
            stepNum = 0.1;
            if (offsetScale >= 3) {
              stepNum = 0.25;
              if (offsetScale >= 8) {
                stepNum = 0.4;
                if (offsetScale >= 16) {
                  stepNum = 0.6;
                  if (offsetScale >= 24) {
                    stepNum = 0.9;
                    if (offsetScale >= 32) {
                      stepNum = 1.3;
                      if (offsetScale >= 39) {
                        stepNum = 1.9;
                        if (offsetScale >= 45) {
                          stepNum = 2.5;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return stepNum;
    };
    const handleZoom = isAdd => {
      const {
        offsetScale
      } = reactData;
      const stepNum = getOffsetZoomStep();
      if (isAdd) {
        reactData.offsetScale = Number(Math.min(49, offsetScale + stepNum).toFixed(2));
      } else {
        reactData.offsetScale = Number(Math.max(-0.9, offsetScale - stepNum).toFixed(2));
      }
    };
    const handleChangeEvent = (evnt, isNext) => {
      let activeIndex = reactData.activeIndex || 0;
      const imgList = computeImgList.value;
      if (isNext) {
        if (activeIndex >= imgList.length - 1) {
          activeIndex = 0;
        } else {
          activeIndex++;
        }
      } else {
        if (activeIndex <= 0) {
          activeIndex = imgList.length - 1;
        } else {
          activeIndex--;
        }
      }
      const imgUrl = imgList[activeIndex || 0];
      reactData.activeIndex = activeIndex;
      resetStyle();
      emitModel(activeIndex);
      dispatchEvent('change', {
        url: imgUrl,
        activeIndex
      }, evnt);
    };
    const handleRotateImgEvent = (evnt, isRight) => {
      const imgList = computeImgList.value;
      const {
        activeIndex
      } = reactData;
      const imgUrl = imgList[activeIndex || 0];
      let offsetRotate = reactData.offsetRotate;
      if (isRight) {
        offsetRotate += 90;
      } else {
        offsetRotate -= 90;
      }
      reactData.offsetRotate = offsetRotate;
      dispatchEvent('rotate', {
        url: imgUrl,
        rotateValue: offsetRotate
      }, evnt);
    };
    const handlePct11 = () => {
      resetStyle();
      reactData.offsetPct11 = true;
    };
    const handlePrintImg = () => {
      const {
        activeIndex
      } = reactData;
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      if (index_esm_VxeUI.print) {
        index_esm_VxeUI.print({
          align: 'center',
          pageBreaks: [{
            bodyHtml: `<img src="${imgUrl}" style="max-width:100%;max-height:100%;">`
          }]
        });
      }
    };
    const handleDownloadEvent = (evnt, imgUrl) => {
      dispatchEvent('download', {
        url: imgUrl
      }, evnt);
    };
    const handleDefaultDownload = (evnt, imgUrl) => {
      if (index_esm_VxeUI.saveFile) {
        fetch(imgUrl).then(res => {
          return res.blob().then(blob => {
            index_esm_VxeUI.saveFile({
              filename: imgUrl,
              content: blob
            });
            handleDownloadEvent(evnt, imgUrl);
          });
        }).catch(() => {
          if (index_esm_VxeUI.modal) {
            index_esm_VxeUI.modal.message({
              content: getI18n('vxe.error.downErr'),
              status: 'error'
            });
          }
        });
      }
    };
    const handleDownloadImg = evnt => {
      const {
        activeIndex
      } = reactData;
      const toolbarOpts = computeToolbarOpts.value;
      const btnConf = toolbarOpts.download;
      const btnOpts = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(btnConf) ? {} : btnConf ? Object.assign({}, btnConf) : {};
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      const beforeDownloadFn = props.beforeDownloadMethod || btnOpts.beforeDownloadMethod || getConfig().imagePreview.beforeDownloadMethod;
      const downloadFn = props.downloadMethod || btnOpts.downloadMethod || getConfig().imagePreview.downloadMethod;
      Promise.resolve(beforeDownloadFn ? beforeDownloadFn({
        $imagePreview: $xeImagePreview,
        url: imgUrl,
        index: activeIndex || 0
      }) : true).then(status => {
        if (status) {
          if (downloadFn) {
            Promise.resolve(downloadFn({
              $imagePreview: $xeImagePreview,
              url: imgUrl,
              index: activeIndex || 0
            })).then(() => {
              handleDownloadEvent(evnt, imgUrl);
            }).catch(e => e);
          } else {
            handleDefaultDownload(evnt, imgUrl);
          }
        }
      });
    };
    const handleOperationBtn = (evnt, code) => {
      const {
        activeIndex
      } = reactData;
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      if (imgUrl) {
        switch (code) {
          case 'zoomOut':
            handleZoom(false);
            break;
          case 'zoomIn':
            handleZoom(true);
            break;
          case 'pctFull':
            resetStyle();
            break;
          case 'pct11':
            handlePct11();
            break;
          case 'rotateLeft':
            handleRotateImgEvent(evnt, false);
            break;
          case 'rotateRight':
            handleRotateImgEvent(evnt, true);
            break;
          case 'print':
            handlePrintImg();
            break;
          case 'download':
            handleDownloadImg(evnt);
            break;
        }
      }
    };
    const wheelEvent = evnt => {
      const delta = evnt.deltaY;
      if (delta > 0) {
        handleZoom(false);
      } else if (delta < 0) {
        handleZoom(true);
      }
    };
    const moveEvent = evnt => {
      const {
        offsetTop,
        offsetLeft
      } = reactData;
      const elem = refElem.value;
      evnt.preventDefault();
      const domMousemove = document.onmousemove;
      const domMouseup = document.onmouseup;
      const startX = evnt.pageX;
      const startY = evnt.pageY;
      const marginSize = computeMarginSize.value;
      document.onmousemove = et => {
        const {
          pageX,
          pageY
        } = et;
        const {
          visibleHeight,
          visibleWidth
        } = getDomNode();
        et.preventDefault();
        addClass(elem, 'is--move');
        // 限制边界值
        if (pageX > marginSize && pageY > marginSize && pageX < visibleWidth - marginSize && pageY < visibleHeight - marginSize) {
          reactData.offsetLeft = offsetLeft + pageX - startX;
          reactData.offsetTop = offsetTop + pageY - startY;
        }
      };
      document.onmouseup = () => {
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        removeClass(elem, 'is--move');
      };
    };
    const handleGlobalKeydownEvent = evnt => {
      const isControlKey = hasControlKey(evnt);
      const hasShiftKey = evnt.shiftKey;
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDownArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
      const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
      const isR = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.R);
      const isP = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.P);
      if (isUpArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetTop -= 1;
        } else {
          handleZoom(true);
        }
      } else if (isDownArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetTop += 1;
        } else {
          handleZoom(false);
        }
      } else if (isLeftArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetLeft -= 1;
        } else {
          handleChangeEvent(evnt, false);
        }
      } else if (isRightArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetLeft += 1;
        } else {
          handleChangeEvent(evnt, true);
        }
      } else if (isR && isControlKey) {
        evnt.preventDefault();
        if (hasShiftKey) {
          handleRotateImgEvent(evnt, false);
        } else {
          handleRotateImgEvent(evnt, true);
        }
      } else if (isP && isControlKey) {
        evnt.preventDefault();
        handlePrintImg();
      }
    };
    const handleClickMaskEvent = evnt => {
      if (props.maskClosable) {
        if (evnt.target === evnt.currentTarget) {
          dispatchEvent('close', {}, evnt);
        }
      }
    };
    Object.assign($xeImagePreview, imagePreviewMethods, imagePreviewPrivateMethods);
    const renderImgWrapper = () => {
      const {
        activeIndex
      } = reactData;
      const imgList = computeImgList.value;
      const imgTransform = computeImgTransform.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--img-list',
        onClick: handleClickMaskEvent
      }, imgList.map((url, index) => {
        const isActive = activeIndex === index;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('img', {
          class: ['vxe-image-preview--img-item', {
            'is--active': isActive
          }],
          src: url,
          style: isActive ? {
            transform: imgTransform
          } : null,
          onMousedown(evnt) {
            moveEvent(evnt);
          }
        });
      }));
    };
    const renderOperationBtn = (code, icon) => {
      const toolbarOpts = computeToolbarOpts.value;
      const btnConf = toolbarOpts[code];
      const btnOpts = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(btnConf) ? {} : btnConf ? Object.assign({}, btnConf) : {};
      const showBtn = btnConf !== false;
      return showBtn ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--operation-btn',
        title: getI18n(`vxe.imagePreview.operBtn.${code}`),
        onClick(evnt) {
          handleOperationBtn(evnt, code);
        }
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: btnOpts.icon || getIcon()[icon]
      })]) : renderEmptyElement($xeImagePreview);
    };
    const renderBtnWrapper = () => {
      const {
        showPrintButton,
        showDownloadButton
      } = props;
      const {
        activeIndex
      } = reactData;
      const imgList = computeImgList.value;
      const rotateText = computeRotateText.value;
      const scaleText = computeScaleText.value;
      const toolbarOpts = computeToolbarOpts.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--btn-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--close-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--close-btn',
        onClick: handleCloseEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().IMAGE_PREVIEW_CLOSE
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--close-bg'
      })]), imgList.length > 1 ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--previous-btn',
        onClick(evnt) {
          handleChangeEvent(evnt, false);
        }
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().IMAGE_PREVIEW_PREVIOUS
      })]) : renderEmptyElement($xeImagePreview), imgList.length > 1 ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--next-btn',
        onClick(evnt) {
          handleChangeEvent(evnt, true);
        }
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().IMAGE_PREVIEW_NEXT
      })]) : renderEmptyElement($xeImagePreview), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--operation-info'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--operation-deg'
      }, rotateText), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--operation-pct'
      }, scaleText)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--operation-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-image-preview--operation-active-count'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-image-preview--operation-active-current'
      }, `${(activeIndex || 0) + 1}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-image-preview--operation-active-total'
      }, `/${imgList.length}`)]), renderOperationBtn('zoomOut', 'IMAGE_PREVIEW_ZOOM_OUT'), renderOperationBtn('zoomIn', 'IMAGE_PREVIEW_ZOOM_IN'), renderOperationBtn('pctFull', 'IMAGE_PREVIEW_PCT_FULL'), renderOperationBtn('pct11', 'IMAGE_PREVIEW_PCT_1_1'), renderOperationBtn('rotateLeft', 'IMAGE_PREVIEW_ROTATE_LEFT'), renderOperationBtn('rotateRight', 'IMAGE_PREVIEW_ROTATE_RIGHT'), showPrintButton || toolbarOpts.print ? renderOperationBtn('print', 'IMAGE_PREVIEW_PRINT') : renderEmptyElement($xeImagePreview), showDownloadButton || toolbarOpts.download ? renderOperationBtn('download', 'IMAGE_PREVIEW_DOWNLOAD') : renderEmptyElement($xeImagePreview)])]);
    };
    const renderVN = () => {
      const {
        offsetPct11
      } = reactData;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-image-preview', {
          'is--pct11': offsetPct11
        }],
        onWheel: wheelEvent
      }, [renderImgWrapper(), renderBtnWrapper()]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.activeIndex = val;
      resetStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      globalEvents.on($xeImagePreview, 'keydown', handleGlobalKeydownEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      const elem = refElem.value;
      if (elem) {
        removeClass(elem, 'is--move');
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeImagePreview, 'keydown');
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeImagePreview', $xeImagePreview);
    $xeImagePreview.renderVN = renderVN;
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/image/src/util.ts




const openPreviewImage = options => {
  if (index_esm_VxeUI.modal) {
    const opts = Object.assign({
      escClosable: true
    }, options);
    const {
      urlList,
      activeIndex
    } = opts;
    const {
      rotate,
      change
    } = opts.events || {};
    const modalId = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('image-preview');
    index_esm_VxeUI.modal.open({
      id: modalId,
      title: '预览',
      width: '100%',
      height: '100%',
      showHeader: false,
      showFooter: false,
      padding: false,
      escClosable: opts.escClosable,
      className: 'vxe-image-preview-popup-wrapper',
      slots: {
        default() {
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(preview, {
            modelValue: activeIndex,
            urlList,
            urlField: opts.urlField,
            marginSize: opts.marginSize,
            maskClosable: opts.maskClosable,
            toolbarConfig: opts.toolbarConfig,
            showPrintButton: opts.showPrintButton,
            showDownloadButton: opts.showDownloadButton,
            beforeDownloadMethod: opts.beforeDownloadMethod,
            downloadMethod: opts.downloadMethod,
            onClose() {
              index_esm_VxeUI.modal.close(modalId);
            },
            onChange(eventParams) {
              if (change) {
                change.call(this, eventParams);
              }
            },
            onRotate(eventParams) {
              if (rotate) {
                rotate.call(this, eventParams);
              }
            }
          });
        }
      }
    });
  }
  return Promise.resolve();
};
;// CONCATENATED MODULE: ./packages/image/src/image.ts






/* harmony default export */ var src_image = (defineVxeComponent({
  name: 'VxeImage',
  props: {
    src: [String, Array],
    alt: [String, Number],
    loading: String,
    title: [String, Number],
    width: [String, Number],
    height: [String, Number],
    circle: Boolean,
    maskClosable: {
      type: Boolean,
      default: () => getConfig().image.maskClosable
    },
    toolbarConfig: Object,
    showPreview: {
      type: Boolean,
      default: () => getConfig().image.showPreview
    },
    showPrintButton: {
      type: Boolean,
      default: () => getConfig().image.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().image.showDownloadButton
    },
    size: {
      type: String,
      default: () => getConfig().image.size || getConfig().size
    },
    getThumbnailUrlMethod: Function
  },
  emits: ['click', 'change', 'rotate'],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeImageGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeImageGroup', null);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeImgStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        width,
        height
      } = props;
      const style = {};
      if (width && height) {
        style.maxWidth = toCssUnit(width);
        style.maxHeight = toCssUnit(height);
      } else {
        if (width) {
          style.width = toCssUnit(width);
        }
        if (height) {
          style.height = toCssUnit(height);
        }
      }
      return style;
    });
    const computeImgList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        src
      } = props;
      if (src) {
        return (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(src) ? src : [src]).map(item => {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
            return {
              url: item,
              alt: ''
            };
          }
          return {
            url: item.url,
            alt: item.alt
          };
        });
      }
      return [];
    });
    const computeImgItem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const imgList = computeImgList.value;
      return imgList[0];
    });
    const computeImgUrl = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const imgItem = computeImgItem.value;
      return imgItem ? `${imgItem.url || ''}` : '';
    });
    const computeImgThumbnailUrl = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const getThumbnailUrlFn = props.getThumbnailUrlMethod || getConfig().image.getThumbnailUrlMethod;
      const imgUrl = computeImgUrl.value;
      return getThumbnailUrlFn ? getThumbnailUrlFn({
        url: imgUrl,
        $image: $xeImage
      }) : '';
    });
    const computeMaps = {
      computeSize
    };
    const $xeImage = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const imageMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $image: $xeImage
        }, params));
      }
    };
    const clickEvent = evnt => {
      const {
        showPreview,
        toolbarConfig,
        showPrintButton,
        showDownloadButton,
        maskClosable
      } = props;
      const imgList = computeImgList.value;
      const imgUrl = computeImgUrl.value;
      if ($xeImageGroup) {
        $xeImageGroup.handleClickImgEvent(evnt, {
          url: imgUrl
        });
      } else {
        if (showPreview && imgUrl) {
          openPreviewImage({
            urlList: imgList,
            toolbarConfig,
            showPrintButton,
            showDownloadButton,
            maskClosable,
            events: {
              change(eventParams) {
                $xeImage.dispatchEvent('change', eventParams, eventParams.$event);
              },
              rotate(eventParams) {
                $xeImage.dispatchEvent('rotate', eventParams, eventParams.$event);
              }
            }
          });
        }
        $xeImage.dispatchEvent('click', {
          url: imgUrl
        }, evnt);
      }
    };
    const imagePrivateMethods = {};
    Object.assign($xeImage, imageMethods, imagePrivateMethods);
    const renderVN = () => {
      const {
        alt,
        loading,
        circle
      } = props;
      const imgStyle = computeImgStyle.value;
      const imgUrl = computeImgUrl.value;
      const imgThumbnailUrl = computeImgThumbnailUrl.value;
      const vSize = computeSize.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('img', {
        ref: refElem,
        class: ['vxe-image', {
          [`size--${vSize}`]: vSize,
          'is--circle': circle
        }],
        src: imgThumbnailUrl || imgUrl,
        alt,
        loading,
        style: imgStyle,
        onClick: clickEvent
      });
    };
    $xeImage.renderVN = renderVN;
    return $xeImage;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/image/index.ts



const VxeImage = Object.assign({}, src_image, {
  install(app) {
    app.component(src_image.name, src_image);
  }
});
dynamicApp.use(VxeImage);
index_esm_VxeUI.component(src_image);
const image_Image = VxeImage;
/* harmony default export */ var packages_image = (VxeImage);
;// CONCATENATED MODULE: ./packages/image/src/group.ts






/* harmony default export */ var src_group = (defineVxeComponent({
  name: 'VxeImageGroup',
  props: {
    urlList: [Array, String],
    showPreview: {
      type: Boolean,
      default: () => getConfig().imageGroup.showPreview
    },
    imageStyle: Object,
    size: {
      type: String,
      default: () => getConfig().imageGroup.size || getConfig().size
    },
    toolbarConfig: Object,
    showPrintButton: {
      type: Boolean,
      default: () => getConfig().imageGroup.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().imageGroup.showDownloadButton
    },
    getThumbnailUrlMethod: Function
  },
  emits: ['click', 'change', 'rotate'],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const computeImgList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        urlList
      } = props;
      if (urlList) {
        return (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(urlList) ? urlList : [urlList]).map(item => {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
            return {
              url: item,
              alt: ''
            };
          }
          return {
            url: item.url,
            alt: item.alt
          };
        });
      }
      return [];
    });
    const computeImgStyleOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().imageGroup.imageStyle, props.imageStyle);
    });
    const computeGetThumbnailUrlMethod = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.getThumbnailUrlMethod || getConfig().imageGroup.getThumbnailUrlMethod;
    });
    const computeMaps = {
      computeSize
    };
    const $xeImageGroup = {
      xID,
      props,
      context,
      getComputeMaps: () => computeMaps
    };
    const imageGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $imageGroup: $xeImageGroup
        }, params));
      }
    };
    const imageGroupPrivateMethods = {
      handleClickImgEvent(evnt, params) {
        const {
          showPreview,
          toolbarConfig,
          showPrintButton,
          showDownloadButton
        } = props;
        const {
          url
        } = params;
        const imgList = computeImgList.value;
        if (showPreview && url) {
          openPreviewImage({
            activeIndex: Math.max(0, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(imgList, item => item.url === url)),
            urlList: imgList,
            toolbarConfig,
            showPrintButton,
            showDownloadButton,
            events: {
              change(eventParams) {
                $xeImageGroup.dispatchEvent('change', eventParams, eventParams.$event);
              },
              rotate(eventParams) {
                $xeImageGroup.dispatchEvent('rotate', eventParams, eventParams.$event);
              }
            }
          });
        }
        $xeImageGroup.dispatchEvent('click', {
          url,
          urlList: imgList
        }, evnt);
      }
    };
    Object.assign($xeImageGroup, imageGroupMethods, imageGroupPrivateMethods);
    const renderVN = () => {
      const imgList = computeImgList.value;
      const vSize = computeSize.value;
      const imgStyleOpts = computeImgStyleOpts.value;
      const getThumbnailUrlMethod = computeGetThumbnailUrlMethod.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-image-group', {
          [`size--${vSize}`]: vSize
        }]
      }, imgList ? imgList.map((item, index) => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_image, {
          key: index,
          src: item.url,
          alt: item.alt,
          width: imgStyleOpts.width,
          height: imgStyleOpts.height,
          getThumbnailUrlMethod
        });
      }) : []);
    };
    $xeImageGroup.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeImageGroup', $xeImageGroup);
    return $xeImageGroup;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/image-group/index.ts



const VxeImageGroup = Object.assign({}, src_group, {
  install(app) {
    app.component(src_group.name, src_group);
  }
});
dynamicApp.use(VxeImageGroup);
index_esm_VxeUI.component(src_group);
const ImageGroup = VxeImageGroup;
/* harmony default export */ var image_group = (VxeImageGroup);
;// CONCATENATED MODULE: ./packages/image-preview/index.ts




const VxeImagePreview = Object.assign(preview, {
  install(app) {
    app.component(preview.name, preview);
    index_esm_VxeUI.previewImage = openPreviewImage;
  }
});
dynamicApp.use(VxeImagePreview);
index_esm_VxeUI.component(preview);
const ImagePreview = VxeImagePreview;
/* harmony default export */ var image_preview = (VxeImagePreview);
;// CONCATENATED MODULE: ./packages/input/index.ts



const VxeInput = Object.assign(input, {
  install(app) {
    app.component(input.name, input);
  }
});
dynamicApp.use(VxeInput);
index_esm_VxeUI.component(input);
const Input = VxeInput;
/* harmony default export */ var packages_input = (VxeInput);
;// CONCATENATED MODULE: ./packages/layout-aside/src/layout-aside.ts






/* harmony default export */ var layout_aside = (defineVxeComponent({
  name: 'VxeLayoutAside',
  props: {
    width: [String, Number],
    collapsed: Boolean,
    collapseWidth: [String, Number],
    loading: Boolean,
    padding: Boolean,
    size: {
      type: String,
      default: () => getConfig().layoutAside.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeWrapperWidth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        width,
        collapsed,
        collapseWidth
      } = props;
      if (collapsed) {
        if (collapseWidth) {
          return toCssUnit(collapseWidth);
        }
      } else {
        if (width) {
          return toCssUnit(width);
        }
      }
      return '';
    });
    const computeMaps = {
      computeSize
    };
    const $xeLayoutAside = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $layoutAside: $xeLayoutAside
      }, params));
    };
    const layoutAsideMethods = {
      dispatchEvent
    };
    const layoutAsidePrivateMethods = {};
    Object.assign($xeLayoutAside, layoutAsideMethods, layoutAsidePrivateMethods);
    const renderVN = () => {
      const {
        width,
        collapsed,
        loading,
        padding
      } = props;
      const wrapperWidth = computeWrapperWidth.value;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('aside', {
        ref: refElem,
        class: ['vxe-layout-aside', {
          [`size--${vSize}`]: vSize,
          'is--padding': padding,
          'is--default-width': !width,
          'is--collapse': collapsed,
          'is--loading': loading
        }],
        style: wrapperWidth ? {
          width: wrapperWidth
        } : null
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-layout-aside--inner'
      }, defaultSlot ? defaultSlot({}) : []),
      /**
       * 加载中
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-list-view--loading',
        modelValue: loading
      })]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeLayoutAside', $xeLayoutAside);
    $xeLayoutAside.renderVN = renderVN;
    return $xeLayoutAside;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/layout-aside/index.ts



const VxeLayoutAside = Object.assign({}, layout_aside, {
  install(app) {
    app.component(layout_aside.name, layout_aside);
  }
});
dynamicApp.use(VxeLayoutAside);
index_esm_VxeUI.component(layout_aside);
const LayoutAside = VxeLayoutAside;
/* harmony default export */ var packages_layout_aside = (VxeLayoutAside);
;// CONCATENATED MODULE: ./packages/layout-body/src/layout-body.ts





/* harmony default export */ var layout_body = (defineVxeComponent({
  name: 'VxeLayoutBody',
  props: {
    loading: Boolean,
    padding: Boolean,
    size: {
      type: String,
      default: () => getConfig().layoutBody.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize
    };
    const $xeLayoutBody = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $layoutBody: $xeLayoutBody
      }, params));
    };
    const layoutBodyMethods = {
      dispatchEvent
    };
    const layoutBodyPrivateMethods = {};
    Object.assign($xeLayoutBody, layoutBodyMethods, layoutBodyPrivateMethods);
    const renderVN = () => {
      const {
        loading,
        padding
      } = props;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-layout-body', {
          [`size--${vSize}`]: vSize,
          'is--loading': loading,
          'is--padding': padding
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-layout-body--inner'
      }, defaultSlot ? defaultSlot({}) : []),
      /**
       * 加载中
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-list-view--loading',
        modelValue: loading
      })]);
    };
    $xeLayoutBody.renderVN = renderVN;
    return $xeLayoutBody;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/layout-body/index.ts



const VxeLayoutBody = Object.assign({}, layout_body, {
  install(app) {
    app.component(layout_body.name, layout_body);
  }
});
dynamicApp.use(VxeLayoutBody);
index_esm_VxeUI.component(layout_body);
const LayoutBody = VxeLayoutBody;
/* harmony default export */ var packages_layout_body = (VxeLayoutBody);
;// CONCATENATED MODULE: ./packages/layout-container/src/layout-container.ts




/* harmony default export */ var layout_container = (defineVxeComponent({
  name: 'VxeLayoutContainer',
  props: {
    vertical: Boolean,
    size: {
      type: String,
      default: () => getConfig().layoutContainer.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize
    };
    const $xeLayoutContainer = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $layoutContainer: $xeLayoutContainer
      }, params));
    };
    const layoutContainerMethods = {
      dispatchEvent
    };
    const layoutContainerPrivateMethods = {};
    Object.assign($xeLayoutContainer, layoutContainerMethods, layoutContainerPrivateMethods);
    const renderVN = () => {
      const {
        vertical
      } = props;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-layout-container', {
          [`size--${vSize}`]: vSize,
          'is--vertical': vertical
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutContainer.renderVN = renderVN;
    return $xeLayoutContainer;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/layout-container/index.ts



const VxeLayoutContainer = Object.assign({}, layout_container, {
  install(app) {
    app.component(layout_container.name, layout_container);
  }
});
dynamicApp.use(VxeLayoutContainer);
index_esm_VxeUI.component(layout_container);
const LayoutContainer = VxeLayoutContainer;
/* harmony default export */ var packages_layout_container = (VxeLayoutContainer);
;// CONCATENATED MODULE: ./packages/layout-footer/src/layout-footer.ts




/* harmony default export */ var layout_footer = (defineVxeComponent({
  name: 'VxeLayoutFooter',
  props: {
    fixed: Boolean,
    align: String
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLayoutFooter = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $layoutFooter: $xeLayoutFooter
      }, params));
    };
    const layoutFooterMethods = {
      dispatchEvent
    };
    const layoutFooterPrivateMethods = {};
    Object.assign($xeLayoutFooter, layoutFooterMethods, layoutFooterPrivateMethods);
    const renderVN = () => {
      const {
        fixed,
        align
      } = props;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('footer', {
        ref: refElem,
        class: ['vxe-layout-footer', align ? `align--${align}` : '', {
          'is--fixed': fixed
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutFooter.renderVN = renderVN;
    return $xeLayoutFooter;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/layout-footer/index.ts



const VxeLayoutFooter = Object.assign({}, layout_footer, {
  install(app) {
    app.component(layout_footer.name, layout_footer);
  }
});
dynamicApp.use(VxeLayoutFooter);
index_esm_VxeUI.component(layout_footer);
const LayoutFooter = VxeLayoutFooter;
/* harmony default export */ var packages_layout_footer = (VxeLayoutFooter);
;// CONCATENATED MODULE: ./packages/layout-header/src/layout-header.ts




/* harmony default export */ var layout_header = (defineVxeComponent({
  name: 'VxeLayoutHeader',
  props: {
    fixed: Boolean
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLayoutHeader = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $layoutHeader: $xeLayoutHeader
      }, params));
    };
    const layoutHeaderMethods = {
      dispatchEvent
    };
    const layoutHeaderPrivateMethods = {};
    Object.assign($xeLayoutHeader, layoutHeaderMethods, layoutHeaderPrivateMethods);
    const renderVN = () => {
      const {
        fixed
      } = props;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('header', {
        ref: refElem,
        class: ['vxe-layout-header', {
          'is--fixed': fixed
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutHeader.renderVN = renderVN;
    return $xeLayoutHeader;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/layout-header/index.ts



const VxeLayoutHeader = Object.assign({}, layout_header, {
  install(app) {
    app.component(layout_header.name, layout_header);
  }
});
dynamicApp.use(VxeLayoutHeader);
index_esm_VxeUI.component(layout_header);
const LayoutHeader = VxeLayoutHeader;
/* harmony default export */ var packages_layout_header = (VxeLayoutHeader);
;// CONCATENATED MODULE: ./packages/link/src/link.ts





/* harmony default export */ var src_link = (defineVxeComponent({
  name: 'VxeLink',
  props: {
    href: String,
    target: String,
    status: String,
    title: [String, Number],
    disabled: Boolean,
    icon: String,
    routerLink: Object,
    underline: {
      type: Boolean,
      default: () => getConfig().link.underline
    },
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    content: [String, Number],
    size: {
      type: String,
      default: () => getConfig().link.size || getConfig().size
    }
  },
  emits: ['click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const {
      computePermissionInfo
    } = usePermission(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLink = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $link: $xeLink
      }, params));
    };
    const linkMethods = {
      dispatchEvent
    };
    const linkPrivateMethods = {};
    const clickEvent = evnt => {
      const {
        disabled
      } = props;
      if (!disabled) {
        dispatchEvent('click', {}, evnt);
      }
    };
    Object.assign($xeLink, linkMethods, linkPrivateMethods);
    const renderContent = () => {
      const {
        icon,
        content
      } = props;
      const defaultSlot = slots.default;
      const iconSlot = slots.icon;
      const textContent = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content);
      return [iconSlot || icon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-link--icon'
      }, iconSlot ? vn_getSlotVNs(iconSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon
      })]) : renderEmptyElement($xeLink), defaultSlot || textContent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-link--content'
      }, defaultSlot ? defaultSlot({}) : textContent) : renderEmptyElement($xeLink)];
    };
    const renderVN = () => {
      const {
        status,
        target,
        href,
        title,
        underline,
        disabled,
        routerLink
      } = props;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      if (!permissionInfo.visible) {
        return renderEmptyElement($xeLink);
      }
      if (routerLink) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('router-link'), {
          class: ['vxe-link', {
            [`size--${vSize}`]: vSize,
            [`theme--${status}`]: status,
            'is--disabled': disabled,
            'is--underline': underline
          }],
          title,
          target,
          to: disabled ? null : routerLink,
          onClick: clickEvent
        }, {
          default() {
            return renderContent();
          }
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('a', {
        ref: refElem,
        class: ['vxe-link', {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          'is--disabled': disabled,
          'is--underline': underline
        }],
        href: disabled ? null : href,
        target,
        title,
        onClick: clickEvent
      }, renderContent());
    };
    $xeLink.renderVN = renderVN;
    return $xeLink;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/link/index.ts



const VxeLink = Object.assign({}, src_link, {
  install(app) {
    app.component(src_link.name, src_link);
  }
});
dynamicApp.use(VxeLink);
index_esm_VxeUI.component(src_link);
const Link = VxeLink;
/* harmony default export */ var packages_link = (VxeLink);
;// CONCATENATED MODULE: ./packages/list/src/list.ts






function list_createInternalData() {
  return {
    resizeObserver: undefined,
    fullData: [],
    lastScrollLeft: 0,
    lastScrollTop: 0,
    scrollYStore: {
      startIndex: 0,
      endIndex: 0,
      visibleSize: 0,
      offsetSize: 0,
      rowHeight: 0
    }
  };
}
/* harmony default export */ var list = (defineVxeComponent({
  name: 'VxeList',
  props: {
    data: Array,
    height: [Number, String],
    maxHeight: [Number, String],
    loading: Boolean,
    className: [String, Function],
    size: {
      type: String,
      default: () => getConfig().list.size || getConfig().size
    },
    autoResize: {
      type: Boolean,
      default: () => getConfig().list.autoResize
    },
    syncResize: [Boolean, String, Number],
    virtualYConfig: Object,
    scrollY: Object
  },
  emits: ['scroll'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const browseObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().browse();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      scrollYLoad: false,
      bodyHeight: 0,
      customHeight: 0,
      customMaxHeight: 0,
      parentHeight: 0,
      topSpaceHeight: 0,
      items: []
    });
    const internalData = list_createInternalData();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refVirtualWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refVirtualBody = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const $xeList = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const computeSYOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().list.virtualYConfig || getConfig().list.scrollY, props.virtualYConfig || props.scrollY);
    });
    const computeStyles = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        height,
        maxHeight
      } = props;
      const {
        customHeight,
        customMaxHeight
      } = reactData;
      const style = {};
      if (height) {
        style.height = `${customHeight}px`;
      } else if (maxHeight) {
        style.height = 'auto';
        style.maxHeight = `${customMaxHeight}px`;
      }
      return style;
    });
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $list: $xeList
      }, params));
    };
    const calcTableHeight = key => {
      const {
        parentHeight
      } = reactData;
      const val = props[key];
      let num = 0;
      if (val) {
        if (val === '100%' || val === 'auto') {
          num = parentHeight;
        } else {
          if (isScale(val)) {
            num = Math.floor((external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(val) || 1) / 100 * parentHeight);
          } else {
            num = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(val);
          }
          num = Math.max(40, num);
        }
      }
      return num;
    };
    const updateHeight = () => {
      reactData.customHeight = calcTableHeight('height');
      reactData.customMaxHeight = calcTableHeight('maxHeight');
    };
    const updateYSpace = () => {
      const {
        scrollYLoad
      } = reactData;
      const {
        scrollYStore,
        fullData
      } = internalData;
      reactData.bodyHeight = scrollYLoad ? fullData.length * scrollYStore.rowHeight : 0;
      reactData.topSpaceHeight = scrollYLoad ? Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0) : 0;
    };
    const handleData = () => {
      const {
        scrollYLoad
      } = reactData;
      const {
        fullData,
        scrollYStore
      } = internalData;
      reactData.items = scrollYLoad ? fullData.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullData.slice(0);
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const updateYData = () => {
      handleData();
      updateYSpace();
    };
    const computeScrollLoad = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          scrollYLoad
        } = reactData;
        const {
          scrollYStore
        } = internalData;
        const virtualBodyElem = refVirtualBody.value;
        const sYOpts = computeSYOpts.value;
        let rowHeight = 0;
        let firstItemElem;
        if (virtualBodyElem) {
          if (sYOpts.sItem) {
            firstItemElem = virtualBodyElem.querySelector(sYOpts.sItem);
          }
          if (!firstItemElem) {
            firstItemElem = virtualBodyElem.children[0];
          }
        }
        if (firstItemElem) {
          rowHeight = firstItemElem.offsetHeight;
        }
        rowHeight = Math.max(12, rowHeight);
        scrollYStore.rowHeight = rowHeight;
        // 计算 Y 逻辑
        if (scrollYLoad) {
          const scrollBodyElem = refVirtualWrapper.value;
          const visibleYSize = Math.max(8, Math.ceil(scrollBodyElem.clientHeight / rowHeight));
          const offsetYSize = sYOpts.oSize ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(sYOpts.oSize) : browseObj.edge ? 10 : 0;
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex + visibleYSize + offsetYSize, scrollYStore.endIndex);
          updateYData();
        } else {
          updateYSpace();
        }
      });
    };
    /**
     * 清除滚动条
     */
    const clearScroll = () => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        scrollBodyElem.scrollTop = 0;
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    /**
     * 如果有滚动条，则滚动到对应的位置
     */
    const scrollTo = (scrollLeft, scrollTop) => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollLeft) {
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollLeft)) {
          scrollTop = scrollLeft.top;
          scrollLeft = scrollLeft.left;
        }
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollLeft)) {
        scrollBodyElem.scrollLeft = scrollLeft;
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollTop)) {
        scrollBodyElem.scrollTop = scrollTop;
      }
      if (reactData.scrollYLoad) {
        return new Promise(resolve => {
          setTimeout(() => {
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              resolve();
            });
          }, 50);
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    /**
     * 刷新滚动条
     */
    const refreshScroll = () => {
      const {
        lastScrollLeft,
        lastScrollTop
      } = internalData;
      return clearScroll().then(() => {
        if (lastScrollLeft || lastScrollTop) {
          internalData.lastScrollLeft = 0;
          internalData.lastScrollTop = 0;
          return scrollTo(lastScrollLeft, lastScrollTop);
        }
      });
    };
    /**
     * 重新计算列表
     */
    const recalculate = () => {
      const el = refElem.value;
      if (el) {
        const parentEl = el.parentElement;
        reactData.parentHeight = parentEl ? parentEl.clientHeight : 0;
        updateHeight();
        if (el.clientWidth && el.clientHeight) {
          return computeScrollLoad();
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const loadYData = evnt => {
      const {
        scrollYStore
      } = internalData;
      const {
        startIndex,
        endIndex,
        visibleSize,
        offsetSize,
        rowHeight
      } = scrollYStore;
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const toVisibleIndex = Math.floor(scrollTop / rowHeight);
      const offsetStartIndex = Math.max(0, toVisibleIndex - 1 - offsetSize);
      const offsetEndIndex = toVisibleIndex + visibleSize + offsetSize;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          updateYData();
        }
      }
    };
    const scrollEvent = evnt => {
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = scrollBodyElem.scrollLeft;
      const isX = scrollLeft !== internalData.lastScrollLeft;
      const isY = scrollTop !== internalData.lastScrollTop;
      internalData.lastScrollTop = scrollTop;
      internalData.lastScrollLeft = scrollLeft;
      if (reactData.scrollYLoad) {
        loadYData(evnt);
      }
      dispatchEvent('scroll', {
        scrollLeft,
        scrollTop,
        isX,
        isY
      }, evnt);
    };
    /**
     * 加载数据
     * @param {Array} datas 数据
     */
    const loadData = datas => {
      const {
        scrollYStore
      } = internalData;
      const sYOpts = computeSYOpts.value;
      const fullData = datas || [];
      Object.assign(scrollYStore, {
        startIndex: 0,
        endIndex: 1,
        visibleSize: 0
      });
      internalData.fullData = fullData;
      // 如果gt为0，则总是启用
      reactData.scrollYLoad = !!sYOpts.enabled && sYOpts.gt > -1 && (sYOpts.gt === 0 || sYOpts.gt <= fullData.length);
      handleData();
      return computeScrollLoad().then(() => {
        refreshScroll();
      });
    };
    const listMethods = {
      dispatchEvent,
      loadData,
      /**
       * 重新加载数据
       * @param {Array} datas 数据
       */
      reloadData(datas) {
        clearScroll();
        return loadData(datas);
      },
      recalculate,
      scrollTo,
      refreshScroll,
      clearScroll
    };
    Object.assign($xeList, listMethods);
    const renderVN = () => {
      const {
        className,
        loading
      } = props;
      const {
        bodyHeight,
        topSpaceHeight,
        items
      } = reactData;
      const defaultSlot = slots.default;
      const vSize = computeSize.value;
      const styles = computeStyles.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-list', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $list: $xeList
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--loading': loading
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refVirtualWrapper,
        class: 'vxe-list--virtual-wrapper',
        style: styles,
        onScroll: scrollEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-list--y-space',
        style: {
          height: bodyHeight ? `${bodyHeight}px` : ''
        }
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refVirtualBody,
        class: 'vxe-list--body',
        style: {
          marginTop: topSpaceHeight ? `${topSpaceHeight}px` : ''
        }
      }, defaultSlot ? defaultSlot({
        items,
        $list: $xeList
      }) : [])]),
      /**
       * 加载中
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-list--loading',
        modelValue: loading
      })]);
    };
    const dataFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.data ? props.data.length : -1, () => {
      dataFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.data, () => {
      dataFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(dataFlag, () => {
      loadData(props.data || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.height, () => {
      recalculate();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.maxHeight, () => {
      recalculate();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.syncResize, value => {
      if (value) {
        recalculate();
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => setTimeout(() => recalculate()));
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onActivated)(() => {
      recalculate().then(() => refreshScroll());
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      loadData(props.data || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      recalculate();
      if (props.autoResize) {
        const el = refElem.value;
        const resizeObserver = globalResize.create(() => recalculate());
        resizeObserver.observe(el);
        if (el) {
          resizeObserver.observe(el.parentElement);
        }
        internalData.resizeObserver = resizeObserver;
      }
      globalEvents.on($xeList, 'resize', recalculate);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      const {
        resizeObserver
      } = internalData;
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      globalEvents.off($xeList, 'resize');
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign(internalData, list_createInternalData());
    });
    $xeList.renderVN = renderVN;
    return $xeList;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/list/index.ts



const VxeList = Object.assign(list, {
  install(app) {
    app.component(list.name, list);
  }
});
dynamicApp.use(VxeList);
index_esm_VxeUI.component(list);
const List = VxeList;
/* harmony default export */ var packages_list = (VxeList);
;// CONCATENATED MODULE: ./packages/menu/src/menu.ts








/* harmony default export */ var menu = (defineVxeComponent({
  name: 'VxeMenu',
  props: {
    modelValue: [String, Number],
    expandAll: Boolean,
    accordion: {
      type: Boolean,
      default: () => getConfig().menu.accordion
    },
    collapsed: {
      type: Boolean,
      default: null
    },
    collapseFixed: Boolean,
    loading: Boolean,
    options: {
      type: Array,
      default: () => []
    },
    size: {
      type: String,
      default: () => getConfig().menu.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'click'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeLayoutAside = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeLayoutAside', null);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refCollapseElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: !!props.collapsed,
      isEnterCollapse: false,
      collapseStyle: {},
      collapseZindex: 0,
      activeName: props.modelValue,
      menuList: [],
      itemHeight: 1
    });
    const refMaps = {
      refElem
    };
    const computeIsCollapsed = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        collapsed
      } = props;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(collapsed)) {
        return collapsed;
      }
      if ($xeLayoutAside) {
        return !!$xeLayoutAside.props.collapsed;
      }
      return false;
    });
    const computeCollapseWidth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      let collapseWidth = '';
      if ($xeLayoutAside) {
        collapseWidth = $xeLayoutAside.props.collapseWidth || '';
      }
      return collapseWidth;
    });
    const computeCollapseEnterWidth = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      let width = '';
      if ($xeLayoutAside) {
        width = $xeLayoutAside.props.width || '';
      }
      return width;
    });
    const computeMaps = {
      computeSize
    };
    const $xeMenu = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getMenuTitle = item => {
      return `${item.title || item.name}`;
    };
    const updateZindex = () => {
      if (reactData.collapseZindex < getLastZIndex()) {
        reactData.collapseZindex = nextZIndex();
      }
    };
    const updateActiveMenu = isDefExpand => {
      const {
        activeName
      } = reactData;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(reactData.menuList, (item, index, items, path, parent, nodes) => {
        if (item.itemKey === activeName) {
          nodes.forEach(obj => {
            obj.isActive = true;
            if (isDefExpand) {
              obj.isExpand = true;
            }
          });
          item.isExactActive = true;
        } else {
          item.isExactActive = false;
          item.isActive = false;
        }
      }, {
        children: 'childList'
      });
    };
    const updateMenuConfig = () => {
      const {
        options,
        expandAll
      } = props;
      reactData.menuList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().mapTree(options, (item, index, items, path, parent) => {
        const objItem = {
          ...item,
          parentKey: parent ? parent.name || path.slice(0, path.length - 1).join(',') : '',
          level: path.length,
          itemKey: item.name || path.join(','),
          isExactActive: false,
          isActive: false,
          isExpand: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(item.expanded) ? item.expanded : !!expandAll,
          hasChild: item.children && item.children.length > 0
        };
        return objItem;
      }, {
        children: 'children',
        mapChildren: 'childList'
      });
    };
    const updateCollapseStyle = () => {
      const {
        collapseFixed
      } = props;
      if (collapseFixed) {
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const {
            isEnterCollapse
          } = reactData;
          const isCollapsed = computeIsCollapsed.value;
          const collapseEnterWidth = computeCollapseEnterWidth.value;
          const collapseWidth = computeCollapseWidth.value;
          const el = refElem.value;
          if (el) {
            const clientRect = el.getBoundingClientRect();
            const parentNode = el.parentNode;
            reactData.collapseStyle = isCollapsed ? {
              top: toCssUnit(clientRect.top),
              left: toCssUnit(clientRect.left),
              height: toCssUnit(parentNode.clientHeight),
              width: isEnterCollapse ? collapseEnterWidth ? toCssUnit(collapseEnterWidth) : '' : collapseWidth ? toCssUnit(collapseWidth) : '',
              zIndex: reactData.collapseZindex
            } : {};
          }
        });
      }
    };
    const handleCollapseMenu = () => {
      const {
        collapseFixed
      } = props;
      if (collapseFixed) {
        const {
          initialized
        } = reactData;
        const isCollapsed = computeIsCollapsed.value;
        if (isCollapsed) {
          if (!initialized) {
            reactData.initialized = true;
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              const collapseEl = refCollapseElem.value;
              if (collapseEl) {
                document.body.appendChild(collapseEl);
              }
            });
          }
        }
        reactData.isEnterCollapse = false;
        updateZindex();
        updateCollapseStyle();
      }
    };
    const handleClickIconCollapse = (evnt, item, itemList) => {
      const {
        accordion
      } = props;
      const {
        hasChild,
        isExpand
      } = item;
      if (hasChild) {
        evnt.stopPropagation();
        evnt.preventDefault();
        if (accordion) {
          itemList.forEach(obj => {
            if (obj !== item) {
              obj.isExpand = false;
            }
          });
        }
        item.isExpand = !isExpand;
      }
    };
    const emitModel = value => {
      reactData.activeName = value;
      emit('update:modelValue', value);
    };
    const handleClickMenu = (evnt, item, itemList) => {
      const {
        itemKey,
        routerLink,
        hasChild
      } = item;
      if (routerLink) {
        emitModel(itemKey);
        handleMenuMouseleave();
      } else {
        if (hasChild) {
          handleClickIconCollapse(evnt, item, itemList);
        } else {
          emitModel(itemKey);
          handleMenuMouseleave();
        }
      }
      dispatchEvent('click', {
        menu: item
      }, evnt);
    };
    const handleMenuMouseenter = () => {
      const {
        collapseStyle
      } = reactData;
      const collapseEnterWidth = computeCollapseEnterWidth.value;
      reactData.collapseStyle = Object.assign({}, collapseStyle, {
        width: collapseEnterWidth ? toCssUnit(collapseEnterWidth) : ''
      });
      reactData.isEnterCollapse = true;
    };
    const handleMenuMouseover = () => {
      const {
        isEnterCollapse
      } = reactData;
      if (!isEnterCollapse) {
        handleMenuMouseenter();
      }
    };
    const handleMenuMouseleave = () => {
      const {
        collapseStyle
      } = reactData;
      const el = refElem.value;
      reactData.collapseStyle = Object.assign({}, collapseStyle, {
        width: el ? toCssUnit(el.offsetWidth) : ''
      });
      reactData.isEnterCollapse = false;
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
          return vn_getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $menu: $xeMenu
      }, params));
    };
    const menuMethods = {
      dispatchEvent
    };
    const menuPrivateMethods = {};
    Object.assign($xeMenu, menuMethods, menuPrivateMethods);
    const renderMenuTitle = (item, itemList) => {
      const {
        icon,
        isExpand,
        hasChild,
        slots: itemSlots
      } = item;
      const optionSlot = itemSlots ? itemSlots.default : slots.option;
      const title = getMenuTitle(item);
      const isCollapsed = computeIsCollapsed.value;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-menu--item-link-icon'
      }, icon ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon
      })] : []), optionSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-menu--item-custom-title'
      }, callSlot(optionSlot, {
        option: item,
        collapsed: isCollapsed
      })) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-menu--item-link-title',
        title
      }, title), hasChild ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-menu--item-link-collapse',
        onClick(evnt) {
          handleClickIconCollapse(evnt, item, itemList);
        }
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: isExpand ? getIcon().MENU_ITEM_EXPAND_OPEN : getIcon().MENU_ITEM_EXPAND_CLOSE
      })]) : renderEmptyElement($xeMenu)];
    };
    const renderDefaultChildren = (item, itemList) => {
      const {
        itemKey,
        level,
        hasChild,
        isActive,
        isExactActive,
        isExpand,
        routerLink,
        childList
      } = item;
      const {
        isEnterCollapse
      } = reactData;
      const isCollapsed = computeIsCollapsed.value;
      if (item.permissionCode) {
        if (!permission.checkVisible(item.permissionCode)) {
          return renderEmptyElement($xeMenu);
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: itemKey,
        class: ['vxe-menu--item-wrapper', `vxe-menu--item-level${level}`, {
          'is--exact-active': isExactActive,
          'is--active': isActive,
          'is--expand': (!isCollapsed || isEnterCollapse) && isExpand
        }]
      }, [routerLink ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('router-link'), {
        class: 'vxe-menu--item-link',
        to: routerLink,
        onClick(evnt) {
          handleClickMenu(evnt, item, itemList);
        }
      }, {
        default: () => renderMenuTitle(item, itemList)
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-menu--item-link',
        onClick(evnt) {
          handleClickMenu(evnt, item, itemList);
        }
      }, renderMenuTitle(item, itemList)), hasChild ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-menu--item-group'
      }, childList.map(child => renderDefaultChildren(child, childList))) : renderEmptyElement($xeMenu)]);
    };
    const renderCollapseChildren = (item, itemList) => {
      const {
        itemKey,
        level,
        hasChild,
        isActive,
        isExactActive,
        routerLink,
        childList
      } = item;
      if (item.permissionCode) {
        if (!permission.checkVisible(item.permissionCode)) {
          return renderEmptyElement($xeMenu);
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: itemKey,
        class: ['vxe-menu--item-wrapper', `vxe-menu--item-level${level}`, {
          'is--exact-active': isExactActive,
          'is--active': isActive
        }]
      }, [routerLink ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('router-link'), {
        class: 'vxe-menu--item-link',
        to: routerLink,
        onClick(evnt) {
          handleClickMenu(evnt, item, itemList);
        }
      }, {
        default: () => renderMenuTitle(item, itemList)
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-menu--item-link',
        onClick(evnt) {
          handleClickMenu(evnt, item, itemList);
        }
      }, renderMenuTitle(item, itemList)), hasChild ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-menu--item-group'
      }, childList.map(child => renderDefaultChildren(child, childList))) : renderEmptyElement($xeMenu)]);
    };
    const renderVN = () => {
      const {
        loading,
        collapseFixed
      } = props;
      const {
        initialized,
        menuList,
        collapseStyle,
        isEnterCollapse
      } = reactData;
      const vSize = computeSize.value;
      const isCollapsed = computeIsCollapsed.value;
      let ons = {};
      if (collapseFixed) {
        ons = {
          onMouseenter: handleMenuMouseenter,
          onMouseover: handleMenuMouseover,
          onMouseleave: handleMenuMouseleave
        };
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-menu', {
          [`size--${vSize}`]: vSize,
          'is--collapsed': isCollapsed,
          'is--loading': loading
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-menu--item-list'
      }, menuList.map(child => isCollapsed ? renderCollapseChildren(child, menuList) : renderDefaultChildren(child, menuList))), initialized ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refCollapseElem,
        class: ['vxe-menu--collapse-wrapper', {
          [`size--${vSize}`]: vSize,
          'is--collapsed': isCollapsed,
          'is--enter': isEnterCollapse,
          'is--loading': loading
        }],
        style: collapseStyle,
        ...ons
      }, [isCollapsed ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-menu--item-list'
      }, menuList.map(child => renderDefaultChildren(child, menuList))) : renderEmptyElement($xeMenu)]) : renderEmptyElement($xeMenu),
      /**
       * 加载中
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-list-view--loading',
        modelValue: loading
      })]);
    };
    const optFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options ? props.options.length : -1, () => {
      optFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options, () => {
      optFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(optFlag, () => {
      updateMenuConfig();
      updateActiveMenu(true);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.activeName = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.activeName, () => {
      updateActiveMenu(true);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeIsCollapsed, () => {
      handleCollapseMenu();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      globalEvents.on($xeMenu, 'resize', updateCollapseStyle);
      updateCollapseStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      globalEvents.off($xeMenu, 'resize');
      const collapseEl = refCollapseElem.value;
      if (collapseEl) {
        const parentNode = collapseEl.parentNode;
        if (parentNode) {
          parentNode.removeChild(collapseEl);
        }
      }
    });
    updateMenuConfig();
    updateActiveMenu(true);
    $xeMenu.renderVN = renderVN;
    return $xeMenu;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/menu/index.ts



const VxeMenu = Object.assign({}, menu, {
  install(app) {
    app.component(menu.name, menu);
  }
});
dynamicApp.use(VxeMenu);
index_esm_VxeUI.component(menu);
const Menu = VxeMenu;
/* harmony default export */ var packages_menu = (VxeMenu);
;// CONCATENATED MODULE: ./packages/modal/src/modal.ts











const allActiveModals = [];
const msgQueue = [];
const notifyQueue = [];
const lockScrollAttrKey = 'data-vxe-lock-scroll';
const lockScrollCssWidthKey = '--vxe-ui-modal-lock-scroll-view-width';
/* harmony default export */ var modal = (defineVxeComponent({
  name: 'VxeModal',
  props: {
    modelValue: Boolean,
    id: String,
    type: {
      type: String,
      default: 'modal'
    },
    loading: {
      type: Boolean,
      default: null
    },
    status: String,
    iconStatus: String,
    className: String,
    top: {
      type: [Number, String],
      default: () => getConfig().modal.top
    },
    position: [String, Object],
    title: String,
    duration: {
      type: [Number, String],
      default: () => getConfig().modal.duration
    },
    content: [Number, String],
    showCancelButton: {
      type: Boolean,
      default: null
    },
    cancelButtonText: {
      type: String,
      default: () => getConfig().modal.cancelButtonText
    },
    showConfirmButton: {
      type: Boolean,
      default: () => getConfig().modal.showConfirmButton
    },
    confirmButtonText: {
      type: String,
      default: () => getConfig().modal.confirmButtonText
    },
    lockView: {
      type: Boolean,
      default: () => getConfig().modal.lockView
    },
    lockScroll: Boolean,
    mask: {
      type: Boolean,
      default: () => getConfig().modal.mask
    },
    maskClosable: {
      type: Boolean,
      default: () => getConfig().modal.maskClosable
    },
    escClosable: {
      type: Boolean,
      default: () => getConfig().modal.escClosable
    },
    cancelClosable: {
      type: Boolean,
      default: () => getConfig().modal.cancelClosable
    },
    confirmClosable: {
      type: Boolean,
      default: () => getConfig().modal.confirmClosable
    },
    resize: Boolean,
    showHeader: {
      type: Boolean,
      default: () => getConfig().modal.showHeader
    },
    showFooter: {
      type: Boolean,
      default: () => getConfig().modal.showFooter
    },
    showZoom: Boolean,
    zoomConfig: Object,
    showMaximize: {
      type: Boolean,
      default: () => handleBooleanDefaultValue(getConfig().modal.showMaximize)
    },
    showMinimize: {
      type: Boolean,
      default: () => handleBooleanDefaultValue(getConfig().modal.showMinimize)
    },
    showClose: {
      type: Boolean,
      default: () => getConfig().modal.showClose
    },
    dblclickZoom: {
      type: Boolean,
      default: () => getConfig().modal.dblclickZoom
    },
    width: [Number, String],
    height: [Number, String],
    minWidth: {
      type: [Number, String],
      default: () => getConfig().modal.minWidth
    },
    minHeight: {
      type: [Number, String],
      default: () => getConfig().modal.minHeight
    },
    zIndex: Number,
    marginSize: {
      type: [Number, String],
      default: () => getConfig().modal.marginSize
    },
    fullscreen: Boolean,
    draggable: {
      type: Boolean,
      default: () => getConfig().modal.draggable
    },
    remember: {
      type: Boolean,
      default: () => getConfig().modal.remember
    },
    destroyOnClose: {
      type: Boolean,
      default: () => getConfig().modal.destroyOnClose
    },
    showTitleOverflow: {
      type: Boolean,
      default: () => getConfig().modal.showTitleOverflow
    },
    transfer: {
      type: Boolean,
      default: () => getConfig().modal.transfer
    },
    storage: {
      type: Boolean,
      default: () => getConfig().modal.storage
    },
    storageKey: {
      type: String,
      default: () => getConfig().modal.storageKey
    },
    padding: {
      type: Boolean,
      default: () => getConfig().modal.padding
    },
    size: {
      type: String,
      default: () => getConfig().modal.size || getConfig().size
    },
    beforeHideMethod: Function,
    slots: Object,
    /**
     * 已废弃
     * @deprecated
     */
    message: [Number, String],
    /**
     * 已废弃
     * @deprecated
     */
    animat: {
      type: Boolean,
      default: () => getConfig().modal.animat
    }
  },
  emits: ['update:modelValue', 'show', 'hide', 'before-hide', 'close', 'confirm', 'cancel', 'zoom', 'resize', 'move'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeParentModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      visible: false,
      contentVisible: false,
      modalTop: 0,
      modalZindex: 0,
      prevZoomStatus: '',
      zoomStatus: '',
      revertLocat: null,
      prevLocat: null,
      firstOpen: true,
      resizeFlag: 1
    });
    const internalData = {
      msgTimeout: undefined
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refModalBox = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeaderElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refConfirmBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refCancelBtn = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().modal.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeParentModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeIsMsg = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.type === 'message' || props.type === 'notification';
    });
    const computeIsMinimizeStatus = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return reactData.zoomStatus === 'minimize';
    });
    const computeIsMaximizeStatus = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return reactData.zoomStatus === 'maximize';
    });
    const computeZoomOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().modal.zoomConfig, props.zoomConfig);
    });
    const computeMaps = {
      computeSize,
      computeZoomOpts
    };
    const $xeModal = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    let modalMethods = {};
    const getBox = () => {
      const boxElem = refModalBox.value;
      return boxElem;
    };
    const recalculate = () => {
      const {
        width,
        height
      } = props;
      const boxElem = getBox();
      if (boxElem) {
        boxElem.style.width = width ? toCssUnit(width) : '';
        boxElem.style.height = height ? toCssUnit(height) : '';
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const updateZindex = () => {
      const {
        zIndex
      } = props;
      const {
        modalZindex
      } = reactData;
      if (zIndex) {
        reactData.modalZindex = zIndex;
      } else {
        const isMsg = computeIsMsg.value;
        if (isMsg) {
          if (modalZindex < getSubLastZIndex()) {
            reactData.modalZindex = nextSubZIndex();
          }
        } else {
          if (modalZindex < getLastZIndex()) {
            reactData.modalZindex = nextZIndex();
          }
        }
      }
    };
    const updatePosition = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          position
        } = props;
        const marginSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.marginSize);
        const boxElem = getBox();
        if (!boxElem) {
          return;
        }
        const clientVisibleWidth = document.documentElement.clientWidth || document.body.clientWidth;
        const clientVisibleHeight = document.documentElement.clientHeight || document.body.clientHeight;
        const isPosCenter = position === 'center';
        const {
          top,
          left
        } = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(position) ? {
          top: position,
          left: position
        } : Object.assign({}, position);
        const topCenter = isPosCenter || top === 'center';
        const leftCenter = isPosCenter || left === 'center';
        let posTop = '';
        let posLeft = '';
        if (left && !leftCenter) {
          posLeft = isNaN(left) ? left : `${left}px`;
        } else {
          posLeft = `${Math.max(marginSize, clientVisibleWidth / 2 - boxElem.offsetWidth / 2)}px`;
        }
        if (top && !topCenter) {
          posTop = isNaN(top) ? top : `${top}px`;
        } else {
          posTop = `${Math.max(marginSize, clientVisibleHeight / 2 - boxElem.offsetHeight / 2)}px`;
        }
        boxElem.style.top = posTop;
        boxElem.style.left = posLeft;
      });
    };
    const updateStyle = () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          type
        } = props;
        const queueList = type === 'notification' ? notifyQueue : msgQueue;
        let offsetTop = 0;
        queueList.forEach(comp => {
          const boxElem = comp.getBox();
          if (boxElem) {
            offsetTop += external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(comp.props.top);
            comp.reactData.modalTop = offsetTop;
            offsetTop += boxElem.clientHeight;
          }
        });
      });
    };
    const removeMsgQueue = () => {
      const {
        type
      } = props;
      const queueList = type === 'notification' ? notifyQueue : msgQueue;
      if (queueList.indexOf($xeModal) > -1) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(queueList, comp => comp === $xeModal);
      }
      updateStyle();
    };
    const closeModal = type => {
      const {
        remember
      } = props;
      const {
        visible
      } = reactData;
      const isMsg = computeIsMsg.value;
      const beforeHideFn = props.beforeHideMethod || getConfig().modal.beforeHideMethod;
      const params = {
        type
      };
      if (visible) {
        Promise.resolve(beforeHideFn ? beforeHideFn(params) : null).then(rest => {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isError(rest)) {
            if (isMsg) {
              removeMsgQueue();
            }
            reactData.contentVisible = false;
            if (!remember) {
              handleRevert();
            }
            external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().remove(allActiveModals, item => item === $xeModal);
            dispatchEvent('before-hide', params, null);
            setTimeout(() => {
              reactData.visible = false;
              emit('update:modelValue', false);
              dispatchEvent('hide', params, null);
            }, 200);
            removeBodyLockScroll();
          }
        }).catch(e => e);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const closeEvent = evnt => {
      const type = 'close';
      dispatchEvent(type, {
        type
      }, evnt);
      closeModal(type);
    };
    const confirmEvent = evnt => {
      const {
        confirmClosable
      } = props;
      const type = 'confirm';
      dispatchEvent(type, {
        type
      }, evnt);
      if (confirmClosable) {
        closeModal(type);
      }
    };
    const cancelEvent = evnt => {
      const {
        cancelClosable
      } = props;
      const type = 'cancel';
      dispatchEvent(type, {
        type
      }, evnt);
      if (cancelClosable) {
        closeModal(type);
      }
    };
    const getStorageMap = key => {
      const version = getConfig().version;
      const rest = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toStringJSON(localStorage.getItem(key) || '');
      return rest && rest._v === version ? rest : {
        _v: version
      };
    };
    const hasPosStorage = () => {
      const {
        id,
        storage,
        storageKey
      } = props;
      return !!(id && storage && getStorageMap(storageKey)[id]);
    };
    const restorePosStorage = () => {
      const {
        id,
        storage,
        storageKey
      } = props;
      if (id && storage) {
        const posStorage = getStorageMap(storageKey)[id];
        if (posStorage) {
          const boxElem = getBox();
          const [left, top, width, height, zoomLeft, zoomTop, zoomWidth, zoomHeight] = posStorage.split(',');
          if (boxElem) {
            if (left) {
              boxElem.style.left = `${left}px`;
            }
            if (top) {
              boxElem.style.top = `${top}px`;
            }
            if (width) {
              boxElem.style.width = `${width}px`;
            }
            if (height) {
              boxElem.style.height = `${height}px`;
            }
          }
          if (zoomLeft && zoomTop) {
            reactData.revertLocat = {
              left: zoomLeft,
              top: zoomTop,
              width: zoomWidth,
              height: zoomHeight
            };
          }
        }
      }
    };
    const addMsgQueue = () => {
      const {
        type
      } = props;
      const queueList = type === 'notification' ? notifyQueue : msgQueue;
      if (queueList.indexOf($xeModal) === -1) {
        queueList.push($xeModal);
      }
      updateStyle();
    };
    const savePosStorage = () => {
      const {
        id,
        storage,
        storageKey
      } = props;
      const {
        zoomStatus,
        revertLocat
      } = reactData;
      if (zoomStatus) {
        return;
      }
      if (id && storage) {
        const boxElem = getBox();
        if (!boxElem) {
          return;
        }
        const posStorageMap = getStorageMap(storageKey);
        posStorageMap[id] = [boxElem.style.left, boxElem.style.top, boxElem.style.width, boxElem.style.height].concat(revertLocat ? [revertLocat.left, revertLocat.top, revertLocat.width, revertLocat.height] : []).map(val => val ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(val) : '').join(',');
        localStorage.setItem(storageKey, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toJSONString(posStorageMap));
      }
    };
    const handleMinimize = () => {
      const zoomOpts = computeZoomOpts.value;
      const {
        minimizeLayout,
        minimizeMaxSize,
        minimizeHorizontalOffset,
        minimizeVerticalOffset,
        minimizeOffsetMethod
      } = zoomOpts;
      const isHorizontalLayout = minimizeLayout === 'horizontal';
      const prevZoomStatus = reactData.zoomStatus;
      const hlMList = [];
      const vlMList = [];
      allActiveModals.forEach(item => {
        if (item.xID !== $xeModal.xID && item.props.type === 'modal' && item.reactData.zoomStatus === 'minimize') {
          const itemZoomOpts = item.getComputeMaps().computeZoomOpts.value;
          if (itemZoomOpts.minimizeLayout === 'horizontal') {
            hlMList.push(item);
          } else {
            vlMList.push(item);
          }
        }
      });
      const mList = isHorizontalLayout ? hlMList : vlMList;
      // 如果配置最小化最大数量
      if (minimizeMaxSize && mList.length >= minimizeMaxSize) {
        if (index_esm_VxeUI.modal) {
          index_esm_VxeUI.modal.message({
            status: 'error',
            content: getI18n('vxe.modal.miniMaxSize', [minimizeMaxSize])
          });
        }
        return Promise.resolve({
          status: false
        });
      }
      reactData.prevZoomStatus = prevZoomStatus;
      reactData.zoomStatus = 'minimize';
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const boxElem = getBox();
        if (!boxElem) {
          return {
            status: false
          };
        }
        const headerEl = refHeaderElem.value;
        if (!headerEl) {
          return {
            status: false
          };
        }
        const {
          visibleHeight
        } = getDomNode();
        // 如果当前处于复原状态
        if (!prevZoomStatus) {
          reactData.revertLocat = {
            top: boxElem.offsetTop,
            left: boxElem.offsetLeft,
            width: boxElem.offsetWidth + (boxElem.style.width ? 0 : 1),
            height: boxElem.offsetHeight + (boxElem.style.height ? 0 : 1)
          };
        }
        const targetModal = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default())[isHorizontalLayout ? 'max' : 'min'](mList, $modal => {
          const boxElem = $modal.getBox();
          return boxElem ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(boxElem.style[isHorizontalLayout ? 'left' : 'top']) : 0;
        });
        let targetTop = visibleHeight - headerEl.offsetHeight - 16;
        let targetLeft = 16;
        if (targetModal) {
          const minBoxElem = targetModal.getBox();
          if (minBoxElem) {
            const boxLeft = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(minBoxElem.style.left);
            const boxTop = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(minBoxElem.style.top);
            let offsetObj = {};
            if (isHorizontalLayout) {
              offsetObj = Object.assign({}, minimizeHorizontalOffset);
            } else {
              offsetObj = Object.assign({}, minimizeVerticalOffset);
            }
            targetLeft = boxLeft + external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(offsetObj.left);
            targetTop = boxTop + external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(offsetObj.top);
            if (minimizeOffsetMethod) {
              offsetObj = minimizeOffsetMethod({
                $modal: $xeModal,
                left: targetLeft,
                top: targetTop
              });
              targetLeft = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(offsetObj.left);
              targetTop = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(offsetObj.top);
            }
          }
        }
        Object.assign(boxElem.style, {
          top: `${targetTop}px`,
          left: `${targetLeft}px`,
          width: '200px',
          height: `${headerEl.offsetHeight}px`
        });
        savePosStorage();
        return {
          status: true
        };
      });
    };
    const handleMaximize = () => {
      const prevZoomStatus = reactData.zoomStatus;
      reactData.prevZoomStatus = prevZoomStatus;
      reactData.zoomStatus = 'maximize';
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const boxElem = getBox();
        if (boxElem) {
          // 如果当前处于复原状态
          if (!prevZoomStatus) {
            const marginSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.marginSize);
            const clientVisibleWidth = document.documentElement.clientWidth || document.body.clientWidth;
            const clientVisibleHeight = document.documentElement.clientHeight || document.body.clientHeight;
            reactData.revertLocat = {
              top: Math.max(marginSize, clientVisibleHeight / 2 - boxElem.offsetHeight / 2),
              left: Math.max(marginSize, clientVisibleWidth / 2 - boxElem.offsetWidth / 2),
              width: boxElem.offsetWidth + (boxElem.style.width ? 0 : 1),
              height: boxElem.offsetHeight + (boxElem.style.height ? 0 : 1)
            };
          }
          Object.assign(boxElem.style, {
            top: '0',
            left: '0',
            width: '100%',
            height: '100%'
          });
        }
        savePosStorage();
        return {
          status: true
        };
      });
    };
    const handleMsgAutoClose = () => {
      const {
        duration
      } = props;
      if (duration !== -1) {
        internalData.msgTimeout = setTimeout(() => closeModal('close'), external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(duration));
      }
    };
    const removeBodyLockScroll = () => {
      const htmlElem = document.documentElement;
      const lockData = htmlElem.getAttribute(lockScrollAttrKey);
      if (lockData) {
        const lockList = lockData.split(',').filter(key => key !== xID);
        if (lockList.length) {
          htmlElem.setAttribute(lockScrollAttrKey, lockList.join(','));
        } else {
          htmlElem.removeAttribute(lockScrollAttrKey);
          htmlElem.style.removeProperty(lockScrollCssWidthKey);
        }
      }
    };
    const addBodyLockScroll = () => {
      const {
        lockScroll
      } = props;
      const isMsg = computeIsMsg.value;
      if (lockScroll && !isMsg) {
        const htmlElem = document.documentElement;
        const clientWidth = document.body.clientWidth;
        const lockData = htmlElem.getAttribute(lockScrollAttrKey);
        const lockList = lockData ? lockData.split(',') : [];
        if (!lockList.includes(xID)) {
          lockList.push(xID);
          htmlElem.setAttribute(lockScrollAttrKey, lockList.join(','));
        }
        htmlElem.style.setProperty(lockScrollCssWidthKey, `${clientWidth}px`);
      }
    };
    const openModal = () => {
      const {
        remember,
        showFooter
      } = props;
      const {
        initialized,
        visible
      } = reactData;
      const isMsg = computeIsMsg.value;
      if (!initialized) {
        reactData.initialized = true;
      }
      if (!visible) {
        addBodyLockScroll();
        reactData.visible = true;
        reactData.contentVisible = false;
        updateZindex();
        allActiveModals.push($xeModal);
        setTimeout(() => {
          reactData.contentVisible = true;
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            if (showFooter) {
              const confirmBtn = refConfirmBtn.value;
              const cancelBtn = refCancelBtn.value;
              const operBtn = confirmBtn || cancelBtn;
              if (operBtn) {
                operBtn.focus();
              }
            }
            const type = '';
            const params = {
              type
            };
            emit('update:modelValue', true);
            dispatchEvent('show', params, null);
          });
        }, 10);
        if (isMsg) {
          addMsgQueue();
          handleMsgAutoClose();
        } else {
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            const {
              fullscreen
            } = props;
            const {
              firstOpen
            } = reactData;
            if (firstOpen) {
              reactData.firstOpen = false;
              if (hasPosStorage()) {
                restorePosStorage();
              } else {
                if (fullscreen) {
                  (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => handleMaximize());
                } else {
                  recalculate();
                  updatePosition().then(() => {
                    setTimeout(() => updatePosition(), 20);
                  });
                }
              }
            } else {
              if (!remember) {
                recalculate();
                updatePosition().then(() => {
                  setTimeout(() => updatePosition(), 20);
                });
              }
            }
          });
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const selfClickEvent = evnt => {
      const el = refElem.value;
      if (props.maskClosable && evnt.target === el) {
        const type = 'mask';
        closeModal(type);
      }
    };
    const selfMouseoverEvent = () => {
      const {
        msgTimeout
      } = internalData;
      if (!msgTimeout) {
        return;
      }
      const isMsg = computeIsMsg.value;
      if (isMsg) {
        clearTimeout(msgTimeout);
        internalData.msgTimeout = undefined;
      }
    };
    const selfMouseoutEvent = () => {
      const {
        msgTimeout
      } = internalData;
      if (!msgTimeout) {
        const isMsg = computeIsMsg.value;
        if (isMsg) {
          handleMsgAutoClose();
        }
      }
    };
    const handleGlobalKeydownEvent = evnt => {
      const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
      if (isEsc) {
        const lastModal = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().max(allActiveModals, item => item.reactData.modalZindex);
        // 多个时，只关掉最上层的窗口
        if (lastModal) {
          setTimeout(() => {
            if (lastModal === $xeModal && lastModal.props.escClosable) {
              const type = 'exit';
              dispatchEvent('close', {
                type
              }, evnt);
              closeModal(type);
            }
          }, 10);
        }
      }
    };
    const isMinimized = () => {
      return reactData.zoomStatus === 'minimize';
    };
    const isMaximized = () => {
      return reactData.zoomStatus === 'maximize';
    };
    const handleRevert = () => {
      reactData.prevZoomStatus = reactData.zoomStatus;
      reactData.zoomStatus = '';
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          revertLocat
        } = reactData;
        if (revertLocat) {
          const boxElem = getBox();
          reactData.revertLocat = null;
          if (boxElem) {
            Object.assign(boxElem.style, {
              top: `${revertLocat.top}px`,
              left: `${revertLocat.left}px`,
              width: `${revertLocat.width}px`,
              height: `${revertLocat.height}px`
            });
          }
          savePosStorage();
          return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
            return {
              status: true
            };
          });
        }
        return {
          status: false
        };
      });
    };
    const handleZoom = type => {
      const {
        zoomStatus
      } = reactData;
      return new Promise(resolve => {
        if (type) {
          if (type === 'maximize') {
            resolve(handleMaximize());
            return;
          }
          if (type === 'minimize') {
            resolve(handleMinimize());
            return;
          }
          resolve(handleRevert());
          return;
        }
        resolve(zoomStatus ? handleRevert() : handleMaximize());
      }).then(() => {
        return reactData.zoomStatus || 'revert';
      });
    };
    const toggleZoomMinEvent = evnt => {
      const {
        zoomStatus,
        prevZoomStatus
      } = reactData;
      return handleZoom(zoomStatus === 'minimize' ? prevZoomStatus || 'revert' : 'minimize').then(type => {
        const params = {
          type
        };
        dispatchEvent('zoom', params, evnt);
      });
    };
    const toggleZoomMaxEvent = evnt => {
      return handleZoom().then(type => {
        const params = {
          type
        };
        dispatchEvent('zoom', params, evnt);
      });
    };
    const getPosition = () => {
      const isMsg = computeIsMsg.value;
      if (!isMsg) {
        const boxElem = getBox();
        if (boxElem) {
          return {
            top: boxElem.offsetTop,
            left: boxElem.offsetLeft
          };
        }
      }
      return null;
    };
    const setPosition = (top, left) => {
      const isMsg = computeIsMsg.value;
      if (!isMsg) {
        const boxElem = getBox();
        if (boxElem) {
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(top)) {
            boxElem.style.top = `${top}px`;
          }
          if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(left)) {
            boxElem.style.left = `${left}px`;
          }
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const boxMousedownEvent = () => {
      const {
        modalZindex
      } = reactData;
      if (allActiveModals.some(comp => comp.reactData.visible && comp.reactData.modalZindex > modalZindex)) {
        updateZindex();
      }
    };
    const mousedownEvent = evnt => {
      const {
        storage
      } = props;
      const {
        zoomStatus
      } = reactData;
      const marginSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.marginSize);
      const boxElem = getBox();
      if (!boxElem) {
        return;
      }
      if (zoomStatus !== 'maximize' && evnt.button === 0 && !getEventTargetNode(evnt, boxElem, 'trigger--btn').flag) {
        evnt.preventDefault();
        const disX = evnt.clientX - boxElem.offsetLeft;
        const disY = evnt.clientY - boxElem.offsetTop;
        const {
          visibleHeight,
          visibleWidth
        } = getDomNode();
        document.onmousemove = evnt => {
          evnt.preventDefault();
          const offsetWidth = boxElem.offsetWidth;
          const offsetHeight = boxElem.offsetHeight;
          const minX = marginSize;
          const maxX = visibleWidth - offsetWidth - marginSize - 1;
          const minY = marginSize;
          const maxY = visibleHeight - offsetHeight - marginSize - 1;
          let left = evnt.clientX - disX;
          let top = evnt.clientY - disY;
          if (left > maxX) {
            left = maxX;
          }
          if (left < minX) {
            left = minX;
          }
          if (top > maxY) {
            top = maxY;
          }
          if (top < minY) {
            top = minY;
          }
          boxElem.style.left = `${left}px`;
          boxElem.style.top = `${top}px`;
          boxElem.className = boxElem.className.replace(/\s?is--drag/, '') + ' is--drag';
          dispatchEvent('move', {
            type: 'move'
          }, evnt);
          reactData.resizeFlag++;
        };
        document.onmouseup = () => {
          document.onmousemove = null;
          document.onmouseup = null;
          if (storage) {
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              savePosStorage();
            });
          }
          reactData.resizeFlag++;
          setTimeout(() => {
            boxElem.className = boxElem.className.replace(/\s?is--drag/, '');
          }, 50);
        };
      }
    };
    const dragEvent = evnt => {
      evnt.preventDefault();
      const {
        storage
      } = props;
      const {
        visibleHeight,
        visibleWidth
      } = getDomNode();
      const marginSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.marginSize);
      const targetElem = evnt.target;
      const type = targetElem.getAttribute('type');
      const minWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.minWidth);
      const minHeight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.minHeight);
      const maxWidth = visibleWidth;
      const maxHeight = visibleHeight;
      const boxElem = getBox();
      const clientWidth = boxElem.clientWidth;
      const clientHeight = boxElem.clientHeight;
      const disX = evnt.clientX;
      const disY = evnt.clientY;
      const offsetTop = boxElem.offsetTop;
      const offsetLeft = boxElem.offsetLeft;
      const params = {
        type: 'resize'
      };
      document.onmousemove = evnt => {
        evnt.preventDefault();
        let dragLeft;
        let dragTop;
        let width;
        let height;
        switch (type) {
          case 'wl':
            dragLeft = disX - evnt.clientX;
            width = dragLeft + clientWidth;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            break;
          case 'swst':
            dragLeft = disX - evnt.clientX;
            dragTop = disY - evnt.clientY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case 'swlb':
            dragLeft = disX - evnt.clientX;
            dragTop = evnt.clientY - disY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case 'st':
            dragTop = disY - evnt.clientY;
            height = clientHeight + dragTop;
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case 'wr':
            dragLeft = evnt.clientX - disX;
            width = dragLeft + clientWidth;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            break;
          case 'sest':
            dragLeft = evnt.clientX - disX;
            dragTop = disY - evnt.clientY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case 'selb':
            dragLeft = evnt.clientX - disX;
            dragTop = evnt.clientY - disY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case 'sb':
            dragTop = evnt.clientY - disY;
            height = dragTop + clientHeight;
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
        }
        boxElem.className = boxElem.className.replace(/\s?is--drag/, '') + ' is--drag';
        if (storage) {
          savePosStorage();
        }
        dispatchEvent('resize', params, evnt);
      };
      document.onmouseup = () => {
        reactData.revertLocat = null;
        document.onmousemove = null;
        document.onmouseup = null;
        setTimeout(() => {
          boxElem.className = boxElem.className.replace(/\s?is--drag/, '');
        }, 50);
      };
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $modal: $xeModal
      }, params));
    };
    modalMethods = {
      dispatchEvent,
      open: openModal,
      close() {
        return closeModal('close');
      },
      getBox,
      getPosition,
      setPosition,
      isMinimized,
      isMaximized,
      zoom() {
        return handleZoom();
      },
      minimize() {
        if (!reactData.visible) {
          return Promise.resolve({
            status: false
          });
        }
        return handleMinimize();
      },
      maximize() {
        if (!reactData.visible) {
          return Promise.resolve({
            status: false
          });
        }
        return handleMaximize();
      },
      revert() {
        if (!reactData.visible) {
          return Promise.resolve({
            status: false
          });
        }
        return handleRevert();
      }
    };
    Object.assign($xeModal, modalMethods);
    const renderTitles = () => {
      const {
        slots: propSlots = {},
        showClose,
        showZoom,
        showMaximize,
        showMinimize,
        title
      } = props;
      const {
        zoomStatus
      } = reactData;
      const titleSlot = slots.title || propSlots.title;
      const cornerSlot = slots.corner || propSlots.corner;
      const isMinimizeStatus = computeIsMinimizeStatus.value;
      const isMaximizeStatus = computeIsMaximizeStatus.value;
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--header-title'
      }, titleSlot ? vn_getSlotVNs(titleSlot({
        $modal: $xeModal,
        minimized: isMinimizeStatus,
        maximized: isMaximizeStatus
      })) : title ? getFuncText(title) : getI18n('vxe.alert.title')), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--header-right'
      }, [cornerSlot && !isMinimizeStatus ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--corner-wrapper'
      }, vn_getSlotVNs(cornerSlot({
        $modal: $xeModal
      }))) : renderEmptyElement($xeModal), (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(showMinimize) ? showMinimize : showZoom) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-modal--zoom-btn', 'trigger--btn'],
        title: getI18n(`vxe.modal.zoom${zoomStatus === 'minimize' ? 'Out' : 'Min'}`),
        onClick: toggleZoomMinEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: zoomStatus === 'minimize' ? getIcon().MODAL_ZOOM_REVERT : getIcon().MODAL_ZOOM_MIN
      })]) : renderEmptyElement($xeModal), (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(showMaximize) ? showMaximize : showZoom) && zoomStatus !== 'minimize' ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-modal--zoom-btn', 'trigger--btn'],
        title: getI18n(`vxe.modal.zoom${zoomStatus === 'maximize' ? 'Out' : 'In'}`),
        onClick: toggleZoomMaxEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: zoomStatus === 'maximize' ? getIcon().MODAL_ZOOM_OUT : getIcon().MODAL_ZOOM_IN
      })]) : renderEmptyElement($xeModal), showClose ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-modal--close-btn', 'trigger--btn'],
        title: getI18n('vxe.modal.close'),
        onClick: closeEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().MODAL_CLOSE
      })]) : renderEmptyElement($xeModal)])];
    };
    const renderHeader = () => {
      const {
        slots: propSlots = {},
        showZoom,
        showMaximize,
        draggable
      } = props;
      const headerSlot = slots.header || propSlots.header;
      if (props.showHeader) {
        const headerOns = {};
        if (draggable) {
          headerOns.onMousedown = mousedownEvent;
        }
        if ((external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(showMaximize) ? showMaximize : showZoom) && props.dblclickZoom && props.type === 'modal') {
          headerOns.onDblclick = toggleZoomMaxEvent;
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refHeaderElem,
          class: ['vxe-modal--header', {
            'is--ellipsis': props.showTitleOverflow
          }],
          ...headerOns
        }, headerSlot ? vn_getSlotVNs(headerSlot({
          $modal: $xeModal
        })) : renderTitles());
      }
      return renderEmptyElement($xeModal);
    };
    const renderBody = () => {
      const {
        slots: propSlots = {},
        status,
        message,
        iconStatus
      } = props;
      const content = props.content || message;
      const isMsg = computeIsMsg.value;
      const defaultSlot = slots.default || propSlots.default;
      const leftSlot = slots.left || propSlots.left;
      const rightSlot = slots.right || propSlots.right;
      const contVNs = [];
      if (!isMsg && (status || iconStatus)) {
        contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-modal--status-wrapper'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-modal--status-icon', iconStatus || getIcon()[`MODAL_${status}`.toLocaleUpperCase()]]
        })]));
      }
      contVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--content'
      }, defaultSlot ? vn_getSlotVNs(defaultSlot({
        $modal: $xeModal
      })) : getFuncText(content)));
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--body'
      }, [leftSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--body-left'
      }, vn_getSlotVNs(leftSlot({
        $modal: $xeModal
      }))) : renderEmptyElement($xeModal), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--body-default'
      }, contVNs), rightSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--body-right'
      }, vn_getSlotVNs(rightSlot({
        $modal: $xeModal
      }))) : renderEmptyElement($xeModal), isMsg ? renderEmptyElement($xeModal) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(loading, {
        class: 'vxe-modal--loading',
        modelValue: props.loading
      })]);
    };
    const renderDefaultFooter = () => {
      const {
        slots: propSlots = {},
        showCancelButton,
        showConfirmButton,
        type,
        loading
      } = props;
      const lfSlot = slots.leftfoot || propSlots.leftfoot;
      const rfSlot = slots.rightfoot || propSlots.rightfoot;
      const btnVNs = [];
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(showCancelButton) ? showCancelButton : type === 'confirm') {
        btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          key: 1,
          ref: refCancelBtn,
          content: props.cancelButtonText || getI18n('vxe.button.cancel'),
          onClick: cancelEvent
        }));
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(showConfirmButton) ? showConfirmButton : type === 'confirm' || type === 'alert') {
        btnVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          key: 2,
          ref: refConfirmBtn,
          loading: loading,
          status: 'primary',
          content: props.confirmButtonText || getI18n('vxe.button.confirm'),
          onClick: confirmEvent
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--footer-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--footer-left'
      }, lfSlot ? vn_getSlotVNs(lfSlot({
        $modal: $xeModal
      })) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--footer-right'
      }, rfSlot ? vn_getSlotVNs(rfSlot({
        $modal: $xeModal
      })) : btnVNs)]);
    };
    const renderFooter = () => {
      const {
        slots: propSlots = {}
      } = props;
      const footerSlot = slots.footer || propSlots.footer;
      if (props.showFooter) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-modal--footer'
        }, footerSlot ? vn_getSlotVNs(footerSlot({
          $modal: $xeModal
        })) : [renderDefaultFooter()]);
      }
      return renderEmptyElement($xeModal);
    };
    const renderVN = () => {
      const {
        slots: propSlots = {},
        className,
        type,
        animat,
        draggable,
        iconStatus,
        position,
        loading,
        destroyOnClose,
        status,
        lockScroll,
        padding,
        lockView,
        mask,
        resize
      } = props;
      const {
        initialized,
        modalTop,
        contentVisible,
        visible,
        zoomStatus
      } = reactData;
      const asideSlot = slots.aside || propSlots.aside;
      const vSize = computeSize.value;
      const isMsg = computeIsMsg.value;
      const isMinimizeStatus = computeIsMinimizeStatus.value;
      const btnTransfer = computeBtnTransfer.value;
      const ons = {};
      if (isMsg) {
        ons.onMouseover = selfMouseoverEvent;
        ons.onMouseout = selfMouseoutEvent;
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: btnTransfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-modal--wrapper', `type--${type}`, `zoom--${zoomStatus || 'revert'}`, className || '', position ? `pos--${position}` : '', {
          [`size--${vSize}`]: vSize,
          [`status--${status}`]: status,
          'is--padding': padding,
          'is--animat': animat,
          'lock--scroll': lockScroll,
          'lock--view': lockView,
          'is--draggable': draggable,
          'is--resize': resize,
          'is--mask': mask,
          'is--visible': contentVisible,
          'is--active': visible,
          'is--loading': loading
        }],
        style: {
          zIndex: reactData.modalZindex,
          top: modalTop ? `${modalTop}px` : null
        },
        onClick: selfClickEvent,
        ...ons
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refModalBox,
        class: 'vxe-modal--box',
        onMousedown: boxMousedownEvent
      }, [(isMsg || asideSlot) && !isMinimizeStatus ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--aside'
      }, asideSlot ? vn_getSlotVNs(asideSlot({
        $modal: $xeModal
      })) : [status || iconStatus ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--status-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-modal--status-icon', iconStatus || getIcon()[`MODAL_${status}`.toLocaleUpperCase()]]
      })]) : renderEmptyElement($xeModal)]) : renderEmptyElement($xeModal), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-modal--container'
      }, !reactData.initialized || destroyOnClose && !reactData.visible ? [] : [renderHeader(), renderBody(), renderFooter(), !isMsg && resize ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-modal--resize'
      }, ['wl', 'wr', 'swst', 'sest', 'st', 'swlb', 'selb', 'sb'].map(type => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: `${type}-resize`,
          type: type,
          onMousedown: dragEvent
        });
      })) : renderEmptyElement($xeModal)])])])]);
    };
    $xeModal.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.width, recalculate);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.height, recalculate);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, value => {
      if (value) {
        openModal();
      } else {
        closeModal('model');
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      if (props.type === 'modal' && props.showFooter && !(props.showConfirmButton || props.showCancelButton || slots.footer)) {
        warnLog('vxe.modal.footPropErr');
      }
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        if (props.storage && !props.id) {
          errLog('vxe.error.reqProp', ['modal.id']);
        }
        if (props.modelValue) {
          openModal();
        }
        recalculate();
      });
      if (props.escClosable) {
        globalEvents.on($xeModal, 'keydown', handleGlobalKeydownEvent);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeModal, 'keydown');
      removeMsgQueue();
      removeBodyLockScroll();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeModal', $xeModal);
    return $xeModal;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/modal/index.ts





function handleModal(options) {
  // 使用动态组件渲染动态弹框
  checkDynamic();
  return new Promise(resolve => {
    const opts = Object.assign({}, options);
    if (opts.id && allActiveModals.some(comp => comp.props.id === opts.id)) {
      resolve('exist');
    } else {
      const _onHide = opts.onHide;
      const modalOpts = Object.assign(opts, {
        key: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId(),
        modelValue: true,
        onHide(params) {
          const modalList = dynamicStore.modals;
          if (_onHide) {
            _onHide(params);
          }
          dynamicStore.modals = modalList.filter(item => item.key !== modalOpts.key);
          resolve(params.type);
        }
      });
      dynamicStore.modals.push(modalOpts);
    }
  });
}
function getModal(id) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().find(allActiveModals, $modal => $modal.props.id === id);
}
/**
 * 全局关闭动态的活动窗口（只能用于关闭动态的创建的活动窗口）
 * 如果传 id 则关闭指定的窗口
 * 如果不传则关闭所有窗口
 */
function closeModal(id) {
  const modals = id ? [getModal(id)] : allActiveModals;
  const restPromises = [];
  modals.forEach($modal => {
    if ($modal) {
      restPromises.push($modal.close());
    }
  });
  return Promise.all(restPromises);
}
function handleOpen(defOpts, content, title, options) {
  let opts;
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isObject(content)) {
    opts = content;
  } else {
    opts = {
      content: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content),
      title
    };
  }
  return handleModal({
    ...defOpts,
    ...options,
    ...opts
  });
}
function openModal(options) {
  return handleOpen({
    type: 'modal'
  }, options);
}
function openAlert(content, title, options) {
  return handleOpen({
    type: 'alert',
    lockScroll: true,
    showHeader: true,
    showFooter: true
  }, content, title, options);
}
function openConfirm(content, title, options) {
  return handleOpen({
    type: 'confirm',
    status: 'question',
    lockScroll: true,
    showHeader: true,
    showFooter: true
  }, content, title, options);
}
function openMessage(content, options) {
  return handleOpen({
    type: 'message',
    mask: false,
    lockView: false,
    lockScroll: false,
    showHeader: false
  }, content, '', options);
}
function openNotification(content, title, options) {
  return handleOpen({
    type: 'notification',
    mask: false,
    lockView: false,
    lockScroll: false,
    showHeader: true,
    draggable: false,
    position: 'top-right',
    width: 320
  }, content, title, options);
}
const ModalController = {
  get: getModal,
  close: closeModal,
  open: openModal,
  alert: openAlert,
  confirm: openConfirm,
  message: openMessage,
  notification: openNotification
};
const VxeModal = Object.assign(modal, {
  install: function (app) {
    app.component(modal.name, modal);
  }
});
index_esm_VxeUI.modal = ModalController;
dynamicApp.use(VxeModal);
index_esm_VxeUI.component(modal);
const Modal = VxeModal;
/* harmony default export */ var packages_modal = (VxeModal);
;// CONCATENATED MODULE: ./packages/notice-bar/src/notice-bar.ts





/* harmony default export */ var notice_bar = (defineVxeComponent({
  name: 'VxeNoticeBar',
  props: {
    duration: [String, Number],
    direction: {
      type: String,
      default: () => getConfig().noticeBar.direction
    },
    speed: {
      type: String,
      default: () => getConfig().noticeBar.speed
    },
    content: String,
    vertical: Boolean,
    loop: {
      type: Boolean
    },
    size: {
      type: String,
      default: () => getConfig().noticeBar.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeTabs = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTabs', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refContentElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      animationDuration: 0
    });
    const refMaps = {
      refElem
    };
    const computeNoticeText = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        content
      } = props;
      return `${content || ''}`;
    });
    const computeTabsResizeFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return $xeTabs ? $xeTabs.reactData.resizeFlag : null;
    });
    const computeMaps = {};
    const $xeNoticeBar = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $noticeBar: $xeNoticeBar
      }, params));
    };
    const noticeBarMethods = {
      dispatchEvent
    };
    const noticeBarPrivateMethods = {};
    const updateAnimationStyle = () => {
      const {
        speed
      } = props;
      const contEl = refContentElem.value;
      if (contEl) {
        let sRate = 46;
        if (speed === 'fast') {
          sRate = 118;
        } else if (speed === 'slow') {
          sRate = 18;
        }
        reactData.animationDuration = Math.ceil(contEl.scrollWidth / sRate);
      }
    };
    Object.assign($xeNoticeBar, noticeBarMethods, noticeBarPrivateMethods);
    const renderVN = () => {
      const {
        vertical,
        duration,
        direction
      } = props;
      const {
        animationDuration
      } = reactData;
      const vSize = computeSize.value;
      const noticeText = computeNoticeText.value;
      const defaultSlot = slots.default;
      const prefixSlot = slots.prefix;
      const suffixSlot = slots.suffix;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-notice-bar', `is--${vertical ? 'vertical' : 'horizontal'}`, `dir--${direction || 'left'}`, {
          [`size--${vSize}`]: vSize
        }]
      }, [prefixSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-notice-bar--prefix'
      }, prefixSlot({})) : renderEmptyElement($xeNoticeBar), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-notice-bar--content'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refContentElem,
        class: 'vxe-notice-bar--inner'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-notice-bar--wrapper',
        style: {
          animationDuration: duration ? toCssUnit(duration, 's') : `${animationDuration}s`
        }
      }, defaultSlot ? defaultSlot({}) : noticeText)])]), suffixSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-notice-bar--suffix'
      }, suffixSlot({})) : renderEmptyElement($xeNoticeBar)]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeTabsResizeFlag, () => {
      updateAnimationStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      globalEvents.on($xeNoticeBar, 'resize', updateAnimationStyle);
      updateAnimationStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      globalEvents.off($xeNoticeBar, 'resize');
    });
    $xeNoticeBar.renderVN = renderVN;
    return $xeNoticeBar;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/notice-bar/index.ts



const VxeNoticeBar = Object.assign({}, notice_bar, {
  install(app) {
    app.component(notice_bar.name, notice_bar);
  }
});
dynamicApp.use(VxeNoticeBar);
index_esm_VxeUI.component(notice_bar);
const NoticeBar = VxeNoticeBar;
/* harmony default export */ var packages_notice_bar = (VxeNoticeBar);
;// CONCATENATED MODULE: ./packages/number-input/index.ts



const VxeNumberInput = Object.assign({}, number_input, {
  install(app) {
    app.component(number_input.name, number_input);
  }
});
dynamicApp.use(VxeNumberInput);
index_esm_VxeUI.component(number_input);
const NumberInput = VxeNumberInput;
/* harmony default export */ var packages_number_input = (VxeNumberInput);
;// CONCATENATED MODULE: ./packages/select/src/option-info.ts

class OptionInfo {
  constructor($xeselect, _vm) {
    Object.assign(this, {
      id: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('option_'),
      value: _vm.value,
      label: _vm.label,
      visible: _vm.visible,
      className: _vm.className,
      disabled: _vm.disabled
    });
  }
  update(name, value) {
    this[name] = value;
  }
}
;// CONCATENATED MODULE: ./packages/select/src/util.ts



function isOption(option) {
  return option instanceof OptionInfo;
}
function createOption($xeSelect, _vm) {
  return isOption(_vm) ? _vm : new OptionInfo($xeSelect, _vm);
}
function watchOption(props, option) {
  Object.keys(props).forEach(name => {
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props[name], value => {
      option.update(name, value);
    });
  });
}
function assembleOption($xeSelect, el, option, $xeOptgroup) {
  const {
    reactData
  } = $xeSelect;
  const {
    staticOptions
  } = reactData;
  const parentElem = el.parentNode;
  const parentOption = $xeOptgroup ? $xeOptgroup.optionConfig : null;
  const parentCols = parentOption ? parentOption.options : staticOptions;
  if (parentElem && parentCols) {
    parentCols.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, el), 0, option);
    reactData.staticOptions = staticOptions.slice(0);
  }
}
function destroyOption($xeSelect, option) {
  const {
    reactData
  } = $xeSelect;
  const {
    staticOptions
  } = reactData;
  const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(staticOptions, item => item.id === option.id, {
    children: 'options'
  });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  reactData.staticOptions = staticOptions.slice(0);
}
;// CONCATENATED MODULE: ./packages/select/src/optgroup.ts



/* harmony default export */ var optgroup = (defineVxeComponent({
  name: 'VxeOptgroup',
  props: {
    label: {
      type: [String, Number, Boolean],
      default: ''
    },
    visible: {
      type: Boolean,
      default: null
    },
    className: [String, Function],
    disabled: Boolean
  },
  emits: [],
  setup(props, {
    slots
  }) {
    const elem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeSelect = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeSelect', {});
    const optionConfig = createOption($xeSelect, props);
    const $xeOptgroup = {
      optionConfig
    };
    optionConfig.options = [];
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeOptgroup', $xeOptgroup);
    watchOption(props, optionConfig);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const el = elem.value;
      assembleOption($xeSelect, el, optionConfig);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      destroyOption($xeSelect, optionConfig);
    });
    return () => {
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: elem
      }, defaultSlot ? defaultSlot({}) : []);
    };
  }
}));
;// CONCATENATED MODULE: ./packages/optgroup/index.ts



const VxeOptgroup = Object.assign(optgroup, {
  install: function (app) {
    app.component(optgroup.name, optgroup);
  }
});
dynamicApp.use(VxeOptgroup);
index_esm_VxeUI.component(optgroup);
const Optgroup = VxeOptgroup;
/* harmony default export */ var packages_optgroup = (VxeOptgroup);
;// CONCATENATED MODULE: ./packages/select/src/option.ts



/* harmony default export */ var src_option = (defineVxeComponent({
  name: 'VxeOption',
  props: {
    value: [String, Number, Boolean],
    label: {
      type: [String, Number, Boolean],
      default: ''
    },
    visible: {
      type: Boolean,
      default: null
    },
    className: [String, Function],
    disabled: Boolean
  },
  emits: [],
  setup(props, {
    slots
  }) {
    const elem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeSelect = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeSelect', {});
    const $xeOptgroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeOptgroup', null);
    const optionConfig = createOption($xeSelect, props);
    optionConfig.slots = slots;
    watchOption(props, optionConfig);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const el = elem.value;
      assembleOption($xeSelect, el, optionConfig, $xeOptgroup);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      destroyOption($xeSelect, optionConfig);
    });
    return () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: elem
      });
    };
  }
}));
;// CONCATENATED MODULE: ./packages/option/index.ts



const VxeOption = Object.assign(src_option, {
  install: function (app) {
    app.component(src_option.name, src_option);
  }
});
dynamicApp.use(VxeOption);
index_esm_VxeUI.component(src_option);
const Option = VxeOption;
/* harmony default export */ var packages_option = (VxeOption);
;// CONCATENATED MODULE: ./packages/select/src/select.ts










function isOptionVisible(option) {
  return option.visible !== false;
}
function getOptUniqueId() {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('opt_');
}
function select_createInternalData() {
  return {
    synchData: [],
    fullData: [],
    afterVisibleList: [],
    optAddMaps: {},
    optGroupKeyMaps: {},
    optFullValMaps: {},
    remoteValMaps: {},
    lastScrollLeft: 0,
    lastScrollTop: 0,
    scrollYStore: {
      startIndex: 0,
      endIndex: 0,
      visibleSize: 0,
      offsetSize: 0,
      rowHeight: 0
    },
    lastScrollTime: 0,
    hpTimeout: undefined
  };
}
/* harmony default export */ var src_select = (defineVxeComponent({
  name: 'VxeSelect',
  props: {
    modelValue: [String, Number, Boolean, Array],
    defaultConfig: Object,
    clearable: Boolean,
    placeholder: String,
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    multiple: Boolean,
    multiCharOverflow: {
      type: [Number, String],
      default: () => getConfig().select.multiCharOverflow
    },
    prefixIcon: String,
    allowCreate: {
      type: Boolean,
      default: () => getConfig().select.allowCreate
    },
    placement: String,
    options: Array,
    optionProps: Object,
    optionGroups: Array,
    optionGroupProps: Object,
    optionConfig: Object,
    className: [String, Function],
    popupClassName: [String, Function],
    max: {
      type: [String, Number],
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().select.size || getConfig().size
    },
    filterable: Boolean,
    filterMethod: Function,
    remote: Boolean,
    remoteConfig: Object,
    emptyText: String,
    showTotalButoon: {
      type: Boolean,
      default: () => getConfig().select.showTotalButoon
    },
    showCheckedButoon: {
      type: Boolean,
      default: () => getConfig().select.showCheckedButoon
    },
    showClearButton: {
      type: Boolean,
      default: () => getConfig().select.showClearButton
    },
    transfer: {
      type: Boolean,
      default: null
    },
    virtualYConfig: Object,
    scrollY: Object,
    /**
     * 已废弃，被 remote-config.queryMethod 替换
     * @deprecated
     */
    remoteMethod: Function,
    /**
     * 已废弃，被 option-config.keyField 替换
     * @deprecated
     */
    optionId: {
      type: String,
      default: () => getConfig().select.optionId
    },
    /**
     * 已废弃，被 option-config.useKey 替换
     * @deprecated
     */
    optionKey: Boolean
  },
  emits: ['update:modelValue', 'change', 'all-change', 'clear', 'blur', 'focus', 'click', 'scroll', 'visible-change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInput = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInpSearch = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refVirtualWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refOptionPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refVirtualBody = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      scrollYLoad: false,
      bodyHeight: 0,
      topSpaceHeight: 0,
      optList: [],
      staticOptions: [],
      reactFlag: 0,
      currentOption: null,
      searchValue: '',
      searchLoading: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = select_createInternalData();
    const refMaps = {
      refElem
    };
    const $xeSelect = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().select.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().select.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n('vxe.base.pleaseSelect');
    });
    const computeDefaultOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, props.defaultConfig);
    });
    const computePropsOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, props.optionProps);
    });
    const computeGroupPropsOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, props.optionGroupProps);
    });
    const computeLabelField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || 'label';
    });
    const computeValueField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || 'value';
    });
    const computeGroupLabelField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const groupPropsOpts = computeGroupPropsOpts.value;
      return groupPropsOpts.label || 'label';
    });
    const computeGroupOptionsField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const groupPropsOpts = computeGroupPropsOpts.value;
      return groupPropsOpts.options || 'options';
    });
    const computeIsMaximize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue
      } = props;
      return checkMaxLimit(modelValue);
    });
    const computeVirtualYOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().select.virtualYConfig || getConfig().select.scrollY, props.virtualYConfig || props.scrollY);
    });
    const computeRemoteOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().select.remoteConfig, props.remoteConfig);
    });
    const computeOptionOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().select.optionConfig, props.optionConfig);
    });
    const computeMultiMaxCharNum = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.multiCharOverflow);
    });
    const computeSelectLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue,
        remote,
        multiple
      } = props;
      const {
        reactFlag
      } = reactData;
      const multiMaxCharNum = computeMultiMaxCharNum.value;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(modelValue)) {
        return '';
      }
      const vals = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue : [modelValue];
      if (remote && reactFlag) {
        return vals.map(val => getRemoteSelectLabel(val)).join(', ');
      }
      return vals.map(val => {
        const label = getSelectLabel(val);
        if (multiple && multiMaxCharNum > 0 && label.length > multiMaxCharNum) {
          return `${label.substring(0, multiMaxCharNum)}...`;
        }
        return label;
      }).join(', ');
    });
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
          return vn_getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $select: $xeSelect
      }, params));
    };
    const emitModel = value => {
      emit('update:modelValue', value);
    };
    const getOptKey = () => {
      const optionOpts = computeOptionOpts.value;
      return optionOpts.keyField || props.optionId || '_X_OPTION_KEY';
    };
    const getOptId = option => {
      const optid = option[getOptKey()];
      return optid ? encodeURIComponent(optid) : '';
    };
    const checkMaxLimit = selectVals => {
      const {
        multiple,
        max
      } = props;
      if (multiple && max) {
        return (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(selectVals) ? selectVals.length : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(selectVals) ? 0 : 1) >= external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(max);
      }
      return false;
    };
    const getRemoteSelectLabel = value => {
      const {
        remoteValMaps,
        optFullValMaps
      } = internalData;
      const labelField = computeLabelField.value;
      const remoteItem = remoteValMaps[value] || optFullValMaps[value];
      const item = remoteItem ? remoteItem.item : null;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(item ? item[labelField] : value);
    };
    const getSelectLabel = value => {
      const {
        optFullValMaps
      } = internalData;
      const labelField = computeLabelField.value;
      const cacheItem = reactData.reactFlag ? optFullValMaps[value] : null;
      return cacheItem ? cacheItem.item[labelField] : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(value);
    };
    const cacheItemMap = datas => {
      const groupOptionsField = computeGroupOptionsField.value;
      const valueField = computeValueField.value;
      const key = getOptKey();
      const groupKeyMaps = {};
      const fullKeyMaps = {};
      const list = [];
      const handleOptItem = item => {
        list.push(item);
        let optid = getOptId(item);
        if (!optid) {
          optid = getOptUniqueId();
          item[key] = optid;
        }
        fullKeyMaps[item[valueField]] = {
          key: optid,
          item,
          _index: -1
        };
      };
      datas.forEach(group => {
        handleOptItem(group);
        if (group[groupOptionsField]) {
          groupKeyMaps[group[key]] = group;
          group[groupOptionsField].forEach(handleOptItem);
        }
      });
      internalData.fullData = list;
      internalData.optGroupKeyMaps = groupKeyMaps;
      internalData.optFullValMaps = fullKeyMaps;
      reactData.reactFlag++;
      handleOption();
    };
    /**
     * 处理选项，当选项被动态显示/隐藏时可能会用到
     */
    const handleOption = () => {
      const {
        modelValue,
        filterable,
        filterMethod
      } = props;
      const {
        searchValue
      } = reactData;
      const {
        fullData,
        optFullValMaps
      } = internalData;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const searchStr = `${searchValue || ''}`.toLowerCase();
      let avList = [];
      if (filterable && filterMethod) {
        avList = fullData.filter(option => isOptionVisible(option) && filterMethod({
          $select: $xeSelect,
          group: null,
          option,
          searchValue,
          value: modelValue
        }));
      } else if (filterable) {
        avList = fullData.filter(option => isOptionVisible(option) && (!searchStr || `${option[labelField] || option[valueField]}`.toLowerCase().indexOf(searchStr) > -1));
      } else {
        avList = fullData.filter(isOptionVisible);
      }
      avList.forEach((item, index) => {
        const cacheItem = optFullValMaps[item[valueField]];
        if (cacheItem) {
          cacheItem._index = index;
        }
      });
      internalData.afterVisibleList = avList;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const setCurrentOption = option => {
      if (option) {
        reactData.currentOption = option;
      }
    };
    const updateZIndex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      const {
        placement
      } = props;
      const {
        panelIndex
      } = reactData;
      const targetElem = refElem.value;
      const panelElem = refOptionPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(handleStyle);
    };
    const showOptionPanel = () => {
      const {
        loading,
        filterable,
        remote
      } = props;
      const {
        fullData,
        hpTimeout
      } = internalData;
      const isDisabled = computeIsDisabled.value;
      const remoteOpts = computeRemoteOpts.value;
      if (!loading && !isDisabled) {
        if (hpTimeout) {
          clearTimeout(hpTimeout);
          internalData.hpTimeout = undefined;
        }
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (filterable) {
          if (remote && remoteOpts.enabled && remoteOpts.autoLoad && !fullData.length) {
            handleSearchEvent();
          } else {
            handleOption();
            updateYData();
          }
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
          handleFocusSearch();
          recalculate().then(() => refreshScroll());
        }, 10);
        setTimeout(() => {
          recalculate().then(() => refreshScroll());
        }, 100);
        updateZIndex();
        updatePlacement();
        dispatchEvent('visible-change', {
          visible: true
        }, null);
      }
    };
    const hideOptionPanel = () => {
      reactData.searchValue = '';
      reactData.searchLoading = false;
      reactData.visiblePanel = false;
      internalData.hpTimeout = setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
      dispatchEvent('visible-change', {
        visible: false
      }, null);
    };
    const changeEvent = (evnt, selectValue, option) => {
      emitModel(selectValue);
      if (selectValue !== props.modelValue) {
        dispatchEvent('change', {
          value: selectValue,
          option
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      internalData.remoteValMaps = {};
      changeEvent(evnt, selectValue, null);
      dispatchEvent('clear', {
        value: selectValue
      }, evnt);
    };
    const clearEvent = params => {
      const {
        $event
      } = params;
      clearValueEvent($event, null);
      hideOptionPanel();
    };
    const allCheckedPanelEvent = params => {
      const {
        $event
      } = params;
      const {
        modelValue,
        multiple,
        max
      } = props;
      const {
        optList
      } = reactData;
      const valueField = computeValueField.value;
      if (multiple) {
        const multipleValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(modelValue) ? [] : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue : [modelValue];
        for (let i = 0; i < optList.length; i++) {
          const option = optList[i];
          const selectValue = option[valueField];
          // 检测是否超过最大可选数量
          if (checkMaxLimit(multipleValue)) {
            if (index_esm_VxeUI) {
              index_esm_VxeUI.modal.message({
                content: getI18n('vxe.select.overSizeErr', [max]),
                status: 'warning'
              });
            }
            break;
          }
          if (!multipleValue.some(val => val === selectValue)) {
            multipleValue.push(selectValue);
          }
        }
        changeEvent($event, multipleValue, optList[0]);
        dispatchEvent('all-change', {
          value: multipleValue
        }, $event);
        hideOptionPanel();
      }
    };
    const clearCheckedPanelEvent = params => {
      const {
        $event
      } = params;
      clearValueEvent($event, null);
      hideOptionPanel();
    };
    const changeOptionEvent = (evnt, option) => {
      const {
        modelValue,
        multiple
      } = props;
      const {
        remoteValMaps
      } = internalData;
      const valueField = computeValueField.value;
      const selectValue = option[valueField];
      const remoteItem = remoteValMaps[selectValue];
      if (!reactData.visiblePanel) {
        return;
      }
      if (remoteItem) {
        remoteItem.item = option;
      } else {
        remoteValMaps[selectValue] = {
          key: getOptId(option),
          item: option,
          _index: -1
        };
      }
      if (multiple) {
        let multipleValue = [];
        const selectVals = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(modelValue) ? [] : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue : [modelValue];
        const index = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(selectVals, val => val === selectValue);
        if (index === -1) {
          multipleValue = selectVals.concat([selectValue]);
        } else {
          multipleValue = selectVals.filter(val => val !== selectValue);
        }
        changeEvent(evnt, multipleValue, option);
      } else {
        changeEvent(evnt, selectValue, option);
        hideOptionPanel();
      }
      reactData.reactFlag++;
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const validOffsetOption = option => {
      const isDisabled = option.disabled;
      const optid = getOptId(option);
      if (!isDisabled && !hasOptGroupById(optid)) {
        return true;
      }
      return false;
    };
    const findOffsetOption = (option, isDwArrow) => {
      const {
        allowCreate
      } = props;
      const {
        optList
      } = reactData;
      const {
        optFullValMaps,
        optAddMaps,
        afterVisibleList
      } = internalData;
      const valueField = computeValueField.value;
      let fullList = afterVisibleList;
      let offsetAddIndex = 0;
      if (allowCreate && optList.length) {
        const firstItem = optList[0];
        const optid = getOptId(firstItem);
        if (optAddMaps[optid]) {
          offsetAddIndex = 1;
          fullList = [optAddMaps[optid]].concat(fullList);
        }
      }
      if (!option) {
        if (isDwArrow) {
          for (let i = 0; i < fullList.length; i++) {
            const item = fullList[i];
            if (validOffsetOption(item)) {
              return item;
            }
          }
        } else {
          for (let len = fullList.length - 1; len >= 0; len--) {
            const item = fullList[len];
            if (validOffsetOption(item)) {
              return item;
            }
          }
        }
      }
      let avIndex = 0;
      const cacheItem = option ? optFullValMaps[option[valueField]] : null;
      if (cacheItem) {
        avIndex = cacheItem._index + offsetAddIndex;
      }
      if (avIndex > -1) {
        if (isDwArrow) {
          for (let i = avIndex + 1; i <= fullList.length - 1; i++) {
            const item = fullList[i];
            if (validOffsetOption(item)) {
              return item;
            }
          }
        } else {
          if (avIndex > 0) {
            for (let len = avIndex - 1; len >= 0; len--) {
              const item = fullList[len];
              if (validOffsetOption(item)) {
                return item;
              }
            }
          }
        }
      }
      return null;
    };
    const handleGlobalKeydownEvent = evnt => {
      const {
        clearable
      } = props;
      const {
        visiblePanel,
        currentOption
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hideOptionPanel();
          } else if (isEnter) {
            if (currentOption) {
              evnt.preventDefault();
              evnt.stopPropagation();
              changeOptionEvent(evnt, currentOption);
            }
          } else if (isUpArrow || isDwArrow) {
            evnt.preventDefault();
            let offsetOption = findOffsetOption(currentOption, isDwArrow);
            // 如果不匹配，默认最接近一个
            if (!offsetOption) {
              offsetOption = findOffsetOption(null, isDwArrow);
            }
            if (offsetOption) {
              setCurrentOption(offsetOption);
              handleScrollToOption(offsetOption, isDwArrow);
            }
          }
        } else if ((isUpArrow || isDwArrow || isEnter) && reactData.isActivated) {
          evnt.preventDefault();
          showOptionPanel();
        }
        if (reactData.isActivated) {
          if (isDel && clearable) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const {
        visiblePanel,
        isActivated
      } = reactData;
      if (visiblePanel) {
        hideOptionPanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        const $input = refInput.value;
        if ($input) {
          $input.blur();
        }
      }
    };
    const handleGlobalResizeEvent = () => {
      const {
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    const handleFocusSearch = () => {
      if (props.filterable) {
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const inpSearch = refInpSearch.value;
          if (inpSearch) {
            inpSearch.focus();
          }
        });
      }
    };
    const focusEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          reactData.triggerFocusPanel = true;
          showOptionPanel();
          setTimeout(() => {
            reactData.triggerFocusPanel = false;
          }, 500);
        }
      }
      dispatchEvent('focus', {}, evnt);
    };
    const clickEvent = evnt => {
      togglePanelEvent(evnt);
      dispatchEvent('click', {
        triggerButton: false,
        visible: reactData.visiblePanel
      }, evnt);
    };
    const blurEvent = evnt => {
      reactData.isActivated = false;
      dispatchEvent('blur', {}, evnt);
    };
    const suffixClickEvent = evnt => {
      togglePanelEvent(evnt);
      dispatchEvent('click', {
        triggerButton: true,
        visible: reactData.visiblePanel
      }, evnt);
    };
    const modelSearchEvent = value => {
      reactData.searchValue = value;
    };
    const focusSearchEvent = () => {
      reactData.isActivated = true;
    };
    const handleSearchEvent = () => {
      const {
        modelValue,
        remote,
        remoteMethod
      } = props;
      const {
        searchValue
      } = reactData;
      const remoteOpts = computeRemoteOpts.value;
      const queryMethod = remoteOpts.queryMethod || remoteMethod;
      if (remote && queryMethod && remoteOpts.enabled) {
        reactData.searchLoading = true;
        Promise.resolve(queryMethod({
          $select: $xeSelect,
          searchValue,
          value: modelValue
        })).then(() => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)()).catch(() => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)()).finally(() => {
          reactData.searchLoading = false;
          handleOption();
          updateYData();
        });
      } else {
        handleOption();
        updateYData();
      }
    };
    const triggerSearchEvent = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().debounce(handleSearchEvent, 350, {
      trailing: true
    });
    const togglePanelEvent = params => {
      const {
        $event
      } = params;
      $event.preventDefault();
      if (reactData.triggerFocusPanel) {
        reactData.triggerFocusPanel = false;
      } else {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
      }
    };
    const checkOptionDisabled = (isSelected, option) => {
      if (option.disabled) {
        return true;
      }
      const isMaximize = computeIsMaximize.value;
      if (isMaximize && !isSelected) {
        return true;
      }
      return false;
    };
    const updateYSpace = () => {
      const {
        scrollYLoad
      } = reactData;
      const {
        scrollYStore,
        afterVisibleList
      } = internalData;
      reactData.bodyHeight = scrollYLoad ? afterVisibleList.length * scrollYStore.rowHeight : 0;
      reactData.topSpaceHeight = scrollYLoad ? Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0) : 0;
    };
    const handleData = () => {
      const {
        filterable,
        allowCreate
      } = props;
      const {
        scrollYLoad,
        searchValue
      } = reactData;
      const {
        optAddMaps,
        scrollYStore,
        afterVisibleList
      } = internalData;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const restList = scrollYLoad ? afterVisibleList.slice(scrollYStore.startIndex, scrollYStore.endIndex) : afterVisibleList.slice(0);
      if (filterable && allowCreate && searchValue) {
        if (!restList.some(option => option[labelField] === searchValue)) {
          const addItem = optAddMaps[searchValue] || (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
            [getOptKey()]: searchValue,
            [labelField]: searchValue,
            [valueField]: searchValue
          });
          optAddMaps[searchValue] = addItem;
          restList.unshift(addItem);
        }
      }
      reactData.optList = restList;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const updateYData = () => {
      handleData();
      updateYSpace();
    };
    const computeScrollLoad = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          scrollYLoad
        } = reactData;
        const {
          scrollYStore
        } = internalData;
        const virtualBodyElem = refVirtualBody.value;
        const virtualYOpts = computeVirtualYOpts.value;
        let rowHeight = 0;
        let firstItemElem;
        if (virtualBodyElem) {
          if (!firstItemElem) {
            firstItemElem = virtualBodyElem.children[0];
          }
        }
        if (firstItemElem) {
          rowHeight = firstItemElem.offsetHeight;
        }
        rowHeight = Math.max(20, rowHeight);
        scrollYStore.rowHeight = rowHeight;
        // 计算 Y 逻辑
        if (scrollYLoad) {
          const scrollBodyElem = refVirtualWrapper.value;
          const visibleYSize = Math.max(8, scrollBodyElem ? Math.ceil(scrollBodyElem.clientHeight / rowHeight) : 0);
          const offsetYSize = Math.max(0, Math.min(2, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(virtualYOpts.oSize)));
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex, visibleYSize + offsetYSize, scrollYStore.endIndex);
          updateYData();
        } else {
          updateYSpace();
        }
      });
    };
    const handleScrollToOption = (option, isDwArrow) => {
      const {
        scrollYLoad
      } = reactData;
      const {
        optFullValMaps,
        scrollYStore
      } = internalData;
      const valueField = computeValueField.value;
      const cacheItem = optFullValMaps[option[valueField]];
      if (cacheItem) {
        const optid = cacheItem.key;
        const avIndex = cacheItem._index;
        if (avIndex > -1) {
          const optWrapperElem = refVirtualWrapper.value;
          const panelElem = refOptionPanel.value;
          if (!panelElem) {
            return;
          }
          const optElem = panelElem.querySelector(`[optid='${optid}']`);
          if (optWrapperElem) {
            if (optElem) {
              const wrapperHeight = optWrapperElem.offsetHeight;
              const offsetPadding = 1;
              if (isDwArrow) {
                if (optElem.offsetTop + optElem.offsetHeight - optWrapperElem.scrollTop > wrapperHeight) {
                  optWrapperElem.scrollTop = optElem.offsetTop + optElem.offsetHeight - wrapperHeight;
                } else if (optElem.offsetTop + offsetPadding < optWrapperElem.scrollTop || optElem.offsetTop + offsetPadding > optWrapperElem.scrollTop + optWrapperElem.clientHeight) {
                  optWrapperElem.scrollTop = optElem.offsetTop - offsetPadding;
                }
              } else {
                if (optElem.offsetTop + offsetPadding < optWrapperElem.scrollTop || optElem.offsetTop + offsetPadding > optWrapperElem.scrollTop + optWrapperElem.clientHeight) {
                  optWrapperElem.scrollTop = optElem.offsetTop - offsetPadding;
                } else if (optElem.offsetTop + optElem.offsetHeight - optWrapperElem.scrollTop > wrapperHeight) {
                  optWrapperElem.scrollTop = optElem.offsetTop + optElem.offsetHeight - wrapperHeight;
                }
              }
            } else if (scrollYLoad) {
              if (isDwArrow) {
                optWrapperElem.scrollTop = avIndex * scrollYStore.rowHeight - optWrapperElem.clientHeight + scrollYStore.rowHeight;
              } else {
                optWrapperElem.scrollTop = avIndex * scrollYStore.rowHeight;
              }
            }
          }
        }
      }
    };
    /**
     * 如果有滚动条，则滚动到对应的位置
     * @param {Number} scrollLeft 左距离
     * @param {Number} scrollTop 上距离
     */
    const scrollTo = (scrollLeft, scrollTop) => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollLeft)) {
          scrollBodyElem.scrollLeft = scrollLeft;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollTop)) {
          scrollBodyElem.scrollTop = scrollTop;
        }
      }
      if (reactData.scrollYLoad) {
        return new Promise(resolve => {
          setTimeout(() => {
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              resolve();
            });
          }, 50);
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    /**
     * 刷新滚动条
     */
    const refreshScroll = () => {
      const {
        lastScrollLeft,
        lastScrollTop
      } = internalData;
      return clearScroll().then(() => {
        if (lastScrollLeft || lastScrollTop) {
          internalData.lastScrollLeft = 0;
          internalData.lastScrollTop = 0;
          return scrollTo(lastScrollLeft, lastScrollTop);
        }
      });
    };
    /**
     * 重新计算列表
     */
    const recalculate = () => {
      const el = refElem.value;
      if (el && el.clientWidth && el.clientHeight) {
        return computeScrollLoad();
      }
      return Promise.resolve();
    };
    const loadYData = evnt => {
      const {
        scrollYStore
      } = internalData;
      const {
        startIndex,
        endIndex,
        visibleSize,
        offsetSize,
        rowHeight
      } = scrollYStore;
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const toVisibleIndex = Math.floor(scrollTop / rowHeight);
      const offsetStartIndex = Math.max(0, toVisibleIndex - 1 - offsetSize);
      const offsetEndIndex = toVisibleIndex + visibleSize + offsetSize;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          updateYData();
        }
      }
    };
    // 滚动、拖动过程中不需要触发
    const isVMScrollProcess = () => {
      const delayHover = 250;
      const {
        lastScrollTime
      } = internalData;
      return !!(lastScrollTime && Date.now() < lastScrollTime + delayHover);
    };
    const scrollEvent = evnt => {
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = scrollBodyElem.scrollLeft;
      const isX = scrollLeft !== internalData.lastScrollLeft;
      const isY = scrollTop !== internalData.lastScrollTop;
      internalData.lastScrollTop = scrollTop;
      internalData.lastScrollLeft = scrollLeft;
      if (reactData.scrollYLoad) {
        loadYData(evnt);
      }
      internalData.lastScrollTime = Date.now();
      dispatchEvent('scroll', {
        scrollLeft,
        scrollTop,
        isX,
        isY
      }, evnt);
    };
    /**
     * 加载数据
     * @param {Array} datas 数据
     */
    const loadData = datas => {
      cacheItemMap(datas || []);
      const {
        isLoaded,
        fullData,
        scrollYStore
      } = internalData;
      const defaultOpts = computeDefaultOpts.value;
      const virtualYOpts = computeVirtualYOpts.value;
      const valueField = computeValueField.value;
      Object.assign(scrollYStore, {
        startIndex: 0,
        endIndex: 1,
        visibleSize: 0
      });
      internalData.synchData = datas || [];
      // 如果gt为0，则总是启用
      reactData.scrollYLoad = !!virtualYOpts.enabled && virtualYOpts.gt > -1 && (virtualYOpts.gt === 0 || virtualYOpts.gt <= fullData.length);
      handleData();
      if (!isLoaded) {
        const {
          selectMode
        } = defaultOpts;
        if (datas.length > 0 && external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(props.modelValue)) {
          if (selectMode === 'first' || selectMode === 'last') {
            const selectItem = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default())[selectMode](datas);
            if (selectItem) {
              (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
                if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(props.modelValue)) {
                  emitModel(selectItem[valueField]);
                }
              });
            }
          }
          internalData.isLoaded = true;
        }
      }
      return computeScrollLoad().then(() => {
        refreshScroll();
      });
    };
    const clearScroll = () => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        scrollBodyElem.scrollTop = 0;
        scrollBodyElem.scrollLeft = 0;
      }
      internalData.lastScrollTop = 0;
      internalData.lastScrollLeft = 0;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const hasOptGroupById = optid => {
      const {
        optGroupKeyMaps
      } = internalData;
      return !!optGroupKeyMaps[optid];
    };
    const selectMethods = {
      dispatchEvent,
      loadData,
      reloadData(datas) {
        internalData.isLoaded = false;
        clearScroll();
        return loadData(datas);
      },
      isPanelVisible() {
        return reactData.visiblePanel;
      },
      togglePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      hidePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      showPanel() {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      refreshOption() {
        handleOption();
        updateYData();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      focus() {
        const $input = refInput.value;
        if ($input) {
          $input.blur();
        }
        reactData.isActivated = true;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const $input = refInput.value;
        if ($input) {
          $input.blur();
        }
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      recalculate,
      clearScroll
    };
    Object.assign($xeSelect, selectMethods);
    const renderOption = list => {
      const {
        allowCreate,
        optionKey,
        modelValue
      } = props;
      const {
        currentOption
      } = reactData;
      const {
        optAddMaps
      } = internalData;
      const optionOpts = computeOptionOpts.value;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const groupLabelField = computeGroupLabelField.value;
      const {
        useKey
      } = optionOpts;
      const optionSlot = slots.option;
      return list.map((option, cIndex) => {
        const {
          slots,
          className
        } = option;
        const optid = getOptId(option);
        const optionValue = option[valueField];
        const isOptGroup = hasOptGroupById(optid);
        const isAdd = !!(allowCreate && optAddMaps[optid]);
        const isSelected = !isAdd && (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue.indexOf(optionValue) > -1 : modelValue === optionValue);
        const isVisible = isAdd || !isOptGroup || isOptionVisible(option);
        const isDisabled = !isAdd && checkOptionDisabled(isSelected, option);
        const defaultSlot = slots ? slots.default : null;
        const optParams = {
          option,
          group: isOptGroup ? option : null,
          $select: $xeSelect
        };
        let optLabel = '';
        let optVNs = [];
        if (optionSlot) {
          optVNs = callSlot(optionSlot, optParams);
        } else if (defaultSlot) {
          optVNs = callSlot(defaultSlot, optParams);
        } else {
          optLabel = getFuncText(option[isOptGroup ? groupLabelField : labelField] || optionValue);
          optVNs = optLabel;
        }
        return isVisible ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: useKey || optionKey ? optid : cIndex,
          class: ['vxe-select-option', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className(optParams) : className : '', {
            'vxe-select-optgroup': isOptGroup,
            'is--disabled': isDisabled,
            'is--selected': isSelected,
            'is--add': isAdd,
            'is--hover': currentOption && getOptId(currentOption) === optid
          }],
          optid: optid,
          title: optLabel || null,
          onMousedown: evnt => {
            const isLeftBtn = evnt.button === 0;
            if (isLeftBtn) {
              evnt.stopPropagation();
            }
          },
          onClick: evnt => {
            if (!isDisabled && !isOptGroup) {
              changeOptionEvent(evnt, option);
            }
          },
          onMouseenter: () => {
            if (!isDisabled && !isOptGroup && !isVMScrollProcess()) {
              setCurrentOption(option);
            }
          }
        }, allowCreate ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          key: 1,
          class: 'vxe-select-option--label'
        }, optVNs), isAdd ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          key: 2,
          class: 'vxe-select-option--add-icon'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon().SELECT_ADD_OPTION
        })]) : renderEmptyElement($xeSelect)] : optVNs) : renderEmptyElement($xeSelect);
      });
    };
    const renderOpts = () => {
      const {
        optList,
        searchLoading
      } = reactData;
      if (searchLoading) {
        return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-select--search-loading'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: ['vxe-select--search-icon', getIcon().SELECT_LOADED]
        }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-select--search-text'
        }, getI18n('vxe.select.loadingText'))])];
      }
      if (optList.length) {
        return renderOption(optList);
      }
      return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--empty-placeholder'
      }, props.emptyText || getI18n('vxe.select.emptyText'))];
    };
    const renderVN = () => {
      const {
        modelValue,
        className,
        popupClassName,
        multiple,
        loading,
        filterable,
        showTotalButoon,
        showCheckedButoon,
        showClearButton
      } = props;
      const {
        initialized,
        isActivated,
        isAniVisible,
        optList,
        visiblePanel,
        bodyHeight,
        topSpaceHeight
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const selectLabel = computeSelectLabel.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-select--readonly', className]
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-select-slots',
          ref: 'hideOption'
        }, defaultSlot ? defaultSlot({}) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-select-label'
        }, selectLabel)]);
      }
      const selectVals = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(modelValue) ? [] : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue : [modelValue];
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-select', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $select: $xeSelect
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--visible': visiblePanel,
          'is--disabled': isDisabled,
          'is--filter': filterable,
          'is--loading': loading,
          'is--active': isActivated
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select-slots',
        ref: 'hideOption'
      }, defaultSlot ? defaultSlot({}) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
        ref: refInput,
        clearable: props.clearable,
        placeholder: inpPlaceholder,
        readonly: true,
        disabled: isDisabled,
        type: 'text',
        prefixIcon: props.prefixIcon,
        suffixIcon: loading ? getIcon().SELECT_LOADED : visiblePanel ? getIcon().SELECT_OPEN : getIcon().SELECT_CLOSE,
        autoFocus: false,
        title: selectLabel,
        modelValue: selectLabel,
        onClear: clearEvent,
        onClick: clickEvent,
        onFocus: focusEvent,
        onBlur: blurEvent,
        onSuffixClick: suffixClickEvent
      }, prefixSlot ? {
        prefix: () => prefixSlot({})
      } : {}), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: btnTransfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refOptionPanel,
        class: ['vxe-table--ignore-clear vxe-select--panel', popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
          $select: $xeSelect
        }) : popupClassName : '', {
          [`size--${vSize}`]: vSize,
          'is--transfer': btnTransfer,
          'ani--leave': !loading && isAniVisible,
          'ani--enter': !loading && visiblePanel
        }],
        placement: reactData.panelPlacement,
        style: reactData.panelStyle
      }, initialized && (visiblePanel || isAniVisible) ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--panel-wrapper'
      }, [filterable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--panel-search'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
        ref: refInpSearch,
        class: 'vxe-select-search--input',
        modelValue: reactData.searchValue,
        type: 'text',
        clearable: true,
        disabled: false,
        readonly: false,
        placeholder: getI18n('vxe.select.search'),
        prefixIcon: getIcon().INPUT_SEARCH,
        'onUpdate:modelValue': modelSearchEvent,
        onFocus: focusSearchEvent,
        onChange: triggerSearchEvent,
        onSearch: triggerSearchEvent
      })]) : renderEmptyElement($xeSelect), showTotalButoon || showCheckedButoon && multiple || showClearButton || headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--panel-header'
      }, headerSlot ? callSlot(headerSlot, {}) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--header-button'
      }, [showTotalButoon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--header-total'
      }, getI18n('vxe.select.total', [selectVals.length, optList.length])) : renderEmptyElement($xeSelect), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--header-btns'
      }, [showCheckedButoon && multiple ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        content: getI18n('vxe.select.allChecked'),
        mode: 'text',
        onClick: allCheckedPanelEvent
      }) : renderEmptyElement($xeSelect), showClearButton ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        content: getI18n('vxe.select.clear'),
        mode: 'text',
        onClick: clearCheckedPanelEvent
      }) : renderEmptyElement($xeSelect)])])]) : renderEmptyElement($xeSelect), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--panel-body'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refVirtualWrapper,
        class: 'vxe-select-option--wrapper',
        onScroll: scrollEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--y-space',
        style: {
          height: bodyHeight ? `${bodyHeight}px` : ''
        }
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refVirtualBody,
        class: 'vxe-select--body',
        style: {
          transform: `translateY(${topSpaceHeight}px)`
        }
      }, renderOpts())])]), footerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-select--panel-footer'
      }, callSlot(footerSlot, {})) : renderEmptyElement($xeSelect)])] : [])])]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticOptions, val => {
      loadData(val);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options, val => {
      loadData(val || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.optionGroups, val => {
      loadData(val || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const {
          options,
          optionGroups
        } = props;
        if (optionGroups) {
          loadData(optionGroups);
        } else if (options) {
          loadData(options);
        }
      });
      globalEvents.on($xeSelect, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeSelect, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeSelect, 'keydown', handleGlobalKeydownEvent);
      globalEvents.on($xeSelect, 'blur', handleGlobalBlurEvent);
      globalEvents.on($xeSelect, 'resize', handleGlobalResizeEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeSelect, 'mousewheel');
      globalEvents.off($xeSelect, 'mousedown');
      globalEvents.off($xeSelect, 'keydown');
      globalEvents.off($xeSelect, 'blur');
      globalEvents.off($xeSelect, 'resize');
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign(internalData, select_createInternalData());
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeSelect', $xeSelect);
    $xeSelect.renderVN = renderVN;
    return $xeSelect;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/pager/src/pager.ts








/* harmony default export */ var pager = (defineVxeComponent({
  name: 'VxePager',
  props: {
    size: {
      type: String,
      default: () => getConfig().pager.size || getConfig().size
    },
    // 自定义布局
    layouts: {
      type: Array,
      default: () => getConfig().pager.layouts || ['PrevJump', 'PrevPage', 'Jump', 'PageCount', 'NextPage', 'NextJump', 'Sizes', 'Total']
    },
    // 当前页
    currentPage: {
      type: Number,
      default: 1
    },
    // 加载中
    loading: Boolean,
    // 每页大小
    pageSize: {
      type: Number,
      default: () => getConfig().pager.pageSize || 10
    },
    // 总条数
    total: {
      type: Number,
      default: 0
    },
    // 显示页码按钮的数量
    pagerCount: {
      type: Number,
      default: () => getConfig().pager.pagerCount || 7
    },
    // 每页大小选项列表
    pageSizes: {
      type: Array,
      default: () => getConfig().pager.pageSizes || [10, 15, 20, 50, 100]
    },
    // 列对齐方式
    align: {
      type: String,
      default: () => getConfig().pager.align
    },
    // 带边框
    border: {
      type: Boolean,
      default: () => getConfig().pager.border
    },
    // 带背景颜色
    background: {
      type: Boolean,
      default: () => getConfig().pager.background
    },
    // 配套的样式
    perfect: {
      type: Boolean,
      default: () => getConfig().pager.perfect
    },
    // 当只有一页时隐藏
    autoHidden: {
      type: Boolean,
      default: () => getConfig().pager.autoHidden
    },
    transfer: {
      type: Boolean,
      default: () => getConfig().pager.transfer
    },
    className: [String, Function],
    pageSizePlacement: {
      type: String,
      default: () => getConfig().pager.pageSizePlacement
    },
    // 自定义图标
    iconPrevPage: String,
    iconJumpPrev: String,
    iconJumpNext: String,
    iconNextPage: String,
    iconJumpMore: String,
    iconHomePage: String,
    iconEndPage: String
  },
  emits: ['update:pageSize', 'update:currentPage', 'page-change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const $xeGrid = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeGrid', null);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      inpCurrPage: props.currentPage
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem
    };
    const computePageCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return getPageCount(props.total, props.pageSize);
    });
    const computeNumList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        pagerCount
      } = props;
      const pageCount = computePageCount.value;
      const len = pageCount > pagerCount ? pagerCount - 2 : pagerCount;
      const rest = [];
      for (let index = 0; index < len; index++) {
        rest.push(index);
      }
      return rest;
    });
    const computeOffsetNumber = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Math.floor((props.pagerCount - 2) / 2);
    });
    const computeSizeList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.pageSizes.map(item => {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(item)) {
          return {
            value: item,
            label: `${getI18n('vxe.pager.pagesize', [item])}`
          };
        }
        return {
          value: '',
          label: '',
          ...item
        };
      });
    });
    const $xePager = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $pager: $xePager
      }, params));
    };
    const getPageCount = (total, size) => {
      return Math.max(Math.ceil(total / size), 1);
    };
    const handleJumpPageEvent = (evnt, currentPage) => {
      emit('update:currentPage', currentPage);
      if (evnt && currentPage !== props.currentPage) {
        dispatchEvent('page-change', {
          type: 'current',
          pageSize: props.pageSize,
          currentPage
        }, evnt);
      }
    };
    const handleChangeCurrentPage = (currentPage, evnt) => {
      emit('update:currentPage', currentPage);
      if (evnt && currentPage !== props.currentPage) {
        dispatchEvent('page-change', {
          type: 'current',
          pageSize: props.pageSize,
          currentPage
        }, evnt);
      }
    };
    const triggerJumpEvent = params => {
      const {
        $event
      } = params;
      const inputElem = $event.target;
      const inpValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(inputElem.value);
      const pageCount = computePageCount.value;
      const current = inpValue <= 0 ? 1 : inpValue >= pageCount ? pageCount : inpValue;
      const currPage = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(current);
      inputElem.value = currPage;
      reactData.inpCurrPage = currPage;
      handleChangeCurrentPage(current, $event);
    };
    const handleHomePage = evnt => {
      const {
        currentPage
      } = props;
      if (currentPage > 1) {
        handleChangeCurrentPage(1, evnt);
      }
    };
    const handleEndPage = evnt => {
      const {
        currentPage
      } = props;
      const pageCount = computePageCount.value;
      if (currentPage < pageCount) {
        handleChangeCurrentPage(pageCount, evnt);
      }
    };
    const handlePrevPage = evnt => {
      const {
        currentPage
      } = props;
      const pageCount = computePageCount.value;
      if (currentPage > 1) {
        handleChangeCurrentPage(Math.min(pageCount, Math.max(currentPage - 1, 1)), evnt);
      }
    };
    const handleNextPage = evnt => {
      const {
        currentPage
      } = props;
      const pageCount = computePageCount.value;
      if (currentPage < pageCount) {
        handleChangeCurrentPage(Math.min(pageCount, currentPage + 1), evnt);
      }
    };
    const handlePrevJump = evnt => {
      const numList = computeNumList.value;
      handleChangeCurrentPage(Math.max(props.currentPage - numList.length, 1), evnt);
    };
    const handleNextJump = evnt => {
      const pageCount = computePageCount.value;
      const numList = computeNumList.value;
      handleChangeCurrentPage(Math.min(props.currentPage + numList.length, pageCount), evnt);
    };
    const pageSizeEvent = params => {
      const {
        value,
        $event
      } = params;
      const pageSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(value);
      const pageCount = getPageCount(props.total, pageSize);
      let currentPage = props.currentPage;
      if (currentPage > pageCount) {
        currentPage = pageCount;
        emit('update:currentPage', pageCount);
      }
      emit('update:pageSize', pageSize);
      if ($event) {
        dispatchEvent('page-change', {
          type: 'size',
          pageSize,
          currentPage
        }, $event);
      }
    };
    const jumpKeydownEvent = params => {
      const {
        $event
      } = params;
      if (globalEvents.hasKey($event, GLOBAL_EVENT_KEYS.ENTER)) {
        triggerJumpEvent(params);
      } else if (globalEvents.hasKey($event, GLOBAL_EVENT_KEYS.ARROW_UP)) {
        $event.preventDefault();
        handleNextPage($event);
      } else if (globalEvents.hasKey($event, GLOBAL_EVENT_KEYS.ARROW_DOWN)) {
        $event.preventDefault();
        handlePrevPage($event);
      }
    };
    // 第一页
    const renderHomePage = () => {
      const {
        currentPage,
        total
      } = props;
      const homeSlot = slots.home;
      const pageCount = computePageCount.value;
      if (homeSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--custom-home-btn'
        }, homeSlot({
          $pager: $xePager,
          total,
          currentPage,
          pageCount
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: ['vxe-pager--home-btn', {
          'is--disabled': currentPage <= 1
        }],
        type: 'button',
        title: getI18n('vxe.pager.homePageTitle'),
        onClick: handleHomePage
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--btn-icon', props.iconHomePage || getIcon().PAGER_HOME]
      })]);
    };
    // 上一页
    const renderPrevPage = () => {
      const {
        currentPage,
        total
      } = props;
      const prevPageSlot = slots.prevPage || slots['prev-page'];
      const pageCount = computePageCount.value;
      if (prevPageSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--custom-prev-btn'
        }, prevPageSlot({
          $pager: $xePager,
          total,
          currentPage,
          pageCount
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: ['vxe-pager--prev-btn', {
          'is--disabled': currentPage <= 1
        }],
        type: 'button',
        title: getI18n('vxe.pager.prevPageTitle'),
        onClick: handlePrevPage
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--btn-icon', props.iconPrevPage || getIcon().PAGER_PREV_PAGE]
      })]);
    };
    // 向上翻页
    const renderPrevJump = tagName => {
      const {
        currentPage,
        total
      } = props;
      const prevJumpSlot = slots.prevJump || slots['prev-jump'];
      const pageCount = computePageCount.value;
      if (prevJumpSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--custom-jump-prev'
        }, prevJumpSlot({
          $pager: $xePager,
          total,
          currentPage,
          pageCount
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tagName || 'button', {
        class: ['vxe-pager--jump-prev', {
          'is--fixed': !tagName,
          'is--disabled': currentPage <= 1
        }],
        type: 'button',
        title: getI18n('vxe.pager.prevJumpTitle'),
        onClick: handlePrevJump
      }, [tagName ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--jump-more-icon', props.iconJumpMore || getIcon().PAGER_JUMP_MORE]
      }) : null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--jump-icon', props.iconJumpPrev || getIcon().PAGER_JUMP_PREV]
      })]);
    };
    // 向下翻页
    const renderNextJump = tagName => {
      const {
        currentPage,
        total
      } = props;
      const nextJumpSlot = slots.nextJump || slots['next-jump'];
      const pageCount = computePageCount.value;
      if (nextJumpSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--custom-jump-next'
        }, nextJumpSlot({
          $pager: $xePager,
          total,
          currentPage,
          pageCount
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tagName || 'button', {
        class: ['vxe-pager--jump-next', {
          'is--fixed': !tagName,
          'is--disabled': currentPage >= pageCount
        }],
        type: 'button',
        title: getI18n('vxe.pager.nextJumpTitle'),
        onClick: handleNextJump
      }, [tagName ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--jump-more-icon', props.iconJumpMore || getIcon().PAGER_JUMP_MORE]
      }) : null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--jump-icon', props.iconJumpNext || getIcon().PAGER_JUMP_NEXT]
      })]);
    };
    // 下一页
    const renderNextPage = () => {
      const {
        currentPage,
        total
      } = props;
      const nextPageSlot = slots.nextPage || slots['next-page'];
      const pageCount = computePageCount.value;
      if (nextPageSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--custom-next-btn'
        }, nextPageSlot({
          $pager: $xePager,
          total,
          currentPage,
          pageCount
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: ['vxe-pager--next-btn', {
          'is--disabled': currentPage >= pageCount
        }],
        type: 'button',
        title: getI18n('vxe.pager.nextPageTitle'),
        onClick: handleNextPage
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--btn-icon', props.iconNextPage || getIcon().PAGER_NEXT_PAGE]
      })]);
    };
    // 最后一页
    const renderEndPage = () => {
      const {
        currentPage,
        total
      } = props;
      const endSlot = slots.end;
      const pageCount = computePageCount.value;
      if (endSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--custom-end-btn'
        }, endSlot({
          $pager: $xePager,
          total,
          currentPage,
          pageCount
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        class: ['vxe-pager--end-btn', {
          'is--disabled': currentPage >= pageCount
        }],
        type: 'button',
        title: getI18n('vxe.pager.endPageTitle'),
        onClick: handleEndPage
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-pager--btn-icon', props.iconEndPage || getIcon().PAGER_END]
      })]);
    };
    // 页数
    const renderNumber = showJump => {
      const {
        currentPage,
        total,
        pagerCount
      } = props;
      const numberSlot = showJump ? slots.numberJump || slots['number-jump'] : slots.number;
      const nums = [];
      const pageCount = computePageCount.value;
      const numList = computeNumList.value;
      const offsetNumber = computeOffsetNumber.value;
      const isOv = pageCount > pagerCount;
      const isLt = isOv && currentPage > offsetNumber + 1;
      const isGt = isOv && currentPage < pageCount - offsetNumber;
      const restList = [];
      let startNumber = 1;
      if (isOv) {
        if (currentPage >= pageCount - offsetNumber) {
          startNumber = Math.max(pageCount - numList.length + 1, 1);
        } else {
          startNumber = Math.max(currentPage - offsetNumber, 1);
        }
      }
      if (showJump && isLt) {
        restList.push(1);
        nums.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
          class: 'vxe-pager--num-btn',
          type: 'button',
          onClick: evnt => handleJumpPageEvent(evnt, 1)
        }, '1'), renderPrevJump('span'));
      }
      numList.forEach((item, index) => {
        const number = startNumber + index;
        if (number <= pageCount) {
          restList.push(number);
          nums.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
            key: number,
            class: ['vxe-pager--num-btn', {
              'is--active': currentPage === number
            }],
            type: 'button',
            onClick: evnt => handleJumpPageEvent(evnt, number)
          }, `${number}`));
        }
      });
      if (showJump && isGt) {
        restList.push(pageCount);
        nums.push(renderNextJump('button'), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
          class: 'vxe-pager--num-btn',
          type: 'button',
          onClick: evnt => handleJumpPageEvent(evnt, pageCount)
        }, pageCount));
      }
      if (numberSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--custom-btn-wrapper'
        }, numberSlot({
          $pager: $xePager,
          total,
          numList: restList,
          currentPage,
          pageCount
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--btn-wrapper'
      }, nums);
    };
    // jumpNumber
    const renderJumpNumber = () => {
      return renderNumber(true);
    };
    // sizes
    const renderSizes = () => {
      const {
        total,
        currentPage,
        pageSize,
        pageSizePlacement,
        transfer
      } = props;
      const sizesSlot = slots.sizes;
      const sizeList = computeSizeList.value;
      const pageCount = computePageCount.value;
      if (sizesSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--custom-sizes'
        }, sizesSlot({
          $pager: $xePager,
          total,
          currentPage,
          pageCount,
          pageSize,
          options: sizeList
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_select, {
        class: 'vxe-pager--sizes',
        modelValue: pageSize,
        placement: pageSizePlacement,
        transfer: transfer,
        options: sizeList,
        onChange: pageSizeEvent
      });
    };
    // Jump
    const renderJump = isFull => {
      const {
        total
      } = props;
      const {
        inpCurrPage
      } = reactData;
      const jumpSlot = isFull ? slots.fullJump || slots['full-jump'] : slots.jump;
      const pageCount = computePageCount.value;
      if (jumpSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--custom-jump'
        }, jumpSlot({
          $pager: $xePager,
          total,
          currentPage: inpCurrPage,
          pageCount
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--jump'
      }, [isFull ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--goto-text'
      }, getI18n('vxe.pager.goto')) : null, (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(number_input, {
        class: 'vxe-pager--goto',
        modelValue: reactData.inpCurrPage,
        placeholder: getI18n('vxe.pager.gotoTitle'),
        align: 'center',
        type: 'integer',
        max: pageCount,
        min: 1,
        controls: false,
        onKeydown: jumpKeydownEvent,
        onBlur: triggerJumpEvent,
        'onUpdate:modelValue'(val) {
          reactData.inpCurrPage = val;
        }
      }), isFull ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--classifier-text'
      }, getI18n('vxe.pager.pageClassifier')) : null]);
    };
    // FullJump
    const renderFullJump = () => {
      return renderJump(true);
    };
    // PageCount
    const renderPageCount = () => {
      const {
        currentPage,
        total
      } = props;
      const pageCountSlot = slots.pageCount || slots['page-count'];
      const pageCount = computePageCount.value;
      if (pageCountSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--custom-count'
        }, pageCountSlot({
          $pager: $xePager,
          total,
          currentPage,
          pageCount
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--count'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--separator'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', pageCount)]);
    };
    // total
    const renderTotal = () => {
      const {
        currentPage,
        total
      } = props;
      const totalSlot = slots.total;
      const pageCount = computePageCount.value;
      if (totalSlot) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--custom-total'
        }, totalSlot({
          $pager: $xePager,
          total,
          currentPage,
          pageCount
        }));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-pager--total'
      }, getI18n('vxe.pager.total', [total]));
    };
    const pagerMethods = {
      dispatchEvent,
      setPageSize(num) {
        pageSizeEvent({
          value: num
        });
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      setPageSizeByEvent(evnt, num) {
        pageSizeEvent({
          value: num,
          $event: evnt
        });
      },
      homePage() {
        handleHomePage();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      homePageByEvent(evnt) {
        handleHomePage(evnt);
      },
      endPage() {
        handleEndPage();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      endPageByEvent(evnt) {
        handleEndPage(evnt);
      },
      prevPage() {
        handlePrevPage();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      prevPageByEvent(evnt) {
        handlePrevPage(evnt);
      },
      nextPage() {
        handleNextPage();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      nextPageByEvent(evnt) {
        handleNextPage(evnt);
      },
      prevJump() {
        handlePrevJump();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      prevJumpByEvent(evnt) {
        handlePrevJump(evnt);
      },
      nextJump() {
        handleNextJump();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      nextJumpByEvent(evnt) {
        handleNextJump(evnt);
      },
      setCurrentPage(currentPage) {
        const current = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(currentPage) || 1;
        reactData.inpCurrPage = current;
        handleChangeCurrentPage(current);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      setCurrentPageByEvent(evnt, currentPage) {
        const current = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(currentPage) || 1;
        reactData.inpCurrPage = current;
        handleChangeCurrentPage(current, evnt);
      },
      /**
       * 已废弃，被 setCurrentPage 替换
       * @deprecated
       */
      jumpPage(currentPage) {
        warnLog('vxe.error.delFunc', ['jumpPage', 'setCurrentPage']);
        return $xePager.setCurrentPage(currentPage);
      }
    };
    const pagerPrivateMethods = {
      handlePrevPage,
      handleNextPage,
      handlePrevJump,
      handleNextJump
    };
    Object.assign($xePager, pagerMethods, pagerPrivateMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.currentPage, value => {
      reactData.inpCurrPage = value;
    });
    const renderVN = () => {
      const {
        align,
        layouts,
        className
      } = props;
      const childNodes = [];
      const vSize = computeSize.value;
      const pageCount = computePageCount.value;
      if (slots.left) {
        childNodes.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--left-wrapper'
        }, slots.left({
          $grid: $xeGrid
        })));
      }
      layouts.forEach(name => {
        let renderFn;
        switch (name) {
          case 'Home':
            renderFn = renderHomePage;
            break;
          case 'PrevJump':
            renderFn = renderPrevJump;
            break;
          case 'PrevPage':
            renderFn = renderPrevPage;
            break;
          case 'Number':
            renderFn = renderNumber;
            break;
          case 'JumpNumber':
            renderFn = renderJumpNumber;
            break;
          case 'NextPage':
            renderFn = renderNextPage;
            break;
          case 'NextJump':
            renderFn = renderNextJump;
            break;
          case 'End':
            renderFn = renderEndPage;
            break;
          case 'Sizes':
            renderFn = renderSizes;
            break;
          case 'FullJump':
            renderFn = renderFullJump;
            break;
          case 'Jump':
            renderFn = renderJump;
            break;
          case 'PageCount':
            renderFn = renderPageCount;
            break;
          case 'Total':
            renderFn = renderTotal;
            break;
        }
        if (renderFn) {
          childNodes.push(renderFn());
        } else {
          errLog('vxe.error.notProp', [`layouts -> ${name}`]);
        }
      });
      if (slots.right) {
        childNodes.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-pager--right-wrapper'
        }, slots.right({
          $grid: $xeGrid
        })));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-pager', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $pager: $xePager
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          [`align--${align}`]: align,
          'is--border': props.border,
          'is--background': props.background,
          'is--perfect': props.perfect,
          'is--hidden': props.autoHidden && pageCount === 1,
          'is--loading': props.loading
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-pager--wrapper'
      }, childNodes)]);
    };
    $xePager.renderVN = renderVN;
    return $xePager;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/pager/index.ts



const VxePager = Object.assign(pager, {
  install: function (app) {
    app.component(pager.name, pager);
  }
});
dynamicApp.use(VxePager);
index_esm_VxeUI.component(pager);
const Pager = VxePager;
/* harmony default export */ var packages_pager = (VxePager);
;// CONCATENATED MODULE: ./packages/password-input/src/password-input.ts






/* harmony default export */ var password_input = (defineVxeComponent({
  name: 'VxePasswordInput',
  props: {
    modelValue: String,
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    clearable: {
      type: Boolean,
      default: () => getConfig().passwordInput.clearable
    },
    readonly: Boolean,
    disabled: Boolean,
    maxLength: [String, Number],
    placeholder: String,
    autoComplete: {
      type: String,
      default: 'off'
    },
    className: String,
    size: {
      type: String,
      default: () => getConfig().passwordInput.size || getConfig().size
    },
    prefixIcon: String,
    suffixIcon: String,
    controls: {
      type: Boolean,
      default: () => getConfig().passwordInput.controls
    },
    // 已废弃
    autocomplete: String
  },
  emits: ['update:modelValue', 'input', 'change', 'click', 'focus', 'blur', 'clear', 'toggle-visible', 'prefix-click', 'suffix-click'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      showPwd: false,
      isActivated: false,
      inputValue: props.modelValue
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInputTarget = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xePasswordInput = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let passwordInputMethods = {};
    const computeIsClearable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.clearable;
    });
    const computeInpReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      return readonly;
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().passwordInput.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n('vxe.base.pleaseInput');
    });
    const computeInputType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        showPwd
      } = reactData;
      if (showPwd) {
        return 'text';
      }
      return 'password';
    });
    const computeInpImmediate = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        immediate
      } = props;
      return immediate;
    });
    const triggerEvent = evnt => {
      const {
        inputValue
      } = reactData;
      passwordInputMethods.dispatchEvent(evnt.type, {
        value: inputValue
      }, evnt);
    };
    const emitInputEvent = (value, evnt) => {
      const inpImmediate = computeInpImmediate.value;
      reactData.inputValue = value;
      if (inpImmediate) {
        handleChange(value, evnt);
      } else {
        passwordInputMethods.dispatchEvent('input', {
          value
        }, evnt);
      }
    };
    const inputEvent = evnt => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit('update:modelValue', value);
      passwordInputMethods.dispatchEvent('input', {
        value
      }, evnt);
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(props.modelValue) !== value) {
        passwordInputMethods.dispatchEvent('change', {
          value
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const changeEvent = evnt => {
      triggerEvent(evnt);
      const {
        inputValue
      } = reactData;
      // 自动更新校验状态
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, inputValue);
      }
    };
    const focusEvent = evnt => {
      reactData.isActivated = true;
      triggerEvent(evnt);
    };
    const blurEvent = evnt => {
      const {
        inputValue
      } = reactData;
      const value = inputValue;
      passwordInputMethods.dispatchEvent('blur', {
        value
      }, evnt);
      // 自动更新校验状态
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const passwordToggleEvent = evnt => {
      const {
        readonly,
        disabled
      } = props;
      const {
        showPwd
      } = reactData;
      if (!disabled && !readonly) {
        reactData.showPwd = !showPwd;
      }
      passwordInputMethods.dispatchEvent('toggle-visible', {
        visible: reactData.showPwd
      }, evnt);
    };
    const clickEvent = evnt => {
      triggerEvent(evnt);
    };
    const clearValueEvent = (evnt, value) => {
      focus();
      handleChange('', evnt);
      passwordInputMethods.dispatchEvent('clear', {
        value
      }, evnt);
    };
    const clickSuffixEvent = evnt => {
      const {
        disabled
      } = props;
      if (!disabled) {
        const {
          inputValue
        } = reactData;
        passwordInputMethods.dispatchEvent('suffix-click', {
          value: inputValue
        }, evnt);
      }
    };
    const clickPrefixEvent = evnt => {
      const {
        disabled
      } = props;
      if (!disabled) {
        const {
          inputValue
        } = reactData;
        passwordInputMethods.dispatchEvent('prefix-click', {
          value: inputValue
        }, evnt);
      }
    };
    const renderPasswordIcon = () => {
      const {
        showPwd
      } = reactData;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-password-input--control-icon',
        onClick: passwordToggleEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-password-input--password-icon', showPwd ? getIcon().PASSWORD_INPUT_SHOW_PWD : getIcon().PASSWORD_INPUT_HIDE_PWD]
      })]);
    };
    const renderPrefixIcon = () => {
      const {
        prefixIcon
      } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-password-input--prefix',
        onClick: clickPrefixEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-password-input--prefix-icon'
      }, prefixSlot ? vn_getSlotVNs(prefixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: prefixIcon
      })])]) : null;
    };
    const renderSuffixIcon = () => {
      const {
        disabled,
        suffixIcon,
        controls
      } = props;
      const {
        inputValue
      } = reactData;
      const suffixSlot = slots.suffix;
      const isClearable = computeIsClearable.value;
      return isClearable || controls || suffixSlot || suffixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-password-input--suffix', {
          'is--clear': isClearable && !disabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }]
      }, [isClearable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-password-input--clear-icon',
        onClick: clearValueEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: getIcon().INPUT_CLEAR
      })]) : renderEmptyElement($xePasswordInput), controls ? renderPasswordIcon() : renderEmptyElement($xePasswordInput), suffixSlot || suffixIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-password-input--suffix-icon',
        onClick: clickSuffixEvent
      }, suffixSlot ? vn_getSlotVNs(suffixSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: suffixIcon
      })]) : renderEmptyElement($xePasswordInput)]) : null;
    };
    passwordInputMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $passwordInput: $xePasswordInput
        }, params));
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    Object.assign($xePasswordInput, passwordInputMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.inputValue = val;
    });
    const renderVN = () => {
      const {
        className,
        name,
        disabled,
        readonly,
        autocomplete,
        autoComplete,
        maxLength
      } = props;
      const {
        inputValue,
        isActivated
      } = reactData;
      const vSize = computeSize.value;
      const inpReadonly = computeInpReadonly.value;
      const inputType = computeInputType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon();
      const suffix = renderSuffixIcon();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-password-input', className, {
          [`size--${vSize}`]: vSize,
          'is--prefix': !!prefix,
          'is--suffix': !!suffix,
          'is--readonly': readonly,
          'is--disabled': disabled,
          'is--active': isActivated,
          'show--clear': isClearable && !disabled && !(inputValue === '' || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(inputValue))
        }],
        spellcheck: false
      }, [prefix || renderEmptyElement($xePasswordInput), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-password-input--wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        ref: refInputTarget,
        class: 'vxe-password-input--inner',
        value: inputValue,
        name,
        type: inputType,
        placeholder: inpPlaceholder,
        readonly: inpReadonly,
        disabled,
        autocomplete: autocomplete || autoComplete,
        maxlength: maxLength,
        onClick: clickEvent,
        onInput: inputEvent,
        onChange: changeEvent,
        onFocus: focusEvent,
        onBlur: blurEvent
      })]), suffix || renderEmptyElement($xePasswordInput)]);
    };
    $xePasswordInput.renderVN = renderVN;
    return $xePasswordInput;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/password-input/index.ts



const VxePasswordInput = Object.assign({}, password_input, {
  install(app) {
    app.component(password_input.name, password_input);
  }
});
dynamicApp.use(VxePasswordInput);
index_esm_VxeUI.component(password_input);
const PasswordInput = VxePasswordInput;
/* harmony default export */ var packages_password_input = (VxePasswordInput);
// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.delete.js
var web_url_search_params_delete = __webpack_require__(4603);
// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.has.js
var web_url_search_params_has = __webpack_require__(7566);
// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url-search-params.size.js
var web_url_search_params_size = __webpack_require__(8721);
;// CONCATENATED MODULE: ./packages/print/src/util.ts





const browseObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().browse();
// 打印
let printFrame;
// 默认导出或打印的 HTML 样式
const defaultHtmlStyle = 'body{padding:0;font-family:"Microsoft YaHei",微软雅黑,"MicrosoftJhengHei",华文细黑,STHeiti,MingLiu}body *{-webkit-box-sizing:border-box;box-sizing:border-box}.vxe-table{border-collapse:collapse;text-align:left;border-spacing:0}.vxe-table:not(.is--print){table-layout:fixed}.vxe-table,.vxe-table th,.vxe-table td,.vxe-table td{border-color:#D0D0D0;border-style:solid;border-width:0}.vxe-table.is--print{width:100%}.border--default,.border--full,.border--outer{border-top-width:1px}.border--default,.border--full,.border--outer{border-left-width:1px}.border--outer,.border--default th,.border--default td,.border--full th,.border--full td,.border--outer th,.border--inner th,.border--inner td{border-bottom-width:1px}.border--default,.border--outer,.border--full th,.border--full td{border-right-width:1px}.border--default th,.border--full th,.border--outer th{background-color:#f8f8f9}.vxe-table td>div,.vxe-table th>div{padding:.5em .4em}.col--center{text-align:center}.col--right{text-align:right}.vxe-table:not(.is--print) .col--ellipsis>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-break:break-all}.vxe-table--tree-node{text-align:left}.vxe-table--tree-node-wrapper{position:relative}.vxe-table--tree-icon-wrapper{position:absolute;top:50%;width:1em;height:1em;text-align:center;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.vxe-table--tree-unfold-icon,.vxe-table--tree-fold-icon{position:absolute;width:0;height:0;border-style:solid;border-width:.5em;border-right-color:transparent;border-bottom-color:transparent}.vxe-table--tree-unfold-icon{left:.3em;top:0;border-left-color:#939599;border-top-color:transparent}.vxe-table--tree-fold-icon{left:0;top:.3em;border-left-color:transparent;border-top-color:#939599}.vxe-table--tree-cell{display:block;padding-left:1.5em}.vxe-table input[type="checkbox"]{margin:0}.vxe-table input[type="checkbox"],.vxe-table input[type="radio"],.vxe-table input[type="checkbox"]+span,.vxe-table input[type="radio"]+span{vertical-align:middle;padding-left:0.4em}';
function trimHtml(html) {
  return `${html}`.replace(/(<!---->)/, '');
}
function createPrintFrame() {
  const frame = document.createElement('iframe');
  frame.className = 'vxe-table--print-frame';
  return frame;
}
function appendPrintFrame() {
  if (!printFrame.parentNode) {
    document.body.appendChild(printFrame);
  }
}
function afterPrintEvent() {
  requestAnimationFrame(removeFrame);
}
function removeFrame() {
  if (printFrame) {
    if (printFrame.parentNode) {
      try {
        printFrame.contentDocument.write('');
      } catch (e) {}
      printFrame.parentNode.removeChild(printFrame);
    }
    printFrame = null;
  }
}
function getExportBlobByString(str, type) {
  return new Blob([str], {
    type: `text/${type};charset=utf-8;`
  });
}
const defaultPrintMargin = 50;
const defaultFontColor = '#000000';
function parsePageStyle(val) {
  const styOpts = Object.assign({}, val);
  const headStyOpts = Object.assign({}, styOpts.header);
  const titStyOpts = Object.assign({}, styOpts.title);
  const footStyOpts = Object.assign({}, styOpts.footer);
  const pnStyOpts = Object.assign({}, styOpts.pageNumber);
  let mVal = defaultPrintMargin;
  let marginTop = mVal;
  let marginBottom = mVal;
  let marginLeft = mVal;
  let marginRight = mVal;
  if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(styOpts.margin) || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(styOpts.margin)) {
    mVal = styOpts.margin;
    marginTop = mVal;
    marginBottom = mVal;
    marginLeft = mVal;
    marginRight = mVal;
  }
  return {
    marginTop: toCssUnit(styOpts.marginTop || marginTop),
    marginBottom: toCssUnit(styOpts.marginBottom || marginBottom),
    marginLeft: toCssUnit(styOpts.marginLeft || marginLeft),
    marginRight: toCssUnit(styOpts.marginRight || marginRight),
    fontSize: toCssUnit(styOpts.fontSize),
    color: styOpts.color,
    textAlign: styOpts.textAlign,
    header: {
      height: toCssUnit(headStyOpts.height),
      textAlign: headStyOpts.textAlign
    },
    title: {
      color: titStyOpts.color,
      fontSize: toCssUnit(titStyOpts.fontSize),
      textAlign: titStyOpts.textAlign
    },
    footer: {
      height: toCssUnit(footStyOpts.height),
      textAlign: footStyOpts.textAlign
    },
    pageNumber: {
      color: pnStyOpts.color,
      fontSize: toCssUnit(pnStyOpts.fontSize),
      textAlign: pnStyOpts.textAlign
    }
  };
}
function createHtmlPage(opts, printHtml) {
  const {
    pageStyle,
    customStyle
  } = opts;
  const pageStyObj = parsePageStyle(pageStyle);
  const headStyOpts = pageStyObj.header;
  const titStyOpts = pageStyObj.title;
  const footStyOpts = pageStyObj.header;
  const pnStyOpts = pageStyObj.pageNumber;
  const isPbMode = opts._pageBreaks || opts.pageBreaks && opts.pageBreaks.length;
  return ['<!DOCTYPE html><html>', '<head>', '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">', `<title>${opts.title || ''}</title>`, `<style media="print">@page{size:auto;${isPbMode ? 'margin: 0mm;' : ''}}</style>`, `<style>body{font-size:${pageStyObj.fontSize || '14px'};color:${pageStyObj.color || defaultFontColor};text-align:${pageStyObj.textAlign || 'left'};}</style>`, '<style>', '.vxe-print-slots{display:none;}', '.vxe-print-page-break.align--center{text-align:center;}', '.vxe-print-page-break.align--left{text-align:left;}', '.vxe-print-page-break.align--right{text-align:right;}', '.vxe-print-page-break{break-before:always;page-break-before:always;display:flex;flex-direction:column;height:100vh;overflow:hidden;}', '.vxe-print-page-break--body{display:flex;flex-direction:row;flex-grow:1;overflow:hidden;}', '.vxe-print-page-break--left,.vxe-print-page-break--right{flex-shrink:0;height:100%;}', `.vxe-print-page-break--left{width:${pageStyObj.marginLeft};}`, `.vxe-print-page-break--right{width:${pageStyObj.marginRight};}`, '.vxe-print-page-break--header,.vxe-print-page-break--footer{display:flex;justify-content:center;flex-direction:column;flex-shrink:0;width:100%;}', `.vxe-print-page-break--header{height:${headStyOpts.height || pageStyObj.marginTop};padding:0 ${pageStyObj.marginLeft} 0 ${pageStyObj.marginRight};text-align:${headStyOpts.textAlign || 'left'};}`, `.vxe-print-page-break--header-title{font-size:${titStyOpts.fontSize || '1.6em'};color:${titStyOpts.color || defaultFontColor};text-align:${opts.headerAlign || pnStyOpts.textAlign || 'center'};}`, `.vxe-print-page-break--footer{height:${footStyOpts.height || pageStyObj.marginBottom};padding:0 ${pageStyObj.marginLeft} 0 ${pageStyObj.marginRight};text-align:${footStyOpts.textAlign || 'left'};}`, '.vxe-print-page-break--content{flex-grow:1;overflow:hidden;}', `.vxe-print-page-break--footer-page-number{font-size:${pnStyOpts.fontSize || '1.2em'};color:${pnStyOpts.color || defaultFontColor};text-align:${opts.footerAlign || pnStyOpts.textAlign || 'center'};}`, '</style>', '<style>.vxe-table{white-space:pre;}</style>', `<style>${defaultHtmlStyle}</style>`, isPbMode ? '<style>body{margin:0;}</style>' : '', customStyle ? `<style>${customStyle}</style>` : '', '</head>', '<body>', `${printHtml}`, '</body>', '</html>'].join('');
}
function handlePrint(opts, printHtml = '') {
  const {
    beforeMethod
  } = opts;
  if (beforeMethod) {
    printHtml = beforeMethod({
      content: printHtml,
      html: printHtml,
      options: opts
    }) || '';
  }
  printHtml = createHtmlPage(opts, printHtml);
  const blob = getExportBlobByString(printHtml, 'html');
  return new Promise(resolve => {
    if (browseObj.msie) {
      removeFrame();
      printFrame = createPrintFrame();
      appendPrintFrame();
      const contentDocument = printFrame.contentDocument;
      if (contentDocument) {
        contentDocument.write(printHtml);
        contentDocument.execCommand('print');
      }
      setTimeout(() => {
        resolve({
          status: true
        });
      }, 300);
    } else {
      if (!printFrame) {
        printFrame = createPrintFrame();
        printFrame.onload = evnt => {
          const frameEl = evnt.target;
          if (frameEl.src) {
            try {
              const contentWindow = frameEl.contentWindow;
              if (contentWindow) {
                contentWindow.onafterprint = afterPrintEvent;
                contentWindow.print();
              }
            } catch (e) {}
          }
          resolve({
            status: true
          });
        };
        printFrame.onerror = () => {
          resolve({
            status: false
          });
        };
      }
      appendPrintFrame();
      printFrame.src = URL.createObjectURL(blob);
    }
  });
}
function createPageBreak(opts) {
  const {
    title,
    showPageNumber,
    align,
    headerAlign,
    footerAlign,
    showAllPageTitle
  } = opts;
  const pageBreaks = opts.pageBreaks || [];
  const pageCount = pageBreaks.length;
  return pageBreaks.map((item, index) => {
    const bodyHtml = item.bodyHtml;
    const headerHtml = item.headerHtml || opts.headerHtml;
    const footerHtml = item.footerHtml || opts.footerHtml;
    const leftHtml = item.leftHtml || opts.leftHtml;
    const rightHtml = item.rightHtml || opts.rightHtml;
    const currentPage = index + 1;
    const params = {
      currentPage,
      pageCount
    };
    return [`<div class="${['vxe-print-page-break', align ? `align--${align}` : ''].join(' ')}">`, `<div class="${['vxe-print-page-break--header', headerAlign ? `align--${headerAlign}` : ''].join(' ')}">`, headerHtml ? `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerHtml) ? headerHtml(params) : headerHtml || ''}` : title && (showAllPageTitle || !index) ? `<div class="vxe-print-page-break--header-title">${title || ''}</div>` : '', '</div>', '<div class="vxe-print-page-break--body">', `<div class="vxe-print-page-break--left">${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(leftHtml) ? leftHtml(params) : leftHtml || ''}</div>`, `<div class="vxe-print-page-break--content">${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(bodyHtml) ? bodyHtml(params) : bodyHtml || ''}</div>`, `<div class="vxe-print-page-break--right">${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(rightHtml) ? rightHtml(params) : rightHtml || ''}</div>`, '</div>', `<div class="${['vxe-print-page-break--footer', footerAlign ? `align--${footerAlign}` : ''].join(' ')}">`, footerHtml ? `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerHtml) ? footerHtml(params) : footerHtml || ''}` : showPageNumber ? `<div class="vxe-print-page-break--footer-page-number">${currentPage}/${pageCount}</div>` : '', '</div>', '</div>'].join('');
  }).join('');
}
const printHtml = options => {
  const opts = Object.assign({
    _pageBreaks: false,
    customLayout: true
  }, options);
  if (opts.sheetName) {
    opts.title = opts.title || opts.sheetName;
  }
  if (opts.style) {
    opts.customStyle = opts.customStyle || opts.style;
  }
  if (opts.beforePrintMethod) {
    opts.beforeMethod = opts.beforeMethod || opts.beforePrintMethod;
  }
  if (opts.pageBreaks && opts.pageBreaks.length) {
    return handlePrint(opts, createPageBreak(opts));
  }
  const printHtml = opts.html || opts.content;
  return handlePrint(opts, printHtml);
};
function assemblePageBreak($xePageBreak, elem, pageBreakConfig) {
  const staticPageBreaks = $xePageBreak.reactData.staticPageBreaks;
  const parentElem = elem.parentNode;
  if (parentElem && staticPageBreaks) {
    staticPageBreaks.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, elem), 0, pageBreakConfig);
    $xePageBreak.reactData.staticPageBreaks = staticPageBreaks.slice(0);
  }
}
function destroyPageBreak($xePageBreak, pageBreakConfig) {
  $xePageBreak.reactData.staticPageBreaks = $xePageBreak.reactData.staticPageBreaks.filter(item => item.id !== pageBreakConfig.id);
}
;// CONCATENATED MODULE: ./packages/print/src/page-break.ts





/* harmony default export */ var page_break = (defineVxeComponent({
  name: 'VxePrintPageBreak',
  props: {},
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xePrint = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xePrint', null);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const pageBreakConfig = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      id: xID,
      slots
    });
    const $xePrintPageBreak = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $print: $xePrint
      }, params));
    };
    const printPageBreakMethods = {
      dispatchEvent
    };
    const printPageBreakPrivateMethods = {};
    Object.assign($xePrintPageBreak, printPageBreakMethods, printPageBreakPrivateMethods);
    if (!$xePrint) {
      $xePrintPageBreak.renderVN = () => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.createCommentVNode)();
      };
      return $xePrintPageBreak;
    }
    const renderVN = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      });
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const elem = refElem.value;
      if ($xePrint && elem) {
        assemblePageBreak($xePrint, elem, pageBreakConfig);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      if ($xePrint) {
        destroyPageBreak($xePrint, pageBreakConfig);
      }
    });
    $xePrintPageBreak.renderVN = renderVN;
    return $xePrintPageBreak;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/print-page-break/index.ts



const VxePrintPageBreak = Object.assign({}, page_break, {
  install(app) {
    app.component(page_break.name, page_break);
  }
});
dynamicApp.use(VxePrintPageBreak);
index_esm_VxeUI.component(page_break);
const PrintPageBreak = VxePrintPageBreak;
/* harmony default export */ var print_page_break = (VxePrintPageBreak);
;// CONCATENATED MODULE: ./packages/print/src/print.ts






/* harmony default export */ var print = (defineVxeComponent({
  name: 'VxePrint',
  props: {
    align: {
      type: String,
      default: () => getConfig().print.align
    },
    title: String,
    headerAlign: {
      type: String,
      default: () => getConfig().print.headerAlign
    },
    footerAlign: {
      type: String,
      default: () => getConfig().print.footerAlign
    },
    showPageNumber: {
      type: Boolean,
      default: () => getConfig().print.showPageNumber
    },
    customLayout: Boolean,
    pageBreaks: Array,
    content: String,
    html: String,
    headerHtml: String,
    footerHtml: String,
    leftHtml: String,
    rightHtml: String,
    showAllPageTitle: {
      type: Boolean,
      default: () => getConfig().print.showAllPageTitle
    },
    pageStyle: {
      type: Object,
      default: () => getConfig().print.pageStyle
    },
    customStyle: {
      type: String,
      default: () => getConfig().print.customStyle
    },
    beforeMethod: Function
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      staticPageBreaks: []
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xePrint = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $print: $xePrint
      }, params));
    };
    const printMethods = {
      dispatchEvent,
      print() {
        const elem = refElem.value;
        return printHtml(Object.assign({}, props, {
          _pageBreaks: !!reactData.staticPageBreaks.length,
          html: trimHtml(elem ? elem.outerHTML : '') || props.html || props.content || ''
        }));
      }
    };
    const printPrivateMethods = {};
    Object.assign($xePrint, printMethods, printPrivateMethods);
    const renderPageConfigLayouts = () => {
      const {
        title,
        showPageNumber,
        showAllPageTitle,
        align,
        headerAlign,
        footerAlign
      } = props;
      const pageBreaks = props.pageBreaks || [];
      const pageCount = pageBreaks.length;
      return pageBreaks.map((item, index) => {
        const bodyHtml = item.bodyHtml;
        const headerHtml = item.headerHtml || props.headerHtml;
        const footerHtml = item.footerHtml || props.footerHtml;
        const leftHtml = item.leftHtml || props.leftHtml;
        const rightHtml = item.rightHtml || props.rightHtml;
        const currentPage = index + 1;
        const params = {
          currentPage,
          pageCount
        };
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-print-page-break', align ? `align--${align}` : '']
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-print-page-break--header', headerAlign ? `align--${headerAlign}` : '']
        }, headerHtml ? `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(headerHtml) ? headerHtml(params) : headerHtml || ''}` : [title && (showAllPageTitle || !index) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--header-title'
        }, `${title || ''}`) : renderEmptyElement($xePrint)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--body'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--left'
        }, `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(leftHtml) ? leftHtml(params) : leftHtml || ''}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--content'
        }, `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(bodyHtml) ? bodyHtml(params) : bodyHtml || ''}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--right'
        }, `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(rightHtml) ? rightHtml(params) : rightHtml || ''}`)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-print-page-break--footer', footerAlign ? `align--${footerAlign}` : '']
        }, footerHtml ? `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(footerHtml) ? footerHtml(params) : footerHtml || ''}` : [showPageNumber ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--footer-page-number'
        }, `${currentPage}/${pageCount}`) : renderEmptyElement($xePrint)])]);
      });
    };
    const renderPageStaticLayouts = () => {
      const {
        title,
        showPageNumber,
        showAllPageTitle,
        align,
        headerAlign,
        footerAlign
      } = props;
      const {
        staticPageBreaks
      } = reactData;
      const pageCount = staticPageBreaks.length;
      return staticPageBreaks.map((item, index) => {
        const itemSlots = item.slots || {};
        const currentPage = index + 1;
        const defaultSlot = itemSlots.default;
        const headerSlot = itemSlots.header || slots.header;
        const footerSlot = itemSlots.footer || slots.footer;
        const leftSlot = itemSlots.left || slots.left;
        const rightSlot = itemSlots.right || slots.right;
        const params = {
          currentPage,
          pageCount
        };
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-print-page-break', align ? `align--${align}` : '']
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-print-page-break--header', headerAlign ? `align--${headerAlign}` : '']
        }, headerSlot ? vn_getSlotVNs(headerSlot(params)) : [title && (showAllPageTitle || !index) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--header-title'
        }, `${title || ''}`) : renderEmptyElement($xePrint)]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--body'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--left'
        }, leftSlot ? vn_getSlotVNs(leftSlot(params)) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--content'
        }, defaultSlot ? vn_getSlotVNs(defaultSlot(params)) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--right'
        }, rightSlot ? vn_getSlotVNs(rightSlot(params)) : [])]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-print-page-break--footer', footerAlign ? `align--${footerAlign}` : '']
        }, footerSlot ? vn_getSlotVNs(footerSlot(params)) : [showPageNumber ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-print-page-break--footer-page-number'
        }, `${currentPage}/${pageCount}`) : renderEmptyElement($xePrint)])]);
      });
    };
    const renderVN = () => {
      const {
        customLayout
      } = props;
      const {
        staticPageBreaks
      } = reactData;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-print']
      }, customLayout ? defaultSlot ? vn_getSlotVNs(defaultSlot({})) : [] : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'slot',
        class: 'vxe-print-slots'
      }, defaultSlot ? vn_getSlotVNs(defaultSlot({})) : [])].concat(staticPageBreaks.length ? renderPageStaticLayouts() : renderPageConfigLayouts()));
    };
    $xePrint.renderVN = renderVN;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xePrint', $xePrint);
    return $xePrint;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/print/index.ts




const VxePrint = Object.assign({}, print, {
  install(app) {
    app.component(print.name, print);
  }
});
dynamicApp.use(VxePrint);
index_esm_VxeUI.component(print);
index_esm_VxeUI.print = printHtml;
const Print = VxePrint;
/* harmony default export */ var packages_print = (VxePrint);
;// CONCATENATED MODULE: ./packages/pulldown/src/pulldown.ts






/* harmony default export */ var pulldown = (defineVxeComponent({
  name: 'VxePulldown',
  props: {
    modelValue: Boolean,
    disabled: Boolean,
    placement: String,
    trigger: {
      type: String,
      default: getConfig().pulldown.trigger
    },
    size: {
      type: String,
      default: () => getConfig().size
    },
    options: Array,
    className: {
      type: [String, Function],
      default: getConfig().pulldown.className
    },
    popupClassName: [String, Function],
    showPopupShadow: Boolean,
    destroyOnClose: {
      type: Boolean,
      default: getConfig().pulldown.destroyOnClose
    },
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: ['update:modelValue', 'click', 'option-click', 'show-panel', 'hide-panel', 'visible-change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = {
      hpTimeout: undefined
    };
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPulldownContent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPulldownPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().pulldown.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const refMaps = {
      refElem
    };
    const $xePulldown = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let pulldownMethods = {};
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const isPanelVisible = () => {
      return reactData.visiblePanel;
    };
    /**
     * 手动更新位置
     */
    const updatePlacement = () => {
      const {
        placement
      } = props;
      const {
        panelIndex
      } = reactData;
      const targetElem = refPulldownContent.value;
      const panelElem = refPulldownPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(handleStyle);
    };
    /**
     * 显示下拉面板
     */
    const showPanel = () => {
      if (!reactData.initialized) {
        reactData.initialized = true;
      }
      return new Promise(resolve => {
        if (!props.disabled) {
          if (internalData.hpTimeout) {
            clearTimeout(internalData.hpTimeout);
          }
          reactData.isActivated = true;
          reactData.isAniVisible = true;
          setTimeout(() => {
            reactData.visiblePanel = true;
            emit('update:modelValue', true);
            updatePlacement();
            setTimeout(() => {
              resolve(updatePlacement());
            }, 40);
          }, 10);
          updateZindex();
          dispatchEvent('visible-change', {
            visible: true
          }, null);
        } else {
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            resolve();
          });
        }
      });
    };
    /**
     * 隐藏下拉面板
     */
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      dispatchEvent('visible-change', {
        visible: false
      }, null);
      emit('update:modelValue', false);
      return new Promise(resolve => {
        if (reactData.isAniVisible) {
          internalData.hpTimeout = setTimeout(() => {
            reactData.isAniVisible = false;
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              resolve();
            });
          }, 350);
        } else {
          (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
            resolve();
          });
        }
      });
    };
    /**
     * 切换下拉面板
     */
    const togglePanel = () => {
      if (reactData.visiblePanel) {
        return hideOptionPanel();
      }
      return showPanel();
    };
    const handleOptionEvent = (evnt, option) => {
      if (!option.disabled) {
        if (reactData.visiblePanel) {
          hideOptionPanel();
          dispatchEvent('hide-panel', {}, evnt);
        }
        dispatchEvent('option-click', {
          option
        }, evnt);
      }
    };
    const clickTargetEvent = evnt => {
      const {
        trigger
      } = props;
      if (trigger === 'click') {
        if (reactData.visiblePanel) {
          hideOptionPanel();
          dispatchEvent('hide-panel', {}, evnt);
        } else {
          showPanel();
          dispatchEvent('show-panel', {}, evnt);
        }
      }
      dispatchEvent('click', {
        $pulldown: $xePulldown
      }, evnt);
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        disabled
      } = props;
      const {
        visiblePanel
      } = reactData;
      const panelElem = refPulldownPanel.value;
      if (!disabled) {
        if (visiblePanel) {
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
            dispatchEvent('hide-panel', {}, evnt);
          }
        }
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const {
        disabled
      } = props;
      const {
        visiblePanel
      } = reactData;
      const el = refElem.value;
      const panelElem = refPulldownPanel.value;
      if (!disabled) {
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
          dispatchEvent('hide-panel', {}, evnt);
        }
      }
    };
    const handleGlobalBlurEvent = evnt => {
      const {
        visiblePanel,
        isActivated
      } = reactData;
      if (visiblePanel) {
        hideOptionPanel();
        dispatchEvent('hide-panel', {}, evnt);
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
    };
    const handleGlobalResizeEvent = () => {
      const {
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $pulldown: $xePulldown
      }, params));
    };
    pulldownMethods = {
      dispatchEvent,
      isPanelVisible,
      togglePanel,
      showPanel,
      hidePanel: hideOptionPanel
    };
    Object.assign($xePulldown, pulldownMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, value => {
      reactData.isActivated = !!value;
      if (value) {
        showPanel();
      } else {
        hideOptionPanel();
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      if (props.modelValue) {
        showPanel();
      }
      globalEvents.on($xePulldown, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xePulldown, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xePulldown, 'blur', handleGlobalBlurEvent);
      globalEvents.on($xePulldown, 'resize', handleGlobalResizeEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xePulldown, 'mousewheel');
      globalEvents.off($xePulldown, 'mousedown');
      globalEvents.off($xePulldown, 'blur');
      globalEvents.off($xePulldown, 'resize');
    });
    const renderDefaultPanel = options => {
      const optionSlot = slots.option;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-pulldown--panel-list'
      }, options ? options.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-pulldown--panel-item',
          onClick(evnt) {
            handleOptionEvent(evnt, item);
          }
        }, optionSlot ? optionSlot({
          $pulldown: $xePulldown,
          option: item
        }) : `${item.label || ''}`);
      }) : []);
    };
    const renderVN = () => {
      const {
        className,
        options,
        popupClassName,
        showPopupShadow,
        destroyOnClose,
        disabled
      } = props;
      const {
        initialized,
        isActivated,
        isAniVisible,
        visiblePanel,
        panelStyle,
        panelPlacement
      } = reactData;
      const btnTransfer = computeBtnTransfer.value;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const dropdownSlot = slots.dropdown;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-pulldown', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $pulldown: $xePulldown
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--visible': visiblePanel,
          'is--disabled': disabled,
          'is--active': isActivated
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refPulldownContent,
        class: 'vxe-pulldown--content',
        onClick: clickTargetEvent
      }, defaultSlot ? defaultSlot({
        $pulldown: $xePulldown
      }) : []), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: btnTransfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refPulldownPanel,
        class: ['vxe-table--ignore-clear vxe-pulldown--panel', popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
          $pulldown: $xePulldown
        }) : popupClassName : '', {
          [`size--${vSize}`]: vSize,
          'is--transfer': btnTransfer,
          'ani--leave': isAniVisible,
          'ani--enter': visiblePanel
        }],
        placement: panelPlacement,
        style: panelStyle
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-pulldown--panel-wrapper', {
          'is--shadow': showPopupShadow
        }]
      }, initialized && (destroyOnClose ? visiblePanel || isAniVisible : true) ? [headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-pulldown--panel-header'
      }, headerSlot({
        $pulldown: $xePulldown
      })) : renderEmptyElement($xePulldown), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-pulldown--panel-body'
      }, dropdownSlot ? dropdownSlot({
        $pulldown: $xePulldown
      }) : [renderDefaultPanel(options)]), footerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-pulldown--panel-footer'
      }, footerSlot({
        $pulldown: $xePulldown
      })) : renderEmptyElement($xePulldown)] : [])])])]);
    };
    $xePulldown.renderVN = renderVN;
    return $xePulldown;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/pulldown/index.ts



const VxePulldown = Object.assign(pulldown, {
  install: function (app) {
    app.component(pulldown.name, pulldown);
  }
});
dynamicApp.use(VxePulldown);
index_esm_VxeUI.component(pulldown);
const Pulldown = VxePulldown;
/* harmony default export */ var packages_pulldown = (VxePulldown);
;// CONCATENATED MODULE: ./packages/radio/src/radio.ts





/* harmony default export */ var src_radio = (defineVxeComponent({
  name: 'VxeRadio',
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number, Boolean],
      default: null
    },
    title: [String, Number],
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    name: String,
    strict: {
      type: Boolean,
      default: () => getConfig().radio.strict
    },
    size: {
      type: String,
      default: () => getConfig().radio.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const $xeRadioGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeRadioGroup', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const $xeRadio = {
      xID,
      props,
      context,
      reactData
    };
    const {
      computeSize
    } = useSize(props);
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeRadioGroup) {
          const {
            computeIsDisabled
          } = $xeRadioGroup.getComputeMaps();
          return computeIsDisabled.value;
        }
      }
      return disabled;
    });
    const computeName = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return $xeRadioGroup ? $xeRadioGroup.name : props.name;
    });
    const computeStrict = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return $xeRadioGroup ? $xeRadioGroup.props.strict : props.strict;
    });
    const computeChecked = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        label
      } = props;
      return $xeRadioGroup ? $xeRadioGroup.props.modelValue === label : props.modelValue === label;
    });
    const handleValue = (label, evnt) => {
      if ($xeRadioGroup) {
        $xeRadioGroup.handleChecked({
          label
        }, evnt);
      } else {
        emit('update:modelValue', label);
        dispatchEvent('change', {
          value: label,
          label
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, label);
        }
      }
    };
    const changeEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        handleValue(props.label, evnt);
      }
    };
    const clickEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      const isStrict = computeStrict.value;
      if (!isDisabled && !isStrict) {
        if (props.label === ($xeRadioGroup ? $xeRadioGroup.props.modelValue : props.modelValue)) {
          handleValue(null, evnt);
        }
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $radio: $xeRadio
      }, params));
    };
    const radioMethods = {
      dispatchEvent
    };
    const radioPrivateMethods = {};
    Object.assign($xeRadio, radioMethods, radioPrivateMethods);
    const renderVN = () => {
      const {
        label
      } = props;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const name = computeName.value;
      const isChecked = computeChecked.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('label', {
        key: label,
        class: ['vxe-radio vxe-radio--default', {
          [`size--${vSize}`]: vSize,
          'is--checked': isChecked,
          'is--disabled': isDisabled
        }],
        title: props.title
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        class: 'vxe-radio--input',
        type: 'radio',
        name,
        checked: isChecked,
        disabled: isDisabled,
        onChange: changeEvent,
        onClick: clickEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-radio--icon', isChecked ? getIcon().RADIO_CHECKED : isDisabled ? getIcon().RADIO_DISABLED_UNCHECKED : getIcon().RADIO_UNCHECKED]
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-radio--label'
      }, slots.default ? slots.default({}) : getFuncText(props.content))]);
    };
    $xeRadio.renderVN = renderVN;
    return $xeRadio;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/radio/index.ts



const VxeRadio = Object.assign(src_radio, {
  install: function (app) {
    app.component(src_radio.name, src_radio);
  }
});
dynamicApp.use(VxeRadio);
index_esm_VxeUI.component(src_radio);
const Radio = VxeRadio;
/* harmony default export */ var packages_radio = (VxeRadio);
;// CONCATENATED MODULE: ./packages/radio/src/button.ts





/* harmony default export */ var radio_src_button = (defineVxeComponent({
  name: 'VxeRadioButton',
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number, Boolean],
      default: null
    },
    title: [String, Number],
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    strict: {
      type: Boolean,
      default: () => getConfig().radioButton.strict
    },
    size: {
      type: String,
      default: () => getConfig().radioButton.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const $xeRadioGroup = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeRadioGroup', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const {
      computeSize
    } = useSize(props);
    const $xeRadioButton = {
      xID,
      props,
      context,
      reactData
    };
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeRadioGroup) {
          const {
            computeIsDisabled
          } = $xeRadioGroup.getComputeMaps();
          return computeIsDisabled.value;
        }
      }
      return disabled;
    });
    const computeName = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return $xeRadioGroup ? $xeRadioGroup.name : null;
    });
    const computeStrict = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return $xeRadioGroup ? $xeRadioGroup.props.strict : props.strict;
    });
    const computeChecked = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        label
      } = props;
      return $xeRadioGroup ? $xeRadioGroup.props.modelValue === label : props.modelValue === label;
    });
    const radioButtonMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $radioButton: $xeRadioButton
        }, params));
      }
    };
    const radioButtonPrivateMethods = {};
    Object.assign($xeRadioButton, radioButtonMethods, radioButtonPrivateMethods);
    const handleValue = (label, evnt) => {
      if ($xeRadioGroup) {
        $xeRadioGroup.handleChecked({
          label
        }, evnt);
      } else {
        emit('update:modelValue', label);
        radioButtonMethods.dispatchEvent('change', {
          value: label,
          label
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, label);
        }
      }
    };
    const changeEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        handleValue(props.label, evnt);
      }
    };
    const clickEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      const isStrict = computeStrict.value;
      if (!isDisabled && !isStrict) {
        if (props.label === ($xeRadioGroup ? $xeRadioGroup.props.modelValue : props.modelValue)) {
          handleValue(null, evnt);
        }
      }
    };
    const renderVN = () => {
      const {
        label
      } = props;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const name = computeName.value;
      const isChecked = computeChecked.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('label', {
        key: label,
        class: ['vxe-radio vxe-radio--button', {
          [`size--${vSize}`]: vSize,
          'is--disabled': isDisabled
        }],
        title: props.title
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('input', {
        class: 'vxe-radio--input',
        type: 'radio',
        name,
        checked: isChecked,
        disabled: isDisabled,
        onChange: changeEvent,
        onClick: clickEvent
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-radio--label'
      }, slots.default ? slots.default({}) : getFuncText(props.content))]);
    };
    $xeRadioButton.renderVN = renderVN;
    return renderVN;
  }
}));
;// CONCATENATED MODULE: ./packages/radio-button/index.ts



const VxeRadioButton = Object.assign(radio_src_button, {
  install: function (app) {
    app.component(radio_src_button.name, radio_src_button);
  }
});
dynamicApp.use(VxeRadioButton);
index_esm_VxeUI.component(radio_src_button);
const RadioButton = VxeRadioButton;
/* harmony default export */ var radio_button = (VxeRadioButton);
;// CONCATENATED MODULE: ./packages/radio/src/group.ts






/* harmony default export */ var radio_src_group = (defineVxeComponent({
  name: 'VxeRadioGroup',
  props: {
    modelValue: [String, Number, Boolean],
    disabled: {
      type: Boolean,
      default: null
    },
    type: String,
    options: Array,
    optionProps: Object,
    strict: {
      type: Boolean,
      default: () => getConfig().radioGroup.strict
    },
    size: {
      type: String,
      default: () => getConfig().radioGroup.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeMaps = {
      computeIsDisabled
    };
    const $xeRadioGroup = {
      xID,
      props,
      context,
      reactData,
      name: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('xe_group_'),
      getComputeMaps: () => computeMaps
    };
    const computePropsOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, props.optionProps);
    });
    const computeLabelField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || 'label';
    });
    const computeValueField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || 'value';
    });
    const computeDisabledField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.disabled || 'disabled';
    });
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $radioGroup: $xeRadioGroup
      }, params));
    };
    const radioGroupMethods = {
      dispatchEvent
    };
    const radioGroupPrivateMethods = {
      handleChecked(params, evnt) {
        const value = params.label;
        emit('update:modelValue', value);
        dispatchEvent('change', {
          value,
          label: value
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    Object.assign($xeRadioGroup, radioGroupMethods, radioGroupPrivateMethods);
    const renderVN = () => {
      const {
        options,
        type
      } = props;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const disabledField = computeDisabledField.value;
      const btnComp = type === 'button' ? radio_src_button : src_radio;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-radio-group', {
          [`size--${vSize}`]: vSize
        }]
      }, defaultSlot ? defaultSlot({}) : options ? options.map(item => {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(btnComp, {
          key: item[valueField],
          label: item[valueField],
          content: item[labelField],
          disabled: item[disabledField]
        });
      }) : []);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeRadioGroup', $xeRadioGroup);
    $xeRadioGroup.renderVN = renderVN;
    return $xeRadioGroup;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/radio-group/index.ts



const VxeRadioGroup = Object.assign(radio_src_group, {
  install: function (app) {
    app.component(radio_src_group.name, radio_src_group);
  }
});
dynamicApp.use(VxeRadioGroup);
index_esm_VxeUI.component(radio_src_group);
const RadioGroup = VxeRadioGroup;
/* harmony default export */ var radio_group = (VxeRadioGroup);
;// CONCATENATED MODULE: ./packages/rate/src/rate.ts




/* harmony default export */ var rate = (defineVxeComponent({
  name: 'VxeRate',
  props: {
    modelValue: [Number, String],
    disabled: {
      type: Boolean,
      default: null
    },
    readonly: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().rate.size || getConfig().size
    },
    status: String
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      activeValue: null
    });
    const refMaps = {
      refElem
    };
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return readonly;
    });
    const computeNumVal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue
      } = props;
      const {
        activeValue
      } = reactData;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(activeValue === null ? modelValue : activeValue);
    });
    const computeItemList = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return [1, 2, 3, 4, 5].map(num => {
        return {
          value: num,
          label: num
        };
      });
    });
    const computeMaps = {};
    const $xeRate = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $rate: $xeRate
      }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    const emitModel = value => {
      emit('update:modelValue', value);
    };
    const mouseenterEvent = (evnt, item) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!(isDisabled || isReadonly)) {
        const value = item.value;
        reactData.activeValue = value;
      }
    };
    const mouseleaveEvent = () => {
      reactData.activeValue = null;
    };
    const clickEvent = (evnt, item) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!(isDisabled || isReadonly)) {
        const value = item.value;
        emitModel(value);
        dispatchEvent('change', {
          value
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    Object.assign($xeRate, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const {
        status
      } = props;
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      const itemList = computeItemList.value;
      const vSize = computeSize.value;
      const numVal = computeNumVal.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-rate', {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          'is--disabled': isDisabled,
          'is--readonly': isReadonly
        }]
      }, itemList.map(item => {
        const isChecked = numVal >= item.value;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-rte--item', {
            'is--checked': isChecked
          }],
          onMouseenter(evnt) {
            if (!(isDisabled || isReadonly)) {
              mouseenterEvent(evnt, item);
            }
          },
          onMouseleave: mouseleaveEvent,
          onClick(evnt) {
            if (!(isDisabled || isReadonly)) {
              clickEvent(evnt, item);
            }
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: isChecked ? getIcon().RATE_CHECKED : getIcon().RATE_UNCHECKED
        })]);
      }));
    };
    $xeRate.renderVN = renderVN;
    return $xeRate;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/rate/index.ts



const VxeRate = Object.assign({}, rate, {
  install(app) {
    app.component(rate.name, rate);
  }
});
dynamicApp.use(VxeRate);
index_esm_VxeUI.component(rate);
const Rate = VxeRate;
/* harmony default export */ var packages_rate = (VxeRate);
;// CONCATENATED MODULE: ./packages/result/src/result.ts




/* harmony default export */ var result = (defineVxeComponent({
  name: 'VxeResult',
  props: {
    imageUrl: String,
    imageStyle: Object,
    icon: String,
    type: [String, Number],
    status: [String, Number],
    title: [String, Number],
    content: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeResult = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $result: $xeResult
      }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeResult, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const {
        imageUrl,
        imageStyle,
        icon,
        title,
        type,
        content
      } = props;
      const status = props.status || type;
      const slotExtra = slots.extra;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: 'refElem',
        class: ['vxe-result', {
          [`theme--${status}`]: status
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-result--inner'
      }, [imageUrl ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-result--img-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('img', {
        src: imageUrl,
        style: imageStyle
      })]) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-result--icon-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: [icon, type ? getIcon()[`RESULT_${type}`.toLocaleUpperCase()] : '']
      })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-result--title-wrapper'
      }, `${title || ''}`), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-result--content-wrapper'
      }, `${content || ''}`), slotExtra ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-result--extra-wrapper'
      }, slotExtra({})) : renderEmptyElement($xeResult)])]);
    };
    $xeResult.renderVN = renderVN;
    return $xeResult;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/result/index.ts



const VxeResult = Object.assign({}, result, {
  install(app) {
    app.component(result.name, result);
  }
});
dynamicApp.use(VxeResult);
index_esm_VxeUI.component(result);
const Result = VxeResult;
/* harmony default export */ var packages_result = (VxeResult);
;// CONCATENATED MODULE: ./packages/row/src/row.ts





/* harmony default export */ var row = (defineVxeComponent({
  name: 'VxeRow',
  props: {
    gutter: [Number, String, Array],
    wrap: {
      type: Boolean,
      default: () => getConfig().row.wrap
    },
    vertical: Boolean,
    size: {
      type: String,
      default: () => getConfig().row.size || getConfig().size
    }
  },
  emits: ['click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeRowStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        gutter,
        vertical
      } = props;
      const style = {};
      if (gutter) {
        let [lrGutter, tbGutter] = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(gutter) ? gutter : [gutter];
        if (vertical) {
          tbGutter = lrGutter;
          lrGutter = '';
        }
        if (lrGutter) {
          const offsetSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(lrGutter) ? toCssUnit(-(lrGutter / 2)) : `calc(${toCssUnit(lrGutter)} / 2 * -1)`;
          style.marginLeft = offsetSize;
          style.marginRight = offsetSize;
        }
        if (tbGutter) {
          const offsetSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(tbGutter) ? toCssUnit(-(tbGutter / 2)) : `calc(${toCssUnit(tbGutter)} / 2 * -1)`;
          style.marginTop = offsetSize;
          style.marginBottom = offsetSize;
        }
      }
      return style;
    });
    const computeMaps = {};
    const $xeRow = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const clickEvent = evnt => {
      dispatchEvent('click', {}, evnt);
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $row: $xeRow
      }, params));
    };
    const rowMethods = {
      dispatchEvent
    };
    const rowPrivateMethods = {};
    Object.assign($xeRow, rowMethods, rowPrivateMethods);
    const renderVN = () => {
      const {
        vertical,
        wrap
      } = props;
      const rowStyle = computeRowStyle.value;
      const defaultSlot = slots.default;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-row', {
          'is--vertical': vertical,
          'is--wrap': wrap
        }],
        style: rowStyle,
        onClick: clickEvent
      }, defaultSlot ? defaultSlot({}) : []);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeRow', $xeRow);
    $xeRow.renderVN = renderVN;
    return $xeRow;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/row/index.ts



const VxeRow = Object.assign({}, row, {
  install(app) {
    app.component(row.name, row);
  }
});
dynamicApp.use(VxeRow);
index_esm_VxeUI.component(row);
const Row = VxeRow;
/* harmony default export */ var packages_row = (VxeRow);
;// CONCATENATED MODULE: ./packages/select/index.ts



const VxeSelect = Object.assign(src_select, {
  install: function (app) {
    app.component(src_select.name, src_select);
  }
});
dynamicApp.use(VxeSelect);
index_esm_VxeUI.component(src_select);
const Select = VxeSelect;
/* harmony default export */ var packages_select = (VxeSelect);
;// CONCATENATED MODULE: ./packages/split/src/split.ts









/* harmony default export */ var split = (defineVxeComponent({
  name: 'VxeSplit',
  props: {
    width: [Number, String],
    height: [Number, String],
    vertical: {
      type: Boolean,
      default: () => getConfig().split.vertical
    },
    border: {
      type: Boolean,
      default: () => getConfig().split.border
    },
    padding: {
      type: Boolean,
      default: () => getConfig().split.padding
    },
    resize: {
      type: Boolean,
      default: () => getConfig().split.resize
    },
    items: Array,
    itemConfig: Object,
    barConfig: Object,
    actionConfig: Object
  },
  emits: ['action-dblclick', 'action-click', 'toggle-expand', 'resize-start', 'resize-drag', 'resize-end'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      staticItems: [],
      itemList: []
    });
    const internalData = {
      wrapperWidth: 0,
      wrapperHeight: 0
    };
    const computeItemOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().split.itemConfig, props.itemConfig);
    });
    const computeBarOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().split.barConfig, props.barConfig);
    });
    const computeActionOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().split.actionConfig, props.actionConfig);
    });
    const computeIsFoldNext = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const actionOpts = computeActionOpts.value;
      return actionOpts.direction === 'next';
    });
    const computeVisibleItems = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return reactData.itemList.filter(item => item.isVisible);
    });
    const computeAutoItems = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        vertical
      } = props;
      const autoItems = [];
      let heightCount = 0;
      let widthCount = 0;
      reactData.itemList.forEach(vertical ? item => {
        const {
          renderHeight,
          resizeHeight,
          foldHeight,
          isVisible,
          height
        } = item;
        const itemHeight = isVisible ? foldHeight || resizeHeight || renderHeight : 0;
        if (!height) {
          autoItems.push(item);
        }
        heightCount += itemHeight;
      } : item => {
        const {
          renderWidth,
          resizeWidth,
          foldWidth,
          isVisible,
          width
        } = item;
        const itemWidth = isVisible ? foldWidth || resizeWidth || renderWidth : 0;
        if (!width) {
          autoItems.push(item);
        }
        widthCount += itemWidth;
      });
      return {
        autoItems,
        heightCount,
        heightRatio: heightCount / 100,
        widthCount,
        widthRatio: widthCount / 100
      };
    });
    const computeBarStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const barOpts = computeBarOpts.value;
      const {
        width,
        height
      } = barOpts;
      const stys = {};
      if (height) {
        stys.height = toCssUnit(height);
      }
      if (width) {
        stys.width = toCssUnit(width);
      }
      return stys;
    });
    const computeMaps = {
      computeItemOpts,
      computeBarOpts,
      computeActionOpts,
      computeIsFoldNext
    };
    const refMaps = {
      refElem
    };
    const $xeSplit = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $split: $xeSplit
      }, params));
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
          return vn_getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const getDefaultActionIcon = item => {
      const {
        vertical
      } = props;
      const {
        showAction,
        isExpand
      } = item;
      const isFoldNext = computeIsFoldNext.value;
      const topIcon = 'SPLIT_TOP_ACTION';
      const bottomIcon = 'SPLIT_BOTTOM_ACTION';
      const leftIcon = 'SPLIT_LEFT_ACTION';
      const rightIcon = 'SPLIT_RIGHT_ACTION';
      if (showAction) {
        let iconName = '';
        if (isFoldNext) {
          if (vertical) {
            iconName = isExpand ? bottomIcon : topIcon;
          } else {
            iconName = isExpand ? rightIcon : leftIcon;
          }
        } else {
          if (vertical) {
            iconName = isExpand ? topIcon : bottomIcon;
          } else {
            iconName = isExpand ? leftIcon : rightIcon;
          }
        }
        if (iconName) {
          return getIcon()[iconName];
        }
      }
      return '';
    };
    const reset = () => {
      const {
        itemList
      } = reactData;
      itemList.forEach(item => {
        item.isExpand = true;
        item.isVisible = true;
        item.foldHeight = 0;
        item.foldWidth = 0;
        item.resizeHeight = 0;
        item.resizeWidth = 0;
      });
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const handleLoadItem = (list, isReset) => {
      const {
        staticItems
      } = reactData;
      const itemDef = {
        isVisible: true,
        isExpand: true,
        renderWidth: 0,
        resizeWidth: 0,
        foldWidth: 0,
        renderHeight: 0,
        resizeHeight: 0,
        foldHeight: 0
      };
      reactData.itemList = list.map(item => {
        if (item.slots) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(item.slots, func => {
            if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(func)) {
              if (!slots[func]) {
                errLog('vxe.error.notSlot', [func]);
              }
            }
          });
        }
        return Object.assign({}, isReset ? null : itemDef, item, isReset ? itemDef : null, {
          id: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId()
        });
      });
      if (staticItems.length) {
        errLog('vxe.error.errConflicts', ['<vxe-split-pane ...>', 'items']);
      }
      return recalculate();
    };
    const loadItem = list => {
      return handleLoadItem(list || [], false);
    };
    const reloadItem = list => {
      return handleLoadItem(list || [], true);
    };
    const recalculate = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          vertical
        } = props;
        const {
          itemList
        } = reactData;
        const el = refElem.value;
        if (!el) {
          return;
        }
        const wWidth = el.clientWidth;
        const wHeight = el.clientHeight;
        if (!wWidth || !wHeight) {
          return;
        }
        const itemOpts = computeItemOpts.value;
        const allMinWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(itemOpts.minWidth);
        const allMinHeight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(itemOpts.minHeight);
        const residueItems = [];
        if (vertical) {
          let countHeight = 0;
          itemList.forEach(item => {
            const {
              height
            } = item;
            let itemHeight = 0;
            if (height) {
              if (isScale(height)) {
                itemHeight = wHeight * external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(height) / 100;
              } else {
                itemHeight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(height);
              }
              item.renderHeight = itemHeight;
            } else {
              residueItems.push(item);
            }
            countHeight += itemHeight;
          });
          if (residueItems.length) {
            const reMeanHeight = (wHeight - countHeight) / residueItems.length;
            residueItems.forEach(item => {
              item.renderHeight = Math.max(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getGlobalDefaultConfig(item.minHeight, allMinHeight)), reMeanHeight);
            });
          }
        } else {
          let countWidth = 0;
          itemList.forEach(item => {
            const {
              width
            } = item;
            let itemWidth = 0;
            if (width) {
              if (isScale(width)) {
                itemWidth = wWidth * external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(width) / 100;
              } else {
                itemWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(width);
              }
              item.renderWidth = itemWidth;
            } else {
              residueItems.push(item);
            }
            countWidth += itemWidth;
          });
          if (residueItems.length) {
            const reMeanWidth = (wWidth - countWidth) / residueItems.length;
            residueItems.forEach(item => {
              item.renderWidth = Math.max(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getGlobalDefaultConfig(item.minWidth, allMinWidth)), reMeanWidth);
            });
          }
        }
        internalData.wrapperWidth = wWidth;
        internalData.wrapperHeight = wHeight;
      });
    };
    const dragEvent = evnt => {
      const {
        resize,
        vertical
      } = props;
      const {
        itemList
      } = reactData;
      if (!resize) {
        return;
      }
      evnt.preventDefault();
      const barEl = evnt.currentTarget;
      const handleEl = barEl.parentElement;
      const el = refElem.value;
      if (!el) {
        return;
      }
      const itemId = handleEl.getAttribute('itemid');
      const itemIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(itemList, item => item.id === itemId);
      const item = itemList[itemIndex];
      if (!item) {
        return;
      }
      if (!item.isExpand) {
        return;
      }
      const isFoldNext = computeIsFoldNext.value;
      const itemOpts = computeItemOpts.value;
      const allMinWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(itemOpts.minWidth);
      const allMinHeight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(itemOpts.minHeight);
      const targetItem = itemList[itemIndex + (isFoldNext ? 1 : -1)];
      const targetItemEl = targetItem ? el.querySelector(`.vxe-split-pane[itemid="${targetItem.id}"]`) : null;
      const currItemEl = item ? el.querySelector(`.vxe-split-pane[itemid="${item.id}"]`) : null;
      const targetWidth = targetItemEl ? targetItemEl.clientWidth : 0;
      const currWidth = currItemEl ? currItemEl.clientWidth : 0;
      const targetHeight = targetItemEl ? targetItemEl.clientHeight : 0;
      const currHeight = currItemEl ? currItemEl.clientHeight : 0;
      const targetMinWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(targetItem ? getGlobalDefaultConfig(targetItem.minWidth, allMinWidth) : allMinWidth);
      const currMinWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getGlobalDefaultConfig(item.minWidth, allMinWidth));
      const targetMinHeight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(targetItem ? getGlobalDefaultConfig(targetItem.minHeight, allMinHeight) : allMinHeight);
      const currMinHeight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getGlobalDefaultConfig(item.minHeight, allMinHeight));
      const disX = evnt.clientX;
      const disY = evnt.clientY;
      addClass(el, 'is--drag');
      document.onmousemove = evnt => {
        evnt.preventDefault();
        if (vertical) {
          const offsetTop = isFoldNext ? disY - evnt.clientY : evnt.clientY - disY;
          if (offsetTop > 0) {
            if (targetItem) {
              if (currHeight - offsetTop >= currMinHeight) {
                const reHeight = currHeight - offsetTop;
                targetItem.resizeHeight = targetHeight + offsetTop;
                item.resizeHeight = reHeight;
                dispatchEvent('resize-drag', {
                  item,
                  name: item.name,
                  offsetHeight: offsetTop,
                  resizeHeight: reHeight,
                  offsetWidth: 0,
                  resizeWidth: 0
                }, evnt);
              }
            }
          } else {
            if (targetItem) {
              if (targetHeight + offsetTop >= targetMinHeight) {
                const reHeight = currHeight - offsetTop;
                targetItem.resizeHeight = targetHeight + offsetTop;
                item.resizeHeight = reHeight;
                dispatchEvent('resize-drag', {
                  item,
                  name: item.name,
                  offsetHeight: offsetTop,
                  resizeHeight: reHeight,
                  offsetWidth: 0,
                  resizeWidth: 0
                }, evnt);
              }
            }
          }
        } else {
          const offsetLeft = isFoldNext ? disX - evnt.clientX : evnt.clientX - disX;
          if (offsetLeft > 0) {
            if (targetItem) {
              if (currWidth - offsetLeft >= currMinWidth) {
                const reWidth = currWidth - offsetLeft;
                targetItem.resizeWidth = targetWidth + offsetLeft;
                item.resizeWidth = reWidth;
                dispatchEvent('resize-drag', {
                  item,
                  name: item.name,
                  offsetHeight: 0,
                  resizeHeight: 0,
                  offsetWidth: offsetLeft,
                  resizeWidth: reWidth
                }, evnt);
              }
            }
          } else {
            if (targetItem) {
              if (targetWidth + offsetLeft >= targetMinWidth) {
                const reWidth = currWidth - offsetLeft;
                targetItem.resizeWidth = targetWidth + offsetLeft;
                item.resizeWidth = reWidth;
                dispatchEvent('resize-drag', {
                  item,
                  name: item.name,
                  offsetHeight: 0,
                  resizeHeight: 0,
                  offsetWidth: offsetLeft,
                  resizeWidth: reWidth
                }, evnt);
              }
            }
          }
        }
      };
      document.onmouseup = evnt => {
        document.onmousemove = null;
        document.onmouseup = null;
        removeClass(el, 'is--drag');
        dispatchEvent('resize-end', {
          item,
          name: item.name,
          resizeHeight: item.resizeHeight,
          resizeWidth: item.resizeWidth
        }, evnt);
        recalculate();
      };
      dispatchEvent('resize-start', {
        item,
        name: item.name
      }, evnt);
    };
    const handleItemActionEvent = evnt => {
      const el = refElem.value;
      if (!el) {
        return;
      }
      const {
        vertical
      } = props;
      const {
        itemList
      } = reactData;
      const isFoldNext = computeIsFoldNext.value;
      const btnEl = evnt.currentTarget;
      const handleEl = btnEl.parentElement;
      const itemId = handleEl.getAttribute('itemid');
      const itemIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(itemList, item => item.id === itemId);
      const item = itemList[itemIndex];
      const targetItem = itemList[itemIndex + (isFoldNext ? 1 : -1)];
      if (item) {
        const {
          showAction,
          isExpand
        } = item;
        if (showAction) {
          if (vertical) {
            if (targetItem) {
              targetItem.isVisible = !isExpand;
              targetItem.foldHeight = 0;
              item.isExpand = !isExpand;
              item.isVisible = true;
              item.foldHeight = isExpand ? (targetItem.resizeHeight || targetItem.renderHeight) + (item.resizeHeight || item.renderHeight) : 0;
            }
          } else {
            if (targetItem) {
              targetItem.isVisible = !isExpand;
              targetItem.foldWidth = 0;
              item.isExpand = !isExpand;
              item.isVisible = true;
              item.foldWidth = isExpand ? (targetItem.resizeWidth || targetItem.renderWidth) + (item.resizeWidth || item.renderWidth) : 0;
            }
          }
          dispatchEvent('toggle-expand', {
            item,
            name: item.name,
            targetItem,
            targetName: targetItem ? targetItem.name : '',
            expanded: item.isExpand
          }, evnt);
          recalculate();
        }
      }
    };
    const handleActionDblclickEvent = evnt => {
      const {
        itemList
      } = reactData;
      const actionOpts = computeActionOpts.value;
      const btnEl = evnt.currentTarget;
      const handleEl = btnEl.parentElement;
      const itemId = handleEl.getAttribute('itemid');
      const itemIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(itemList, item => item.id === itemId);
      const item = itemList[itemIndex];
      if (actionOpts.trigger === 'dblclick') {
        handleItemActionEvent(evnt);
      }
      dispatchEvent('action-dblclick', {
        item,
        name: item ? item.name : ''
      }, evnt);
    };
    const handleActionClickEvent = evnt => {
      const {
        itemList
      } = reactData;
      const actionOpts = computeActionOpts.value;
      const btnEl = evnt.currentTarget;
      const handleEl = btnEl.parentElement;
      const itemId = handleEl.getAttribute('itemid');
      const itemIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(itemList, item => item.id === itemId);
      const item = itemList[itemIndex];
      if (actionOpts.trigger !== 'dblclick') {
        handleItemActionEvent(evnt);
      }
      dispatchEvent('action-click', {
        item,
        name: item ? item.name : ''
      }, evnt);
    };
    const handleGlobalResizeEvent = () => {
      recalculate();
    };
    const splitMethods = {
      dispatchEvent,
      recalculate,
      reset,
      loadItem,
      reloadItem
    };
    const splitPrivateMethods = {};
    Object.assign($xeSplit, splitMethods, splitPrivateMethods);
    const renderHandleBar = item => {
      const barStyle = computeBarStyle.value;
      const actionOpts = computeActionOpts.value;
      const isFoldNext = computeIsFoldNext.value;
      const {
        id,
        isExpand,
        showAction
      } = item;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        itemid: id,
        class: ['vxe-split-pane-handle', isFoldNext ? 'to--next' : 'to--prev']
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-split-pane-handle-bar',
        style: barStyle,
        onMousedown: dragEvent
      }), showAction ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-split-pane-action-btn',
        onDblclick: handleActionDblclickEvent,
        onClick: handleActionClickEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: (isExpand ? actionOpts.openIcon : actionOpts.closeIcon) || getDefaultActionIcon(item)
      })]) : renderEmptyElement($xeSplit)]);
    };
    const renderItems = () => {
      const {
        border,
        padding,
        resize,
        vertical
      } = props;
      const {
        itemList
      } = reactData;
      const visibleItems = computeVisibleItems.value;
      const {
        autoItems
      } = computeAutoItems.value;
      const isFoldNext = computeIsFoldNext.value;
      const itemVNs = [];
      itemList.forEach((item, index) => {
        const {
          id,
          name,
          slots,
          renderHeight,
          resizeHeight,
          foldHeight,
          renderWidth,
          resizeWidth,
          foldWidth,
          isVisible,
          isExpand
        } = item;
        const defaultSlot = slots ? slots.default : null;
        const stys = {};
        let itemWidth = isVisible ? foldWidth || resizeWidth || renderWidth : 0;
        let itemHeight = isVisible ? foldHeight || resizeHeight || renderHeight : 0;
        // 至少存在一个自适应
        if (autoItems.length === 1) {
          if (vertical) {
            if (!item.height) {
              itemHeight = 0;
            }
          } else {
            if (!item.width) {
              itemWidth = 0;
            }
          }
        }
        // 当只剩下一个可视区自动占用 100%
        if (vertical) {
          if (itemHeight) {
            stys.height = visibleItems.length === 1 ? '100%' : toCssUnit(itemHeight);
          }
        } else {
          if (itemWidth) {
            stys.width = visibleItems.length === 1 ? '100%' : toCssUnit(itemWidth);
          }
        }
        itemVNs.push((0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          itemid: id,
          class: ['vxe-split-pane', vertical ? 'is--vertical' : 'is--horizontal', {
            'is--resize': resize,
            'is--padding': padding,
            'is--border': border,
            'is--height': itemHeight,
            'is--width': itemWidth,
            'is--fill': isVisible && !itemHeight && !itemWidth,
            'is--handle': index > 0,
            'is--expand': isExpand,
            'is--hidden': !isVisible
          }],
          style: stys
        }, [index && !isFoldNext ? renderHandleBar(item) : renderEmptyElement($xeSplit), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          itemid: id,
          class: 'vxe-split-pane--wrapper'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-split-pane--inner'
        }, defaultSlot ? callSlot(defaultSlot, {
          name,
          isVisible,
          isExpand
        }) : [])]), isFoldNext && index < itemList.length - 1 ? renderHandleBar(item) : renderEmptyElement($xeSplit)]));
      });
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-split-wrapper'
      }, itemVNs);
    };
    const renderVN = () => {
      const {
        vertical,
        width,
        height
      } = props;
      const defaultSlot = slots.default;
      const stys = {};
      if (height) {
        stys.height = toCssUnit(height);
      }
      if (width) {
        stys.width = toCssUnit(width);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-split', vertical ? 'is--vertical' : 'is--horizontal'],
        style: stys
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-split-slots'
      }, defaultSlot ? defaultSlot({}) : []), renderItems()]);
    };
    const itemFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.items ? props.items.length : -1, () => {
      itemFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.items, () => {
      itemFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(itemFlag, () => {
      loadItem(props.items || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticItems, val => {
      if (props.items && props.items.length) {
        errLog('vxe.error.errConflicts', ['<vxe-split-pane ...>', 'items']);
      }
      reactData.itemList = val;
      recalculate();
    });
    let resizeObserver;
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        recalculate();
      });
      const el = refElem.value;
      if (el) {
        resizeObserver = globalResize.create(() => {
          recalculate();
        });
        resizeObserver.observe(el);
      }
      globalEvents.on($xeSplit, 'resize', handleGlobalResizeEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      globalEvents.off($xeSplit, 'resize');
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onActivated)(() => {
      recalculate();
    });
    if (props.items) {
      loadItem(props.items);
    }
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeSplit', $xeSplit);
    $xeSplit.renderVN = renderVN;
    return $xeSplit;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/split/index.ts



const VxeSplit = Object.assign({}, split, {
  install(app) {
    app.component(split.name, split);
  }
});
dynamicApp.use(VxeSplit);
index_esm_VxeUI.component(split);
const Split = VxeSplit;
/* harmony default export */ var packages_split = (VxeSplit);
;// CONCATENATED MODULE: ./packages/split/src/util.ts

function assembleSplitItem($xeSplit, elem, paneConfig) {
  const staticItems = $xeSplit.reactData.staticItems;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticItems.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, elem), 0, paneConfig);
    $xeSplit.reactData.staticItems = staticItems.slice(0);
  }
}
function destroySplitItem($xeSplit, paneConfig) {
  const staticItems = $xeSplit.reactData.staticItems;
  const index = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(staticItems, item => item.id === paneConfig.id);
  if (index > -1) {
    staticItems.splice(index, 1);
  }
  $xeSplit.reactData.staticItems = staticItems.slice(0);
}
;// CONCATENATED MODULE: ./packages/split/src/split-pane.ts





/* harmony default export */ var split_pane = (defineVxeComponent({
  name: 'VxeSplitPane',
  props: {
    name: [Number, String],
    width: [Number, String],
    height: [Number, String],
    showAction: Boolean,
    minWidth: {
      type: [Number, String],
      default: () => null
    },
    minHeight: {
      type: [Number, String],
      default: () => null
    }
  },
  emits: [],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeSplit = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeSplit', null);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const paneConfig = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      id: xID,
      name: props.name,
      width: props.width,
      height: props.height,
      minWidth: props.minWidth,
      minHeight: props.minHeight,
      showAction: props.showAction,
      isVisible: true,
      isExpand: true,
      renderWidth: 0,
      resizeWidth: 0,
      foldWidth: 0,
      renderHeight: 0,
      resizeHeight: 0,
      foldHeight: 0,
      slots: slots
    });
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const internalData = {};
    const computeMaps = {};
    const refMaps = {
      refElem
    };
    const $xeSplitItem = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $splitPane: $xeSplitItem
      }, params));
    };
    const splitPaneMethods = {
      dispatchEvent
    };
    const splitPanePrivateMethods = {};
    Object.assign($xeSplitItem, splitPaneMethods, splitPanePrivateMethods);
    const renderVN = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      });
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.name, val => {
      paneConfig.name = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.width, val => {
      paneConfig.width = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.height, val => {
      paneConfig.height = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.minWidth, val => {
      paneConfig.minWidth = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.minHeight, val => {
      paneConfig.minHeight = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.showAction, val => {
      paneConfig.showAction = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const elem = refElem.value;
      if ($xeSplit && elem) {
        assembleSplitItem($xeSplit, elem, paneConfig);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      if ($xeSplit) {
        destroySplitItem($xeSplit, paneConfig);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeSplitItem', $xeSplitItem);
    $xeSplitItem.renderVN = renderVN;
    return $xeSplitItem;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/split-pane/index.ts



const VxeSplitPane = Object.assign({}, split_pane, {
  install(app) {
    app.component(split_pane.name, split_pane);
    app.component('VxeSplitItem', split_pane);
  }
});
dynamicApp.use(VxeSplitPane);
index_esm_VxeUI.component(split_pane);
const SplitPane = VxeSplitPane;
/* harmony default export */ var packages_split_pane = (VxeSplitPane);
;// CONCATENATED MODULE: ./packages/slider/src/slider.ts




/* harmony default export */ var slider = (defineVxeComponent({
  name: 'VxeSlider',
  props: {
    modelValue: [String, Number, Array],
    vertical: Boolean,
    max: {
      type: [String, Number],
      default: () => getConfig().slider.max
    },
    min: {
      type: [String, Number],
      default: () => getConfig().slider.min
    },
    step: {
      type: [String, Number],
      default: () => getConfig().slider.step
    },
    size: {
      type: String,
      default: () => getConfig().slider.size || getConfig().size
    },
    range: {
      type: Boolean,
      default: () => getConfig().slider.range
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    }
  },
  emits: ['update:modelValue', 'change'],
  setup(props, context) {
    const {
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refBarElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTrackElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refStartBtnElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refEndBtnElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      startValue: 0,
      endValue: 0
    });
    const refMaps = {
      refElem
    };
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeMaxNum = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.max || 0);
    });
    const computeMinNum = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.min || 0);
    });
    const computeMaps = {};
    const $xeSlider = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const emitModel = value => {
      emit('update:modelValue', value);
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $slider: $xeSlider
      }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const getStartPercent = startValue => {
      const {
        range
      } = props;
      const maxNum = computeMaxNum.value;
      const minNum = computeMinNum.value;
      return range ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor((startValue - minNum) / external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(maxNum - minNum) * 100) : 0;
    };
    const getEndPercent = (startValue, endValue) => {
      const {
        range
      } = props;
      const maxNum = computeMaxNum.value;
      const minNum = computeMinNum.value;
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor((endValue - (range ? startValue : 0) - minNum) / external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(maxNum - minNum) * 100);
    };
    const updateModel = () => {
      const {
        modelValue
      } = props;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue)) {
        const [sVal, eVal] = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(modelValue, true).sort();
        reactData.startValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(sVal || 0));
        reactData.endValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(eVal || 0));
      } else {
        reactData.startValue = 0;
        reactData.endValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(modelValue || 0));
      }
    };
    const updateBarStyle = () => {
      const {
        startValue,
        endValue
      } = reactData;
      const trackElem = refTrackElem.value;
      const startBtnElem = refStartBtnElem.value;
      const endBtnElem = refEndBtnElem.value;
      let startPercent = 0;
      let endPercent = 0;
      if (startValue > endValue) {
        startPercent = getStartPercent(endValue);
        endPercent = getEndPercent(endValue, startValue);
      } else {
        startPercent = getStartPercent(startValue);
        endPercent = getEndPercent(startValue, endValue);
      }
      if (trackElem) {
        trackElem.style.left = `${startPercent}%`;
        trackElem.style.width = `${endPercent}%`;
      }
      if (startBtnElem) {
        startBtnElem.style.left = `${startPercent}%`;
      }
      if (endBtnElem) {
        endBtnElem.style.left = `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(startPercent + endPercent)}%`;
      }
    };
    const changeEvent = evnt => {
      const {
        range
      } = props;
      const {
        startValue,
        endValue
      } = reactData;
      const value = range ? [startValue, endValue].sort() : endValue;
      emitModel(value);
      dispatchEvent('change', {
        value
      }, evnt);
      // 自动更新校验状态
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const handleMousedownEvent = (evnt, isEnd) => {
      const formReadonly = computeFormReadonly.value;
      const isDisabled = computeIsDisabled.value;
      const maxNum = computeMaxNum.value;
      const minNum = computeMinNum.value;
      if (!(formReadonly || isDisabled)) {
        evnt.preventDefault();
        document.onmousemove = evnt => {
          evnt.preventDefault();
          const el = refElem.value;
          const barElem = refBarElem.value;
          if (el && barElem) {
            const barRect = barElem.getBoundingClientRect();
            const trackWidth = (evnt.clientX - barRect.left) / barRect.width;
            if (isEnd) {
              reactData.endValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(Math.max(minNum, Math.min(maxNum, trackWidth * (maxNum - minNum) + minNum)));
            } else {
              reactData.startValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().floor(Math.max(minNum, Math.min(maxNum, trackWidth * (maxNum - minNum))));
            }
          }
          updateBarStyle();
        };
        document.onmouseup = evnt => {
          document.onmousemove = null;
          document.onmouseup = null;
          changeEvent(evnt);
          updateBarStyle();
        };
      }
    };
    const handleStartMousedownEvent = evnt => {
      const endBtnElem = refEndBtnElem.value;
      const startBtnElem = evnt.currentTarget;
      handleMousedownEvent(evnt, endBtnElem ? endBtnElem.offsetLeft < startBtnElem.offsetLeft : false);
    };
    const handleEndMousedownEvent = evnt => {
      const startBtnElem = refStartBtnElem.value;
      const endBtnElem = evnt.currentTarget;
      handleMousedownEvent(evnt, startBtnElem ? endBtnElem.offsetLeft > startBtnElem.offsetLeft : true);
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeSlider, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const {
        vertical,
        range
      } = props;
      const vSize = computeSize.value;
      const formReadonly = computeFormReadonly.value;
      const isDisabled = computeIsDisabled.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-slider', {
          [`size--${vSize}`]: vSize,
          'is--vertical': vertical,
          'is--readonly': formReadonly,
          'is--disabled': isDisabled
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-slider--inner'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refBarElem,
        class: 'vxe-slider--bar-wrapper'
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refTrackElem,
        class: 'vxe-slider--bar-track'
      }), formReadonly || !range ? renderEmptyElement($xeSlider) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refStartBtnElem,
        class: 'vxe-slider--bar-btn vxe-slider--start-btn',
        onMousedown: handleStartMousedownEvent
      }), formReadonly ? renderEmptyElement($xeSlider) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refEndBtnElem,
        class: 'vxe-slider--bar-btn vxe-slider--end-btn',
        onMousedown: handleEndMousedownEvent
      })])]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, () => {
      updateModel();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      updateBarStyle();
    });
    updateModel();
    $xeSlider.renderVN = renderVN;
    return $xeSlider;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/slider/index.ts



const VxeSlider = Object.assign({}, slider, {
  install(app) {
    app.component(slider.name, slider);
  }
});
dynamicApp.use(VxeSlider);
index_esm_VxeUI.component(slider);
const Slider = VxeSlider;
/* harmony default export */ var packages_slider = (VxeSlider);
;// CONCATENATED MODULE: ./packages/steps/src/steps.ts




/* harmony default export */ var steps = (defineVxeComponent({
  name: 'VxeSteps',
  props: {},
  emits: [],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeSteps = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $steps: $xeSteps
      }, params));
    };
    const stepsMethods = {
      dispatchEvent
    };
    const stepsPrivateMethods = {};
    Object.assign($xeSteps, stepsMethods, stepsPrivateMethods);
    const renderVN = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: 'vxe-steps'
      }, []);
    };
    $xeSteps.renderVN = renderVN;
    return $xeSteps;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/steps/index.ts



const VxeSteps = Object.assign({}, steps, {
  install(app) {
    app.component(steps.name, steps);
  }
});
dynamicApp.use(VxeSteps);
index_esm_VxeUI.component(steps);
const Steps = VxeSteps;
/* harmony default export */ var packages_steps = (VxeSteps);
;// CONCATENATED MODULE: ./packages/switch/src/switch.ts





/* harmony default export */ var src_switch = (defineVxeComponent({
  name: 'VxeSwitch',
  props: {
    modelValue: [String, Number, Boolean],
    disabled: {
      type: Boolean,
      default: null
    },
    readonly: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().switch.size || getConfig().size
    },
    openLabel: String,
    closeLabel: String,
    openValue: {
      type: [String, Number, Boolean],
      default: true
    },
    closeValue: {
      type: [String, Number, Boolean],
      default: false
    },
    openIcon: String,
    closeIcon: String,
    openActiveIcon: String,
    closeActiveIcon: String
  },
  emits: ['update:modelValue', 'change', 'focus', 'blur'],
  setup(props, context) {
    const {
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      isActivated: false,
      hasAnimat: false,
      offsetLeft: 0
    });
    const internalData = {};
    const $xeSwitch = {
      xID,
      props,
      context,
      reactData,
      internalData
    };
    const refButton = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    let switchMethods = {};
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return readonly;
    });
    const computeOnShowLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return getFuncText(props.openLabel);
    });
    const computeOffShowLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return getFuncText(props.closeLabel);
    });
    const computeIsChecked = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.modelValue === props.openValue;
    });
    const emitModel = value => {
      emit('update:modelValue', value);
    };
    const clickEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!(isDisabled || isReadonly)) {
        const isChecked = computeIsChecked.value;
        clearTimeout(internalData.atTimeout);
        const value = isChecked ? props.closeValue : props.openValue;
        reactData.hasAnimat = true;
        emitModel(value);
        switchMethods.dispatchEvent('change', {
          value
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
        internalData.atTimeout = setTimeout(() => {
          reactData.hasAnimat = false;
          internalData.atTimeout = undefined;
        }, 400);
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $switch: $xeSwitch
      }, params));
    };
    const focusEvent = evnt => {
      reactData.isActivated = true;
      switchMethods.dispatchEvent('focus', {
        value: props.modelValue
      }, evnt);
    };
    const blurEvent = evnt => {
      reactData.isActivated = false;
      switchMethods.dispatchEvent('blur', {
        value: props.modelValue
      }, evnt);
    };
    switchMethods = {
      dispatchEvent,
      focus() {
        const btnElem = refButton.value;
        reactData.isActivated = true;
        if (btnElem) {
          btnElem.focus();
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const btnElem = refButton.value;
        if (btnElem) {
          btnElem.blur();
        }
        reactData.isActivated = false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    Object.assign($xeSwitch, switchMethods);
    const renderVN = () => {
      const {
        openIcon,
        closeIcon,
        openActiveIcon,
        closeActiveIcon
      } = props;
      const vSize = computeSize.value;
      const isChecked = computeIsChecked.value;
      const onShowLabel = computeOnShowLabel.value;
      const offShowLabel = computeOffShowLabel.value;
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-switch', isChecked ? 'is--on' : 'is--off', {
          [`size--${vSize}`]: vSize,
          'is--disabled': isDisabled,
          'is--readonly': isReadonly,
          'is--animat': reactData.hasAnimat
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('button', {
        ref: refButton,
        class: 'vxe-switch--button',
        type: 'button',
        disabled: isDisabled || isReadonly,
        onClick: clickEvent,
        onFocus: focusEvent,
        onBlur: blurEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-switch--label vxe-switch--label-on'
      }, [openIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-switch--label-icon', openIcon]
      }) : renderEmptyElement($xeSwitch), onShowLabel]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-switch--label vxe-switch--label-off'
      }, [closeIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: ['vxe-switch--label-icon', closeIcon]
      }) : renderEmptyElement($xeSwitch), offShowLabel]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-switch--icon']
      }, openActiveIcon || closeActiveIcon ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: isChecked ? openActiveIcon : closeActiveIcon
      })] : [])])]);
    };
    $xeSwitch.renderVN = renderVN;
    return $xeSwitch;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/switch/index.ts



const VxeSwitch = Object.assign(src_switch, {
  install: function (app) {
    app.component(src_switch.name, src_switch);
  }
});
dynamicApp.use(VxeSwitch);
index_esm_VxeUI.component(src_switch);
const Switch = VxeSwitch;
/* harmony default export */ var packages_switch = (VxeSwitch);
;// CONCATENATED MODULE: ./packages/tabs/src/util.ts

function assembleTabItem($xeTabs, elem, tabConfig) {
  const staticTabs = $xeTabs.reactData.staticTabs;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticTabs.splice(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayIndexOf(parentElem.children, elem), 0, tabConfig);
    $xeTabs.reactData.staticTabs = staticTabs.slice(0);
  }
}
function destroyTabItem($xeTabs, tabConfig) {
  const staticTabs = $xeTabs.reactData.staticTabs;
  const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(staticTabs, item => item.id === tabConfig.id, {
    children: 'children'
  });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  $xeTabs.reactData.staticTabs = staticTabs.slice(0);
}
;// CONCATENATED MODULE: ./packages/tabs/src/tab-pane.ts





/* harmony default export */ var tab_pane = (defineVxeComponent({
  name: 'VxeTabPane',
  props: {
    title: [String, Number],
    name: [String, Number],
    icon: String,
    titleWidth: [String, Number],
    titleAlign: [String, Number],
    preload: Boolean,
    permissionCode: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const $xeTabs = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTabs', null);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const tabConfig = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      id: xID,
      title: props.title,
      name: props.name,
      icon: props.icon,
      titleWidth: props.titleWidth,
      titleAlign: props.titleAlign,
      preload: props.preload,
      permissionCode: props.permissionCode,
      slots: slots
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTabPane = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $tabPane: $xeTabPane
      }, params));
    };
    const tabPaneMethods = {
      dispatchEvent
    };
    const tabPanePrivateMethods = {};
    Object.assign($xeTabPane, tabPaneMethods, tabPanePrivateMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.title, val => {
      tabConfig.title = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.name, val => {
      tabConfig.name = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.icon, val => {
      tabConfig.icon = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.permissionCode, val => {
      tabConfig.permissionCode = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      const elem = refElem.value;
      if ($xeTabs && elem) {
        assembleTabItem($xeTabs, elem, tabConfig);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      if ($xeTabs) {
        destroyTabItem($xeTabs, tabConfig);
      }
    });
    const renderVN = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem
      }, []);
    };
    $xeTabPane.renderVN = renderVN;
    return $xeTabPane;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/tab-pane/index.ts



const VxeTabPane = Object.assign({}, tab_pane, {
  install(app) {
    app.component(tab_pane.name, tab_pane);
  }
});
dynamicApp.use(VxeTabPane);
index_esm_VxeUI.component(tab_pane);
const TabPane = VxeTabPane;
/* harmony default export */ var packages_tab_pane = (VxeTabPane);
;// CONCATENATED MODULE: ./packages/table-select/src/table-select.ts










function getRowUniqueId() {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('row_');
}
/* harmony default export */ var table_select = (defineVxeComponent({
  name: 'VxeTableSelect',
  props: {
    modelValue: [String, Number, Array],
    clearable: Boolean,
    placeholder: {
      type: String,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(getConfig().tableSelect.placeholder) ? getI18n('vxe.base.pleaseSelect') : getConfig().tableSelect.placeholder
    },
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    multiple: Boolean,
    className: [String, Function],
    prefixIcon: String,
    placement: String,
    columns: Array,
    options: Array,
    optionProps: Object,
    size: {
      type: String,
      default: () => getConfig().select.size || getConfig().size
    },
    popupConfig: Object,
    gridConfig: Object,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: ['update:modelValue', 'change', 'clear', 'blur', 'focus', 'click', 'form-submit', 'form-reset', 'form-collapse', 'page-change'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const VxeTableGridComponent = index_esm_VxeUI.getComponent('vxe-grid');
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInput = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refGridWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refOptionPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refGrid = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      tableColumns: [],
      fullOptionList: [],
      fullRowMaps: {},
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = {
      // hpTimeout: undefined,
      // vpTimeout: undefined
    };
    const refMaps = {
      refElem
    };
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().select.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computePropsOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.optionProps || {};
    });
    const computeRowOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const gridOpts = computeGridOpts.value;
      return Object.assign({}, gridOpts.rowConfig, {
        isCurrent: true
      });
    });
    const computeRowKeyField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const rowOpts = computeRowOpts.value;
      return rowOpts.keyField || '_X_ROW_KEY';
    });
    const computeLabelField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || 'label';
    });
    const computeValueField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || 'value';
    });
    const computePopupOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().tableSelect.popupConfig, props.popupConfig);
    });
    const computeGridOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().tableSelect.gridConfig, props.gridConfig, {
        data: undefined,
        columns: undefined
      });
    });
    const computeSelectLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue
      } = props;
      const {
        fullRowMaps
      } = reactData;
      const labelField = computeLabelField.value;
      return (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue : [modelValue]).map(val => {
        const cacheItem = fullRowMaps[val];
        return cacheItem ? cacheItem.item[labelField] : val;
      }).join(', ');
    });
    const computePopupWrapperStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const popupOpts = computePopupOpts.value;
      const {
        height,
        width
      } = popupOpts;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeMaps = {};
    const $xeTableSelect = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const gridEventKeys = ['form-submit', 'form-reset', 'form-collapse', 'page-change'];
    const gridEvents = {};
    gridEventKeys.forEach(name => {
      gridEvents[getOnName(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().camelCase(name))] = params => {
        dispatchEvent(name, params, params.$event);
      };
    });
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $tableSelect: $xeTableSelect
      }, params));
    };
    const emitModel = value => {
      emit('update:modelValue', value);
    };
    const tableSelectMethods = {
      dispatchEvent
    };
    const tableSelectPrivateMethods = {};
    const getRowid = option => {
      const nodeKeyField = computeRowKeyField.value;
      const rowid = option[nodeKeyField];
      return rowid ? encodeURIComponent(rowid) : '';
    };
    const getRowsByValue = modelValue => {
      const {
        fullRowMaps
      } = reactData;
      const rows = [];
      const vals = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(modelValue) ? [] : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue : [modelValue];
      vals.forEach(val => {
        const cacheItem = fullRowMaps[val];
        if (cacheItem) {
          rows.push(cacheItem.item);
        }
      });
      return rows;
    };
    const updateModel = modelValue => {
      const {
        multiple
      } = props;
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        const $grid = refGrid.value;
        if ($grid) {
          const selectList = getRowsByValue(modelValue);
          if (selectList.length) {
            if (multiple) {
              $grid.setCheckboxRow(selectList, true);
            } else {
              $grid.setRadioRow(selectList[0]);
            }
          }
        }
      });
    };
    const loadTableColumn = columns => {
      const {
        multiple
      } = props;
      const tableCols = [];
      let hasRadioCol = false;
      let hasCheckboxCol = false;
      columns.forEach(column => {
        if (!hasRadioCol && column.type === 'radio') {
          hasRadioCol = true;
        } else if (!hasCheckboxCol && column.type === 'checkbox') {
          hasCheckboxCol = true;
        }
        tableCols.push(column);
      });
      if (multiple) {
        if (!hasCheckboxCol) {
          tableCols.unshift({
            type: 'checkbox',
            width: 70
          });
        }
      } else {
        if (!hasRadioCol) {
          tableCols.unshift({
            type: 'radio',
            width: 70
          });
        }
      }
      reactData.tableColumns = tableCols;
    };
    const cacheDataMap = () => {
      const {
        options
      } = props;
      const rowKeyField = computeRowKeyField.value;
      const valueField = computeValueField.value;
      const gridOpts = computeGridOpts.value;
      const {
        treeConfig
      } = gridOpts;
      const rowMaps = {};
      const keyMaps = {};
      if (treeConfig) {
        // x
      } else {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(options || [], (item, index, items) => {
          let rowid = getRowid(item);
          if (!rowid) {
            rowid = getRowUniqueId();
          }
          if (keyMaps[rowid]) {
            errLog('vxe.error.repeatKey', [rowKeyField, rowid]);
          }
          keyMaps[rowid] = true;
          const value = item[valueField];
          if (rowMaps[value]) {
            errLog('vxe.error.repeatKey', [valueField, value]);
          }
          rowMaps[value] = {
            item,
            index,
            items,
            parent: null,
            nodes: []
          };
        });
      }
      reactData.fullOptionList = options || [];
      reactData.fullRowMaps = rowMaps;
      updateModel(props.modelValue);
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      const {
        placement
      } = props;
      const {
        panelIndex
      } = reactData;
      const targetElem = refElem.value;
      const panelElem = refOptionPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(handleStyle);
    };
    const showOptionPanel = () => {
      const {
        loading
      } = props;
      const isDisabled = computeIsDisabled.value;
      if (!loading && !isDisabled) {
        if (internalData.vpTimeout) {
          clearTimeout(internalData.vpTimeout);
        }
        if (internalData.hpTimeout) {
          clearTimeout(internalData.hpTimeout);
        }
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        internalData.vpTimeout = setTimeout(() => {
          reactData.visiblePanel = true;
          updateModel(props.modelValue);
          internalData.vpTimeout = undefined;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      if (internalData.vpTimeout) {
        clearTimeout(internalData.vpTimeout);
      }
      if (internalData.hpTimeout) {
        clearTimeout(internalData.hpTimeout);
      }
      internalData.hpTimeout = setTimeout(() => {
        reactData.isAniVisible = false;
        internalData.hpTimeout = undefined;
      }, 350);
    };
    const changeEvent = (evnt, selectValue, row) => {
      emitModel(selectValue);
      if (selectValue !== props.modelValue) {
        dispatchEvent('change', {
          value: selectValue,
          row,
          option: row
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue, null);
      dispatchEvent('clear', {
        value: selectValue
      }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const {
        visiblePanel,
        isActivated
      } = reactData;
      if (visiblePanel) {
        hideOptionPanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        const $input = refInput.value;
        if ($input) {
          $input.blur();
        }
      }
    };
    const handleGlobalResizeEvent = () => {
      const {
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    const focusEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          reactData.triggerFocusPanel = true;
          showOptionPanel();
          setTimeout(() => {
            reactData.triggerFocusPanel = false;
          }, 150);
        }
      }
      dispatchEvent('focus', {}, evnt);
    };
    const clickEvent = evnt => {
      togglePanelEvent(evnt);
      dispatchEvent('click', {}, evnt);
    };
    const blurEvent = evnt => {
      reactData.isActivated = false;
      dispatchEvent('blur', {}, evnt);
    };
    const togglePanelEvent = params => {
      const {
        $event
      } = params;
      $event.preventDefault();
      if (reactData.triggerFocusPanel) {
        reactData.triggerFocusPanel = false;
      } else {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
      }
    };
    const radioChangeEvent = params => {
      const {
        $event,
        row
      } = params;
      const valueField = computeValueField.value;
      const value = row[valueField];
      changeEvent($event, value, row);
      hideOptionPanel();
    };
    const checkboxChangeEvent = params => {
      const {
        $grid,
        $event,
        row
      } = params;
      const valueField = computeValueField.value;
      if ($grid) {
        const checkboxRecords = $grid.getCheckboxRecords();
        const value = checkboxRecords.map(row => {
          return row[valueField];
        });
        changeEvent($event, value, row);
      }
    };
    const checkboxAllEvent = params => {
      checkboxChangeEvent(params);
    };
    Object.assign($xeTableSelect, tableSelectMethods, tableSelectPrivateMethods);
    const renderVN = () => {
      const {
        className,
        options,
        loading
      } = props;
      const {
        initialized,
        isActivated,
        isAniVisible,
        visiblePanel,
        tableColumns
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const selectLabel = computeSelectLabel.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const popupOpts = computePopupOpts.value;
      const {
        className: popupClassName
      } = popupOpts;
      const gridOpts = computeGridOpts.value;
      const rowOpts = computeRowOpts.value;
      const popupWrapperStyle = computePopupWrapperStyle.value;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-table-select--readonly', className]
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-table-select-label'
        }, selectLabel)]);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-table-select', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $tableSelect: $xeTableSelect
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--visible': visiblePanel,
          'is--disabled': isDisabled,
          'is--loading': loading,
          'is--active': isActivated
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
        ref: refInput,
        clearable: props.clearable,
        placeholder: loading ? getI18n('vxe.select.loadingText') : props.placeholder,
        readonly: true,
        disabled: isDisabled,
        type: 'text',
        prefixIcon: props.prefixIcon,
        suffixIcon: loading ? getIcon().TABLE_SELECT_LOADED : visiblePanel ? getIcon().TABLE_SELECT_OPEN : getIcon().TABLE_SELECT_CLOSE,
        modelValue: loading ? '' : selectLabel,
        onClear: clearEvent,
        onClick: clickEvent,
        onFocus: focusEvent,
        onBlur: blurEvent,
        onSuffixClick: togglePanelEvent
      }, prefixSlot ? {
        prefix: () => prefixSlot({})
      } : {}), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: btnTransfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refOptionPanel,
        class: ['vxe-table--ignore-clear vxe-table-select--panel', popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
          $tableSelect: $xeTableSelect
        }) : popupClassName : '', {
          [`size--${vSize}`]: vSize,
          'is--transfer': btnTransfer,
          'ani--leave': !loading && isAniVisible,
          'ani--enter': !loading && visiblePanel
        }],
        placement: reactData.panelPlacement,
        style: reactData.panelStyle
      }, initialized ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-select--panel-wrapper'
      }, [headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-select--panel-header'
      }, headerSlot({})) : renderEmptyElement($xeTableSelect), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-select--panel-body'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refGridWrapper,
        class: 'vxe-table-select-grid--wrapper',
        style: popupWrapperStyle
      }, [VxeTableGridComponent ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(VxeTableGridComponent, {
        ...gridOpts,
        ...gridEvents,
        class: 'vxe-table-select--grid',
        ref: refGrid,
        rowConfig: rowOpts,
        data: options,
        columns: tableColumns,
        height: '100%',
        autoResize: true,
        onRadioChange: radioChangeEvent,
        onCheckboxChange: checkboxChangeEvent,
        onCheckboxAll: checkboxAllEvent
      }, Object.assign({}, slots, {
        header: undefined,
        footer: undefined,
        prefixSlot: undefined
      })) : renderEmptyElement($xeTableSelect)])]), footerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-table-select--panel-footer'
      }, footerSlot({})) : renderEmptyElement($xeTableSelect)])] : [])])]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options, () => {
      cacheDataMap();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.columns, val => {
      loadTableColumn(val || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      updateModel(val);
    });
    loadTableColumn(props.columns || []);
    cacheDataMap();
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      globalEvents.on($xeTableSelect, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeTableSelect, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeTableSelect, 'blur', handleGlobalBlurEvent);
      globalEvents.on($xeTableSelect, 'resize', handleGlobalResizeEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeTableSelect, 'mousewheel');
      globalEvents.off($xeTableSelect, 'mousedown');
      globalEvents.off($xeTableSelect, 'blur');
      globalEvents.off($xeTableSelect, 'resize');
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      if (!VxeTableGridComponent) {
        errLog('vxe.error.reqComp', ['vxe-grid']);
      }
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeTableSelect', $xeTableSelect);
    $xeTableSelect.renderVN = renderVN;
    return $xeTableSelect;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/table-select/index.ts



const VxeTableSelect = Object.assign({}, table_select, {
  install(app) {
    app.component(table_select.name, table_select);
  }
});
dynamicApp.use(VxeTableSelect);
index_esm_VxeUI.component(table_select);
const TableSelect = VxeTableSelect;
/* harmony default export */ var packages_table_select = (VxeTableSelect);
;// CONCATENATED MODULE: ./packages/tabs/src/tabs.ts










const scrollbarOffsetSize = 20;
/* harmony default export */ var tabs = (defineVxeComponent({
  name: 'VxeTabs',
  props: {
    modelValue: [String, Number, Boolean],
    options: Array,
    width: [String, Number],
    height: [String, Number],
    destroyOnClose: Boolean,
    titleWidth: [String, Number],
    titleAlign: [String, Number],
    type: {
      type: String,
      default: () => getConfig().tabs.type
    },
    position: {
      type: String,
      default: () => getConfig().tabs.position
    },
    showClose: Boolean,
    showBody: {
      type: Boolean,
      default: true
    },
    padding: {
      type: Boolean,
      default: () => getConfig().tabs.padding
    },
    trigger: String,
    beforeChangeMethod: Function,
    closeConfig: Object,
    refreshConfig: Object,
    // 已废弃
    beforeCloseMethod: Function
  },
  emits: ['update:modelValue', 'change', 'tab-change', 'tab-change-fail', 'tab-close', 'tab-close-fail', 'tab-click', 'tab-load'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const $xeParentTabs = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTabs', null);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeadWrapperElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeadPrevElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeadNextElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      staticTabs: [],
      activeName: null,
      initNames: [],
      lintLeft: 0,
      lintTop: 0,
      lintWidth: 0,
      lintHeight: 0,
      scrollbarWidth: 0,
      scrollbarHeight: 0,
      isTabOver: false,
      resizeFlag: 1,
      cacheTabMaps: {}
    });
    const internalData = {
      slTimeout: undefined
    };
    const refMaps = {
      refElem
    };
    const computeTabType = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        type
      } = props;
      return type || 'default';
    });
    const computeTabPosition = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        position
      } = props;
      return position || 'top';
    });
    const computeLrPosition = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const tabPosition = computeTabPosition.value;
      return tabPosition === 'left' || tabPosition === 'right';
    });
    const computeLineStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        lintLeft,
        lintTop,
        lintWidth,
        lintHeight
      } = reactData;
      const lrPosition = computeLrPosition.value;
      return lrPosition ? {
        top: `${lintTop}px`,
        height: `${lintHeight}px`
      } : {
        left: `${lintLeft}px`,
        width: `${lintWidth}px`
      };
    });
    const computeWrapperStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        width,
        height
      } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeCloseOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().tabs.closeConfig, props.closeConfig);
    });
    const computeRefreshOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().tabs.refreshConfig, props.refreshConfig);
    });
    const computeTabOptions = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        options
      } = props;
      return (options || []).filter(item => handleFilterTab(item));
    });
    const computeTabStaticOptions = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        staticTabs
      } = reactData;
      return staticTabs.filter(item => handleFilterTab(item));
    });
    const computeParentTabsResizeFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return $xeParentTabs ? $xeParentTabs.reactData.resizeFlag : null;
    });
    const computeMaps = {};
    const $xeTabs = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const handleFilterTab = item => {
      const {
        permissionCode
      } = item;
      if (permissionCode) {
        if (!permission.checkVisible(permissionCode)) {
          return false;
        }
      }
      return true;
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(slotFunc)) {
          return vn_getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    const checkScrolling = () => {
      const lrPosition = computeLrPosition.value;
      const headerWrapperEl = refHeadWrapperElem.value;
      const headPrevEl = refHeadPrevElem.value;
      const headNextEl = refHeadNextElem.value;
      if (headerWrapperEl) {
        const {
          scrollLeft,
          scrollTop,
          clientWidth,
          clientHeight,
          scrollWidth,
          scrollHeight
        } = headerWrapperEl;
        if (headPrevEl) {
          if ((lrPosition ? scrollTop : scrollLeft) > 0) {
            addClass(headPrevEl, 'scrolling--middle');
          } else {
            removeClass(headPrevEl, 'scrolling--middle');
          }
        }
        if (headNextEl) {
          if (lrPosition ? clientHeight < scrollHeight - Math.ceil(scrollTop) : clientWidth < scrollWidth - Math.ceil(scrollLeft)) {
            addClass(headNextEl, 'scrolling--middle');
          } else {
            removeClass(headNextEl, 'scrolling--middle');
          }
        }
      }
    };
    const updateTabStyle = () => {
      const handleStyle = () => {
        const {
          activeName
        } = reactData;
        const tabType = computeTabType.value;
        const tabOptions = computeTabOptions.value;
        const tabStaticOptions = computeTabStaticOptions.value;
        const headerWrapperEl = refHeadWrapperElem.value;
        const lrPosition = computeLrPosition.value;
        let lintWidth = 0;
        let lintHeight = 0;
        let lintLeft = 0;
        let lintTop = 0;
        let sBarWidth = 0;
        let sBarHeight = 0;
        let isOver = false;
        if (headerWrapperEl) {
          const index = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(tabStaticOptions.length ? tabStaticOptions : tabOptions, item => item.name === activeName);
          const {
            children,
            offsetWidth,
            scrollWidth,
            offsetHeight,
            scrollHeight,
            clientWidth,
            clientHeight
          } = headerWrapperEl;
          sBarWidth = offsetWidth - clientWidth;
          sBarHeight = offsetHeight - clientHeight;
          if (lrPosition) {
            isOver = scrollHeight !== clientHeight;
            if (index > -1) {
              const tabEl = children[index];
              if (tabEl) {
                const tabHeight = tabEl.clientHeight;
                const tabWidth = tabEl.clientWidth;
                if (tabType === 'card') {
                  lintWidth = tabWidth;
                  lintHeight = tabHeight;
                  lintTop = tabEl.offsetTop;
                } else if (tabType === 'border-card') {
                  lintWidth = tabWidth;
                  lintHeight = tabHeight;
                  lintTop = tabEl.offsetTop - 1;
                } else {
                  lintHeight = Math.max(4, Math.floor(tabHeight * 0.6));
                  lintTop = tabEl.offsetTop + Math.floor((tabHeight - lintHeight) / 2);
                }
              }
            }
          } else {
            isOver = scrollWidth !== clientWidth;
            if (index > -1) {
              const tabEl = children[index];
              if (tabEl) {
                const tabWidth = tabEl.clientWidth;
                if (tabType === 'card') {
                  lintWidth = tabWidth + 1;
                  lintLeft = tabEl.offsetLeft;
                } else if (tabType === 'border-card') {
                  lintWidth = tabWidth;
                  lintLeft = tabEl.offsetLeft - 1;
                } else {
                  lintWidth = Math.max(4, Math.floor(tabWidth * 0.6));
                  lintLeft = tabEl.offsetLeft + Math.floor((tabWidth - lintWidth) / 2);
                }
              }
            }
          }
        }
        reactData.scrollbarWidth = sBarWidth;
        reactData.scrollbarHeight = sBarHeight;
        reactData.lintLeft = lintLeft;
        reactData.lintTop = lintTop;
        reactData.lintWidth = lintWidth;
        reactData.lintHeight = lintHeight;
        reactData.isTabOver = isOver;
        checkScrolling();
      };
      handleStyle();
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(handleStyle);
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $tabs: $xeTabs
      }, params));
    };
    const addInitName = (name, evnt) => {
      const {
        initNames
      } = reactData;
      if (name && !initNames.includes(name)) {
        dispatchEvent('tab-load', {
          name
        }, evnt);
        initNames.push(name);
        return true;
      }
      return false;
    };
    const initDefaultName = list => {
      let activeName = null;
      const nameMaps = {};
      if (list && list.length) {
        let validVal = false;
        activeName = props.modelValue;
        list.forEach(item => {
          const {
            name,
            preload
          } = item || {};
          if (name) {
            nameMaps[`${name}`] = {
              loading: false
            };
            if (activeName === name) {
              validVal = true;
            }
            if (preload) {
              addInitName(name, null);
            }
          }
        });
        if (!validVal) {
          activeName = list[0].name;
          addInitName(activeName, null);
          emit('update:modelValue', activeName);
        }
      }
      reactData.activeName = activeName;
      reactData.cacheTabMaps = nameMaps;
    };
    const clickEvent = (evnt, item) => {
      const {
        trigger
      } = props;
      const beforeMethod = props.beforeChangeMethod || getConfig().tabs.beforeChangeMethod;
      const {
        activeName
      } = reactData;
      const {
        name
      } = item;
      const value = name;
      dispatchEvent('tab-click', {
        name
      }, evnt);
      if (trigger === 'manual') {
        return;
      }
      if (name !== activeName) {
        Promise.resolve(!beforeMethod || beforeMethod({
          $tabs: $xeTabs,
          name,
          oldName: activeName,
          newName: name,
          option: item
        })).then(status => {
          if (status) {
            reactData.activeName = name;
            emit('update:modelValue', value);
            addInitName(name, evnt);
            dispatchEvent('change', {
              value,
              name,
              oldName: activeName,
              newName: name,
              option: item
            }, evnt);
            dispatchEvent('tab-change', {
              value,
              name,
              oldName: activeName,
              newName: name,
              option: item
            }, evnt);
          } else {
            dispatchEvent('tab-change-fail', {
              value,
              name,
              oldName: activeName,
              newName: name,
              option: item
            }, evnt);
          }
        }).catch(() => {
          dispatchEvent('tab-change-fail', {
            value,
            name,
            oldName: activeName,
            newName: name,
            option: item
          }, evnt);
        });
      }
    };
    const handleRefreshTabEvent = (evnt, item) => {
      evnt.stopPropagation();
      const {
        activeName,
        cacheTabMaps
      } = reactData;
      const {
        name
      } = item;
      const refreshOpts = computeRefreshOpts.value;
      const {
        queryMethod
      } = refreshOpts;
      const cacheItem = name ? cacheTabMaps[`${name}`] : null;
      if (cacheItem) {
        if (queryMethod) {
          if (cacheItem.loading) {
            return;
          }
          cacheItem.loading = true;
          Promise.resolve(queryMethod({
            $tabs: $xeTabs,
            value: activeName,
            name,
            option: item
          })).finally(() => {
            cacheItem.loading = false;
          });
        } else {
          errLog('vxe.error.notFunc', ['refresh-config.queryMethod']);
        }
      }
    };
    const handleCloseTabEvent = (evnt, item, index, list) => {
      evnt.stopPropagation();
      const {
        activeName
      } = reactData;
      const closeOpts = computeCloseOpts.value;
      const beforeMethod = closeOpts.beforeMethod || props.beforeCloseMethod || getConfig().tabs.beforeCloseMethod;
      const {
        name
      } = item;
      const value = activeName;
      let nextName = value;
      if (activeName === name) {
        const nextItem = index < list.length - 1 ? list[index + 1] : list[index - 1];
        nextName = nextItem ? nextItem.name : null;
      }
      Promise.resolve(!beforeMethod || beforeMethod({
        $tabs: $xeTabs,
        value,
        name,
        nextName,
        option: item
      })).then(status => {
        if (status) {
          dispatchEvent('tab-close', {
            value,
            name,
            nextName
          }, evnt);
        } else {
          dispatchEvent('tab-close-fail', {
            value,
            name,
            nextName
          }, evnt);
        }
      }).catch(() => {
        dispatchEvent('tab-close-fail', {
          value,
          name,
          nextName
        }, evnt);
      });
    };
    const startScrollAnimation = (offsetPos, offsetSize) => {
      const {
        slTimeout
      } = internalData;
      const lrPosition = computeLrPosition.value;
      let offsetLeft = lrPosition ? 0 : offsetSize;
      let offsetTop = lrPosition ? offsetSize : 0;
      let scrollCount = 6;
      let delayNum = 35;
      if (slTimeout) {
        clearTimeout(slTimeout);
        internalData.slTimeout = undefined;
      }
      const scrollAnimate = () => {
        const headerWrapperEl = refHeadWrapperElem.value;
        if (scrollCount > 0) {
          scrollCount--;
          if (headerWrapperEl) {
            const {
              clientWidth,
              clientHeight,
              scrollWidth,
              scrollHeight,
              scrollLeft,
              scrollTop
            } = headerWrapperEl;
            if (lrPosition) {
              offsetTop = Math.floor(offsetTop / 2);
              if (offsetPos > 0) {
                if (clientHeight + scrollTop < scrollHeight) {
                  headerWrapperEl.scrollTop += offsetTop;
                  delayNum -= 4;
                  internalData.slTimeout = setTimeout(scrollAnimate, delayNum);
                }
              } else {
                if (scrollTop > 0) {
                  headerWrapperEl.scrollTop -= offsetTop;
                  delayNum -= 4;
                  internalData.slTimeout = setTimeout(scrollAnimate, delayNum);
                }
              }
            } else {
              offsetLeft = Math.floor(offsetLeft / 2);
              if (offsetPos > 0) {
                if (clientWidth + scrollLeft < scrollWidth) {
                  headerWrapperEl.scrollLeft += offsetLeft;
                  delayNum -= 4;
                  internalData.slTimeout = setTimeout(scrollAnimate, delayNum);
                }
              } else {
                if (scrollLeft > 0) {
                  headerWrapperEl.scrollLeft -= offsetLeft;
                  delayNum -= 4;
                  internalData.slTimeout = setTimeout(scrollAnimate, delayNum);
                }
              }
            }
            updateTabStyle();
          }
        }
      };
      scrollAnimate();
    };
    const handleScrollToLeft = offsetPos => {
      const lrPosition = computeLrPosition.value;
      const headerWrapperEl = refHeadWrapperElem.value;
      if (headerWrapperEl) {
        const {
          clientWidth,
          clientHeight
        } = headerWrapperEl;
        const offsetSize = Math.floor((lrPosition ? clientHeight : clientWidth) * 0.75);
        startScrollAnimation(offsetPos, offsetSize);
      }
    };
    const scrollLeftEvent = () => {
      handleScrollToLeft(-1);
    };
    const scrollRightEvent = () => {
      handleScrollToLeft(1);
    };
    const scrollToTab = name => {
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      const lrPosition = computeLrPosition.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const headerWrapperEl = refHeadWrapperElem.value;
        if (headerWrapperEl) {
          const index = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(tabStaticOptions.length ? tabStaticOptions : tabOptions, item => item.name === name);
          if (index > -1) {
            const {
              scrollLeft,
              scrollTop,
              clientWidth,
              clientHeight,
              children
            } = headerWrapperEl;
            const tabEl = children[index];
            if (tabEl) {
              if (lrPosition) {
                const tabOffsetTop = tabEl.offsetTop;
                const tabClientHeight = tabEl.clientHeight;
                // 如果顶部被挡
                const overSize = tabOffsetTop + tabClientHeight - (scrollTop + clientHeight);
                if (overSize > 0) {
                  headerWrapperEl.scrollTop += overSize;
                }
                // 如果底部被挡，优先
                if (tabOffsetTop < scrollTop) {
                  headerWrapperEl.scrollTop = tabOffsetTop;
                }
              } else {
                const tabOffsetLeft = tabEl.offsetLeft;
                const tabClientWidth = tabEl.clientWidth;
                // 如果右侧被挡
                const overSize = tabOffsetLeft + tabClientWidth - (scrollLeft + clientWidth);
                if (overSize > 0) {
                  headerWrapperEl.scrollLeft += overSize;
                }
                // 如果左侧被挡，优先
                if (tabOffsetLeft < scrollLeft) {
                  headerWrapperEl.scrollLeft = tabOffsetLeft;
                }
              }
            }
          }
          updateTabStyle();
        }
      });
    };
    const handlePrevNext = isNext => {
      const {
        activeName
      } = reactData;
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      const list = tabStaticOptions.length ? tabStaticOptions : tabOptions;
      const index = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(list, item => item.name === activeName);
      if (index > -1) {
        let item = null;
        if (isNext) {
          if (index < list.length - 1) {
            item = list[index + 1];
          }
        } else {
          if (index > 0) {
            item = list[index - 1];
          }
        }
        if (item) {
          const name = item.name;
          const value = name;
          reactData.activeName = name;
          emit('update:modelValue', value);
          addInitName(name, null);
        }
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const tabsMethods = {
      dispatchEvent,
      scrollToTab,
      prev() {
        return handlePrevNext(false);
      },
      next() {
        return handlePrevNext(true);
      },
      prevTab() {
        warnLog('vxe.error.delFunc', ['prevTab', 'prev']);
        return tabsMethods.prev();
      },
      nextTab() {
        warnLog('vxe.error.delFunc', ['nextTab', 'next']);
        return tabsMethods.next();
      }
    };
    const tabsPrivateMethods = {};
    Object.assign($xeTabs, tabsMethods, tabsPrivateMethods);
    const renderTabHeader = tabList => {
      const {
        titleWidth: allTitleWidth,
        titleAlign: allTitleAlign,
        showClose,
        closeConfig,
        refreshConfig
      } = props;
      const {
        activeName,
        scrollbarWidth,
        scrollbarHeight,
        isTabOver,
        cacheTabMaps
      } = reactData;
      const tabType = computeTabType.value;
      const tabPosition = computeTabPosition.value;
      const lrPosition = computeLrPosition.value;
      const lineStyle = computeLineStyle.value;
      const tabPrefixSlot = slots.tabPrefix || slots['tab-prefix'] || slots.prefix;
      const tabSuffixSlot = slots.tabSuffix || slots['tab-suffix'] || slots.suffix || slots.extra;
      const closeOpts = computeCloseOpts.value;
      const closeVisibleMethod = closeOpts.visibleMethod;
      const refreshOpts = computeRefreshOpts.value;
      const refreshVisibleMethod = refreshOpts.visibleMethod;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'th',
        class: ['vxe-tabs-header', `type--${tabType}`, `pos--${tabPosition}`]
      }, [tabPrefixSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-tabs-header--prefix', `type--${tabType}`, `pos--${tabPosition}`]
      }, callSlot(tabPrefixSlot, {
        name: activeName
      })) : renderEmptyElement($xeTabs), isTabOver ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refHeadPrevElem,
        class: ['vxe-tabs-header--bar vxe-tabs-header--prev-bar', `type--${tabType}`, `pos--${tabPosition}`],
        onClick: scrollLeftEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: lrPosition ? getIcon().TABS_TAB_BUTTON_TOP : getIcon().TABS_TAB_BUTTON_LEFT
      })]) : renderEmptyElement($xeTabs), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-tabs-header--wrapper', `type--${tabType}`, `pos--${tabPosition}`]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refHeadWrapperElem,
        class: 'vxe-tabs-header--item-wrapper',
        style: lrPosition ? {
          marginRight: `-${scrollbarWidth + scrollbarOffsetSize}px`,
          paddingRight: `${scrollbarOffsetSize}px`
        } : {
          marginBottom: `-${scrollbarHeight + scrollbarOffsetSize}px`,
          paddingBottom: `${scrollbarOffsetSize}px`
        },
        onScroll: checkScrolling
      }, tabList.map((item, index) => {
        const {
          title,
          titleWidth,
          titleAlign,
          icon,
          name
        } = item;
        const itemSlots = item.slots || {};
        const titleSlot = itemSlots.title || itemSlots.tab;
        const titlePrefixSlot = itemSlots.titlePrefix || itemSlots['title-prefix'];
        const titleSuffixSlot = itemSlots.titleSuffix || itemSlots['title-suffix'];
        const itemWidth = titleWidth || allTitleWidth;
        const itemAlign = titleAlign || allTitleAlign;
        const params = {
          $tabs: $xeTabs,
          value: activeName,
          name,
          option: item
        };
        const isActive = activeName === name;
        const cacheItem = name ? cacheTabMaps[`${name}`] : null;
        const isLoading = cacheItem ? cacheItem.loading : false;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: `${name}`,
          class: ['vxe-tabs-header--item', `type--${tabType}`, `pos--${tabPosition}`, itemAlign ? `align--${itemAlign}` : '', {
            'is--active': isActive
          }],
          style: itemWidth ? {
            width: toCssUnit(itemWidth)
          } : undefined,
          onClick(evnt) {
            clickEvent(evnt, item);
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-tabs-header--item-inner'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-tabs-header--item-content'
        }, [icon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-tabs-header--item-icon'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: icon
        })]) : renderEmptyElement($xeTabs), titlePrefixSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-tabs-header--item-prefix'
        }, callSlot(titlePrefixSlot, {
          name,
          title
        })) : renderEmptyElement($xeTabs), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-tabs-header--item-name'
        }, titleSlot ? callSlot(titleSlot, {
          name,
          title
        }) : `${title}`), titleSuffixSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-tabs-header--item-suffix'
        }, callSlot(titleSuffixSlot, {
          name,
          title
        })) : renderEmptyElement($xeTabs)]), (isEnableConf(refreshConfig) || refreshOpts.enabled) && (refreshVisibleMethod ? refreshVisibleMethod(params) : true) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-tabs-header--refresh-btn', {
            'is--active': isActive,
            'is--loading': isLoading,
            'is--disabled': isLoading
          }],
          onClick(evnt) {
            handleRefreshTabEvent(evnt, item);
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: isLoading ? getIcon().TABS_TAB_REFRESH_LOADING : getIcon().TABS_TAB_REFRESH
        })]) : renderEmptyElement($xeTabs), (showClose || isEnableConf(closeConfig) || closeOpts.enabled) && (!closeVisibleMethod || closeVisibleMethod(params)) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-tabs-header--close-btn', {
            'is--active': isActive
          }],
          onClick(evnt) {
            handleCloseTabEvent(evnt, item, index, tabList);
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon().TABS_TAB_CLOSE
        })]) : renderEmptyElement($xeTabs)])]);
      }).concat([(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        key: 'line',
        class: ['vxe-tabs-header--active-line', `type--${tabType}`, `pos--${tabPosition}`],
        style: lineStyle
      })]))]), isTabOver ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refHeadNextElem,
        class: ['vxe-tabs-header--bar vxe-tabs-header--next-bar', `type--${tabType}`, `pos--${tabPosition}`],
        onClick: scrollRightEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: lrPosition ? getIcon().TABS_TAB_BUTTON_BOTTOM : getIcon().TABS_TAB_BUTTON_RIGHT
      })]) : renderEmptyElement($xeTabs), tabSuffixSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-tabs-header--suffix', `type--${tabType}`, `pos--${tabPosition}`]
      }, callSlot(tabSuffixSlot, {
        name: activeName
      })) : renderEmptyElement($xeTabs)]);
    };
    const renderTabPane = item => {
      const {
        initNames,
        activeName
      } = reactData;
      const {
        name,
        slots
      } = item;
      const defaultSlot = slots ? slots.default : null;
      return name && initNames.includes(name) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: `${name}`,
        class: ['vxe-tabs-pane--item', {
          'is--visible': activeName === name
        }]
      }, defaultSlot ? callSlot(defaultSlot, {
        name
      }) : []) : renderEmptyElement($xeTabs);
    };
    const renderTabContent = tabList => {
      const {
        destroyOnClose
      } = props;
      const {
        activeName
      } = reactData;
      if (destroyOnClose) {
        const activeTab = tabList.find(item => item.name === activeName);
        return [activeTab ? renderTabPane(activeTab) : renderEmptyElement($xeTabs)];
      }
      return tabList.map(item => renderTabPane(item));
    };
    const rendetTabBody = tabList => {
      const {
        height,
        padding,
        showBody
      } = props;
      const {
        activeName,
        cacheTabMaps
      } = reactData;
      const tabType = computeTabType.value;
      const tabPosition = computeTabPosition.value;
      const refreshOpts = computeRefreshOpts.value;
      const {
        showLoading
      } = refreshOpts;
      const headerpSlot = slots.header;
      const footerSlot = slots.footer;
      if (!showBody) {
        return renderEmptyElement($xeTabs);
      }
      const cacheItem = activeName ? cacheTabMaps[`${activeName}`] : null;
      const isLoading = cacheItem ? cacheItem.loading : false;
      const defParams = {
        name: activeName
      };
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'tb',
        class: ['vxe-tabs-pane--wrapper', `type--${tabType}`, `pos--${tabPosition}`, {
          'is--content': showBody
        }]
      }, [headerpSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tabs-pane--header'
      }, callSlot(headerpSlot, defParams)) : renderEmptyElement($xeTabs), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-tabs-pane--body', `type--${tabType}`, `pos--${tabPosition}`, {
          'is--padding': padding,
          'is--height': height
        }]
      }, renderTabContent(tabList)), footerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tabs-pane--footer'
      }, callSlot(footerSlot, defParams)) : renderEmptyElement($xeTabs), showLoading && isLoading ? renderEmptyElement($xeTabs) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-tabs--loading',
        modelValue: isLoading
      })]);
    };
    const renderVN = () => {
      const {
        height,
        padding,
        trigger
      } = props;
      const {
        activeName
      } = reactData;
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      const tabType = computeTabType.value;
      const tabPosition = computeTabPosition.value;
      const wrapperStyle = computeWrapperStyle.value;
      const defaultSlot = slots.default;
      const tabList = defaultSlot ? tabStaticOptions : tabOptions;
      const vns = [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'ts',
        class: 'vxe-tabs-slots'
      }, defaultSlot ? defaultSlot({
        name: activeName
      }) : [])];
      if (tabPosition === 'right' || tabPosition === 'bottom') {
        vns.push(rendetTabBody(tabList), renderTabHeader(tabList));
      } else {
        vns.push(renderTabHeader(tabList), rendetTabBody(tabList));
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-tabs', `pos--${tabPosition}`, `vxe-tabs--${tabType}`, `trigger--${trigger === 'manual' ? 'trigger' : 'default'}`, {
          'is--padding': padding,
          'is--height': height
        }],
        style: wrapperStyle
      }, vns);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.position, () => {
      reactData.resizeFlag++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      addInitName(val, null);
      reactData.activeName = val;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.activeName, val => {
      scrollToTab(val);
    });
    const optsFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options, () => {
      optsFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(optsFlag, () => {
      initDefaultName(props.options);
      reactData.resizeFlag++;
    });
    const stFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticTabs ? reactData.staticTabs.length : -1, () => {
      stFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.staticTabs, () => {
      stFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(stFlag, () => {
      initDefaultName(reactData.staticTabs);
      reactData.resizeFlag++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeParentTabsResizeFlag, () => {
      reactData.resizeFlag++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => reactData.resizeFlag, () => {
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
        updateTabStyle();
      });
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      updateTabStyle();
      globalEvents.on($xeTabs, 'resize', updateTabStyle);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeTabs, 'resize');
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeTabs', $xeTabs);
    addInitName(props.modelValue, null);
    initDefaultName(reactData.staticTabs.length ? reactData.staticTabs : props.options);
    $xeTabs.renderVN = renderVN;
    return $xeTabs;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/tabs/index.ts



const VxeTabs = Object.assign({}, tabs, {
  install(app) {
    app.component(tabs.name, tabs);
  }
});
dynamicApp.use(VxeTabs);
index_esm_VxeUI.component(tabs);
const Tabs = VxeTabs;
/* harmony default export */ var packages_tabs = (VxeTabs);
;// CONCATENATED MODULE: ./packages/tag/src/tag.ts





/* harmony default export */ var tag = (defineVxeComponent({
  name: 'VxeTag',
  props: {
    status: String,
    title: [String, Number],
    icon: String,
    content: [String, Number],
    size: {
      type: String,
      default: () => getConfig().tag.size || getConfig().size
    }
  },
  emits: ['click'],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTag = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $tag: $xeTag
      }, params));
    };
    const tagMethods = {
      dispatchEvent
    };
    const tagPrivateMethods = {};
    const clickEvent = evnt => {
      dispatchEvent('click', {}, evnt);
    };
    Object.assign($xeTag, tagMethods, tagPrivateMethods);
    const renderContent = () => {
      const {
        icon,
        content
      } = props;
      const defaultSlot = slots.default;
      const iconSlot = slots.icon;
      return [iconSlot || icon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-tag--icon'
      }, iconSlot ? vn_getSlotVNs(iconSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon
      })]) : renderEmptyElement($xeTag), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-tag--content'
      }, defaultSlot ? defaultSlot({}) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content))];
    };
    const renderVN = () => {
      const {
        status,
        title
      } = props;
      const vSize = computeSize.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        ref: refElem,
        class: ['vxe-tag', {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status
        }],
        title,
        onClick: clickEvent
      }, renderContent());
    };
    $xeTag.renderVN = renderVN;
    return $xeTag;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/tag/index.ts



const VxeTag = Object.assign({}, tag, {
  install(app) {
    app.component(tag.name, tag);
  }
});
dynamicApp.use(VxeTag);
index_esm_VxeUI.component(tag);
const Tag = VxeTag;
/* harmony default export */ var packages_tag = (VxeTag);
;// CONCATENATED MODULE: ./packages/text-ellipsis/src/text-ellipsis.ts




/* harmony default export */ var text_ellipsis = (defineVxeComponent({
  name: 'VxeTextEllipsis',
  props: {
    href: String,
    target: String,
    content: [String, Number],
    lineClamp: [String, Number],
    status: String,
    title: [String, Number],
    loading: Boolean,
    offsetLength: [String, Number],
    routerLink: Object,
    underline: {
      type: Boolean,
      default: () => getConfig().textEllipsis.underline
    },
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    size: {
      type: String,
      default: () => getConfig().textEllipsis.size || getConfig().size
    }
  },
  emits: ['click'],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const {
      computePermissionInfo
    } = usePermission(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const realityElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      resizeObserver: null,
      visibleLen: 0
    });
    const refMaps = {
      refElem
    };
    const computeTextLineClamp = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.lineClamp);
    });
    const computeTextContent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(props.content);
    });
    const computeTextOffsetLength = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.offsetLength ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.offsetLength) : 0;
    });
    const computeVisibleContent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        visibleLen
      } = reactData;
      const textLineClamp = computeTextLineClamp.value;
      const textContent = computeTextContent.value;
      const textOffsetLength = computeTextOffsetLength.value;
      if (textLineClamp > 1) {
        if (textContent.length > visibleLen) {
          return `${textContent.slice(0, Math.max(1, visibleLen - 3 + textOffsetLength))}...`;
        }
        return textContent;
      }
      return textContent;
    });
    const computeMaps = {};
    const $xeTextEllipsis = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $textEllipsis: $xeTextEllipsis
      }, params));
    };
    const calculateFont = targetWidth => {
      const el = refElem.value;
      const ryEl = realityElem.value;
      if (el && ryEl) {
        let fontSize = 12;
        try {
          fontSize = Math.max(10, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getComputedStyle(ryEl).fontSize));
        } catch (e) {}
        const textContent = computeTextContent.value;
        let currIndex = Math.floor(targetWidth / fontSize);
        let currStr = textContent.slice(0, currIndex);
        ryEl.textContent = currStr;
        reactData.visibleLen = currStr.length;
        let maxCount = 0;
        while (targetWidth > ryEl.clientWidth && maxCount < 30) {
          maxCount++;
          const offsetIndex = Math.floor((targetWidth - ryEl.clientWidth) / fontSize);
          if (offsetIndex) {
            currIndex += offsetIndex;
            currStr = textContent.slice(0, currIndex);
            ryEl.textContent = currStr;
            reactData.visibleLen = currStr.length;
          } else {
            break;
          }
        }
        ryEl.textContent = '';
        ryEl.style.display = '';
        ryEl.style.position = '';
        ryEl.style.top = '';
        ryEl.style.left = '';
      }
    };
    const updateStyle = () => {
      const el = refElem.value;
      const ryEl = realityElem.value;
      const textContent = computeTextContent.value;
      const textLineClamp = computeTextLineClamp.value;
      if (el && ryEl) {
        const cWidth = el.clientWidth;
        ryEl.style.display = 'block';
        ryEl.style.position = 'absolute';
        ryEl.style.top = '-3000px';
        ryEl.style.left = '-3000px';
        ryEl.textContent = textContent;
        const sWidth = ryEl.offsetWidth;
        const targetWidth = Math.floor(cWidth * textLineClamp);
        if (targetWidth > sWidth) {
          reactData.visibleLen = textContent.length;
        } else {
          calculateFont(targetWidth);
        }
      } else {
        reactData.visibleLen = textContent.length;
      }
    };
    const textEllipsisMethods = {
      dispatchEvent
    };
    const clickEvent = () => {
      emit('click', {});
    };
    const initObserver = () => {
      const {
        resizeObserver
      } = reactData;
      const textLineClamp = computeTextLineClamp.value;
      if (!resizeObserver) {
        const el = refElem.value;
        if (el && textLineClamp > 1) {
          if (window.ResizeObserver) {
            const observerObj = new window.ResizeObserver(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().throttle(() => {
              updateStyle();
            }, 300, {
              leading: true,
              trailing: true
            }));
            observerObj.observe(el);
            reactData.resizeObserver = observerObj;
          }
        }
      }
    };
    const textEllipsisPrivateMethods = {};
    Object.assign($xeTextEllipsis, textEllipsisMethods, textEllipsisPrivateMethods);
    const renderContent = () => {
      const {
        routerLink,
        href,
        target,
        title
      } = props;
      const visibleContent = computeVisibleContent.value;
      if (routerLink) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)((0,external_commonjs_vue_commonjs2_vue_root_Vue_.resolveComponent)('router-link'), {
          class: 'vxe-text-ellipsis--link',
          title,
          target,
          to: routerLink
        }, {
          default() {
            return renderContent();
          }
        });
      }
      if (href) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('a', {
          class: 'vxe-text-ellipsis--link',
          href,
          target,
          title
        }, visibleContent);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: 'vxe-text-ellipsis--content'
      }, visibleContent);
    };
    const renderVN = () => {
      const {
        loading,
        status,
        title,
        underline
      } = props;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      const textLineClamp = computeTextLineClamp.value;
      if (!permissionInfo.visible) {
        return renderEmptyElement($xeTextEllipsis);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-text-ellipsis', textLineClamp > 1 ? 'is--multi' : 'is--single', {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          'is--underline': underline,
          'is--loading': loading
        }],
        title,
        onClick: clickEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        ref: realityElem,
        class: 'vxe-text-ellipsis--reality'
      }), renderContent()]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.content, () => {
      updateStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.lineClamp, () => {
      initObserver();
      updateStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      initObserver();
      updateStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onBeforeUnmount)(() => {
      const {
        resizeObserver
      } = reactData;
      const el = refElem.value;
      const ryEl = realityElem.value;
      if (ryEl) {
        ryEl.textContent = '';
      }
      if (resizeObserver) {
        if (el) {
          resizeObserver.unobserve(el);
        }
        resizeObserver.disconnect();
        reactData.resizeObserver = null;
      }
    });
    $xeTextEllipsis.renderVN = renderVN;
    return $xeTextEllipsis;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/text-ellipsis/index.ts



const VxeTextEllipsis = Object.assign({}, text_ellipsis, {
  install(app) {
    app.component(text_ellipsis.name, text_ellipsis);
  }
});
dynamicApp.use(VxeTextEllipsis);
index_esm_VxeUI.component(text_ellipsis);
const TextEllipsis = VxeTextEllipsis;
/* harmony default export */ var packages_text_ellipsis = (VxeTextEllipsis);
;// CONCATENATED MODULE: ./packages/text/index.ts



const VxeText = Object.assign({}, src_text, {
  install(app) {
    app.component(src_text.name, src_text);
  }
});
dynamicApp.use(VxeText);
index_esm_VxeUI.component(src_text);
const Text = VxeText;
/* harmony default export */ var packages_text = (VxeText);
;// CONCATENATED MODULE: ./packages/textarea/src/textarea.ts





let autoTxtElem;
/* harmony default export */ var src_textarea = (defineVxeComponent({
  name: 'VxeTextarea',
  props: {
    modelValue: [String, Number],
    className: String,
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    readonly: {
      type: Boolean,
      default: null
    },
    editable: {
      type: Boolean,
      default: true
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    rows: {
      type: [String, Number],
      default: null
    },
    cols: {
      type: [String, Number],
      default: null
    },
    showWordCount: Boolean,
    countMethod: Function,
    autosize: [Boolean, Object],
    form: String,
    resize: {
      type: String,
      default: () => getConfig().textarea.resize
    },
    size: {
      type: String,
      default: () => getConfig().textarea.size || getConfig().size
    },
    // 已废弃
    maxlength: [String, Number]
  },
  emits: ['update:modelValue', 'input', 'keydown', 'keyup', 'click', 'change', 'focus', 'blur'],
  setup(props, context) {
    const {
      emit
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      inputValue: props.modelValue
    });
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTextarea = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refMaps = {
      refElem,
      refTextarea
    };
    const $xeTextarea = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let textareaMethods = {};
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeInputReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        editable
      } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || !editable;
    });
    const computeInpPlaceholder = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        placeholder
      } = props;
      if (placeholder) {
        return getFuncText(placeholder);
      }
      const globalPlaceholder = getConfig().textarea.placeholder;
      if (globalPlaceholder) {
        return getFuncText(globalPlaceholder);
      }
      return getI18n('vxe.base.pleaseInput');
    });
    const computeInpMaxLength = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        maxLength,
        maxlength
      } = props;
      return maxLength || maxlength;
    });
    const computeInputCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().getSize(reactData.inputValue);
    });
    const computeIsCountError = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const inputCount = computeInputCount.value;
      const inpMaxLength = computeInpMaxLength.value;
      return inpMaxLength && inputCount > external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(inpMaxLength);
    });
    const computeSizeOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({
        minRows: 1,
        maxRows: 10
      }, getConfig().textarea.autosize, props.autosize);
    });
    const updateAutoTxt = () => {
      const {
        size,
        autosize
      } = props;
      const {
        inputValue
      } = reactData;
      if (autosize) {
        if (!autoTxtElem) {
          autoTxtElem = document.createElement('div');
        }
        if (!autoTxtElem.parentNode) {
          document.body.appendChild(autoTxtElem);
        }
        const textElem = refTextarea.value;
        if (!textElem) {
          return;
        }
        const textStyle = getComputedStyle(textElem);
        autoTxtElem.className = ['vxe-textarea--autosize', size ? `size--${size}` : ''].join(' ');
        autoTxtElem.style.width = `${textElem.clientWidth}px`;
        autoTxtElem.style.padding = textStyle.padding;
        autoTxtElem.innerText = ('' + (inputValue || '　')).replace(/\n$/, '\n　');
      }
    };
    const handleResize = () => {
      if (props.autosize) {
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const sizeOpts = computeSizeOpts.value;
          const {
            minRows,
            maxRows
          } = sizeOpts;
          const textElem = refTextarea.value;
          if (!textElem) {
            return;
          }
          const sizeHeight = autoTxtElem.clientHeight;
          const textStyle = getComputedStyle(textElem);
          const lineHeight = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textStyle.lineHeight);
          const paddingTop = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textStyle.paddingTop);
          const paddingBottom = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textStyle.paddingBottom);
          const borderTopWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textStyle.borderTopWidth);
          const borderBottomWidth = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(textStyle.borderBottomWidth);
          const intervalHeight = paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;
          const rowNum = (sizeHeight - intervalHeight) / lineHeight;
          const textRows = rowNum && /[0-9]/.test('' + rowNum) ? rowNum : Math.floor(rowNum) + 1;
          let vaildRows = textRows;
          if (textRows < minRows) {
            vaildRows = minRows;
          } else if (textRows > maxRows) {
            vaildRows = maxRows;
          }
          textElem.style.height = `${vaildRows * lineHeight + intervalHeight}px`;
        });
      }
    };
    const triggerEvent = evnt => {
      const value = reactData.inputValue;
      $xeTextarea.dispatchEvent(evnt.type, {
        value
      }, evnt);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit('update:modelValue', value);
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(props.modelValue) !== value) {
        textareaMethods.dispatchEvent('change', {
          value
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const inputEvent = evnt => {
      const {
        immediate
      } = props;
      const textElem = evnt.target;
      const value = textElem.value;
      reactData.inputValue = value;
      if (immediate) {
        handleChange(value, evnt);
      }
      $xeTextarea.dispatchEvent('input', {
        value
      }, evnt);
      handleResize();
    };
    const changeEvent = evnt => {
      const {
        immediate
      } = props;
      if (immediate) {
        triggerEvent(evnt);
      } else {
        handleChange(reactData.inputValue, evnt);
      }
    };
    const blurEvent = evnt => {
      const {
        immediate
      } = props;
      const {
        inputValue
      } = reactData;
      if (!immediate) {
        handleChange(inputValue, evnt);
      }
      $xeTextarea.dispatchEvent('blur', {
        value: inputValue
      }, evnt);
    };
    textareaMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, {
          $textarea: $xeTextarea
        }, params));
      },
      focus() {
        const textElem = refTextarea.value;
        textElem.focus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      blur() {
        const textElem = refTextarea.value;
        textElem.blur();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      }
    };
    Object.assign($xeTextarea, textareaMethods);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, val => {
      reactData.inputValue = val;
      updateAutoTxt();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(computeSizeOpts, () => {
      updateAutoTxt();
      handleResize();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
      const {
        autosize
      } = props;
      if (autosize) {
        updateAutoTxt();
        handleResize();
      }
    });
    const renderVN = () => {
      const {
        className,
        resize,
        autosize,
        showWordCount,
        countMethod,
        rows,
        cols
      } = props;
      const {
        inputValue
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const isCountError = computeIsCountError.value;
      const inputCount = computeInputCount.value;
      const inputReadonly = computeInputReadonly.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const inpMaxLength = computeInpMaxLength.value;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-textarea--readonly', className]
        }, inputValue);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-textarea', className, {
          [`size--${vSize}`]: vSize,
          'is--autosize': autosize,
          'is--count': showWordCount,
          'is--disabled': isDisabled,
          'is--rows': !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(rows),
          'is--cols': !external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(cols)
        }],
        spellcheck: false
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('textarea', {
        ref: refTextarea,
        class: 'vxe-textarea--inner',
        value: inputValue,
        name: props.name,
        placeholder: inpPlaceholder,
        maxlength: inpMaxLength,
        readonly: inputReadonly,
        disabled: isDisabled,
        rows,
        cols,
        style: resize ? {
          resize
        } : null,
        onInput: inputEvent,
        onChange: changeEvent,
        onKeydown: triggerEvent,
        onKeyup: triggerEvent,
        onClick: triggerEvent,
        onFocus: triggerEvent,
        onBlur: blurEvent
      }), showWordCount ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
        class: ['vxe-textarea--count', {
          'is--error': isCountError
        }]
      }, countMethod ? `${countMethod({
        value: inputValue
      })}` : `${inputCount}${inpMaxLength ? `/${inpMaxLength}` : ''}`) : null]);
    };
    $xeTextarea.renderVN = renderVN;
    return $xeTextarea;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/textarea/index.ts



const VxeTextarea = Object.assign(src_textarea, {
  install: function (app) {
    app.component(src_textarea.name, src_textarea);
  }
});
dynamicApp.use(VxeTextarea);
index_esm_VxeUI.component(src_textarea);
const Textarea = VxeTextarea;
/* harmony default export */ var packages_textarea = (VxeTextarea);
;// CONCATENATED MODULE: ./packages/tip/src/tip.ts





/* harmony default export */ var tip = (defineVxeComponent({
  name: 'VxeTip',
  props: {
    title: {
      type: [String, Number],
      default: () => getConfig().tip.title
    },
    content: [String, Number],
    status: String,
    icon: {
      type: String,
      default: () => getConfig().tip.icon
    },
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    size: {
      type: String,
      default: () => getConfig().tip.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const {
      slots,
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const {
      computePermissionInfo
    } = usePermission(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTip = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $tip: $xeTip
      }, params));
    };
    const tipMethods = {
      dispatchEvent
    };
    const tipPrivateMethods = {};
    Object.assign($xeTip, tipMethods, tipPrivateMethods);
    const renderVN = () => {
      const {
        status,
        content,
        icon,
        title
      } = props;
      const defaultSlot = slots.default;
      const titleSlot = slots.title;
      const iconSlot = slots.icon;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      if (!permissionInfo.visible) {
        return renderEmptyElement($xeTip);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-tip', {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          'has--title': !!(titleSlot || title)
        }]
      }, [iconSlot || icon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tip--icon'
      }, iconSlot ? vn_getSlotVNs(iconSlot({})) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: icon
      })]) : renderEmptyElement($xeTip), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tip--body'
      }, [titleSlot || title ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tip--title'
      }, titleSlot ? vn_getSlotVNs(titleSlot({})) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(title)) : renderEmptyElement($xeTip), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tip--content'
      }, defaultSlot ? vn_getSlotVNs(defaultSlot({})) : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content))])]);
    };
    $xeTip.renderVN = renderVN;
    return $xeTip;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/tip/index.ts



const VxeTip = Object.assign({}, tip, {
  install(app) {
    app.component(tip.name, tip);
    app.component('VxeTipsComponent', tip);
  }
});
dynamicApp.use(VxeTip);
index_esm_VxeUI.component(tip);
const Tips = VxeTip;
const Tip = VxeTip;
/* harmony default export */ var packages_tip = (VxeTip);
;// CONCATENATED MODULE: ./packages/tooltip/index.ts



const VxeTooltip = Object.assign({}, tooltip, {
  install(app) {
    app.component(tooltip.name, tooltip);
  }
});
dynamicApp.use(VxeTooltip);
index_esm_VxeUI.component(tooltip);
const Tooltip = VxeTooltip;
/* harmony default export */ var packages_tooltip = (VxeTooltip);
;// CONCATENATED MODULE: ./packages/tree/src/util.ts

function enNodeValue(nodeid) {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(nodeid) ? '' : encodeURIComponent(`${nodeid}`);
}
function deNodeValue(nodeid) {
  return nodeid ? decodeURIComponent(`${nodeid}`) : nodeid;
}
function countTreeExpand($xeTree, prevNode) {
  let count = 1;
  if (!prevNode) {
    return count;
  }
  const props = $xeTree.props;
  const {
    transform
  } = props;
  const reactData = $xeTree.reactData;
  const {
    updateExpandedFlag
  } = reactData;
  const internalData = $xeTree.internalData;
  const {
    treeExpandedMaps
  } = internalData;
  const {
    computeChildrenField,
    computeMapChildrenField
  } = $xeTree.getComputeMaps();
  const childrenField = computeChildrenField.value;
  const mapChildrenField = computeMapChildrenField.value;
  const nodeChildren = prevNode[transform ? mapChildrenField : childrenField];
  if (nodeChildren && updateExpandedFlag && treeExpandedMaps[$xeTree.getNodeId(prevNode)]) {
    for (let index = 0; index < nodeChildren.length; index++) {
      count += countTreeExpand($xeTree, nodeChildren[index]);
    }
  }
  return count;
}
function calcTreeLine($xeTree, node, prevNode) {
  const internalData = $xeTree.internalData;
  const {
    scrollYStore
  } = internalData;
  const {
    rowHeight
  } = scrollYStore;
  let expandSize = 1;
  if (prevNode) {
    expandSize = countTreeExpand($xeTree, prevNode);
  }
  return (rowHeight || 28) * expandSize - (prevNode ? 1 : 12);
}
;// CONCATENATED MODULE: ./packages/tree/src/tree.ts










/**
 * 生成节点的唯一主键
 */
function getNodeUniqueId() {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('node_');
}
function tree_createInternalData() {
  return {
    // initialized: false,
    // lastFilterValue: '',
    treeFullData: [],
    afterTreeList: [],
    afterVisibleList: [],
    nodeMaps: {},
    selectCheckboxMaps: {},
    indeterminateRowMaps: {},
    treeExpandedMaps: {},
    treeExpandLazyLoadedMaps: {},
    lastScrollLeft: 0,
    lastScrollTop: 0,
    scrollYStore: {
      startIndex: 0,
      endIndex: 0,
      visibleSize: 0,
      offsetSize: 0,
      rowHeight: 0
    },
    lastScrollTime: 0
    // hpTimeout: undefined
  };
}
/* harmony default export */ var tree = (defineVxeComponent({
  name: 'VxeTree',
  props: {
    data: Array,
    autoResize: {
      type: Boolean,
      default: () => getConfig().tree.autoResize
    },
    height: [String, Number],
    maxHeight: {
      type: [String, Number],
      default: () => getConfig().tree.maxHeight
    },
    minHeight: {
      type: [String, Number],
      default: () => getConfig().tree.minHeight
    },
    loading: Boolean,
    loadingConfig: Object,
    accordion: {
      type: Boolean,
      default: () => getConfig().tree.accordion
    },
    childrenField: {
      type: String,
      default: () => getConfig().tree.childrenField
    },
    valueField: {
      type: String,
      default: () => getConfig().tree.valueField
    },
    keyField: {
      type: String,
      default: () => getConfig().tree.keyField
    },
    parentField: {
      type: String,
      default: () => getConfig().tree.parentField
    },
    titleField: {
      type: String,
      default: () => getConfig().tree.titleField
    },
    hasChildField: {
      type: String,
      default: () => getConfig().tree.hasChildField
    },
    mapChildrenField: {
      type: String,
      default: () => getConfig().tree.mapChildrenField
    },
    transform: Boolean,
    // 已废弃
    isCurrent: Boolean,
    // 已废弃
    isHover: Boolean,
    expandAll: Boolean,
    showLine: {
      type: Boolean,
      default: () => getConfig().tree.showLine
    },
    trigger: String,
    indent: {
      type: Number,
      default: () => getConfig().tree.indent
    },
    showRadio: {
      type: Boolean,
      default: () => getConfig().tree.showRadio
    },
    checkNodeKey: {
      type: [String, Number],
      default: () => getConfig().tree.checkNodeKey
    },
    radioConfig: Object,
    showCheckbox: {
      type: Boolean,
      default: () => getConfig().tree.showCheckbox
    },
    checkNodeKeys: {
      type: Array,
      default: () => getConfig().tree.checkNodeKeys
    },
    checkboxConfig: Object,
    nodeConfig: Object,
    lazy: Boolean,
    toggleMethod: Function,
    loadMethod: Function,
    showIcon: {
      type: Boolean,
      default: true
    },
    iconOpen: {
      type: String,
      default: () => getConfig().tree.iconOpen
    },
    iconClose: {
      type: String,
      default: () => getConfig().tree.iconClose
    },
    iconLoaded: {
      type: String,
      default: () => getConfig().tree.iconLoaded
    },
    filterValue: [String, Number],
    filterConfig: Object,
    size: {
      type: String,
      default: () => getConfig().tree.size || getConfig().size
    },
    virtualYConfig: Object
  },
  emits: ['update:modelValue', 'update:checkNodeKey', 'update:checkNodeKeys', 'node-click', 'node-dblclick', 'current-change', 'radio-change', 'checkbox-change', 'load-success', 'load-error', 'scroll'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refHeaderWrapperElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refFooterWrapperElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refVirtualWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refVirtualBody = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      parentHeight: 0,
      customHeight: 0,
      customMinHeight: 0,
      customMaxHeight: 0,
      currentNode: null,
      scrollYLoad: false,
      bodyHeight: 0,
      topSpaceHeight: 0,
      selectRadioKey: enNodeValue(props.checkNodeKey),
      treeList: [],
      updateExpandedFlag: 1,
      updateCheckboxFlag: 1
    });
    const internalData = tree_createInternalData();
    const refMaps = {
      refElem
    };
    const computeTitleField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.titleField || 'title';
    });
    const computeKeyField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.keyField || 'id';
    });
    const computeValueField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const keyField = computeKeyField.value;
      return props.valueField || keyField;
    });
    const computeParentField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.parentField || 'parentId';
    });
    const computeChildrenField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.childrenField || 'children';
    });
    const computeMapChildrenField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.mapChildrenField || 'mapChildren';
    });
    const computeHasChildField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.hasChildField || 'hasChild';
    });
    const computeVirtualYOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().tree.virtualYConfig, props.virtualYConfig);
    });
    const computeIsRowCurrent = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const nodeOpts = computeNodeOpts.value;
      const {
        isCurrent
      } = nodeOpts;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(isCurrent)) {
        return isCurrent;
      }
      return props.isCurrent;
    });
    const computeIsRowHover = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const nodeOpts = computeNodeOpts.value;
      const {
        isHover
      } = nodeOpts;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(isHover)) {
        return isHover;
      }
      return props.isHover;
    });
    const computeRadioOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({
        showIcon: true
      }, getConfig().tree.radioConfig, props.radioConfig);
    });
    const computeCheckboxOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({
        showIcon: true
      }, getConfig().tree.checkboxConfig, props.checkboxConfig);
    });
    const computeNodeOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().tree.nodeConfig, props.nodeConfig);
    });
    const computeLoadingOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().tree.loadingConfig, props.loadingConfig);
    });
    const computeTreeStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        customHeight,
        customMinHeight,
        customMaxHeight
      } = reactData;
      const stys = {};
      if (customHeight) {
        stys.height = toCssUnit(customHeight);
      }
      if (customMinHeight) {
        stys.minHeight = toCssUnit(customMinHeight);
      }
      if (customMaxHeight) {
        stys.maxHeight = toCssUnit(customMaxHeight);
      }
      return stys;
    });
    const computeFilterOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().tree.filterConfig, props.filterConfig);
    });
    const computeMaps = {
      computeChildrenField,
      computeMapChildrenField,
      computeRadioOpts,
      computeCheckboxOpts,
      computeNodeOpts
    };
    const $xeTree = {
      xID,
      props,
      context,
      internalData,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getNodeId = node => {
      const valueField = computeValueField.value;
      const nodeKey = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(node, valueField);
      return enNodeValue(nodeKey);
    };
    const isExpandByNode = node => {
      const {
        updateExpandedFlag
      } = reactData;
      const {
        treeExpandedMaps
      } = internalData;
      const nodeid = getNodeId(node);
      return !!(updateExpandedFlag && treeExpandedMaps[nodeid]);
    };
    const isCheckedByRadioNodeId = nodeid => {
      const {
        selectRadioKey
      } = reactData;
      return selectRadioKey === nodeid;
    };
    const isCheckedByRadioNode = node => {
      return isCheckedByRadioNodeId(getNodeId(node));
    };
    const isCheckedByCheckboxNodeId = nodeid => {
      const {
        updateCheckboxFlag
      } = reactData;
      const {
        selectCheckboxMaps
      } = internalData;
      return !!(updateCheckboxFlag && selectCheckboxMaps[nodeid]);
    };
    const isCheckedByCheckboxNode = node => {
      return isCheckedByCheckboxNodeId(getNodeId(node));
    };
    const isIndeterminateByCheckboxNodeid = nodeid => {
      const {
        updateCheckboxFlag
      } = reactData;
      const {
        indeterminateRowMaps
      } = internalData;
      return !!(updateCheckboxFlag && indeterminateRowMaps[nodeid]);
    };
    const isIndeterminateByCheckboxNode = node => {
      return isIndeterminateByCheckboxNodeid(getNodeId(node));
    };
    const emitCheckboxMode = value => {
      emit('update:checkNodeKeys', value);
    };
    const emitRadioMode = value => {
      emit('update:checkNodeKey', value);
    };
    const handleSetCheckboxByNodeId = (nodeKeys, checked) => {
      const {
        nodeMaps
      } = internalData;
      if (nodeKeys) {
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(nodeKeys)) {
          nodeKeys = [nodeKeys];
        }
        const nodeList = [];
        nodeKeys.forEach(nodeKey => {
          const nodeid = enNodeValue(nodeKey);
          const nodeItem = nodeMaps[nodeid];
          if (nodeItem) {
            nodeList.push(nodeItem.item);
          }
        });
        handleCheckedCheckboxNode(nodeList, checked);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const handleCheckedCheckboxNode = (nodeList, checked) => {
      const {
        transform
      } = props;
      const {
        selectCheckboxMaps
      } = internalData;
      const mapChildrenField = computeMapChildrenField.value;
      const childrenField = computeChildrenField.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const {
        checkStrictly
      } = checkboxOpts;
      const handleSelect = node => {
        const nodeid = getNodeId(node);
        if (checked) {
          if (!selectCheckboxMaps[nodeid]) {
            selectCheckboxMaps[nodeid] = node;
          }
        } else {
          if (selectCheckboxMaps[nodeid]) {
            delete selectCheckboxMaps[nodeid];
          }
        }
      };
      if (checkStrictly) {
        nodeList.forEach(handleSelect);
      } else {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(nodeList, handleSelect, {
          children: transform ? mapChildrenField : childrenField
        });
      }
      reactData.updateCheckboxFlag++;
      updateCheckboxStatus();
    };
    const updateCheckboxChecked = nodeKeys => {
      internalData.selectCheckboxMaps = {};
      handleSetCheckboxByNodeId(nodeKeys, true);
    };
    const handleSetExpand = (nodeid, expanded, expandedMaps) => {
      if (expanded) {
        if (!expandedMaps[nodeid]) {
          expandedMaps[nodeid] = true;
        }
      } else {
        if (expandedMaps[nodeid]) {
          delete expandedMaps[nodeid];
        }
      }
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $tree: $xeTree
      }, params));
    };
    const getParentElem = () => {
      const el = refElem.value;
      return el ? el.parentElement : null;
    };
    const calcTableHeight = key => {
      const {
        parentHeight
      } = reactData;
      const val = props[key];
      let num = 0;
      if (val) {
        if (val === '100%' || val === 'auto') {
          num = parentHeight;
        } else {
          if (isScale(val)) {
            num = Math.floor((external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toInteger(val) || 1) / 100 * parentHeight);
          } else {
            num = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(val);
          }
          num = Math.max(40, num);
        }
      }
      return num;
    };
    const updateHeight = () => {
      reactData.customHeight = calcTableHeight('height');
      reactData.customMinHeight = calcTableHeight('minHeight');
      reactData.customMaxHeight = calcTableHeight('maxHeight');
      // 如果启用虚拟滚动，默认高度
      if (reactData.scrollYLoad && !(reactData.customHeight || reactData.customMinHeight)) {
        reactData.customHeight = 300;
      }
    };
    const createNode = records => {
      const valueField = computeValueField.value;
      return Promise.resolve(records.map(obj => {
        const item = {
          ...obj
        };
        let nodeid = getNodeId(item);
        if (!nodeid) {
          nodeid = getNodeUniqueId();
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(item, valueField, nodeid);
        }
        return item;
      }));
    };
    const cacheNodeMap = () => {
      const {
        treeFullData
      } = internalData;
      const valueField = computeValueField.value;
      const childrenField = computeChildrenField.value;
      const keyMaps = {};
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(treeFullData, (item, index, items, path, parent, nodes) => {
        let nodeid = getNodeId(item);
        if (!nodeid) {
          nodeid = getNodeUniqueId();
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().set(item, valueField, nodeid);
        }
        keyMaps[nodeid] = {
          item,
          index,
          items,
          parent,
          nodes,
          level: nodes.length,
          treeIndex: index,
          lineCount: 0,
          treeLoaded: false
        };
      }, {
        children: childrenField
      });
      internalData.nodeMaps = keyMaps;
    };
    const updateAfterDataIndex = () => {
      const {
        transform
      } = props;
      const {
        afterTreeList,
        nodeMaps
      } = internalData;
      const childrenField = computeChildrenField.value;
      const mapChildrenField = computeMapChildrenField.value;
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterTreeList, (item, index, items) => {
        const nodeid = getNodeId(item);
        const nodeItem = nodeMaps[nodeid];
        if (nodeItem) {
          nodeItem.items = items;
          nodeItem.treeIndex = index;
        } else {
          const rest = {
            item,
            index,
            items,
            parent,
            nodes: [],
            level: 0,
            treeIndex: index,
            lineCount: 0,
            treeLoaded: false
          };
          nodeMaps[nodeid] = rest;
        }
      }, {
        children: transform ? mapChildrenField : childrenField
      });
    };
    const updateAfterFullData = () => {
      const {
        transform,
        filterValue
      } = props;
      const {
        treeFullData,
        lastFilterValue
      } = internalData;
      const titleField = computeTitleField.value;
      const childrenField = computeChildrenField.value;
      const mapChildrenField = computeMapChildrenField.value;
      const filterOpts = computeFilterOpts.value;
      const {
        autoExpandAll,
        beforeFilterMethod,
        filterMethod,
        afterFilterMethod
      } = filterOpts;
      let fullList = treeFullData;
      let treeList = fullList;
      let filterStr = '';
      if (filterValue || filterValue === 0) {
        filterStr = `${filterValue}`;
        const handleSearch = filterMethod ? item => {
          return filterMethod({
            $tree: $xeTree,
            node: item,
            filterValue: filterStr
          });
        } : item => {
          return String(item[titleField]).toLowerCase().indexOf(filterStr) > -1;
        };
        const bafParams = {
          $tree: $xeTree,
          filterValue: filterStr
        };
        if (beforeFilterMethod) {
          beforeFilterMethod(bafParams);
        }
        if (transform) {
          treeList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(treeFullData, handleSearch, {
            original: true,
            isEvery: true,
            children: childrenField,
            mapChildren: mapChildrenField
          });
          fullList = treeList;
        } else {
          fullList = treeFullData.filter(handleSearch);
        }
        internalData.lastFilterValue = filterStr;
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          // 筛选时自动展开
          if (autoExpandAll) {
            $xeTree.setAllExpandNode(true).then(() => {
              if (afterFilterMethod) {
                afterFilterMethod(bafParams);
              }
            });
          } else {
            if (afterFilterMethod) {
              afterFilterMethod(bafParams);
            }
          }
        });
      } else {
        if (transform) {
          treeList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().searchTree(treeFullData, () => true, {
            original: true,
            isEvery: true,
            children: childrenField,
            mapChildren: mapChildrenField
          });
          fullList = treeList;
          if (lastFilterValue) {
            const bafParams = {
              $tree: $xeTree,
              filterValue: filterStr
            };
            if (beforeFilterMethod) {
              beforeFilterMethod(bafParams);
            }
            // 取消筛选时自动收起
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              if (autoExpandAll) {
                $xeTree.clearAllExpandNode().then(() => {
                  if (afterFilterMethod) {
                    afterFilterMethod(bafParams);
                  }
                });
              } else {
                if (afterFilterMethod) {
                  afterFilterMethod(bafParams);
                }
              }
            });
          }
        }
        internalData.lastFilterValue = '';
      }
      internalData.afterVisibleList = fullList;
      internalData.afterTreeList = treeList;
      updateAfterDataIndex();
    };
    /**
     * 如果为虚拟树、则将树结构拍平
     */
    const handleTreeToList = () => {
      const {
        transform
      } = props;
      const {
        afterTreeList,
        treeExpandedMaps
      } = internalData;
      const mapChildrenField = computeMapChildrenField.value;
      const expandMaps = {};
      if (transform) {
        const fullData = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterTreeList, (item, index, items, path, parentRow) => {
          const nodeid = getNodeId(item);
          const parentNodeid = getNodeId(parentRow);
          if (!parentRow || expandMaps[parentNodeid] && treeExpandedMaps[parentNodeid]) {
            expandMaps[nodeid] = 1;
            fullData.push(item);
          }
        }, {
          children: mapChildrenField
        });
        updateScrollYStatus(fullData);
        internalData.afterVisibleList = fullData;
        return fullData;
      }
      return internalData.afterVisibleList;
    };
    const handleData = force => {
      const {
        scrollYLoad
      } = reactData;
      const {
        scrollYStore
      } = internalData;
      let fullList = internalData.afterVisibleList;
      if (force) {
        // 更新数据，处理筛选和排序
        updateAfterFullData();
        // 如果为虚拟树，将树结构拍平
        fullList = handleTreeToList();
      }
      const treeList = scrollYLoad ? fullList.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullList.slice(0);
      reactData.treeList = treeList;
    };
    const triggerSearchEvent = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().debounce(() => handleData(true), 350, {
      trailing: true
    });
    const loadData = list => {
      const {
        expandAll,
        transform
      } = props;
      const {
        initialized,
        scrollYStore
      } = internalData;
      const keyField = computeKeyField.value;
      const parentField = computeParentField.value;
      const childrenField = computeChildrenField.value;
      const fullData = transform ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toArrayTree(list, {
        key: keyField,
        parentKey: parentField,
        mapChildren: childrenField
      }) : list ? list.slice(0) : [];
      internalData.treeFullData = fullData;
      Object.assign(scrollYStore, {
        startIndex: 0,
        endIndex: 1,
        visibleSize: 0
      });
      const sYLoad = updateScrollYStatus(fullData);
      cacheNodeMap();
      handleData(true);
      if (sYLoad) {
        if (!(props.height || props.maxHeight)) {
          errLog('vxe.error.reqProp', ['height | max-height | virtual-y-config.enabled=false']);
        }
      }
      return computeScrollLoad().then(() => {
        if (!initialized) {
          if (list && list.length) {
            internalData.initialized = true;
            if (expandAll) {
              $xeTree.setAllExpandNode(true);
            }
            handleSetCheckboxByNodeId(props.checkNodeKeys || [], true);
          }
        }
        updateHeight();
        refreshScroll();
      });
    };
    const updateScrollYStatus = fullData => {
      const {
        transform
      } = props;
      const virtualYOpts = computeVirtualYOpts.value;
      const allList = fullData || internalData.treeFullData;
      // 如果gt为0，则总是启用
      const scrollYLoad = !!transform && !!virtualYOpts.enabled && virtualYOpts.gt > -1 && (virtualYOpts.gt === 0 || virtualYOpts.gt < allList.length);
      reactData.scrollYLoad = scrollYLoad;
      return scrollYLoad;
    };
    const updateYSpace = () => {
      const {
        scrollYLoad
      } = reactData;
      const {
        scrollYStore,
        afterVisibleList
      } = internalData;
      reactData.bodyHeight = scrollYLoad ? afterVisibleList.length * scrollYStore.rowHeight : 0;
      reactData.topSpaceHeight = scrollYLoad ? Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0) : 0;
    };
    const updateYData = () => {
      handleData();
      updateYSpace();
    };
    const computeScrollLoad = () => {
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
        const {
          scrollYLoad
        } = reactData;
        const {
          scrollYStore
        } = internalData;
        const virtualBodyElem = refVirtualBody.value;
        const virtualYOpts = computeVirtualYOpts.value;
        let rowHeight = 0;
        let firstItemElem;
        if (virtualBodyElem) {
          if (!firstItemElem) {
            firstItemElem = virtualBodyElem.children[0];
          }
        }
        if (firstItemElem) {
          rowHeight = firstItemElem.offsetHeight;
        }
        rowHeight = Math.max(20, rowHeight);
        scrollYStore.rowHeight = rowHeight;
        // 计算 Y 逻辑
        if (scrollYLoad) {
          const scrollBodyElem = refVirtualWrapper.value;
          const visibleYSize = Math.max(8, scrollBodyElem ? Math.ceil(scrollBodyElem.clientHeight / rowHeight) : 0);
          const offsetYSize = Math.max(0, Math.min(2, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(virtualYOpts.oSize)));
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex, visibleYSize + offsetYSize, scrollYStore.endIndex);
          updateYData();
        } else {
          updateYSpace();
        }
      });
    };
    /**
     * 如果有滚动条，则滚动到对应的位置
     */
    const handleScrollTo = (scrollLeft, scrollTop) => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollLeft) {
        if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollLeft)) {
          scrollTop = scrollLeft.top;
          scrollLeft = scrollLeft.left;
        }
      }
      if (scrollBodyElem) {
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollLeft)) {
          scrollBodyElem.scrollLeft = scrollLeft;
        }
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isNumber(scrollTop)) {
          scrollBodyElem.scrollTop = scrollTop;
        }
      }
      if (reactData.scrollYLoad) {
        return new Promise(resolve => {
          setTimeout(() => {
            (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
              resolve();
            });
          }, 50);
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    /**
     * 刷新滚动条
     */
    const refreshScroll = () => {
      const {
        lastScrollLeft,
        lastScrollTop
      } = internalData;
      return clearScroll().then(() => {
        if (lastScrollLeft || lastScrollTop) {
          internalData.lastScrollLeft = 0;
          internalData.lastScrollTop = 0;
          return scrollTo(lastScrollLeft, lastScrollTop);
        }
      });
    };
    /**
     * 重新计算列表
     */
    const recalculate = () => {
      const {
        scrollYStore
      } = internalData;
      const {
        rowHeight
      } = scrollYStore;
      const el = refElem.value;
      if (el && el.clientWidth && el.clientHeight) {
        const parentEl = getParentElem();
        const headerWrapperEl = refHeaderWrapperElem.value;
        const footerWrapperEl = refFooterWrapperElem.value;
        const headHeight = headerWrapperEl ? headerWrapperEl.clientHeight : 0;
        const footHeight = footerWrapperEl ? footerWrapperEl.clientHeight : 0;
        if (parentEl) {
          const parentPaddingSize = getPaddingTopBottomSize(parentEl);
          reactData.parentHeight = Math.max(headHeight + footHeight + rowHeight, parentEl.clientHeight - parentPaddingSize - headHeight - footHeight);
        }
        updateHeight();
        return computeScrollLoad().then(() => {
          updateHeight();
          updateYSpace();
        });
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const loadYData = () => {
      const {
        scrollYStore
      } = internalData;
      const {
        startIndex,
        endIndex,
        visibleSize,
        offsetSize,
        rowHeight
      } = scrollYStore;
      const scrollBodyElem = refVirtualWrapper.value;
      if (!scrollBodyElem) {
        return;
      }
      const scrollTop = scrollBodyElem.scrollTop;
      const toVisibleIndex = Math.floor(scrollTop / rowHeight);
      const offsetStartIndex = Math.max(0, toVisibleIndex - 1 - offsetSize);
      const offsetEndIndex = toVisibleIndex + visibleSize + offsetSize;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          updateYData();
        }
      }
    };
    const scrollEvent = evnt => {
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = scrollBodyElem.scrollLeft;
      const isX = scrollLeft !== internalData.lastScrollLeft;
      const isY = scrollTop !== internalData.lastScrollTop;
      internalData.lastScrollTop = scrollTop;
      internalData.lastScrollLeft = scrollLeft;
      if (reactData.scrollYLoad) {
        loadYData();
      }
      internalData.lastScrollTime = Date.now();
      dispatchEvent('scroll', {
        scrollLeft,
        scrollTop,
        isX,
        isY
      }, evnt);
    };
    const clearScroll = () => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        scrollBodyElem.scrollTop = 0;
        scrollBodyElem.scrollLeft = 0;
      }
      internalData.lastScrollTop = 0;
      internalData.lastScrollLeft = 0;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
    };
    const handleNodeClickEvent = (evnt, node) => {
      const {
        showRadio,
        showCheckbox,
        trigger
      } = props;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const isRowCurrent = computeIsRowCurrent.value;
      let triggerCurrent = false;
      let triggerRadio = false;
      let triggerCheckbox = false;
      let triggerExpand = false;
      if (isRowCurrent) {
        triggerCurrent = true;
        changeCurrentEvent(evnt, node);
      } else if (reactData.currentNode) {
        reactData.currentNode = null;
      }
      if (trigger === 'node') {
        triggerExpand = true;
        toggleExpandEvent(evnt, node);
      }
      if (showRadio && radioOpts.trigger === 'node') {
        triggerRadio = true;
        changeRadioEvent(evnt, node);
      }
      if (showCheckbox && checkboxOpts.trigger === 'node') {
        triggerCheckbox = true;
        changeCheckboxEvent(evnt, node);
      }
      dispatchEvent('node-click', {
        node,
        triggerCurrent,
        triggerRadio,
        triggerCheckbox,
        triggerExpand
      }, evnt);
    };
    const handleNodeDblclickEvent = (evnt, node) => {
      dispatchEvent('node-dblclick', {
        node
      }, evnt);
    };
    const handleAsyncTreeExpandChilds = node => {
      const checkboxOpts = computeCheckboxOpts.value;
      const {
        loadMethod
      } = props;
      const {
        checkStrictly
      } = checkboxOpts;
      return new Promise(resolve => {
        if (loadMethod) {
          const {
            nodeMaps
          } = internalData;
          const nodeid = getNodeId(node);
          const nodeItem = nodeMaps[nodeid];
          internalData.treeExpandLazyLoadedMaps[nodeid] = true;
          Promise.resolve(loadMethod({
            $tree: $xeTree,
            node
          })).then(childRecords => {
            const {
              treeExpandLazyLoadedMaps
            } = internalData;
            nodeItem.treeLoaded = true;
            if (treeExpandLazyLoadedMaps[nodeid]) {
              treeExpandLazyLoadedMaps[nodeid] = false;
            }
            if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(childRecords)) {
              childRecords = [];
            }
            if (childRecords) {
              return $xeTree.loadChildrenNode(node, childRecords).then(childRows => {
                const {
                  treeExpandedMaps
                } = internalData;
                if (childRows.length && !treeExpandedMaps[nodeid]) {
                  treeExpandedMaps[nodeid] = true;
                }
                reactData.updateExpandedFlag++;
                // 如果当前节点已选中，则展开后子节点也被选中
                if (!checkStrictly && $xeTree.isCheckedByCheckboxNodeId(nodeid)) {
                  handleCheckedCheckboxNode(childRows, true);
                }
                dispatchEvent('load-success', {
                  node,
                  data: childRecords
                }, new Event('load-success'));
                return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
              });
            } else {
              dispatchEvent('load-success', {
                node,
                data: childRecords
              }, new Event('load-success'));
            }
          }).catch(e => {
            const {
              treeExpandLazyLoadedMaps
            } = internalData;
            nodeItem.treeLoaded = false;
            if (treeExpandLazyLoadedMaps[nodeid]) {
              treeExpandLazyLoadedMaps[nodeid] = false;
            }
            dispatchEvent('load-error', {
              node,
              data: e
            }, new Event('load-error'));
          }).finally(() => {
            handleTreeToList();
            handleData();
            return recalculate();
          });
        } else {
          resolve();
        }
      });
    };
    /**
     * 展开与收起树节点
     * @param nodeList
     * @param expanded
     * @returns
     */
    const handleBaseTreeExpand = (nodeList, expanded) => {
      const {
        lazy,
        accordion,
        toggleMethod
      } = props;
      const {
        treeExpandLazyLoadedMaps,
        treeExpandedMaps
      } = internalData;
      const {
        nodeMaps
      } = internalData;
      const childrenField = computeChildrenField.value;
      const hasChildField = computeHasChildField.value;
      const result = [];
      let validNodes = toggleMethod ? nodeList.filter(node => toggleMethod({
        $tree: $xeTree,
        expanded,
        node
      })) : nodeList;
      if (accordion) {
        validNodes = validNodes.length ? [validNodes[validNodes.length - 1]] : [];
        // 同一级只能展开一个
        const nodeid = getNodeId(validNodes[0]);
        const nodeItem = nodeMaps[nodeid];
        if (nodeItem) {
          nodeItem.items.forEach(item => {
            const itemNodeId = getNodeId(item);
            if (treeExpandedMaps[itemNodeId]) {
              delete treeExpandedMaps[itemNodeId];
            }
          });
        }
      }
      const expandNodes = [];
      if (expanded) {
        validNodes.forEach(item => {
          const itemNodeId = getNodeId(item);
          if (!treeExpandedMaps[itemNodeId]) {
            const nodeItem = nodeMaps[itemNodeId];
            const isLoad = lazy && item[hasChildField] && !nodeItem.treeLoaded && !treeExpandLazyLoadedMaps[itemNodeId];
            // 是否使用懒加载
            if (isLoad) {
              result.push(handleAsyncTreeExpandChilds(item));
            } else {
              if (item[childrenField] && item[childrenField].length) {
                treeExpandedMaps[itemNodeId] = true;
                expandNodes.push(item);
              }
            }
          }
        });
      } else {
        validNodes.forEach(item => {
          const itemNodeId = getNodeId(item);
          if (treeExpandedMaps[itemNodeId]) {
            delete treeExpandedMaps[itemNodeId];
            expandNodes.push(item);
          }
        });
      }
      reactData.updateExpandedFlag++;
      handleTreeToList();
      handleData();
      return Promise.all(result).then(() => recalculate());
    };
    const toggleExpandEvent = (evnt, node) => {
      const {
        lazy
      } = props;
      const {
        treeExpandedMaps,
        treeExpandLazyLoadedMaps
      } = internalData;
      const nodeid = getNodeId(node);
      const expanded = !treeExpandedMaps[nodeid];
      evnt.stopPropagation();
      if (!lazy || !treeExpandLazyLoadedMaps[nodeid]) {
        handleBaseTreeExpand([node], expanded);
      }
    };
    const updateCheckboxStatus = () => {
      const {
        transform
      } = props;
      const {
        selectCheckboxMaps,
        indeterminateRowMaps,
        afterTreeList
      } = internalData;
      const childrenField = computeChildrenField.value;
      const mapChildrenField = computeMapChildrenField.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const {
        checkStrictly,
        checkMethod
      } = checkboxOpts;
      if (!checkStrictly) {
        const childRowMaps = {};
        const childRowList = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(afterTreeList, node => {
          const nodeid = getNodeId(node);
          const childList = node[childrenField];
          if (childList && childList.length && !childRowMaps[nodeid]) {
            childRowMaps[nodeid] = 1;
            childRowList.unshift([node, nodeid, childList]);
          }
        }, {
          children: transform ? mapChildrenField : childrenField
        });
        childRowList.forEach(vals => {
          const node = vals[0];
          const nodeid = vals[1];
          const childList = vals[2];
          let sLen = 0; // 已选
          let hLen = 0; // 半选
          let vLen = 0; // 有效子行
          const cLen = childList.length; // 子行
          childList.forEach(checkMethod ? item => {
            const childNodeid = getNodeId(item);
            const isSelect = selectCheckboxMaps[childNodeid];
            if (checkMethod({
              $tree: $xeTree,
              node: item
            })) {
              if (isSelect) {
                sLen++;
              } else if (indeterminateRowMaps[childNodeid]) {
                hLen++;
              }
              vLen++;
            } else {
              if (isSelect) {
                sLen++;
              } else if (indeterminateRowMaps[childNodeid]) {
                hLen++;
              }
            }
          } : item => {
            const childNodeid = getNodeId(item);
            const isSelect = selectCheckboxMaps[childNodeid];
            if (isSelect) {
              sLen++;
            } else if (indeterminateRowMaps[childNodeid]) {
              hLen++;
            }
            vLen++;
          });
          let isSelected = false;
          if (cLen > 0) {
            if (vLen > 0) {
              isSelected = (sLen > 0 || hLen > 0) && sLen >= vLen;
            } else {
              // 如果存在子项禁用
              if (sLen > 0 && sLen >= vLen) {
                isSelected = true;
              } else if (selectCheckboxMaps[nodeid]) {
                isSelected = true;
              } else {
                isSelected = false;
              }
            }
          } else {
            // 如果无子项
            isSelected = selectCheckboxMaps[nodeid];
          }
          const halfSelect = !isSelected && (sLen > 0 || hLen > 0);
          if (isSelected) {
            selectCheckboxMaps[nodeid] = node;
            if (indeterminateRowMaps[nodeid]) {
              delete indeterminateRowMaps[nodeid];
            }
          } else {
            if (selectCheckboxMaps[nodeid]) {
              delete selectCheckboxMaps[nodeid];
            }
            if (halfSelect) {
              indeterminateRowMaps[nodeid] = node;
            } else {
              if (indeterminateRowMaps[nodeid]) {
                delete indeterminateRowMaps[nodeid];
              }
            }
          }
        });
        reactData.updateCheckboxFlag++;
      }
    };
    const changeCheckboxEvent = (evnt, node) => {
      evnt.preventDefault();
      evnt.stopPropagation();
      const {
        transform
      } = props;
      const {
        selectCheckboxMaps
      } = internalData;
      const childrenField = computeChildrenField.value;
      const mapChildrenField = computeMapChildrenField.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const {
        checkStrictly,
        checkMethod
      } = checkboxOpts;
      let isDisabled = !!checkMethod;
      if (checkMethod) {
        isDisabled = !checkMethod({
          $tree: $xeTree,
          node
        });
      }
      if (isDisabled) {
        return;
      }
      const nodeid = getNodeId(node);
      let isChecked = false;
      if (selectCheckboxMaps[nodeid]) {
        delete selectCheckboxMaps[nodeid];
      } else {
        isChecked = true;
        selectCheckboxMaps[nodeid] = node;
      }
      if (!checkStrictly) {
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(node, transform ? mapChildrenField : childrenField), childNode => {
          const childNodeid = getNodeId(childNode);
          if (isChecked) {
            if (!selectCheckboxMaps[childNodeid]) {
              selectCheckboxMaps[childNodeid] = true;
            }
          } else {
            if (selectCheckboxMaps[childNodeid]) {
              delete selectCheckboxMaps[childNodeid];
            }
          }
        }, {
          children: transform ? mapChildrenField : childrenField
        });
      }
      reactData.updateCheckboxFlag++;
      updateCheckboxStatus();
      const nodeids = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().keys(selectCheckboxMaps);
      const value = nodeids.map(deNodeValue);
      emitCheckboxMode(value);
      dispatchEvent('checkbox-change', {
        node,
        value,
        checked: isChecked
      }, evnt);
    };
    const changeCurrentEvent = (evnt, node) => {
      evnt.preventDefault();
      const nodeOpts = computeNodeOpts.value;
      const {
        currentMethod,
        trigger
      } = nodeOpts;
      const childrenField = computeChildrenField.value;
      const childList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(node, childrenField);
      const hasChild = childList && childList.length;
      let isDisabled = !!currentMethod;
      if (trigger === 'child') {
        if (hasChild) {
          return;
        }
      } else if (trigger === 'parent') {
        if (!hasChild) {
          return;
        }
      }
      if (currentMethod) {
        isDisabled = !currentMethod({
          node
        });
      }
      if (isDisabled) {
        return;
      }
      const isChecked = true;
      reactData.currentNode = node;
      dispatchEvent('current-change', {
        node,
        checked: isChecked
      }, evnt);
    };
    const changeRadioEvent = (evnt, node) => {
      evnt.preventDefault();
      evnt.stopPropagation();
      const radioOpts = computeRadioOpts.value;
      const {
        checkMethod
      } = radioOpts;
      let isDisabled = !!checkMethod;
      if (checkMethod) {
        isDisabled = !checkMethod({
          $tree: $xeTree,
          node
        });
      }
      if (isDisabled) {
        return;
      }
      const isChecked = true;
      const nodeid = getNodeId(node);
      const value = deNodeValue(nodeid);
      reactData.selectRadioKey = nodeid;
      emitRadioMode(value);
      dispatchEvent('radio-change', {
        node,
        value,
        checked: isChecked
      }, evnt);
    };
    const handleGlobalResizeEvent = () => {
      const el = refElem.value;
      if (!el || !el.clientWidth) {
        return;
      }
      recalculate();
    };
    const treeMethods = {
      dispatchEvent,
      getNodeId,
      getNodeById(nodeid) {
        const {
          nodeMaps
        } = internalData;
        if (nodeid) {
          const nodeItem = nodeMaps[nodeid];
          if (nodeItem) {
            return nodeItem.item;
          }
        }
        return null;
      },
      loadData(data) {
        return loadData(data || []);
      },
      reloadData(data) {
        return loadData(data || []);
      },
      clearCurrentNode() {
        reactData.currentNode = null;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      getCurrentNodeId() {
        const {
          currentNode
        } = reactData;
        if (currentNode) {
          return deNodeValue(getNodeId(currentNode));
        }
        return null;
      },
      getCurrentNode() {
        const {
          currentNode
        } = reactData;
        const {
          nodeMaps
        } = internalData;
        if (currentNode) {
          const nodeItem = nodeMaps[getNodeId(currentNode)];
          if (nodeItem) {
            return nodeItem.item;
          }
        }
        return null;
      },
      setCurrentNodeId(nodeKey) {
        const {
          nodeMaps
        } = internalData;
        const nodeItem = nodeMaps[enNodeValue(nodeKey)];
        reactData.currentNode = nodeItem ? nodeItem.item : null;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      setCurrentNode(node) {
        reactData.currentNode = node;
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      clearRadioNode() {
        reactData.selectRadioKey = null;
        emitRadioMode(null);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      getRadioNodeId() {
        return reactData.selectRadioKey || null;
      },
      getRadioNode() {
        const {
          selectRadioKey
        } = reactData;
        const {
          nodeMaps
        } = internalData;
        if (selectRadioKey) {
          const nodeItem = nodeMaps[selectRadioKey];
          if (nodeItem) {
            return nodeItem.item;
          }
        }
        return null;
      },
      setRadioNodeId(nodeKey) {
        reactData.selectRadioKey = enNodeValue(nodeKey);
        emitRadioMode(nodeKey);
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      setRadioNode(node) {
        if (node) {
          const nodeid = getNodeId(node);
          reactData.selectRadioKey = nodeid;
          emitRadioMode(deNodeValue(nodeid));
        } else {
          emitRadioMode(null);
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      setCheckboxNode(nodeList, checked) {
        if (nodeList) {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(nodeList)) {
            nodeList = [nodeList];
          }
          handleCheckedCheckboxNode(nodeList, checked);
        }
        emitCheckboxMode($xeTree.getCheckboxNodeIds());
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      setCheckboxByNodeId(nodeKeys, selected) {
        handleSetCheckboxByNodeId(nodeKeys, selected);
        emitCheckboxMode($xeTree.getCheckboxNodeIds());
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)();
      },
      getCheckboxNodeIds() {
        const {
          selectCheckboxMaps
        } = internalData;
        const nodeKeys = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(selectCheckboxMaps, (item, nodeId) => {
          nodeKeys.push(deNodeValue(nodeId));
        });
        return nodeKeys;
      },
      getCheckboxNodes() {
        const {
          nodeMaps,
          selectCheckboxMaps
        } = internalData;
        const list = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(selectCheckboxMaps, (item, nodeid) => {
          const nodeItem = nodeMaps[nodeid];
          if (nodeItem) {
            list.push(nodeItem.item);
          }
        });
        return list;
      },
      clearCheckboxNode() {
        internalData.indeterminateRowMaps = {};
        internalData.selectCheckboxMaps = {};
        reactData.updateCheckboxFlag++;
        emitCheckboxMode([]);
        updateCheckboxStatus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
          return {
            checkNodeKeys: [],
            checkNodes: []
          };
        });
      },
      setAllCheckboxNode(checked) {
        const {
          transform
        } = props;
        const selectMaps = {};
        const childrenField = computeChildrenField.value;
        const mapChildrenField = computeMapChildrenField.value;
        const checkKeys = [];
        const checkNodes = [];
        if (checked) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(internalData.afterTreeList, node => {
            const nodeid = getNodeId(node);
            checkKeys.push(nodeid);
            checkNodes.push(node);
            selectMaps[nodeid] = true;
          }, {
            children: transform ? mapChildrenField : childrenField
          });
        }
        internalData.indeterminateRowMaps = {};
        internalData.selectCheckboxMaps = selectMaps;
        reactData.updateCheckboxFlag++;
        updateCheckboxStatus();
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(() => {
          return {
            checkNodeKeys: checkKeys,
            checkNodes
          };
        });
      },
      clearExpandNode() {
        return treeMethods.clearAllExpandNode();
      },
      clearAllExpandNode() {
        const {
          nodeMaps,
          scrollYStore
        } = internalData;
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(nodeMaps, nodeItem => {
          nodeItem.treeLoaded = false;
        });
        internalData.treeExpandedMaps = {};
        reactData.updateExpandedFlag++;
        reactData.topSpaceHeight = 0;
        scrollYStore.startIndex = 0;
        scrollYStore.endIndex = 1;
        handleTreeToList();
        handleData();
        return recalculate();
      },
      setExpandByNodeId(nodeKeys, expanded) {
        const {
          treeExpandedMaps
        } = internalData;
        if (nodeKeys) {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(nodeKeys)) {
            nodeKeys = [nodeKeys];
          }
          nodeKeys.forEach(nodeKey => {
            const nodeid = enNodeValue(nodeKey);
            handleSetExpand(nodeid, expanded, treeExpandedMaps);
          });
          reactData.updateExpandedFlag++;
        }
        handleTreeToList();
        handleData();
        return recalculate();
      },
      getExpandNodeIds() {
        const {
          treeExpandedMaps
        } = internalData;
        const nodeKeys = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(treeExpandedMaps, (item, nodeId) => {
          nodeKeys.push(deNodeValue(nodeId));
        });
        return nodeKeys;
      },
      getExpandNodes() {
        const {
          nodeMaps,
          treeExpandedMaps
        } = internalData;
        const list = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(treeExpandedMaps, (item, nodeid) => {
          const nodeItem = nodeMaps[nodeid];
          if (nodeItem) {
            list.push(nodeItem.item);
          }
        });
        return list;
      },
      setExpandNode(nodes, expanded) {
        const {
          treeExpandedMaps
        } = internalData;
        if (nodes) {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(nodes)) {
            nodes = [nodes];
          }
          nodes.forEach(node => {
            const nodeid = getNodeId(node);
            handleSetExpand(nodeid, expanded, treeExpandedMaps);
          });
          reactData.updateExpandedFlag++;
        }
        handleTreeToList();
        handleData();
        return recalculate();
      },
      toggleExpandByNodeId(nodeKeys) {
        const {
          treeExpandedMaps
        } = internalData;
        if (nodeKeys) {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(nodeKeys)) {
            nodeKeys = [nodeKeys];
          }
          nodeKeys.forEach(nodeKey => {
            const nodeid = enNodeValue(nodeKey);
            handleSetExpand(nodeid, !treeExpandedMaps[`${nodeid}`], treeExpandedMaps);
          });
          reactData.updateExpandedFlag++;
        }
        handleTreeToList();
        handleData();
        return recalculate();
      },
      toggleExpandNode(nodes) {
        const {
          treeExpandedMaps
        } = internalData;
        if (nodes) {
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(nodes)) {
            nodes = [nodes];
          }
          nodes.forEach(node => {
            const nodeid = getNodeId(node);
            handleSetExpand(nodeid, !treeExpandedMaps[nodeid], treeExpandedMaps);
          });
          reactData.updateExpandedFlag++;
        }
        handleTreeToList();
        handleData();
        return recalculate();
      },
      setAllExpandNode(expanded) {
        const {
          transform
        } = props;
        const {
          scrollYLoad
        } = reactData;
        const {
          scrollYStore,
          treeExpandedMaps
        } = internalData;
        const childrenField = computeChildrenField.value;
        const mapChildrenField = computeMapChildrenField.value;
        if (expanded) {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(internalData.afterTreeList, node => {
            const childList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(node, childrenField);
            const hasChild = childList && childList.length;
            if (hasChild) {
              const nodeid = getNodeId(node);
              treeExpandedMaps[nodeid] = true;
            }
          }, {
            children: transform ? mapChildrenField : childrenField
          });
        } else {
          internalData.treeExpandedMaps = {};
        }
        reactData.updateExpandedFlag++;
        reactData.topSpaceHeight = 0;
        scrollYStore.startIndex = 0;
        scrollYStore.endIndex = 1;
        handleTreeToList();
        handleData();
        return recalculate().then(() => {
          if (scrollYLoad) {
            loadYData();
          }
          return recalculate();
        });
      },
      reloadExpandNode(node) {
        const {
          lazy
        } = props;
        if (lazy) {
          treeMethods.clearExpandLoaded(node);
          return handleAsyncTreeExpandChilds(node);
        }
        return recalculate();
      },
      clearExpandLoaded(node) {
        const {
          lazy
        } = props;
        const {
          nodeMaps
        } = internalData;
        if (lazy) {
          const nodeItem = nodeMaps[getNodeId(node)];
          if (nodeItem) {
            nodeItem.treeLoaded = false;
          }
        }
        return recalculate();
      },
      /**
       * 用于树结构，给行数据加载子节点
       */
      loadChildrenNode(node, childRecords) {
        const {
          lazy,
          transform
        } = props;
        const {
          nodeMaps
        } = internalData;
        if (!lazy) {
          return Promise.resolve([]);
        }
        const childrenField = computeChildrenField.value;
        const mapChildrenField = computeMapChildrenField.value;
        const parentNodeItem = nodeMaps[getNodeId(node)];
        const parentLevel = parentNodeItem ? parentNodeItem.level : 0;
        const parentNodes = parentNodeItem ? parentNodeItem.nodes : [];
        return createNode(childRecords).then(nodeList => {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(nodeList, (childRow, index, items, path, parent, nodes) => {
            const itemNodeId = getNodeId(childRow);
            nodeMaps[itemNodeId] = {
              item: node,
              index: -1,
              items,
              parent: parent || parentNodeItem.item,
              nodes: parentNodes.concat(nodes),
              level: parentLevel + nodes.length,
              treeIndex: -1,
              lineCount: 0,
              treeLoaded: false
            };
          }, {
            children: childrenField
          });
          node[childrenField] = nodeList;
          if (transform) {
            node[mapChildrenField] = nodeList;
          }
          updateAfterDataIndex();
          return nodeList;
        });
      },
      isExpandByNode,
      isCheckedByRadioNodeId,
      isCheckedByRadioNode,
      isCheckedByCheckboxNodeId,
      isIndeterminateByCheckboxNode,
      isCheckedByCheckboxNode,
      getCheckboxIndeterminateNodes() {
        const {
          nodeMaps,
          indeterminateRowMaps
        } = internalData;
        const list = [];
        external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().each(indeterminateRowMaps, (item, nodeid) => {
          const nodeItem = nodeMaps[nodeid];
          if (nodeItem) {
            list.push(nodeItem.item);
          }
        });
        return list;
      },
      recalculate,
      scrollTo: handleScrollTo,
      scrollToNode(node) {
        return $xeTree.scrollToNodeId(getNodeId(node));
      },
      scrollToNodeId(nodeid) {
        const {
          transform
        } = props;
        const {
          scrollYStore,
          afterTreeList
        } = internalData;
        const childrenField = computeChildrenField.value;
        const mapChildrenField = computeMapChildrenField.value;
        const scrollBodyElem = refVirtualWrapper.value;
        if (nodeid && scrollBodyElem) {
          if (transform) {
            const matchObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findTree(afterTreeList, item => getNodeId(item) === nodeid, {
              children: transform ? mapChildrenField : childrenField
            });
            if (matchObj) {
              return $xeTree.setExpandNode(matchObj.nodes, true).then(() => {
                const itemIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(internalData.afterVisibleList, item => getNodeId(item) === nodeid);
                if (itemIndex > -1) {
                  const targetTop = Math.max(0, (itemIndex - 1) * scrollYStore.rowHeight);
                  return handleScrollTo(scrollBodyElem.scrollLeft, targetTop);
                }
              });
            }
          } else {
            const itemEl = scrollBodyElem.querySelector(`.vxe-tree--node-wrapper[nodeid="${nodeid}"]`);
            if (itemEl) {
              return handleScrollTo(scrollBodyElem.scrollLeft, itemEl.offsetTop);
            }
          }
        }
        return recalculate();
      },
      clearScroll
    };
    const treePrivateMethods = {};
    Object.assign($xeTree, treeMethods, treePrivateMethods);
    const renderRadio = (node, nodeid, isChecked) => {
      const {
        showRadio
      } = props;
      const radioOpts = computeRadioOpts.value;
      const {
        showIcon,
        checkMethod,
        visibleMethod
      } = radioOpts;
      const isVisible = !visibleMethod || visibleMethod({
        $tree: $xeTree,
        node
      });
      let isDisabled = !!checkMethod;
      if (showRadio && showIcon && isVisible) {
        if (checkMethod) {
          isDisabled = !checkMethod({
            $tree: $xeTree,
            node
          });
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-tree--radio-option', {
            'is--checked': isChecked,
            'is--disabled': isDisabled
          }],
          onClick: evnt => {
            if (!isDisabled) {
              changeRadioEvent(evnt, node);
            }
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-radio--icon', isChecked ? getIcon().RADIO_CHECKED : getIcon().RADIO_UNCHECKED]
        })]);
      }
      return renderEmptyElement($xeTree);
    };
    const renderCheckbox = (node, nodeid, isChecked) => {
      const {
        showCheckbox
      } = props;
      const checkboxOpts = computeCheckboxOpts.value;
      const {
        showIcon,
        checkMethod,
        visibleMethod
      } = checkboxOpts;
      const isIndeterminate = isIndeterminateByCheckboxNodeid(nodeid);
      const isVisible = !visibleMethod || visibleMethod({
        $tree: $xeTree,
        node
      });
      let isDisabled = !!checkMethod;
      if (showCheckbox && showIcon && isVisible) {
        if (checkMethod) {
          isDisabled = !checkMethod({
            $tree: $xeTree,
            node
          });
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: ['vxe-tree--checkbox-option', {
            'is--checked': isChecked,
            'is--indeterminate': isIndeterminate,
            'is--disabled': isDisabled
          }],
          onClick: evnt => {
            if (!isDisabled) {
              changeCheckboxEvent(evnt, node);
            }
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: ['vxe-checkbox--icon', isIndeterminate ? getIcon().CHECKBOX_INDETERMINATE : isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
        })]);
      }
      return renderEmptyElement($xeTree);
    };
    const renderNode = (node, nodeid) => {
      const {
        lazy,
        showRadio,
        showCheckbox,
        showLine,
        indent,
        iconOpen,
        iconClose,
        iconLoaded,
        showIcon
      } = props;
      const {
        currentNode,
        selectRadioKey,
        updateExpandedFlag
      } = reactData;
      const {
        afterTreeList,
        nodeMaps,
        treeExpandedMaps,
        treeExpandLazyLoadedMaps
      } = internalData;
      const childrenField = computeChildrenField.value;
      const titleField = computeTitleField.value;
      const hasChildField = computeHasChildField.value;
      const childList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(node, childrenField);
      const hasChild = childList && childList.length;
      const iconSlot = slots.icon;
      const titleSlot = slots.title;
      const extraSlot = slots.extra;
      const isExpand = updateExpandedFlag && treeExpandedMaps[nodeid];
      const nodeItem = nodeMaps[nodeid];
      const nodeValue = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(node, titleField);
      const nLevel = nodeItem.level;
      let isRadioChecked = false;
      if (showRadio) {
        isRadioChecked = nodeid === String(selectRadioKey);
      }
      let isCheckboxChecked = false;
      if (showCheckbox) {
        isCheckboxChecked = isCheckedByCheckboxNodeId(nodeid);
      }
      let hasLazyChilds = false;
      let isLazyLoading = false;
      let isLazyLoaded = false;
      if (lazy) {
        isLazyLoading = !!treeExpandLazyLoadedMaps[nodeid];
        hasLazyChilds = node[hasChildField];
        isLazyLoaded = !!nodeItem.treeLoaded;
      }
      const prevNode = nodeItem.items[nodeItem.treeIndex - 1];
      const nParams = {
        node,
        isExpand
      };
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: nodeid,
        class: ['vxe-tree--node-wrapper', `node--level-${nLevel}`],
        nodeid
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-tree--node-item', {
          'is--current': currentNode && nodeid === getNodeId(currentNode),
          'is-radio--checked': isRadioChecked,
          'is-checkbox--checked': isCheckboxChecked
        }],
        style: {
          paddingLeft: `${(nLevel - 1) * (indent || 1)}px`
        },
        onClick(evnt) {
          handleNodeClickEvent(evnt, node);
        },
        onDblclick(evnt) {
          handleNodeDblclickEvent(evnt, node);
        }
      }, [showLine ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--node-line-wrapper'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--node-line',
        style: {
          height: `${getNodeId(afterTreeList[0]) === nodeid ? 1 : calcTreeLine($xeTree, node, prevNode)}px`
        }
      })]) : renderEmptyElement($xeTree), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--node-item-switcher'
      }, showIcon && (lazy ? isLazyLoaded ? hasChild : hasLazyChilds : hasChild) ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--node-item-icon',
        onClick(evnt) {
          toggleExpandEvent(evnt, node);
        }
      }, iconSlot ? vn_getSlotVNs(iconSlot(nParams)) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: isLazyLoading ? iconLoaded || getIcon().TREE_NODE_LOADED : isExpand ? iconOpen || getIcon().TREE_NODE_OPEN : iconClose || getIcon().TREE_NODE_CLOSE
      })])] : []), renderRadio(node, nodeid, isRadioChecked), renderCheckbox(node, nodeid, isCheckboxChecked), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--node-item-inner'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--node-item-title'
      }, titleSlot ? vn_getSlotVNs(titleSlot(nParams)) : `${nodeValue}`), extraSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--node-item-extra'
      }, vn_getSlotVNs(extraSlot(nParams))) : renderEmptyElement($xeTree)])])]);
    };
    const renderList = treeList => {
      const {
        transform
      } = props;
      const {
        treeExpandedMaps
      } = internalData;
      const childrenField = computeChildrenField.value;
      if (!treeList.length) {
        return [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-tree--empty-placeholder'
        }, getI18n('vxe.tree.searchEmpty'))];
      }
      const nodeVNs = [];
      treeList.forEach(transform ? node => {
        const nodeid = getNodeId(node);
        nodeVNs.push(renderNode(node, nodeid));
      } : node => {
        const nodeid = getNodeId(node);
        nodeVNs.push(renderNode(node, nodeid));
        const childList = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().get(node, childrenField);
        const hasChild = childList && childList.length;
        if (hasChild && treeExpandedMaps[nodeid]) {
          nodeVNs.push(...renderList(childList));
        }
      });
      return nodeVNs;
    };
    const renderVN = () => {
      const {
        loading,
        trigger,
        showLine
      } = props;
      const {
        bodyHeight,
        topSpaceHeight,
        treeList
      } = reactData;
      const vSize = computeSize.value;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const loadingOpts = computeLoadingOpts.value;
      const isRowHover = computeIsRowHover.value;
      const treeStyle = computeTreeStyle.value;
      const loadingSlot = slots.loading;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-tree', {
          [`size--${vSize}`]: vSize,
          'show--line': showLine,
          'checkbox--highlight': checkboxOpts.highlight,
          'radio--highlight': radioOpts.highlight,
          'node--hover': isRowHover,
          'node--trigger': trigger === 'node',
          'is--loading': loading
        }]
      }, [headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refHeaderWrapperElem,
        class: 'vxe-tree--header-wrapper'
      }, headerSlot({
        $tree: $xeTree
      })) : renderEmptyElement($xeTree), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refVirtualWrapper,
        class: 'vxe-tree--node-list-wrapper',
        style: treeStyle,
        onScroll: scrollEvent
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree--y-space',
        style: {
          height: bodyHeight ? `${bodyHeight}px` : ''
        }
      }), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refVirtualBody,
        class: 'vxe-tree--node-list-body',
        style: {
          transform: `translateY(${topSpaceHeight}px)`
        }
      }, renderList(treeList))]), footerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refFooterWrapperElem,
        class: 'vxe-tree--footer-wrapper'
      }, footerSlot({
        $tree: $xeTree
      })) : renderEmptyElement($xeTree),
      /**
       * 加载中
       */
      (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_loading, {
        class: 'vxe-tree--loading',
        modelValue: loading,
        icon: loadingOpts.icon,
        text: loadingOpts.text
      }, loadingSlot ? {
        default: () => loadingSlot({
          $tree: $xeTree
        })
      } : {})]);
    };
    const dataFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.data ? props.data.length : 0, () => {
      dataFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.data, () => {
      dataFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(dataFlag, () => {
      loadData(props.data || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.checkNodeKey, nodeKey => {
      reactData.selectRadioKey = enNodeValue(nodeKey);
    });
    const checkboxFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.checkNodeKeys ? props.checkNodeKeys.length : 0, () => {
      checkboxFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.checkNodeKeys, () => {
      checkboxFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(checkboxFlag, () => {
      updateCheckboxChecked(props.checkNodeKeys || []);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.filterValue, () => {
      triggerSearchEvent(new Event('filter'));
    });
    const hFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.height, () => {
      hFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.minHeight, () => {
      hFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.maxHeight, () => {
      hFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(hFlag, () => {
      recalculate();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      if (props.autoResize) {
        const el = refElem.value;
        const parentEl = getParentElem();
        const resizeObserver = globalResize.create(() => {
          if (props.autoResize) {
            recalculate();
          }
        });
        if (el) {
          resizeObserver.observe(el);
        }
        if (parentEl) {
          resizeObserver.observe(parentEl);
        }
        internalData.resizeObserver = resizeObserver;
      }
      globalEvents.on($xeTree, 'resize', handleGlobalResizeEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      const {
        resizeObserver
      } = internalData;
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      globalEvents.off($xeTree, 'resize');
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign(internalData, tree_createInternalData());
    });
    loadData(props.data || []);
    $xeTree.renderVN = renderVN;
    return $xeTree;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/tree/index.ts



const VxeTree = Object.assign({}, tree, {
  install(app) {
    app.component(tree.name, tree);
  }
});
dynamicApp.use(VxeTree);
index_esm_VxeUI.component(tree);
const Tree = VxeTree;
/* harmony default export */ var packages_tree = (VxeTree);
;// CONCATENATED MODULE: ./packages/tree-select/src/tree-select.ts











function tree_select_getOptUniqueId() {
  return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId('node_');
}
function tree_select_createInternalData() {
  return {
    // hpTimeout: undefined,
    fullOptionList: [],
    fullNodeMaps: {}
  };
}
/* harmony default export */ var tree_select = (defineVxeComponent({
  name: 'VxeTreeSelect',
  props: {
    modelValue: [String, Number, Array],
    clearable: Boolean,
    placeholder: {
      type: String,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(getConfig().treeSelect.placeholder) ? getI18n('vxe.base.pleaseSelect') : getConfig().treeSelect.placeholder
    },
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    filterable: Boolean,
    filterConfig: Object,
    multiple: Boolean,
    className: [String, Function],
    popupClassName: [String, Function],
    prefixIcon: String,
    placement: String,
    options: Array,
    optionProps: Object,
    size: {
      type: String,
      default: () => getConfig().treeSelect.size || getConfig().size
    },
    remote: Boolean,
    remoteConfig: Function,
    popupConfig: Object,
    treeConfig: Object,
    virtualYConfig: Object,
    autoClose: {
      type: Boolean,
      default: () => getConfig().treeSelect.autoClose
    },
    showTotalButoon: {
      type: Boolean,
      default: () => getConfig().treeSelect.showTotalButoon
    },
    showCheckedButoon: {
      type: Boolean,
      default: () => getConfig().treeSelect.showCheckedButoon
    },
    showClearButton: {
      type: Boolean,
      default: () => getConfig().treeSelect.showClearButton
    },
    showExpandButton: {
      type: Boolean,
      default: () => getConfig().treeSelect.showExpandButton
    },
    transfer: {
      type: Boolean,
      default: null
    },
    /**
     * 已废弃，被 remote-config.queryMethod 替换
     * @deprecated
     */
    remoteMethod: Function
  },
  emits: ['update:modelValue', 'change', 'all-change', 'clear', 'blur', 'focus', 'click', 'node-click'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const $xeModal = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeModal', null);
    const $xeDrawer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeDrawer', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInput = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refInpSearch = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTreeWrapper = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refOptionPanel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refTree = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      initialized: false,
      searchValue: '',
      searchLoading: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = tree_select_createInternalData();
    const refMaps = {
      refElem
    };
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        transfer
      } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().select.transfer;
        if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computePopupOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().treeSelect.popupConfig, props.popupConfig);
    });
    const computeTreeOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().treeSelect.treeConfig, props.treeConfig, {
        data: undefined
      });
    });
    const computeTreeNodeOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({
        isHover: true
      }, treeOpts.nodeConfig);
    });
    const computeTreeCheckboxOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({
        showIcon: !!treeOpts.showCheckbox
      }, treeOpts.checkboxConfig, {
        trigger: 'node'
      });
    });
    const computeTreeRadioOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({
        showIcon: !!treeOpts.showRadio
      }, treeOpts.radioConfig, {
        trigger: 'node'
      });
    });
    const computePropsOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.optionProps || {};
    });
    const computeNodeKeyField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const treeOpts = computeTreeOpts.value;
      return treeOpts.keyField || 'id';
    });
    const computeLabelField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || 'label';
    });
    const computeValueField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || 'value';
    });
    const computeChildrenField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.children || 'children';
    });
    const computeParentField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.parent || 'parentField';
    });
    const computeHasChildField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.hasChild || 'hasChild';
    });
    const computeVirtualYOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().treeSelect.virtualYConfig, props.virtualYConfig);
    });
    const computeRemoteOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, getConfig().treeSelect.remoteConfig, props.remoteConfig);
    });
    const computeFilterOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({}, treeOpts.filterConfig, props.filterConfig);
    });
    const computeSelectLabel = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        modelValue
      } = props;
      const {
        fullNodeMaps
      } = internalData;
      const labelField = computeLabelField.value;
      const selectVals = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(modelValue) ? [] : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue : [modelValue];
      return selectVals.map(val => {
        const cacheItem = fullNodeMaps[val];
        return cacheItem ? cacheItem.item[labelField] : val;
      }).join(', ');
    });
    const computePopupWrapperStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const popupOpts = computePopupOpts.value;
      const {
        height,
        width
      } = popupOpts;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
        stys.maxHeight = toCssUnit(height);
      }
      return stys;
    });
    const computeMaps = {};
    const $xeTreeSelect = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $treeSelect: $xeTreeSelect
      }, params));
    };
    const emitModel = value => {
      emit('update:modelValue', value);
    };
    const treeSelectMethods = {
      dispatchEvent
    };
    const getNodeid = option => {
      const nodeKeyField = computeNodeKeyField.value;
      const nodeid = option[nodeKeyField];
      return nodeid ? encodeURIComponent(nodeid) : '';
    };
    const cacheDataMap = () => {
      const {
        options
      } = props;
      const treeOpts = computeTreeOpts.value;
      const nodeKeyField = computeNodeKeyField.value;
      const childrenField = computeChildrenField.value;
      const valueField = computeValueField.value;
      const {
        transform
      } = treeOpts;
      const nodeMaps = {};
      const keyMaps = {};
      const handleOptNode = (item, index, items, path, parent, nodes) => {
        let nodeid = getNodeid(item);
        if (!nodeid) {
          nodeid = tree_select_getOptUniqueId();
        }
        if (keyMaps[nodeid]) {
          errLog('vxe.error.repeatKey', [nodeKeyField, nodeid]);
        }
        keyMaps[nodeid] = true;
        const value = item[valueField];
        if (nodeMaps[value]) {
          errLog('vxe.error.repeatKey', [valueField, value]);
        }
        nodeMaps[value] = {
          item,
          index,
          items,
          parent,
          nodes
        };
      };
      if (options) {
        if (transform) {
          options.forEach((item, index, items) => {
            handleOptNode(item, index, items, [], null, []);
          });
        } else {
          external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eachTree(options, handleOptNode, {
            children: childrenField
          });
        }
      }
      internalData.fullOptionList = options || [];
      internalData.fullNodeMaps = nodeMaps;
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex()) {
        reactData.panelIndex = nextZIndex();
      }
    };
    const updatePlacement = () => {
      const {
        placement
      } = props;
      const {
        panelIndex
      } = reactData;
      const targetElem = refElem.value;
      const panelElem = refOptionPanel.value;
      const btnTransfer = computeBtnTransfer.value;
      const handleStyle = () => {
        const ppObj = updatePanelPlacement(targetElem, panelElem, {
          placement,
          teleportTo: btnTransfer
        });
        const panelStyle = Object.assign(ppObj.style, {
          zIndex: panelIndex
        });
        reactData.panelStyle = panelStyle;
        reactData.panelPlacement = ppObj.placement;
      };
      handleStyle();
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)().then(handleStyle);
    };
    const showOptionPanel = () => {
      const {
        loading,
        remote,
        filterable
      } = props;
      const {
        fullOptionList
      } = internalData;
      const isDisabled = computeIsDisabled.value;
      const remoteOpts = computeRemoteOpts.value;
      if (!loading && !isDisabled) {
        clearTimeout(internalData.hpTimeout);
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (filterable) {
          if (remote && remoteOpts.enabled && remoteOpts.autoLoad && !fullOptionList.length) {
            handleSearchEvent();
          }
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
          handleFocusSearch();
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      internalData.hpTimeout = setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue, node) => {
      const value = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(selectValue) ? selectValue.map(deNodeValue) : deNodeValue(selectValue);
      emitModel(value);
      if (value !== props.modelValue) {
        dispatchEvent('change', {
          value,
          node,
          option: node
        }, evnt);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue, null);
      dispatchEvent('clear', {
        value: selectValue
      }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const allCheckedPanelEvent = params => {
      const {
        $event
      } = params;
      const {
        multiple,
        autoClose
      } = props;
      const $tree = refTree.value;
      if (multiple) {
        if ($tree) {
          $tree.setAllCheckboxNode(true).then(({
            checkNodeKeys,
            checkNodes
          }) => {
            changeEvent($event, checkNodeKeys, checkNodes[0]);
            dispatchEvent('all-change', {
              value: checkNodeKeys
            }, $event);
            if (autoClose) {
              hideOptionPanel();
            }
          });
        }
      }
    };
    const clearCheckedPanelEvent = params => {
      const {
        $event
      } = params;
      const {
        multiple,
        autoClose
      } = props;
      const $tree = refTree.value;
      if ($tree) {
        const value = multiple ? [] : null;
        $tree.clearCheckboxNode().then(() => {
          if (autoClose) {
            hideOptionPanel();
          }
        });
        changeEvent($event, value, null);
        dispatchEvent('clear', {
          value
        }, $event);
      }
    };
    const allExpandPanelEvent = () => {
      const $tree = refTree.value;
      if ($tree) {
        $tree.setAllExpandNode(true);
      }
    };
    const clearExpandPanelEvent = () => {
      const $tree = refTree.value;
      if ($tree) {
        $tree.clearAllExpandNode();
      }
    };
    const handleGlobalMousewheelEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const {
        visiblePanel
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode(evnt, el).flag || getEventTargetNode(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const {
        visiblePanel,
        isActivated
      } = reactData;
      if (visiblePanel) {
        hideOptionPanel();
      }
      if (isActivated) {
        reactData.isActivated = false;
      }
      if (visiblePanel || isActivated) {
        const $input = refInput.value;
        if ($input) {
          $input.blur();
        }
      }
    };
    const handleGlobalResizeEvent = () => {
      const {
        visiblePanel
      } = reactData;
      if (visiblePanel) {
        updatePlacement();
      }
    };
    const handleFocusSearch = () => {
      if (props.filterable) {
        (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)(() => {
          const inpSearch = refInpSearch.value;
          if (inpSearch) {
            inpSearch.focus();
          }
        });
      }
    };
    const focusEvent = evnt => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          reactData.triggerFocusPanel = true;
          showOptionPanel();
          setTimeout(() => {
            reactData.triggerFocusPanel = false;
          }, 150);
        }
      }
      dispatchEvent('focus', {}, evnt);
    };
    const clickEvent = evnt => {
      togglePanelEvent(evnt);
      dispatchEvent('click', {}, evnt);
    };
    const blurEvent = evnt => {
      reactData.isActivated = false;
      dispatchEvent('blur', {}, evnt);
    };
    const modelSearchEvent = value => {
      reactData.searchValue = value;
    };
    const handleSearchEvent = () => {
      const {
        modelValue,
        remote,
        remoteMethod
      } = props;
      const {
        searchValue
      } = reactData;
      const remoteOpts = computeRemoteOpts.value;
      const queryMethod = remoteOpts.queryMethod || remoteMethod;
      if (remote && queryMethod && remoteOpts.enabled) {
        reactData.searchLoading = true;
        Promise.resolve(queryMethod({
          $treeSelect: $xeTreeSelect,
          searchValue,
          value: modelValue
        })).then(() => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)()).catch(() => (0,external_commonjs_vue_commonjs2_vue_root_Vue_.nextTick)()).finally(() => {
          reactData.searchLoading = false;
        });
      }
    };
    const togglePanelEvent = params => {
      const {
        $event
      } = params;
      $event.preventDefault();
      if (reactData.triggerFocusPanel) {
        reactData.triggerFocusPanel = false;
      } else {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
      }
    };
    const nodeClickEvent = params => {
      const {
        $event
      } = params;
      dispatchEvent('node-click', params, $event);
    };
    const radioChangeEvent = params => {
      const {
        value,
        $event,
        node
      } = params;
      changeEvent($event, value, node);
      hideOptionPanel();
    };
    const checkboxChangeEvent = params => {
      const {
        value,
        $event,
        node
      } = params;
      changeEvent($event, value, node);
    };
    const loadSuccessEvent = () => {
      cacheDataMap();
    };
    const treeSelectPrivateMethods = {};
    Object.assign($xeTreeSelect, treeSelectMethods, treeSelectPrivateMethods);
    const renderVN = () => {
      const {
        className,
        modelValue,
        multiple,
        options,
        loading,
        filterable,
        showTotalButoon,
        showCheckedButoon,
        showClearButton,
        showExpandButton
      } = props;
      const {
        initialized,
        isActivated,
        isAniVisible,
        visiblePanel,
        searchValue
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const selectLabel = computeSelectLabel.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const popupWrapperStyle = computePopupWrapperStyle.value;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      const popupOpts = computePopupOpts.value;
      const popupClassName = popupOpts.className || props.popupClassName;
      const treeOpts = computeTreeOpts.value;
      const treeNodeOpts = computeTreeNodeOpts.value;
      const treeCheckboxOpts = computeTreeCheckboxOpts.value;
      const treeRadioOpts = computeTreeRadioOpts.value;
      const nodeKeyField = computeNodeKeyField.value;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const childrenField = computeChildrenField.value;
      const parentField = computeParentField.value;
      const hasChildField = computeHasChildField.value;
      const virtualYOpts = computeVirtualYOpts.value;
      const filterOpts = computeFilterOpts.value;
      if (formReadonly) {
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          ref: refElem,
          class: ['vxe-tree-select--readonly', className]
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('span', {
          class: 'vxe-tree-select-label'
        }, selectLabel)]);
      }
      const selectVals = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().eqNull(modelValue) ? [] : external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue : [modelValue];
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-tree-select', className ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(className) ? className({
          $treeSelect: $xeTreeSelect
        }) : className : '', {
          [`size--${vSize}`]: vSize,
          'is--filterable': filterable,
          'is--visible': visiblePanel,
          'is--disabled': isDisabled,
          'is--loading': loading,
          'is--active': isActivated
        }]
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
        ref: refInput,
        clearable: props.clearable,
        placeholder: loading ? getI18n('vxe.select.loadingText') : props.placeholder,
        readonly: true,
        disabled: isDisabled,
        type: 'text',
        prefixIcon: props.prefixIcon,
        suffixIcon: loading ? getIcon().TREE_SELECT_LOADED : visiblePanel ? getIcon().TREE_SELECT_OPEN : getIcon().TREE_SELECT_CLOSE,
        modelValue: loading ? '' : selectLabel,
        title: selectLabel,
        onClear: clearEvent,
        onClick: clickEvent,
        onFocus: focusEvent,
        onBlur: blurEvent,
        onSuffixClick: togglePanelEvent
      }, prefixSlot ? {
        prefix: () => prefixSlot({})
      } : {}), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.Teleport, {
        to: 'body',
        disabled: btnTransfer ? !initialized : true
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refOptionPanel,
        class: ['vxe-table--ignore-clear vxe-tree-select--panel', popupClassName ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(popupClassName) ? popupClassName({
          $treeSelect: $xeTreeSelect
        }) : popupClassName : '', {
          [`size--${vSize}`]: vSize,
          'is--transfer': btnTransfer,
          'ani--leave': !loading && isAniVisible,
          'ani--enter': !loading && visiblePanel
        }],
        placement: reactData.panelPlacement,
        style: reactData.panelStyle
      }, initialized ? [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree-select--panel-wrapper'
      }, [filterable ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree-select--panel-search'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(input, {
        ref: refInpSearch,
        class: 'vxe-tree-select-search--input',
        modelValue: searchValue,
        clearable: true,
        disabled: false,
        readonly: false,
        placeholder: getI18n('vxe.treeSelect.search'),
        prefixIcon: getIcon().INPUT_SEARCH,
        'onUpdate:modelValue': modelSearchEvent
      })]) : renderEmptyElement($xeTreeSelect), showTotalButoon || showCheckedButoon && multiple || showClearButton || showExpandButton || headerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree-select--panel-header'
      }, headerSlot ? headerSlot({}) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree-select--header-button'
      }, [showTotalButoon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree-select--header-total'
      }, getI18n('vxe.treeSelect.total', [selectVals.length])) : renderEmptyElement($xeTreeSelect), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree-select--header-btns'
      }, [showCheckedButoon && multiple ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        content: getI18n('vxe.treeSelect.allChecked'),
        mode: 'text',
        onClick: allCheckedPanelEvent
      }) : renderEmptyElement($xeTreeSelect), showClearButton ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        content: getI18n('vxe.treeSelect.clearChecked'),
        mode: 'text',
        onClick: clearCheckedPanelEvent
      }) : renderEmptyElement($xeTreeSelect), showExpandButton ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        content: getI18n('vxe.treeSelect.allExpand'),
        mode: 'text',
        onClick: allExpandPanelEvent
      }) : renderEmptyElement($xeTreeSelect), showExpandButton ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        content: getI18n('vxe.treeSelect.clearExpand'),
        mode: 'text',
        onClick: clearExpandPanelEvent
      }) : renderEmptyElement($xeTreeSelect)])])]) : renderEmptyElement($xeTreeSelect), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree-select--panel-body'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refTreeWrapper,
        class: 'vxe-tree-select-tree--wrapper',
        style: popupWrapperStyle
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(tree, {
        ref: refTree,
        class: 'vxe-tree-select--tree',
        height: popupOpts.height ? '100%' : treeOpts.height,
        minHeight: treeOpts.minHeight,
        maxHeight: popupOpts.height ? '' : treeOpts.maxHeight,
        autoResize: true,
        data: options,
        indent: treeOpts.indent,
        showRadio: !multiple,
        radioConfig: treeRadioOpts,
        checkNodeKey: multiple ? null : modelValue,
        showCheckbox: !!multiple,
        checkNodeKeys: multiple ? modelValue : null,
        checkboxConfig: treeCheckboxOpts,
        titleField: labelField,
        valueField: valueField,
        keyField: nodeKeyField,
        childrenField: treeOpts.childrenField || childrenField,
        parentField: treeOpts.parentField || parentField,
        hasChildField: treeOpts.hasChildField || hasChildField,
        accordion: treeOpts.accordion,
        expandAll: treeOpts.expandAll,
        nodeConfig: treeNodeOpts,
        lazy: treeOpts.lazy,
        loadMethod: treeOpts.loadMethod,
        toggleMethod: treeOpts.toggleMethod,
        transform: treeOpts.transform,
        trigger: treeOpts.trigger,
        showIcon: treeOpts.showIcon,
        showLine: treeOpts.showLine,
        iconOpen: treeOpts.iconOpen,
        iconLoaded: treeOpts.iconLoaded,
        iconClose: treeOpts.iconClose,
        filterValue: searchValue,
        filterConfig: filterOpts,
        virtualYConfig: virtualYOpts,
        onNodeClick: nodeClickEvent,
        onRadioChange: radioChangeEvent,
        onCheckboxChange: checkboxChangeEvent,
        onLoadSuccess: loadSuccessEvent
      })])]), footerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-tree-select--panel-footer'
      }, footerSlot({})) : renderEmptyElement($xeTreeSelect)])] : [])])]);
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.options, () => {
      cacheDataMap();
    });
    cacheDataMap();
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      globalEvents.on($xeTreeSelect, 'mousewheel', handleGlobalMousewheelEvent);
      globalEvents.on($xeTreeSelect, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeTreeSelect, 'blur', handleGlobalBlurEvent);
      globalEvents.on($xeTreeSelect, 'resize', handleGlobalResizeEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeTreeSelect, 'mousewheel');
      globalEvents.off($xeTreeSelect, 'mousedown');
      globalEvents.off($xeTreeSelect, 'blur');
      globalEvents.off($xeTreeSelect, 'resize');
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign(internalData, tree_select_createInternalData());
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.provide)('$xeTreeSelect', $xeTreeSelect);
    $xeTreeSelect.renderVN = renderVN;
    return $xeTreeSelect;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/tree-select/index.ts



const VxeTreeSelect = Object.assign({}, tree_select, {
  install(app) {
    app.component(tree_select.name, tree_select);
  }
});
dynamicApp.use(VxeTreeSelect);
index_esm_VxeUI.component(tree_select);
const TreeSelect = VxeTreeSelect;
/* harmony default export */ var packages_tree_select = (VxeTreeSelect);
;// CONCATENATED MODULE: ./packages/upload/src/util.ts





// 导入
let fileForm = null;
let fileInput = null;
function parseFile(file) {
  const name = file.name;
  const tIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().lastIndexOf(name, '.');
  const type = name.substring(tIndex + 1, name.length).toLowerCase();
  const filename = name.substring(0, tIndex);
  return {
    filename,
    type
  };
}
/**
 * 读取本地文件
 */
const readLocalFile = options => {
  const opts = Object.assign({}, options);
  return new Promise((resolve, reject) => {
    if (!fileInput) {
      fileInput = document.createElement('input');
      fileInput.name = 'file';
      fileInput.type = 'file';
    }
    if (!fileForm) {
      fileForm = document.createElement('form');
      fileForm.style.display = 'none';
      fileForm.appendChild(fileInput);
      document.body.appendChild(fileForm);
    }
    const types = opts.types || [];
    const isAllType = !types.length || types.some(type => type === '*');
    fileInput.multiple = !!opts.multiple;
    fileInput.accept = isAllType ? '' : `.${types.join(', .')}`;
    fileInput.onchange = evnt => {
      const eventTarget = evnt.target;
      const files = Array.from(eventTarget.files || []);
      const file = files[0];
      let errType = '';
      // 校验类型
      if (!isAllType) {
        for (let fIndex = 0; fIndex < files.length; fIndex++) {
          const {
            type
          } = parseFile(files[fIndex]);
          if (!external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().includes(types, type)) {
            errType = type;
            break;
          }
        }
      }
      if (!errType) {
        resolve({
          status: true,
          files,
          file
        });
      } else {
        if (opts.message !== false) {
          if (index_esm_VxeUI.modal) {
            index_esm_VxeUI.modal.message({
              content: getI18n('vxe.error.notType', [errType]),
              status: 'error'
            });
          }
        }
        const params = {
          status: false,
          files,
          file
        };
        reject(params);
      }
    };
    fileForm.reset();
    fileInput.click();
  });
};
function getExportBlobByContent(content, options) {
  return new Blob([content], {
    type: `text/${options.type};charset=utf-8;`
  });
}
/**
 * 保存文件到本地
 */
const saveLocalFile = options => {
  const opts = Object.assign({
    type: ''
  }, options);
  const {
    filename,
    type,
    content
  } = opts;
  const name = type ? `${filename}.${type}` : `${filename}`;
  if (window.Blob) {
    const blob = content instanceof Blob ? content : getExportBlobByContent(external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(content), opts);
    const winNavigator = window.navigator;
    if (winNavigator.msSaveBlob) {
      winNavigator.msSaveBlob(blob, name);
    } else {
      const url = URL.createObjectURL(blob);
      const linkElem = document.createElement('a');
      linkElem.target = '_blank';
      linkElem.download = name;
      linkElem.href = url;
      document.body.appendChild(linkElem);
      linkElem.click();
      requestAnimationFrame(() => {
        if (linkElem.parentNode) {
          linkElem.parentNode.removeChild(linkElem);
        }
        URL.revokeObjectURL(url);
      });
    }
    return Promise.resolve();
  }
  return Promise.reject(new Error(getI18n('vxe.error.notExp')));
};
;// CONCATENATED MODULE: ./packages/upload/src/upload.ts













/* harmony default export */ var upload = (defineVxeComponent({
  name: 'VxeUpload',
  props: {
    modelValue: [Array, String, Object],
    showList: {
      type: Boolean,
      default: () => getConfig().upload.showList
    },
    moreConfig: Object,
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    autoSubmit: {
      type: Boolean,
      default: () => getConfig().upload.autoSubmit
    },
    mode: {
      type: String,
      default: () => getConfig().upload.mode
    },
    imageTypes: {
      type: Array,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(getConfig().upload.imageTypes, true)
    },
    imageConfig: {
      type: Object,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(getConfig().upload.imageConfig, true)
    },
    /**
     * 已废弃，被 image-config 替换
     * @deprecated
     */
    imageStyle: {
      type: Object,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(getConfig().upload.imageStyle, true)
    },
    fileTypes: {
      type: Array,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(getConfig().upload.fileTypes, true)
    },
    dragSort: Boolean,
    dragToUpload: {
      type: Boolean,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(getConfig().upload.dragToUpload, true)
    },
    pasteToUpload: {
      type: Boolean,
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(getConfig().upload.pasteToUpload, true)
    },
    keyField: String,
    singleMode: Boolean,
    urlMode: Boolean,
    multiple: Boolean,
    limitSize: {
      type: [String, Number],
      default: () => getConfig().upload.limitSize
    },
    showLimitSize: {
      type: Boolean,
      default: () => getConfig().upload.showLimitSize
    },
    limitSizeText: {
      type: [String, Number, Function],
      default: () => getConfig().upload.limitSizeText
    },
    limitCount: {
      type: [String, Number],
      default: () => getConfig().upload.limitCount
    },
    showLimitCount: {
      type: Boolean,
      default: () => getConfig().upload.showLimitCount
    },
    limitCountText: {
      type: [String, Number, Function],
      default: () => getConfig().upload.limitCountText
    },
    nameField: {
      type: String,
      default: () => getConfig().upload.nameField
    },
    typeField: {
      type: String,
      default: () => getConfig().upload.typeField
    },
    urlField: {
      type: String,
      default: () => getConfig().upload.urlField
    },
    sizeField: {
      type: String,
      default: () => getConfig().upload.sizeField
    },
    showErrorStatus: {
      type: Boolean,
      default: () => getConfig().upload.showErrorStatus
    },
    showProgress: {
      type: Boolean,
      default: () => getConfig().upload.showProgress
    },
    progressText: {
      type: [String, Number, Function],
      default: () => getConfig().upload.progressText
    },
    showSubmitButton: Boolean,
    autoHiddenButton: {
      type: Boolean,
      default: () => getConfig().upload.autoHiddenButton
    },
    showUploadButton: {
      type: Boolean,
      default: () => getConfig().upload.showUploadButton
    },
    buttonText: {
      type: [String, Number, Function],
      default: () => getConfig().upload.buttonText
    },
    buttonIcon: {
      type: String,
      default: () => getConfig().upload.buttonIcon
    },
    showButtonText: {
      type: Boolean,
      default: () => getConfig().upload.showButtonText
    },
    showButtonIcon: {
      type: Boolean,
      default: () => getConfig().upload.showButtonIcon
    },
    showRemoveButton: {
      type: Boolean,
      default: () => getConfig().upload.showRemoveButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().upload.showDownloadButton
    },
    showPreview: {
      type: Boolean,
      default: () => getConfig().upload.showPreview
    },
    showTip: {
      type: Boolean,
      default: () => null
    },
    maxSimultaneousUploads: {
      type: Number,
      default: () => getConfig().upload.maxSimultaneousUploads
    },
    tipText: [String, Number, Function],
    hintText: String,
    previewMethod: Function,
    uploadMethod: Function,
    beforeRemoveMethod: Function,
    removeMethod: Function,
    beforeDownloadMethod: Function,
    downloadMethod: Function,
    getUrlMethod: Function,
    getThumbnailUrlMethod: Function,
    size: {
      type: String,
      default: () => getConfig().upload.size || getConfig().size
    }
  },
  emits: ['update:modelValue', 'add', 'remove', 'remove-fail', 'download', 'download-fail', 'upload-success', 'upload-error', 'sort-dragend'],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const $xeForm = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeForm', null);
    const formItemInfo = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('xeFormItemInfo', null);
    const $xeTable = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.inject)('$xeTable', null);
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const {
      computeSize
    } = useSize(props);
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refPopupElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refDragLineElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const refModalDragLineElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      isDragUploadStatus: false,
      showMorePopup: false,
      isActivated: false,
      fileList: [],
      fileCacheMaps: {},
      isDragMove: false,
      dragIndex: -1,
      dragTipText: ''
    });
    const internalData = {
      imagePreviewTypes: ['jpg', 'jpeg', 'png', 'gif'],
      prevDragIndex: -1
      // prevDragPos: ''
    };
    const refMaps = {
      refElem
    };
    const computeFormReadonly = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        readonly
      } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        disabled
      } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeKeyField = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.keyField || '_X_KEY';
    });
    const computeIsImage = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.mode === 'image';
    });
    const computeNameProp = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.nameField || 'name';
    });
    const computeTypeProp = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.typeField || 'type';
    });
    const computeUrlProp = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.urlField || 'url';
    });
    const computeSizeProp = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.sizeField || 'size';
    });
    const computeLimitMaxSize = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.limitSize) * 1024 * 1024;
    });
    const computeLimitMaxCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return props.multiple ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.limitCount) : 1;
    });
    const computeOverCount = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        multiple
      } = props;
      const {
        fileList
      } = reactData;
      const limitMaxCount = computeLimitMaxCount.value;
      if (multiple) {
        if (limitMaxCount) {
          return fileList.length >= limitMaxCount;
        }
        return true;
      }
      return fileList.length >= 1;
    });
    const computeLimitSizeUnit = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const limitSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(props.limitSize);
      if (limitSize) {
        if (limitSize > 1048576) {
          return `${limitSize / 1048576}T`;
        }
        if (limitSize > 1024) {
          return `${limitSize / 1024}G`;
        }
        return `${limitSize}M`;
      }
      return '';
    });
    const computedShowTipText = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        showTip,
        tipText
      } = props;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(showTip)) {
        return showTip;
      }
      const defShowTip = getConfig().upload.showTip;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isBoolean(defShowTip)) {
        return defShowTip;
      }
      if (tipText) {
        return true;
      }
      return false;
    });
    const computedDefTipText = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        limitSize,
        fileTypes,
        multiple,
        limitCount
      } = props;
      const tipText = props.tipText || props.hintText;
      const isImage = computeIsImage.value;
      const limitSizeUnit = computeLimitSizeUnit.value;
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(tipText)) {
        return tipText;
      }
      if (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(tipText)) {
        return `${tipText({})}`;
      }
      const defTips = [];
      if (isImage) {
        if (multiple && limitCount) {
          defTips.push(getI18n('vxe.upload.imgCountHint', [limitCount]));
        }
        if (limitSize && limitSizeUnit) {
          defTips.push(getI18n('vxe.upload.imgSizeHint', [limitSizeUnit]));
        }
      } else {
        if (fileTypes && fileTypes.length) {
          defTips.push(getI18n('vxe.upload.fileTypeHint', [fileTypes.join('/')]));
        }
        if (limitSize && limitSizeUnit) {
          defTips.push(getI18n('vxe.upload.fileSizeHint', [limitSizeUnit]));
        }
        if (multiple && limitCount) {
          defTips.push(getI18n('vxe.upload.fileCountHint', [limitCount]));
        }
      }
      return defTips.join(getI18n('vxe.base.comma'));
    });
    const computeImageOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({}, props.imageConfig || props.imageStyle);
    });
    const computeImgStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const imageOpts = computeImageOpts.value;
      const {
        width,
        height
      } = imageOpts;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeMoreOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return Object.assign({
        showMoreButton: true
      }, props.moreConfig);
    });
    const computeMaps = {};
    const $xeUpload = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getUniqueKey = () => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    };
    const getFieldKey = item => {
      const keyField = computeKeyField.value;
      return item[keyField];
    };
    const updateFileList = () => {
      const {
        modelValue,
        multiple
      } = props;
      const formReadonly = computeFormReadonly.value;
      const keyField = computeKeyField.value;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      const urlProp = computeUrlProp.value;
      const sizeProp = computeSizeProp.value;
      const fileList = modelValue ? (modelValue ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(modelValue) ? modelValue : [modelValue] : []).map(item => {
        if (!item || external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isString(item)) {
          const url = `${item || ''}`;
          const urlObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().parseUrl(item);
          const name = (urlObj ? urlObj.searchQuery[nameProp] : '') || parseFileName(url);
          return {
            [nameProp]: name,
            [typeProp]: (urlObj ? urlObj.searchQuery[typeProp] : '') || parseFileType(name),
            [urlProp]: url,
            [sizeProp]: external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(urlObj ? urlObj.searchQuery[sizeProp] : 0) || 0,
            [keyField]: getUniqueKey()
          };
        }
        const name = item[nameProp] || '';
        item[nameProp] = name;
        item[typeProp] = item[typeProp] || parseFileType(name);
        item[urlProp] = item[urlProp] || '';
        item[sizeProp] = item[sizeProp] || 0;
        item[keyField] = item[keyField] || getUniqueKey();
        return item;
      }) : [];
      reactData.fileList = formReadonly || multiple ? fileList : fileList.slice(0, 1);
    };
    const parseFileName = url => {
      return decodeURIComponent(`${url || ''}`).split('/').pop() || '';
    };
    const parseFileType = name => {
      // 这里不用split('.').pop()因为没有后缀时会返回自身
      const index = name.lastIndexOf('.');
      if (index > 0) {
        return name.substring(index + 1).toLowerCase();
      }
      return '';
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $upload: $xeUpload
      }, params));
    };
    const handleChange = value => {
      const {
        singleMode,
        urlMode
      } = props;
      const urlProp = computeUrlProp.value;
      const nameProp = computeNameProp.value;
      let restList = value ? value.slice(0) : [];
      if (urlMode) {
        restList = restList.map(item => {
          const url = item[urlProp];
          if (url) {
            const urlObj = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().parseUrl(url);
            if (!urlObj.searchQuery[nameProp]) {
              return `${url}${url.indexOf('?') === -1 ? '?' : '&'}${nameProp}=${encodeURIComponent(item[nameProp] || '')}`;
            }
          }
          return url;
        });
      }
      emit('update:modelValue', singleMode ? restList[0] || null : restList);
    };
    const getThumbnailFileUrl = item => {
      const getThumbnailUrlFn = props.getThumbnailUrlMethod || getConfig().upload.getThumbnailUrlMethod;
      if (getThumbnailUrlFn) {
        return getThumbnailUrlFn({
          $upload: $xeUpload,
          option: item
        });
      }
      return getFileUrl(item);
    };
    const getFileUrl = item => {
      const getUrlFn = props.getUrlMethod || getConfig().upload.getUrlMethod;
      const urlProp = computeUrlProp.value;
      return getUrlFn ? getUrlFn({
        $upload: $xeUpload,
        option: item
      }) : item[urlProp];
    };
    const handleDefaultFilePreview = item => {
      const {
        imageTypes,
        showDownloadButton
      } = props;
      const typeProp = computeTypeProp.value;
      const beforeDownloadFn = props.beforeDownloadMethod || getConfig().upload.beforeDownloadMethod;
      const {
        imagePreviewTypes
      } = internalData;
      // 如果是预览图片
      if (imagePreviewTypes.concat(imageTypes || []).some(type => `${type}`.toLowerCase() === `${item[typeProp]}`.toLowerCase())) {
        if (index_esm_VxeUI.previewImage) {
          index_esm_VxeUI.previewImage({
            urlList: [getFileUrl(item)],
            showDownloadButton,
            beforeDownloadMethod: beforeDownloadFn ? () => {
              return beforeDownloadFn({
                $upload: $xeUpload,
                option: item
              });
            } : undefined
          });
        }
      }
    };
    const handlePreviewFileEvent = (evnt, item) => {
      const previewFn = props.previewMethod || getConfig().upload.previewMethod;
      if (props.showPreview) {
        if (previewFn) {
          previewFn({
            $upload: $xeUpload,
            option: item
          });
        } else {
          handleDefaultFilePreview(item);
        }
      }
    };
    const handlePreviewImageEvent = (evnt, item, index) => {
      const {
        showDownloadButton
      } = props;
      const {
        fileList
      } = reactData;
      const beforeDownloadFn = props.beforeDownloadMethod || getConfig().upload.beforeDownloadMethod;
      if (props.showPreview) {
        if (index_esm_VxeUI.previewImage) {
          index_esm_VxeUI.previewImage({
            urlList: fileList.map(item => getFileUrl(item)),
            activeIndex: index,
            showDownloadButton,
            beforeDownloadMethod: beforeDownloadFn ? ({
              index
            }) => {
              return beforeDownloadFn({
                $upload: $xeUpload,
                option: fileList[index]
              });
            } : undefined
          });
        }
      }
    };
    const handleUploadResult = (item, file) => {
      const {
        showErrorStatus
      } = props;
      const fileKey = getFieldKey(item);
      const uploadFn = props.uploadMethod || getConfig().upload.uploadMethod;
      if (uploadFn) {
        return Promise.resolve(uploadFn({
          $upload: $xeUpload,
          file,
          option: item,
          updateProgress(percentNum) {
            const {
              fileCacheMaps
            } = reactData;
            const cacheItem = fileCacheMaps[getFieldKey(item)];
            if (cacheItem) {
              cacheItem.percent = Math.max(0, Math.min(99, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(percentNum)));
            }
          }
        })).then(res => {
          const {
            fileCacheMaps
          } = reactData;
          const cacheItem = fileCacheMaps[fileKey];
          if (cacheItem) {
            cacheItem.percent = 100;
            cacheItem.status = 'success';
          }
          Object.assign(item, res);
          dispatchEvent('upload-success', {
            option: item,
            data: res
          }, null);
        }).catch(res => {
          const {
            fileCacheMaps
          } = reactData;
          const cacheItem = fileCacheMaps[fileKey];
          if (cacheItem) {
            cacheItem.status = 'error';
          }
          if (showErrorStatus) {
            Object.assign(item, res);
          } else {
            reactData.fileList = reactData.fileList.filter(obj => getFieldKey(obj) !== fileKey);
          }
          dispatchEvent('upload-error', {
            option: item,
            data: res
          }, null);
        }).finally(() => {
          const {
            fileCacheMaps
          } = reactData;
          const cacheItem = fileCacheMaps[fileKey];
          if (cacheItem) {
            cacheItem.loading = false;
          }
        });
      } else {
        const {
          fileCacheMaps
        } = reactData;
        const cacheItem = fileCacheMaps[fileKey];
        if (cacheItem) {
          cacheItem.loading = false;
        }
      }
      return Promise.resolve();
    };
    const handleReUpload = item => {
      const {
        uploadMethod,
        urlMode
      } = props;
      const {
        fileCacheMaps
      } = reactData;
      const fileKey = getFieldKey(item);
      const cacheItem = fileCacheMaps[fileKey];
      const uploadFn = uploadMethod || getConfig().upload.uploadMethod;
      if (uploadFn && cacheItem) {
        const file = cacheItem.file;
        cacheItem.loading = true;
        cacheItem.status = 'pending';
        cacheItem.percent = 0;
        handleUploadResult(item, file).then(() => {
          if (urlMode) {
            handleChange(reactData.fileList);
          }
        });
      }
    };
    const handleUploadFile = (files, evnt) => {
      const {
        multiple,
        urlMode,
        showLimitSize,
        limitSizeText,
        showLimitCount,
        limitCountText,
        autoSubmit
      } = props;
      const {
        fileList
      } = reactData;
      const uploadFn = props.uploadMethod || getConfig().upload.uploadMethod;
      const keyField = computeKeyField.value;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      const urlProp = computeUrlProp.value;
      const sizeProp = computeSizeProp.value;
      const limitMaxSize = computeLimitMaxSize.value;
      const limitMaxCount = computeLimitMaxCount.value;
      const limitSizeUnit = computeLimitSizeUnit.value;
      let selectFiles = files;
      if (multiple && limitMaxCount) {
        // 校验文件数量
        if (showLimitCount && fileList.length >= limitMaxCount) {
          if (index_esm_VxeUI.modal) {
            index_esm_VxeUI.modal.notification({
              title: getI18n('vxe.modal.errTitle'),
              status: 'error',
              content: limitCountText ? `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(limitCountText) ? limitCountText({
                maxCount: limitMaxCount
              }) : limitCountText}` : getI18n('vxe.upload.overCountErr', [limitMaxCount])
            });
          }
          return;
        }
        const overNum = selectFiles.length - (limitMaxCount - fileList.length);
        if (showLimitCount && overNum > 0) {
          const overExtraList = selectFiles.slice(limitMaxCount - fileList.length);
          if (limitCountText) {
            index_esm_VxeUI.modal.notification({
              title: getI18n('vxe.modal.errTitle'),
              status: 'error',
              content: `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(limitCountText) ? limitCountText({
                maxCount: limitMaxCount
              }) : limitCountText}`
            });
          } else if (index_esm_VxeUI.modal) {
            index_esm_VxeUI.modal.notification({
              title: getI18n('vxe.modal.errTitle'),
              status: 'error',
              width: null,
              slots: {
                default() {
                  return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                    class: 'vxe-upload--file-message-over-error'
                  }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {}, getI18n('vxe.upload.overCountExtraErr', [limitMaxCount, overNum])), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                    class: 'vxe-upload--file-message-over-extra'
                  }, overExtraList.map((file, index) => {
                    return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                      key: index,
                      class: 'vxe-upload--file-message-over-extra-item'
                    }, file.name);
                  }))]);
                }
              }
            });
          }
        }
        selectFiles = selectFiles.slice(0, limitMaxCount - fileList.length);
      }
      // 校验文件大小
      if (showLimitSize && limitMaxSize) {
        for (let i = 0; i < files.length; i++) {
          const file = files[0];
          if (file.size > limitMaxSize) {
            if (index_esm_VxeUI.modal) {
              index_esm_VxeUI.modal.notification({
                title: getI18n('vxe.modal.errTitle'),
                status: 'error',
                content: limitSizeText ? `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(limitSizeText) ? limitSizeText({
                  maxSize: limitMaxSize
                }) : limitSizeText}` : getI18n('vxe.upload.overSizeErr', [limitSizeUnit])
              });
            }
            return;
          }
        }
      }
      const cacheMaps = Object.assign({}, reactData.fileCacheMaps);
      const newFileList = multiple ? fileList : [];
      const uploadPromiseRests = [];
      selectFiles.forEach(file => {
        const {
          name
        } = file;
        const fileKey = getUniqueKey();
        const fileObj = {
          [nameProp]: name,
          [typeProp]: parseFileType(name),
          [sizeProp]: file.size,
          [urlProp]: URL.createObjectURL(file),
          [keyField]: fileKey
        };
        if (uploadFn) {
          cacheMaps[fileKey] = {
            file: file,
            loading: !!autoSubmit,
            status: 'pending',
            percent: 0
          };
        }
        const item = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)(fileObj);
        if (uploadFn && autoSubmit) {
          uploadPromiseRests.push(handleUploadResult(item, file));
        }
        newFileList.push(item);
        dispatchEvent('add', {
          option: item
        }, evnt);
      });
      reactData.fileList = newFileList;
      reactData.fileCacheMaps = cacheMaps;
      Promise.all(urlMode ? uploadPromiseRests : []).then(() => {
        handleChange(newFileList);
        // 自动更新校验状态
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, newFileList);
        }
      });
    };
    const handleChoose = evnt => {
      const {
        multiple,
        imageTypes,
        fileTypes
      } = props;
      const isDisabled = computeIsDisabled.value;
      const isImage = computeIsImage.value;
      if (isDisabled) {
        return Promise.resolve({
          status: false,
          files: [],
          file: null
        });
      }
      return readLocalFile({
        multiple,
        types: isImage ? imageTypes : fileTypes
      }).then(params => {
        handleUploadFile(params.files, evnt);
        return params;
      });
    };
    const clickEvent = evnt => {
      handleChoose(evnt).catch(() => {
        // 错误文件类型
      });
    };
    const handleRemoveEvent = (evnt, item, index) => {
      const {
        fileList
      } = reactData;
      fileList.splice(index, 1);
      handleChange(fileList);
      // 自动更新校验状态
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, fileList);
      }
      dispatchEvent('remove', {
        option: item
      }, evnt);
    };
    const removeFileEvent = (evnt, item, index) => {
      const beforeRemoveFn = props.beforeRemoveMethod || getConfig().upload.beforeRemoveMethod;
      const removeFn = props.removeMethod || getConfig().upload.removeMethod;
      Promise.resolve(beforeRemoveFn ? beforeRemoveFn({
        $upload: $xeUpload,
        option: item
      }) : true).then(status => {
        if (status) {
          if (removeFn) {
            Promise.resolve(removeFn({
              $upload: $xeUpload,
              option: item
            })).then(() => {
              handleRemoveEvent(evnt, item, index);
            }).catch(e => e);
          } else {
            handleRemoveEvent(evnt, item, index);
          }
        } else {
          dispatchEvent('remove-fail', {
            option: item
          }, evnt);
        }
      });
    };
    const handleDownloadEvent = (evnt, item) => {
      dispatchEvent('download', {
        option: item
      }, evnt);
    };
    const downloadFileEvent = (evnt, item) => {
      const beforeDownloadFn = props.beforeDownloadMethod || getConfig().upload.beforeDownloadMethod;
      const downloadFn = props.downloadMethod || getConfig().upload.downloadMethod;
      Promise.resolve(beforeDownloadFn ? beforeDownloadFn({
        $upload: $xeUpload,
        option: item
      }) : true).then(status => {
        if (status) {
          if (downloadFn) {
            Promise.resolve(downloadFn({
              $upload: $xeUpload,
              option: item
            })).then(() => {
              handleDownloadEvent(evnt, item);
            }).catch(e => e);
          } else {
            handleDownloadEvent(evnt, item);
          }
        } else {
          dispatchEvent('download-fail', {
            option: item
          }, evnt);
        }
      });
    };
    const handleUploadDragleaveEvent = evnt => {
      const targetElem = evnt.currentTarget;
      const {
        clientX,
        clientY
      } = evnt;
      if (targetElem) {
        const {
          x: targetX,
          y: targetY,
          height: targetHeight,
          width: targetWidth
        } = targetElem.getBoundingClientRect();
        if (clientX < targetX || clientX > targetX + targetWidth || clientY < targetY || clientY > targetY + targetHeight) {
          reactData.isDragUploadStatus = false;
        }
      }
    };
    const handleUploadDragoverEvent = evnt => {
      const dataTransfer = evnt.dataTransfer;
      if (dataTransfer) {
        const {
          items
        } = dataTransfer;
        if (items && items.length) {
          evnt.preventDefault();
          reactData.isDragUploadStatus = true;
        }
      }
    };
    const uploadTransferFileEvent = (evnt, files) => {
      const {
        imageTypes,
        fileTypes
      } = props;
      const {
        imagePreviewTypes
      } = internalData;
      const isImage = computeIsImage.value;
      if (isImage) {
        const pasteImgTypes = imagePreviewTypes.concat(imageTypes && imageTypes.length ? imageTypes : []);
        files = files.filter(file => {
          const fileType = `${file.type.split('/')[1] || ''}`.toLowerCase();
          if (pasteImgTypes.some(type => `${type}`.toLowerCase() === fileType)) {
            return true;
          }
          return false;
        });
      } else {
        if (fileTypes && fileTypes.length) {
          const errTypes = [];
          files.forEach(file => {
            const fileType = parseFileType(file.name);
            if (!fileTypes.some(type => `${type}`.toLowerCase() === fileType)) {
              errTypes.push(fileType);
            }
          });
          if (errTypes.length) {
            if (index_esm_VxeUI.modal) {
              index_esm_VxeUI.modal.message({
                content: getI18n('vxe.error.notType', [errTypes.join(', ')]),
                status: 'error'
              });
            }
            return;
          }
        }
      }
      // 如果全部不满足条件
      if (!files.length) {
        if (index_esm_VxeUI.modal) {
          index_esm_VxeUI.modal.notification({
            title: getI18n('vxe.modal.errTitle'),
            status: 'error',
            content: getI18n('vxe.upload.uploadTypeErr')
          });
        }
        return;
      }
      handleUploadFile(files, evnt);
    };
    const handleUploadDropEvent = evnt => {
      const dataTransfer = evnt.dataTransfer;
      if (dataTransfer) {
        const {
          items
        } = dataTransfer;
        if (items && items.length) {
          evnt.preventDefault();
          const files = handleTransferFiles(items);
          if (files.length) {
            uploadTransferFileEvent(evnt, files);
          }
        }
      }
      reactData.isDragUploadStatus = false;
    };
    const handleTransferFiles = items => {
      const files = [];
      external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().arrayEach(items, item => {
        const file = item.getAsFile();
        if (file) {
          files.push(file);
        }
      });
      return files;
    };
    const handleMoreEvent = () => {
      const formReadonly = computeFormReadonly.value;
      const isImage = computeIsImage.value;
      if (index_esm_VxeUI.modal) {
        index_esm_VxeUI.modal.open({
          title: formReadonly ? getI18n('vxe.upload.morePopup.readTitle') : getI18n(`vxe.upload.morePopup.${isImage ? 'imageTitle' : 'fileTitle'}`),
          width: 660,
          height: 500,
          escClosable: true,
          showMaximize: true,
          resize: true,
          maskClosable: true,
          slots: {
            default() {
              const {
                showErrorStatus,
                dragToUpload,
                dragSort
              } = props;
              const {
                isActivated,
                isDragMove,
                isDragUploadStatus,
                dragIndex
              } = reactData;
              const {
                fileList
              } = reactData;
              const isDisabled = computeIsDisabled.value;
              const ons = {};
              if (dragToUpload && dragIndex === -1) {
                ons.onDragover = handleUploadDragoverEvent;
                ons.onDragleave = handleUploadDragleaveEvent;
                ons.onDrop = handleUploadDropEvent;
              }
              return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                ref: refPopupElem,
                class: ['vxe-upload--more-popup', {
                  'is--readonly': formReadonly,
                  'is--disabled': isDisabled,
                  'is--active': isActivated,
                  'show--error': showErrorStatus,
                  'is--drag': isDragUploadStatus
                }],
                ...ons
              }, [isImage ? dragSort ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.TransitionGroup, {
                name: `vxe-upload--drag-list${isDragMove ? '' : '-disabled'}`,
                tag: 'div',
                class: 'vxe-upload--image-more-list'
              }, {
                default: () => renderImageItemList(fileList, true).concat(renderImageAction(true))
              }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-upload--image-more-list'
              }, renderImageItemList(fileList, true).concat(renderImageAction(true))) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-upload--file-more-list'
              }, [renderFileAction(true), dragSort ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.TransitionGroup, {
                name: `vxe-upload--drag-list${isDragMove ? '' : '-disabled'}`,
                tag: 'div',
                class: 'vxe-upload--file-list'
              }, {
                default: () => renderFileItemList(fileList, false)
              }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-upload--file-list'
              }, renderFileItemList(fileList, true))]), dragSort ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                ref: refModalDragLineElem,
                class: 'vxe-upload--drag-line'
              }) : renderEmptyElement($xeUpload), isDragUploadStatus ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
                class: 'vxe-upload--drag-placeholder'
              }, getI18n('vxe.upload.dragPlaceholder')) : renderEmptyElement($xeUpload)]);
            }
          },
          onShow() {
            reactData.showMorePopup = true;
          },
          onHide() {
            reactData.showMorePopup = false;
          }
        });
      }
    };
    const showDropTip = (evnt, dragEl, dragPos) => {
      const {
        showMorePopup
      } = reactData;
      const el = refElem.value;
      const popupEl = refPopupElem.value;
      const wrapperEl = showMorePopup ? popupEl : el;
      if (!wrapperEl) {
        return;
      }
      const wrapperRect = wrapperEl.getBoundingClientRect();
      const ddLineEl = refDragLineElem.value;
      const mdLineEl = refModalDragLineElem.value;
      const currDLineEl = showMorePopup ? mdLineEl : ddLineEl;
      if (currDLineEl) {
        const dragRect = dragEl.getBoundingClientRect();
        currDLineEl.style.display = 'block';
        currDLineEl.style.top = `${Math.max(1, dragRect.y - wrapperRect.y)}px`;
        currDLineEl.style.left = `${Math.max(1, dragRect.x - wrapperRect.x)}px`;
        currDLineEl.style.height = `${dragRect.height}px`;
        currDLineEl.style.width = `${dragRect.width - 1}px`;
        currDLineEl.setAttribute('drag-pos', dragPos);
      }
    };
    const hideDropTip = () => {
      const ddLineEl = refDragLineElem.value;
      const mdLineEl = refModalDragLineElem.value;
      if (ddLineEl) {
        ddLineEl.style.display = '';
      }
      if (mdLineEl) {
        mdLineEl.style.display = '';
      }
    };
    // 拖拽
    const handleDragSortDragstartEvent = evnt => {
      evnt.stopPropagation();
      if (evnt.dataTransfer) {
        evnt.dataTransfer.setDragImage(getTpImg(), 0, 0);
      }
      const dragEl = evnt.currentTarget;
      const parentEl = dragEl.parentElement;
      const dragIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(Array.from(parentEl.children), item => dragEl === item);
      reactData.isDragMove = true;
      reactData.dragIndex = dragIndex;
      setTimeout(() => {
        reactData.isDragMove = false;
      }, 500);
    };
    const handleDragSortDragoverEvent = evnt => {
      evnt.stopPropagation();
      evnt.preventDefault();
      const {
        dragIndex
      } = reactData;
      if (dragIndex === -1) {
        return;
      }
      const isImage = computeIsImage.value;
      const dragEl = evnt.currentTarget;
      const parentEl = dragEl.parentElement;
      const currIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(Array.from(parentEl.children), item => dragEl === item);
      let dragPos = '';
      if (isImage) {
        const offsetX = evnt.clientX - dragEl.getBoundingClientRect().x;
        dragPos = offsetX < dragEl.clientWidth / 2 ? 'left' : 'right';
      } else {
        const offsetY = evnt.clientY - dragEl.getBoundingClientRect().y;
        dragPos = offsetY < dragEl.clientHeight / 2 ? 'top' : 'bottom';
      }
      if (dragIndex === currIndex) {
        showDropTip(evnt, dragEl, dragPos);
        return;
      }
      showDropTip(evnt, dragEl, dragPos);
      internalData.prevDragIndex = currIndex;
      internalData.prevDragPos = dragPos;
    };
    const handleDragSortDragendEvent = evnt => {
      const {
        fileList,
        dragIndex
      } = reactData;
      const {
        prevDragIndex,
        prevDragPos
      } = internalData;
      const oldIndex = dragIndex;
      const targetIndex = prevDragIndex;
      const dragOffsetIndex = prevDragPos === 'bottom' || prevDragPos === 'right' ? 1 : 0;
      const oldItem = fileList[oldIndex];
      const newItem = fileList[targetIndex];
      if (oldItem && newItem) {
        fileList.splice(oldIndex, 1);
        const ptfIndex = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().findIndexOf(fileList, item => newItem === item);
        const nIndex = ptfIndex + dragOffsetIndex;
        fileList.splice(nIndex, 0, oldItem);
        dispatchEvent('sort-dragend', {
          oldItem: oldItem,
          newItem: newItem,
          dragPos: prevDragPos,
          offsetIndex: dragOffsetIndex,
          _index: {
            newIndex: nIndex,
            oldIndex: oldIndex
          }
        }, evnt);
      }
      hideDropTip();
      reactData.dragIndex = -1;
    };
    const handleItemMousedownEvent = evnt => {
      if ($xeTable) {
        evnt.stopPropagation();
      }
      reactData.isActivated = true;
    };
    const handleGlobalPasteEvent = evnt => {
      const {
        pasteToUpload
      } = props;
      const {
        isActivated
      } = reactData;
      if (!isActivated || !pasteToUpload) {
        return;
      }
      const clipboardData = evnt.clipboardData || evnt.originalEvent.clipboardData;
      if (!clipboardData) {
        return;
      }
      const {
        items
      } = clipboardData;
      if (!items) {
        return;
      }
      const files = handleTransferFiles(items);
      if (files.length) {
        evnt.preventDefault();
        uploadTransferFileEvent(evnt, files);
      }
    };
    const handleGlobalMousedownEvent = evnt => {
      const el = refElem.value;
      const popupEl = refPopupElem.value;
      let isActivated = getEventTargetNode(evnt, el).flag;
      if (!isActivated && popupEl) {
        const parentEl = popupEl.parentElement || popupEl;
        const modalEl = parentEl ? parentEl.parentElement : parentEl;
        isActivated = getEventTargetNode(evnt, modalEl).flag;
      }
      reactData.isActivated = isActivated;
    };
    const handleGlobalBlurEvent = () => {
      reactData.isActivated = false;
    };
    const uploadMethods = {
      dispatchEvent,
      choose() {
        return handleChoose(null);
      },
      submit(isFull) {
        const {
          maxSimultaneousUploads
        } = props;
        const msNum = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(maxSimultaneousUploads || 1) || 1;
        const {
          fileList,
          fileCacheMaps
        } = reactData;
        const allPendingList = fileList.filter(item => {
          const fileKey = getFieldKey(item);
          const cacheItem = fileCacheMaps[fileKey];
          return cacheItem && (cacheItem.status === 'pending' || isFull && cacheItem.status === 'error');
        });
        const handleSubmit = item => {
          const fileKey = getFieldKey(item);
          const cacheItem = fileCacheMaps[fileKey];
          if (cacheItem) {
            const file = cacheItem.file;
            if (file && (cacheItem.status === 'pending' || isFull && cacheItem.status === 'error')) {
              cacheItem.loading = true;
              cacheItem.percent = 0;
              return handleUploadResult(item, file).then(handleNextSubmit);
            }
          }
          return handleNextSubmit();
        };
        const handleNextSubmit = () => {
          if (allPendingList.length) {
            const item = allPendingList[0];
            allPendingList.splice(0, 1);
            return handleSubmit(item).then(handleNextSubmit);
          }
          return Promise.resolve();
        };
        return Promise.all(allPendingList.splice(0, msNum).map(handleSubmit)).then(() => {
          // 完成
        });
      }
    };
    const uploadPrivateMethods = {};
    Object.assign($xeUpload, uploadMethods, uploadPrivateMethods);
    const renderFileItemList = (currList, isMoreView) => {
      const {
        showRemoveButton,
        showDownloadButton,
        showProgress,
        progressText,
        showPreview,
        showErrorStatus,
        dragSort,
        autoSubmit,
        showSubmitButton
      } = props;
      const {
        fileCacheMaps
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      const cornerSlot = slots.corner;
      const ons = {};
      if (dragSort && currList.length > 1) {
        ons.onDragstart = handleDragSortDragstartEvent;
        ons.onDragover = handleDragSortDragoverEvent;
        ons.onDragend = handleDragSortDragendEvent;
      }
      return currList.map((item, index) => {
        const fileKey = getFieldKey(item);
        const cacheItem = fileCacheMaps[fileKey];
        let isLoading = false;
        let isError = false;
        let isPending = false;
        const fileName = `${item[nameProp] || ''}`;
        if (cacheItem) {
          isLoading = cacheItem.loading;
          isError = cacheItem.status === 'error';
          isPending = cacheItem.status === 'pending';
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: dragSort ? fileKey : index,
          class: ['vxe-upload--file-item', {
            'is--preview': showPreview,
            'is--loading': isLoading,
            'is--pending': isPending,
            'is--error': isError
          }],
          fileid: fileKey,
          draggable: dragSort ? true : null,
          ...ons
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-icon'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon()[`UPLOAD_FILE_TYPE_${`${item[typeProp]}`.toLocaleUpperCase()}`] || getIcon().UPLOAD_FILE_TYPE_DEFAULT
        })]), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-name',
          title: fileName,
          onClick(evnt) {
            if (!isLoading && !isError) {
              handlePreviewFileEvent(evnt, item);
            }
          }
        }, fileName), isLoading ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-loading-icon'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon().UPLOAD_LOADING
        })]) : renderEmptyElement($xeUpload), showProgress && isLoading && cacheItem ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-loading-text'
        }, progressText ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFormatString(`${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(progressText) ? progressText({}) : progressText}`, {
          percent: cacheItem.percent
        }) : getI18n('vxe.upload.uploadProgress', [cacheItem.percent])) : renderEmptyElement($xeUpload), !isLoading && (isError && showErrorStatus || isPending && showSubmitButton && !autoSubmit) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-rebtn'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          icon: isError ? getIcon().UPLOAD_IMAGE_RE_UPLOAD : getIcon().UPLOAD_IMAGE_UPLOAD,
          mode: 'text',
          status: 'primary',
          content: isError ? getI18n('vxe.upload.reUpload') : getI18n('vxe.upload.manualUpload'),
          onClick() {
            handleReUpload(item);
          }
        })]) : renderEmptyElement($xeUpload), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-btn-wrapper'
        }, [cornerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-corner'
        }, vn_getSlotVNs(cornerSlot({
          option: item,
          isMoreView,
          readonly: formReadonly
        }))) : renderEmptyElement($xeUpload), showDownloadButton && !(isLoading || isPending) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-download-btn',
          onClick(evnt) {
            downloadFileEvent(evnt, item);
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon().UPLOAD_FILE_DOWNLOAD
        })]) : renderEmptyElement($xeUpload), showRemoveButton && !formReadonly && !isDisabled && !isLoading ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-remove-btn',
          onClick(evnt) {
            removeFileEvent(evnt, item, index);
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon().UPLOAD_FILE_REMOVE
        })]) : renderEmptyElement($xeUpload)])]);
      });
    };
    const renderFileAction = isMoreView => {
      const {
        showUploadButton,
        buttonText,
        buttonIcon,
        showButtonText,
        showButtonIcon,
        autoHiddenButton
      } = props;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const showTipText = computedShowTipText.value;
      const defTipText = computedDefTipText.value;
      const overCount = computeOverCount.value;
      const defaultSlot = slots.default;
      const tipSlot = slots.tip || slots.hint;
      if (formReadonly || !showUploadButton) {
        return renderEmptyElement($xeUpload);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--file-action'
      }, [autoHiddenButton && overCount ? renderEmptyElement($xeUpload) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--file-action-btn',
        onClick: clickEvent
      }, defaultSlot ? vn_getSlotVNs(defaultSlot({
        $upload: $xeUpload
      })) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        class: 'vxe-upload--file-action-button',
        content: isMoreView || showButtonText ? buttonText ? `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(buttonText) ? buttonText({}) : buttonText}` : getI18n('vxe.upload.fileBtnText') : '',
        icon: showButtonIcon ? buttonIcon || getIcon().UPLOAD_FILE_ADD : '',
        disabled: isDisabled
      })]), showTipText && (defTipText || tipSlot) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--file-action-tip'
      }, tipSlot ? vn_getSlotVNs(tipSlot({
        $upload: $xeUpload
      })) : `${defTipText}`) : renderEmptyElement($xeUpload)]);
    };
    const renderAllMode = () => {
      const {
        showList,
        moreConfig,
        dragSort
      } = props;
      const {
        fileList,
        isDragMove
      } = reactData;
      const moreOpts = computeMoreOpts.value;
      const {
        maxCount,
        showMoreButton,
        layout
      } = moreOpts;
      const isHorizontal = layout === 'horizontal';
      let currList = fileList;
      let overMaxNum = 0;
      if (maxCount && fileList.length > maxCount) {
        overMaxNum = fileList.length - maxCount;
        currList = fileList.slice(0, maxCount);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'all',
        class: 'vxe-upload--file-wrapper'
      }, showList ? [showMoreButton && moreConfig && isHorizontal ? renderEmptyElement($xeUpload) : renderFileAction(true), currList.length || showMoreButton && isHorizontal ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: ['vxe-upload--file-list-wrapper', {
          'is--horizontal': isHorizontal
        }]
      }, [currList.length ? dragSort ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.TransitionGroup, {
        name: `vxe-upload--drag-list${isDragMove ? '' : '-disabled'}`,
        tag: 'div',
        class: 'vxe-upload--file-list'
      }, {
        default: () => renderFileItemList(currList, false)
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--file-list'
      }, renderFileItemList(currList, false)) : renderEmptyElement($xeUpload), showMoreButton && overMaxNum ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--file-over-more'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        mode: 'text',
        content: getI18n('vxe.upload.moreBtnText', [fileList.length]),
        status: 'primary',
        onClick: handleMoreEvent
      })]) : renderEmptyElement($xeUpload), showMoreButton && moreConfig && isHorizontal ? renderFileAction(false) : renderEmptyElement($xeUpload)]) : renderEmptyElement($xeUpload)] : [renderFileAction(false)]);
    };
    const renderImageItemList = (currList, isMoreView) => {
      const {
        showRemoveButton,
        showProgress,
        progressText,
        showPreview,
        showErrorStatus,
        dragSort,
        autoSubmit,
        showSubmitButton
      } = props;
      const {
        fileCacheMaps
      } = reactData;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const imageOpts = computeImageOpts.value;
      const imgStyle = computeImgStyle.value;
      const cornerSlot = slots.corner;
      const ons = {
        onMousedown: handleItemMousedownEvent
      };
      if (dragSort && currList.length > 1) {
        ons.onDragstart = handleDragSortDragstartEvent;
        ons.onDragover = handleDragSortDragoverEvent;
        ons.onDragend = handleDragSortDragendEvent;
      }
      return currList.map((item, index) => {
        const fileKey = getFieldKey(item);
        const cacheItem = fileCacheMaps[fileKey];
        let isLoading = false;
        let isError = false;
        let isPending = false;
        if (cacheItem) {
          isLoading = cacheItem.loading;
          isError = cacheItem.status === 'error';
          isPending = cacheItem.status === 'pending';
        }
        return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: dragSort ? fileKey : index,
          class: ['vxe-upload--image-item', {
            'is--preview': showPreview,
            'is--circle': imageOpts.circle,
            'is--loading': isLoading,
            'is--pending': isPending,
            'is--error': isError
          }],
          fileid: fileKey,
          draggable: dragSort ? true : null,
          ...ons
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-box',
          style: isMoreView ? null : imgStyle,
          onClick(evnt) {
            if (!isLoading && !isError) {
              handlePreviewImageEvent(evnt, item, index);
            }
          }
        }, [isLoading && cacheItem ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-loading'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-loading-icon'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon().UPLOAD_LOADING
        })]), showProgress ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-loading-text'
        }, progressText ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toFormatString(`${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(progressText) ? progressText({}) : progressText}`, {
          percent: cacheItem.percent
        }) : getI18n('vxe.upload.uploadProgress', [cacheItem.percent])) : renderEmptyElement($xeUpload)]) : renderEmptyElement($xeUpload), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-img-wrapper',
          title: getI18n('vxe.upload.viewItemTitle')
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('img', {
          class: 'vxe-upload--image-item-img',
          src: getThumbnailFileUrl(item)
        })]), !isLoading && (isError && showErrorStatus || isPending && showSubmitButton && !autoSubmit) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-rebtn'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          icon: isError ? getIcon().UPLOAD_IMAGE_RE_UPLOAD : getIcon().UPLOAD_IMAGE_UPLOAD,
          mode: 'text',
          status: 'primary',
          content: isError ? getI18n('vxe.upload.reUpload') : getI18n('vxe.upload.manualUpload'),
          onClick() {
            handleReUpload(item);
          }
        })]) : renderEmptyElement($xeUpload), (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-btn-wrapper',
          onClick(evnt) {
            evnt.stopPropagation();
          }
        }, [cornerSlot ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--file-item-corner'
        }, vn_getSlotVNs(cornerSlot({
          option: item,
          isMoreView,
          readonly: formReadonly
        }))) : renderEmptyElement($xeUpload), showRemoveButton && !formReadonly && !isDisabled && !isLoading ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          class: 'vxe-upload--image-item-remove-btn',
          onClick(evnt) {
            evnt.stopPropagation();
            removeFileEvent(evnt, item, index);
          }
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
          class: getIcon().UPLOAD_IMAGE_REMOVE
        })]) : renderEmptyElement($xeUpload)])])]);
      });
    };
    const renderImageAction = isMoreView => {
      const {
        showUploadButton,
        buttonText,
        buttonIcon,
        showButtonText,
        showButtonIcon,
        autoHiddenButton
      } = props;
      const formReadonly = computeFormReadonly.value;
      const showTipText = computedShowTipText.value;
      const defTipText = computedDefTipText.value;
      const overCount = computeOverCount.value;
      const imgStyle = computeImgStyle.value;
      const defaultSlot = slots.default;
      const tipSlot = slots.tip || slots.hint;
      if (formReadonly || !showUploadButton || autoHiddenButton && overCount) {
        return renderEmptyElement($xeUpload);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'action',
        class: 'vxe-upload--image-action'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-action-btn',
        onClick: clickEvent
      }, defaultSlot ? defaultSlot({
        $upload: $xeUpload
      }) : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-action-box',
        style: isMoreView ? null : imgStyle
      }, [showButtonIcon ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-action-icon'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('i', {
        class: buttonIcon || getIcon().UPLOAD_IMAGE_ADD
      })]) : renderEmptyElement($xeUpload), isMoreView || showButtonText ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-action-content'
      }, buttonText ? `${external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isFunction(buttonText) ? buttonText({}) : buttonText}` : getI18n('vxe.upload.imgBtnText')) : renderEmptyElement($xeUpload), showTipText && (defTipText || tipSlot) ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-action-hint'
      }, tipSlot ? vn_getSlotVNs(tipSlot({
        $upload: $xeUpload
      })) : `${defTipText}`) : renderEmptyElement($xeUpload)])])]);
    };
    const renderImageMode = () => {
      const {
        showList,
        dragSort
      } = props;
      const {
        fileList,
        isDragMove
      } = reactData;
      const moreOpts = computeMoreOpts.value;
      const {
        maxCount,
        showMoreButton
      } = moreOpts;
      let currList = fileList;
      let overMaxNum = 0;
      if (maxCount && fileList.length > maxCount) {
        overMaxNum = fileList.length - maxCount;
        currList = fileList.slice(0, maxCount);
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        key: 'image',
        class: 'vxe-upload--image-wrapper'
      }, showList ? [dragSort ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(external_commonjs_vue_commonjs2_vue_root_Vue_.TransitionGroup, {
        name: `vxe-upload--drag-list${isDragMove ? '' : '-disabled'}`,
        tag: 'div',
        class: 'vxe-upload--image-list'
      }, {
        default: () => renderImageItemList(currList, false).concat([showMoreButton && overMaxNum ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
          key: 'om',
          class: 'vxe-upload--image-over-more'
        }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
          mode: 'text',
          content: getI18n('vxe.upload.moreBtnText', [fileList.length]),
          status: 'primary',
          onClick: handleMoreEvent
        })]) : renderEmptyElement($xeUpload), renderImageAction(false)])
      }) : (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-list'
      }, renderImageItemList(currList, false).concat([showMoreButton && overMaxNum ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-over-more'
      }, [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)(src_button, {
        mode: 'text',
        content: getI18n('vxe.upload.moreBtnText', [fileList.length]),
        status: 'primary',
        onClick: handleMoreEvent
      })]) : renderEmptyElement($xeUpload), renderImageAction(false)]))] : [(0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--image-list'
      }, [renderImageAction(false)])]);
    };
    const renderVN = () => {
      const {
        showErrorStatus,
        dragToUpload,
        pasteToUpload,
        dragSort
      } = props;
      const {
        isDragUploadStatus,
        showMorePopup,
        isActivated,
        dragIndex
      } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const isImage = computeIsImage.value;
      const ons = {
        onMousedown: handleItemMousedownEvent
      };
      if (dragToUpload && dragIndex === -1) {
        ons.onDragover = handleUploadDragoverEvent;
        ons.onDragleave = handleUploadDragleaveEvent;
        ons.onDrop = handleUploadDropEvent;
      }
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: ['vxe-upload', {
          [`size--${vSize}`]: vSize,
          'is--active': isActivated,
          'is--readonly': formReadonly,
          'is--disabled': isDisabled,
          'is--paste': pasteToUpload,
          'show--error': showErrorStatus,
          'is--drag': isDragUploadStatus
        }],
        ...ons
      }, [isImage ? renderImageMode() : renderAllMode(), dragSort ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refDragLineElem,
        class: 'vxe-upload--drag-line'
      }) : renderEmptyElement($xeUpload), isDragUploadStatus && !showMorePopup ? (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        class: 'vxe-upload--drag-placeholder'
      }, getI18n('vxe.upload.dragPlaceholder')) : renderEmptyElement($xeUpload)]);
    };
    const listFlag = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)(0);
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue ? props.modelValue.length : 0, () => {
      listFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.modelValue, () => {
      listFlag.value++;
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(listFlag, () => {
      updateFileList();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      if (props.multiple && props.singleMode) {
        errLog('vxe.error.errConflicts', ['multiple', 'single-mode']);
      }
      if (props.imageStyle) {
        warnLog('vxe.error.delProp', ['image-style', 'image-config']);
      }
      if (props.dragSort) {
        initTpImg();
      }
      globalEvents.on($xeUpload, 'paste', handleGlobalPasteEvent);
      globalEvents.on($xeUpload, 'mousedown', handleGlobalMousedownEvent);
      globalEvents.on($xeUpload, 'blur', handleGlobalBlurEvent);
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      reactData.isDragUploadStatus = false;
      globalEvents.off($xeUpload, 'paste');
      globalEvents.off($xeUpload, 'mousedown');
      globalEvents.off($xeUpload, 'blur');
    });
    updateFileList();
    $xeUpload.renderVN = renderVN;
    return $xeUpload;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/upload/index.ts




const VxeUpload = Object.assign({}, upload, {
  install(app) {
    app.component(upload.name, upload);
  }
});
dynamicApp.use(VxeUpload);
index_esm_VxeUI.component(upload);
index_esm_VxeUI.saveFile = saveLocalFile;
index_esm_VxeUI.readFile = readLocalFile;
const Upload = VxeUpload;
/* harmony default export */ var packages_upload = (VxeUpload);
;// CONCATENATED MODULE: ./packages/watermark/src/util.ts


let canvasEl = null;
let fontEl = null;
const fontCacheMaps = {};
function getMarkCanvas() {
  if (!canvasEl) {
    canvasEl = document.createElement('canvas');
    canvasEl.style.position = 'absolute';
    canvasEl.style.top = '0';
    canvasEl.style.left = '0';
  }
  return canvasEl;
}
function removeMarkElement(elem) {
  if (elem) {
    const parentEl = elem.parentNode;
    if (parentEl) {
      parentEl.removeChild(elem);
    }
  }
}
function calcFontWH(text, fontSize) {
  const fKey = `${fontSize}_${text}`;
  if (!fontCacheMaps[fKey]) {
    if (!fontEl) {
      fontEl = document.createElement('span');
    }
    if (!fontEl.parentNode) {
      document.body.append(fontEl);
    }
    fontEl.textContent = text;
    fontEl.style.fontSize = toCssUnit(fontSize);
    const width = fontEl.offsetWidth;
    const height = fontEl.offsetHeight;
    fontCacheMaps[fKey] = {
      width,
      height
    };
  }
  return fontCacheMaps[fKey];
}
function calcContentWH(contList) {
  let contentWidth = 0;
  let contentHeight = 0;
  contList.forEach(item => {
    contentWidth = Math.max(item.width, contentWidth);
    contentHeight = Math.max(item.height, contentHeight);
  });
  return {
    contentWidth,
    contentHeight
  };
}
function calcCanvasWH(contentWidth, opts) {
  const {
    gap
  } = opts;
  const [gapX = 0, gapY = 0] = gap ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(gap) ? gap : [gap, gap] : [];
  const canvasWidth = contentWidth + external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(gapX);
  const canvasHeight = contentWidth + external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(gapY);
  return {
    canvasWidth,
    canvasHeight
  };
}
function getFontConf(item, key, opts) {
  return (item.font ? item.font[key] : '') || (opts.font ? opts.font[key] : '');
}
function createMarkFont(contConf, defaultFontSize, opts) {
  const {
    offset
  } = opts;
  const text = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toValueString(contConf.textContent);
  const fontSize = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(getFontConf(contConf, 'fontSize', opts) || defaultFontSize) || 14;
  const [offsetX = 0, offsetY = 0] = offset ? external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(offset) ? offset : [offset, offset] : [];
  const {
    width,
    height
  } = calcFontWH(text, fontSize);
  return {
    text,
    fontSize,
    font: contConf.font,
    width: width + external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(offsetX),
    height: height + external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(offsetY)
  };
}
function drayFont(ctx, item, opts) {
  const fontWeight = getFontConf(item, 'fontWeight', opts);
  ctx.fillStyle = `${getFontConf(item, 'color', opts) || 'rgba(0, 0, 0, 0.15)'}`;
  ctx.font = [getFontConf(item, 'fontStyle', opts) || 'normal', fontWeight === 'bold' || fontWeight === 'bolder' ? 'bold' : '', toCssUnit(item.fontSize), getFontConf(item, 'fontFamily', opts) || 'sans-serif'].join(' ');
}
function getContentUrl(content, defaultFontSize, options) {
  const opts = Object.assign({}, options);
  const {
    rotate
  } = opts;
  const deg = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().toNumber(rotate);
  const contList = (external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().isArray(content) ? content : [content]).map(item => {
    if (item) {
      if (item.textContent) {
        return createMarkFont(item, defaultFontSize, opts);
      }
      return createMarkFont({
        textContent: `${item}`
      }, defaultFontSize, opts);
    }
    return createMarkFont({
      textContent: ''
    }, defaultFontSize, opts);
  });
  removeMarkElement(fontEl);
  return new Promise(resolve => {
    const canvasEl = getMarkCanvas();
    if (!canvasEl.parentNode) {
      document.body.append(canvasEl);
    }
    const ctx = canvasEl.getContext('2d');
    if (ctx && contList.length) {
      const {
        contentWidth,
        contentHeight
      } = calcContentWH(contList);
      const {
        canvasWidth,
        canvasHeight
      } = calcCanvasWH(contentWidth, opts);
      canvasEl.width = canvasWidth;
      canvasEl.height = canvasHeight;
      const x = (canvasWidth - contentWidth) / 2;
      const y = (canvasHeight - contentHeight) / 2;
      const drayX = x + contentWidth / 2;
      const drayY = y + contentHeight / 2;
      ctx.save();
      ctx.translate(drayX, drayY);
      ctx.rotate(deg * Math.PI / 180);
      ctx.translate(-drayX, -drayY);
      let offsetHeight = 0;
      contList.forEach(item => {
        const align = getFontConf(item, 'align', opts);
        drayFont(ctx, item, opts);
        ctx.fillText(item.text, x + (align === 'center' ? (contentWidth - item.width) / 2 : 0), y + (contentHeight + contentHeight) / 2 + offsetHeight, contentWidth);
        offsetHeight += item.height;
      });
      ctx.restore();
      resolve(canvasEl.toDataURL());
      removeMarkElement(canvasEl);
    } else {
      resolve('');
      removeMarkElement(canvasEl);
    }
  });
}
;// CONCATENATED MODULE: ./packages/watermark/src/watermark.ts






/* harmony default export */ var watermark = (defineVxeComponent({
  name: 'VxeWatermark',
  props: {
    width: String,
    height: String,
    imageUrl: String,
    rotate: {
      type: [Number, String],
      default: () => getConfig().watermark.rotate
    },
    gap: {
      type: [Array, Number, String],
      default: () => external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(getConfig().watermark.gap, true)
    },
    content: [String, Array],
    font: Object,
    offset: Object,
    zIndex: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const {
      emit
    } = context;
    const xID = external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().uniqueId();
    const refElem = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.ref)();
    const reactData = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.reactive)({
      markUrl: ''
    });
    const refMaps = {
      refElem
    };
    const computeFontOpts = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      return external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().assign({}, external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().clone(getConfig().watermark.font, true), props.font);
    });
    const computeWrapperStyle = (0,external_commonjs_vue_commonjs2_vue_root_Vue_.computed)(() => {
      const {
        width,
        height,
        zIndex
      } = props;
      const {
        markUrl
      } = reactData;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      if (markUrl) {
        stys.backgroundImage = `url(${markUrl})`;
      }
      if (zIndex) {
        stys.zIndex = zIndex;
      }
      return stys;
    });
    const computeMaps = {};
    const $xeWatermark = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, createEvent(evnt, {
        $watermark: $xeWatermark
      }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent
    };
    const updateMarkStyle = () => {
      const {
        content,
        gap,
        rotate,
        offset
      } = props;
      const el = refElem.value;
      const fontOpts = computeFontOpts.value;
      if (el) {
        if (content) {
          getContentUrl(content, getComputedStyle(el).fontSize, {
            font: fontOpts,
            rotate,
            gap,
            offset
          }).then(url => {
            reactData.markUrl = url;
          });
        }
      }
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeWatermark, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const wrapperStyle = computeWrapperStyle.value;
      return (0,external_commonjs_vue_commonjs2_vue_root_Vue_.h)('div', {
        ref: refElem,
        class: 'vxe-watermark',
        style: wrapperStyle
      });
    };
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.imageUrl, () => {
      updateMarkStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.content, () => {
      updateMarkStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.gap, () => {
      updateMarkStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.rotate, () => {
      updateMarkStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.width, () => {
      updateMarkStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.height, () => {
      updateMarkStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.watch)(() => props.font, () => {
      updateMarkStyle();
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onMounted)(() => {
      updateMarkStyle();
      globalEvents.on($xeWatermark, 'resize', external_root_XEUtils_commonjs_xe_utils_commonjs2_xe_utils_amd_xe_utils_default().throttle(() => {
        updateMarkStyle();
      }, 300, {
        trailing: true,
        leading: true
      }));
    });
    (0,external_commonjs_vue_commonjs2_vue_root_Vue_.onUnmounted)(() => {
      globalEvents.off($xeWatermark, 'resize');
    });
    $xeWatermark.renderVN = renderVN;
    return $xeWatermark;
  },
  render() {
    return this.renderVN();
  }
}));
;// CONCATENATED MODULE: ./packages/watermark/index.ts



const VxeWatermark = Object.assign({}, watermark, {
  install(app) {
    app.component(watermark.name, watermark);
  }
});
dynamicApp.use(VxeWatermark);
index_esm_VxeUI.component(watermark);
const WatermarkController = {
  load(options) {
    checkDynamic();
    dynamicStore.globalWatermark = Object.assign({}, options);
    return Promise.resolve();
  },
  clear() {
    dynamicStore.globalWatermark = null;
    return Promise.resolve();
  }
};
index_esm_VxeUI.watermark = WatermarkController;
const Watermark = VxeWatermark;
/* harmony default export */ var packages_watermark = (VxeWatermark);
;// CONCATENATED MODULE: ./packages/components.ts




















































































const {
  setI18n: components_setI18n,
  setLanguage: components_setLanguage,
  setTheme: components_setTheme,
  setConfig: components_setConfig
} = index_esm_VxeUI;
const components_components = [packages_alert, packages_anchor, packages_anchor_link, packages_avatar, packages_badge, packages_breadcrumb, packages_breadcrumb_item, packages_button, packages_button_group, packages_calendar, packages_card, packages_carousel, packages_carousel_item, packages_checkbox, checkbox_button, checkbox_group, packages_col, packages_collapse, packages_collapse_pane, packages_color_picker, packages_countdown, packages_date_panel, packages_date_picker, packages_date_range_picker, packages_drawer, packages_empty, packages_form, form_gather, packages_form_group, packages_form_item, packages_icon, packages_icon_picker, packages_image, image_group, image_preview, packages_input, packages_layout_aside, packages_layout_body, packages_layout_container, packages_layout_footer, packages_layout_header, packages_link, packages_list, loading, packages_menu, packages_modal, packages_notice_bar, packages_number_input, packages_optgroup, packages_option, packages_pager, packages_password_input, print_page_break, packages_print, packages_pulldown, packages_radio, radio_button, radio_group, packages_rate, packages_result, packages_row, packages_select, packages_split, packages_split_pane, packages_slider, packages_steps, packages_switch, packages_tab_pane, packages_table_select, packages_tabs, packages_tag, packages_text_ellipsis, packages_text, packages_textarea, packages_tip, packages_tooltip, packages_tree, packages_tree_select, packages_upload, packages_watermark];
function install(app, options) {
  components_setConfig(options);
  components_components.forEach(component => app.use(component));
}
// 默认中文
const defaultLanguage = 'zh-CN';
components_setI18n(defaultLanguage, zh_CN);
components_setLanguage(defaultLanguage);
components_setTheme('light');
// 兼容老版本
const components_loading = LoadingController;
const components_modal = ModalController;
const components_drawer = DrawerController;
const components_watermark = WatermarkController;
const components_print = printHtml;
const saveFile = saveLocalFile;
const readFile = readLocalFile;

// Components
















































































;// CONCATENATED MODULE: ./index.ts


if (typeof window !== 'undefined') {
  if (window.VxeUI && !window.VxeUIAll) {
    window.VxeUIAll = components_namespaceObject;
  }
}

/* harmony default export */ var index = (components_namespaceObject);
;// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = (index);


}();
/******/ 	return __webpack_exports__;
/******/ })()
;
});