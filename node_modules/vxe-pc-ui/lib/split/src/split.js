"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _vue = require("vue");
var _ui = require("../../ui");
var _vn = require("../../ui/src/vn");
var _dom = require("../../ui/src/dom");
var _utils = require("../../ui/src/utils");
var _xeUtils = _interopRequireDefault(require("xe-utils"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
var _default = exports.default = (0, _vue.defineComponent)({
  name: 'VxeSplit',
  props: {
    width: [Number, String],
    height: [Number, String],
    vertical: {
      type: Boolean,
      default: () => (0, _ui.getConfig)().split.vertical
    },
    border: {
      type: Boolean,
      default: () => (0, _ui.getConfig)().split.border
    },
    itemConfig: Object
  },
  emits: [],
  setup(props, context) {
    const {
      emit,
      slots
    } = context;
    const xID = _xeUtils.default.uniqueId();
    const refElem = (0, _vue.ref)();
    const reactData = (0, _vue.reactive)({
      staticItems: []
    });
    const internalData = {};
    const computeItemOpts = (0, _vue.computed)(() => {
      return Object.assign({}, (0, _ui.getConfig)().split.itemConfig, props.itemConfig);
    });
    const computeMaps = {
      computeItemOpts
    };
    const refMaps = {
      refElem
    };
    const $xeSplit = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent = (type, params, evnt) => {
      emit(type, (0, _ui.createEvent)(evnt, {
        $split: $xeSplit
      }, params));
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (_xeUtils.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (_xeUtils.default.isFunction(slotFunc)) {
          return (0, _vn.getSlotVNs)(slotFunc(params));
        }
      }
      return [];
    };
    const recalculate = () => {
      return (0, _vue.nextTick)().then(() => {
        const {
          vertical
        } = props;
        const {
          staticItems
        } = reactData;
        const el = refElem.value;
        if (!el) {
          return;
        }
        const wrapperWidth = el.clientWidth;
        const wrapperHeight = el.clientHeight;
        if (!wrapperWidth || !wrapperHeight) {
          return;
        }
        const itemOpts = computeItemOpts.value;
        const allMinWidth = _xeUtils.default.toNumber(itemOpts.minWidth);
        const allMinHeight = _xeUtils.default.toNumber(itemOpts.minHeight);
        const residueItems = [];
        if (vertical) {
          let countHeight = 0;
          staticItems.forEach(item => {
            const {
              height
            } = item;
            let itemHeight = 0;
            if (height) {
              if ((0, _dom.isScale)(height)) {
                itemHeight = wrapperHeight * _xeUtils.default.toNumber(height);
              } else {
                itemHeight = _xeUtils.default.toNumber(height);
              }
              item.renderHeight = itemHeight;
            } else {
              residueItems.push(item);
            }
            countHeight += itemHeight;
          });
          if (residueItems.length) {
            const reMeanHeight = (wrapperHeight - countHeight) / residueItems.length;
            residueItems.forEach(item => {
              item.renderHeight = Math.max(_xeUtils.default.toNumber((0, _utils.getGlobalDefaultConfig)(item.minHeight, allMinHeight)), reMeanHeight);
            });
          }
        } else {
          let countWidth = 0;
          staticItems.forEach(item => {
            const {
              width
            } = item;
            let itemWidth = 0;
            if (width) {
              if ((0, _dom.isScale)(width)) {
                itemWidth = wrapperWidth * _xeUtils.default.toNumber(width);
              } else {
                itemWidth = _xeUtils.default.toNumber(width);
              }
              item.renderWidth = itemWidth;
            } else {
              residueItems.push(item);
            }
            countWidth += itemWidth;
          });
          if (residueItems.length) {
            const reMeanWidth = (wrapperWidth - countWidth) / residueItems.length;
            residueItems.forEach(item => {
              item.renderWidth = Math.max(_xeUtils.default.toNumber((0, _utils.getGlobalDefaultConfig)(item.minWidth, allMinWidth)), reMeanWidth);
            });
          }
        }
      });
    };
    const dragEvent = evnt => {
      evnt.preventDefault();
      const {
        vertical
      } = props;
      const {
        staticItems
      } = reactData;
      const handleEl = evnt.currentTarget;
      const el = refElem.value;
      if (!el) {
        return;
      }
      const itemId = handleEl.getAttribute('xid');
      const itemIndex = _xeUtils.default.findIndexOf(staticItems, item => item.id === itemId);
      const item = staticItems[itemIndex];
      if (!item) {
        return;
      }
      const itemOpts = computeItemOpts.value;
      const allMinWidth = _xeUtils.default.toNumber(itemOpts.minWidth);
      const allMinHeight = _xeUtils.default.toNumber(itemOpts.minHeight);
      const prevItem = staticItems[itemIndex - 1];
      const prevItemEl = prevItem ? el.querySelector(`.vxe-split-item[xid="${prevItem.id}"]`) : null;
      const currItemEl = item ? el.querySelector(`.vxe-split-item[xid="${item.id}"]`) : null;
      const prevWidth = prevItemEl ? prevItemEl.clientWidth : 0;
      const currWidth = currItemEl ? currItemEl.clientWidth : 0;
      const prevHeight = prevItemEl ? prevItemEl.clientHeight : 0;
      const currHeight = currItemEl ? currItemEl.clientHeight : 0;
      const prevMinWidth = _xeUtils.default.toNumber(prevItem ? (0, _utils.getGlobalDefaultConfig)(prevItem.minWidth, allMinWidth) : allMinWidth);
      const currMinWidth = _xeUtils.default.toNumber((0, _utils.getGlobalDefaultConfig)(item.minWidth, allMinWidth));
      const prevMinHeight = _xeUtils.default.toNumber(prevItem ? (0, _utils.getGlobalDefaultConfig)(prevItem.minHeight, allMinHeight) : allMinHeight);
      const currMinHeight = _xeUtils.default.toNumber((0, _utils.getGlobalDefaultConfig)(item.minHeight, allMinHeight));
      const disX = evnt.clientX;
      const disY = evnt.clientY;
      (0, _dom.addClass)(el, 'is--drag');
      document.onmousemove = evnt => {
        evnt.preventDefault();
        if (vertical) {
          const offsetTop = evnt.clientY - disY;
          if (offsetTop > 0) {
            if (prevItem) {
              if (currHeight - offsetTop >= currMinHeight) {
                prevItem.renderHeight = prevHeight + offsetTop;
                item.renderHeight = currHeight - offsetTop;
              }
            }
          } else {
            if (prevItem) {
              if (prevHeight + offsetTop >= prevMinHeight) {
                prevItem.renderHeight = prevHeight + offsetTop;
                item.renderHeight = currHeight - offsetTop;
              }
            }
          }
        } else {
          const offsetLeft = evnt.clientX - disX;
          if (offsetLeft > 0) {
            if (prevItem) {
              if (currWidth - offsetLeft >= currMinWidth) {
                prevItem.renderWidth = prevWidth + offsetLeft;
                item.renderWidth = currWidth - offsetLeft;
              }
            }
          } else {
            if (prevItem) {
              if (prevWidth + offsetLeft >= prevMinWidth) {
                prevItem.renderWidth = prevWidth + offsetLeft;
                item.renderWidth = currWidth - offsetLeft;
              }
            }
          }
        }
      };
      document.onmouseup = () => {
        document.onmousemove = null;
        document.onmouseup = null;
        (0, _dom.removeClass)(el, 'is--drag');
      };
    };
    const splitMethods = {
      dispatchEvent,
      recalculate
    };
    const splitPrivateMethods = {};
    Object.assign($xeSplit, splitMethods, splitPrivateMethods);
    const renderItems = () => {
      const {
        border,
        vertical
      } = props;
      const {
        staticItems
      } = reactData;
      const itemVNs = [];
      staticItems.forEach((item, index) => {
        const {
          id,
          slots,
          renderHeight,
          renderWidth
        } = item;
        const defaultSlot = slots ? slots.default : null;
        const stys = {};
        if (vertical) {
          if (renderHeight) {
            stys.height = (0, _dom.toCssUnit)(renderHeight);
          }
        } else {
          if (renderWidth) {
            stys.width = (0, _dom.toCssUnit)(renderWidth);
          }
        }
        itemVNs.push((0, _vue.h)('div', {
          xid: id,
          class: ['vxe-split-item', vertical ? 'is--vertical' : 'is--horizontal', {
            'is--border': border,
            'is--height': renderHeight,
            'is--width': renderWidth,
            'is--fill': !renderHeight && !renderWidth,
            'is--handle': index > 0
          }],
          style: stys
        }, [index ? (0, _vue.h)('div', {
          xid: id,
          class: 'vxe-split-item-handle',
          onMousedown: dragEvent
        }) : (0, _ui.renderEmptyElement)($xeSplit), (0, _vue.h)('div', {
          xid: id,
          class: 'vxe-split-item--wrapper'
        }, defaultSlot ? callSlot(defaultSlot, {}) : [])]));
      });
      return (0, _vue.h)('div', {
        class: 'vxe-split-wrapper'
      }, itemVNs);
    };
    const renderVN = () => {
      const {
        vertical,
        width,
        height
      } = props;
      const defaultSlot = slots.default;
      const stys = {};
      if (height) {
        stys.height = (0, _dom.toCssUnit)(height);
      }
      if (width) {
        stys.width = (0, _dom.toCssUnit)(width);
      }
      return (0, _vue.h)('div', {
        ref: refElem,
        class: ['vxe-split', vertical ? 'is--vertical' : 'is--horizontal'],
        style: stys
      }, [(0, _vue.h)('div', {
        class: 'vxe-split-slots'
      }, defaultSlot ? defaultSlot({}) : []), renderItems()]);
    };
    (0, _vue.watch)(() => reactData.staticItems, () => {
      recalculate();
    });
    (0, _vue.onMounted)(() => {
      recalculate();
    });
    (0, _vue.onActivated)(() => {
      recalculate();
    });
    (0, _vue.provide)('$xeSplit', $xeSplit);
    $xeSplit.renderVN = renderVN;
    return $xeSplit;
  },
  render() {
    return this.renderVN();
  }
});